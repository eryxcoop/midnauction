import { g as getDefaultExportFromCjs, c as commonjsGlobal, a as commonjsRequire, _ as __vite__initWasm, b as getAugmentedNamespace, m as midnight_onchain_runtime_wasm, __tla as __tla_0 } from './wasm-BNNwrvC8.js';
Promise.all([
    (()=>{
        try {
            return __tla_0;
        } catch  {}
    })()
]).then(async ()=>{
    function _mergeNamespaces(n, m) {
        for(var i = 0; i < m.length; i++){
            const e = m[i];
            if (typeof e !== 'string' && !Array.isArray(e)) {
                for(const k in e){
                    if (k !== 'default' && !(k in n)) {
                        const d = Object.getOwnPropertyDescriptor(e, k);
                        if (d) {
                            Object.defineProperty(n, k, d.get ? d : {
                                enumerable: true,
                                get: ()=>e[k]
                            });
                        }
                    }
                }
            }
        }
        return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
            value: 'Module'
        }));
    }
    true && (function polyfill() {
        const relList = document.createElement("link").relList;
        if (relList && relList.supports && relList.supports("modulepreload")) {
            return;
        }
        for (const link of document.querySelectorAll('link[rel="modulepreload"]')){
            processPreload(link);
        }
        new MutationObserver((mutations)=>{
            for (const mutation of mutations){
                if (mutation.type !== "childList") {
                    continue;
                }
                for (const node of mutation.addedNodes){
                    if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
                }
            }
        }).observe(document, {
            childList: true,
            subtree: true
        });
        function getFetchOpts(link) {
            const fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
            else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
            else fetchOpts.credentials = "same-origin";
            return fetchOpts;
        }
        function processPreload(link) {
            if (link.ep) return;
            link.ep = true;
            const fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
        }
    }());
    var jsxRuntime = {
        exports: {}
    };
    var reactJsxRuntime_production = {};
    var hasRequiredReactJsxRuntime_production;
    function requireReactJsxRuntime_production() {
        if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
        hasRequiredReactJsxRuntime_production = 1;
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        function jsxProd(type, config, maybeKey) {
            var key = null;
            void 0 !== maybeKey && (key = "" + maybeKey);
            void 0 !== config.key && (key = "" + config.key);
            if ("key" in config) {
                maybeKey = {};
                for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
            } else maybeKey = config;
            config = maybeKey.ref;
            return {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: void 0 !== config ? config : null,
                props: maybeKey
            };
        }
        reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
        reactJsxRuntime_production.jsx = jsxProd;
        reactJsxRuntime_production.jsxs = jsxProd;
        return reactJsxRuntime_production;
    }
    var hasRequiredJsxRuntime;
    function requireJsxRuntime() {
        if (hasRequiredJsxRuntime) return jsxRuntime.exports;
        hasRequiredJsxRuntime = 1;
        {
            jsxRuntime.exports = requireReactJsxRuntime_production();
        }
        return jsxRuntime.exports;
    }
    var jsxRuntimeExports = requireJsxRuntime();
    var react = {
        exports: {}
    };
    var react_production = {};
    var hasRequiredReact_production;
    function requireReact_production() {
        if (hasRequiredReact_production) return react_production;
        hasRequiredReact_production = 1;
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        function getIteratorFn(maybeIterable) {
            if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
            maybeIterable = (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) || maybeIterable["@@iterator"];
            return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        var ReactNoopUpdateQueue = {
            isMounted: function() {
                return false;
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
        }, assign = Object.assign, emptyObject = {};
        function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
            if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        function ComponentDummy() {}
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, ReactSharedInternals = {
            H: null,
            A: null,
            T: null,
            S: null,
            V: null
        }, hasOwnProperty = Object.prototype.hasOwnProperty;
        function ReactElement(type, key, self, source, owner, props) {
            self = props.ref;
            return {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                ref: void 0 !== self ? self : null,
                props: props
            };
        }
        function cloneAndReplaceKey(oldElement, newKey) {
            return ReactElement(oldElement.type, newKey, void 0, void 0, void 0, oldElement.props);
        }
        function isValidElement(object) {
            return ("object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE);
        }
        function escape(key) {
            var escaperLookup = {
                "=": "=0",
                ":": "=2"
            };
            return ("$" + key.replace(/[=:]/g, function(match) {
                return escaperLookup[match];
            }));
        }
        var userProvidedKeyEscapeRegex = /\/+/g;
        function getElementKey(element, index) {
            return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
        }
        function noop$1() {}
        function resolveThenable(thenable) {
            switch(thenable.status){
                case "fulfilled":
                    return thenable.value;
                case "rejected":
                    throw thenable.reason;
                default:
                    switch(("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : ((thenable.status = "pending"), thenable.then(function(fulfilledValue) {
                        "pending" === thenable.status && ((thenable.status = "fulfilled"), (thenable.value = fulfilledValue));
                    }, function(error) {
                        "pending" === thenable.status && ((thenable.status = "rejected"), (thenable.reason = error));
                    })), thenable.status)){
                        case "fulfilled":
                            return thenable.value;
                        case "rejected":
                            throw thenable.reason;
                    }
            }
            throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if ("undefined" === type || "boolean" === type) children = null;
            var invokeCallback = false;
            if (null === children) invokeCallback = true;
            else switch(type){
                case "bigint":
                case "string":
                case "number":
                    invokeCallback = true;
                    break;
                case "object":
                    switch(children.$$typeof){
                        case REACT_ELEMENT_TYPE:
                        case REACT_PORTAL_TYPE:
                            invokeCallback = true;
                            break;
                        case REACT_LAZY_TYPE:
                            return ((invokeCallback = children._init), mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback));
                    }
            }
            if (invokeCallback) return ((callback = callback(children)), (invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar), isArrayImpl(callback) ? ((escapedPrefix = ""), null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
                return c;
            })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || (children && children.key === callback.key) ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1);
            invokeCallback = 0;
            var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
            if (isArrayImpl(children)) for(var i = 0; i < children.length; i++)(nameSoFar = children[i]), (type = nextNamePrefix + getElementKey(nameSoFar, i)), (invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback));
            else if (((i = getIteratorFn(children)), "function" === typeof i)) for(children = i.call(children), i = 0; !(nameSoFar = children.next()).done;)(nameSoFar = nameSoFar.value), (type = nextNamePrefix + getElementKey(nameSoFar, i++)), (invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback));
            else if ("object" === type) {
                if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
                array = String(children);
                throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
            }
            return invokeCallback;
        }
        function mapChildren(children, func, context) {
            if (null == children) return children;
            var result = [], count = 0;
            mapIntoArray(children, result, "", "", function(child) {
                return func.call(context, child, count++);
            });
            return result;
        }
        function lazyInitializer(payload) {
            if (-1 === payload._status) {
                var ctor = payload._result;
                ctor = ctor();
                ctor.then(function(moduleObject) {
                    if (0 === payload._status || -1 === payload._status) (payload._status = 1), (payload._result = moduleObject);
                }, function(error) {
                    if (0 === payload._status || -1 === payload._status) (payload._status = 2), (payload._result = error);
                });
                -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
            }
            if (1 === payload._status) return payload._result.default;
            throw payload._result;
        }
        var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
            if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
                var event = new window.ErrorEvent("error", {
                    bubbles: true,
                    cancelable: true,
                    message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                    error: error
                });
                if (!window.dispatchEvent(event)) return;
            } else if ("object" === typeof process && "function" === typeof process.emit) {
                process.emit("uncaughtException", error);
                return;
            }
            console.error(error);
        };
        function noop() {}
        react_production.Children = {
            map: mapChildren,
            forEach: function(children, forEachFunc, forEachContext) {
                mapChildren(children, function() {
                    forEachFunc.apply(this, arguments);
                }, forEachContext);
            },
            count: function(children) {
                var n = 0;
                mapChildren(children, function() {
                    n++;
                });
                return n;
            },
            toArray: function(children) {
                return (mapChildren(children, function(child) {
                    return child;
                }) || []);
            },
            only: function(children) {
                if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
                return children;
            }
        };
        react_production.Component = Component;
        react_production.Fragment = REACT_FRAGMENT_TYPE;
        react_production.Profiler = REACT_PROFILER_TYPE;
        react_production.PureComponent = PureComponent;
        react_production.StrictMode = REACT_STRICT_MODE_TYPE;
        react_production.Suspense = REACT_SUSPENSE_TYPE;
        react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        react_production.__COMPILER_RUNTIME = {
            __proto__: null,
            c: function(size) {
                return ReactSharedInternals.H.useMemoCache(size);
            }
        };
        react_production.cache = function(fn) {
            return function() {
                return fn.apply(null, arguments);
            };
        };
        react_production.cloneElement = function(element, config, children) {
            if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
            var props = assign({}, element.props), key = element.key, owner = void 0;
            if (null != config) for(propName in (void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config))!hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || ("ref" === propName && void 0 === config.ref) || (props[propName] = config[propName]);
            var propName = arguments.length - 2;
            if (1 === propName) props.children = children;
            else if (1 < propName) {
                for(var childArray = Array(propName), i = 0; i < propName; i++)childArray[i] = arguments[i + 2];
                props.children = childArray;
            }
            return ReactElement(element.type, key, void 0, void 0, owner, props);
        };
        react_production.createContext = function(defaultValue) {
            defaultValue = {
                $$typeof: REACT_CONTEXT_TYPE,
                _currentValue: defaultValue,
                _currentValue2: defaultValue,
                _threadCount: 0,
                Provider: null,
                Consumer: null
            };
            defaultValue.Provider = defaultValue;
            defaultValue.Consumer = {
                $$typeof: REACT_CONSUMER_TYPE,
                _context: defaultValue
            };
            return defaultValue;
        };
        react_production.createElement = function(type, config, children) {
            var propName, props = {}, key = null;
            if (null != config) for(propName in (void 0 !== config.key && (key = "" + config.key), config))hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
            var childrenLength = arguments.length - 2;
            if (1 === childrenLength) props.children = children;
            else if (1 < childrenLength) {
                for(var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)childArray[i] = arguments[i + 2];
                props.children = childArray;
            }
            if (type && type.defaultProps) for(propName in ((childrenLength = type.defaultProps), childrenLength))void 0 === props[propName] && (props[propName] = childrenLength[propName]);
            return ReactElement(type, key, void 0, void 0, null, props);
        };
        react_production.createRef = function() {
            return {
                current: null
            };
        };
        react_production.forwardRef = function(render) {
            return {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: render
            };
        };
        react_production.isValidElement = isValidElement;
        react_production.lazy = function(ctor) {
            return {
                $$typeof: REACT_LAZY_TYPE,
                _payload: {
                    _status: -1,
                    _result: ctor
                },
                _init: lazyInitializer
            };
        };
        react_production.memo = function(type, compare) {
            return {
                $$typeof: REACT_MEMO_TYPE,
                type: type,
                compare: void 0 === compare ? null : compare
            };
        };
        react_production.startTransition = function(scope) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            try {
                var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
            } catch (error) {
                reportGlobalError(error);
            } finally{
                ReactSharedInternals.T = prevTransition;
            }
        };
        react_production.unstable_useCacheRefresh = function() {
            return ReactSharedInternals.H.useCacheRefresh();
        };
        react_production.use = function(usable) {
            return ReactSharedInternals.H.use(usable);
        };
        react_production.useActionState = function(action, initialState, permalink) {
            return ReactSharedInternals.H.useActionState(action, initialState, permalink);
        };
        react_production.useCallback = function(callback, deps) {
            return ReactSharedInternals.H.useCallback(callback, deps);
        };
        react_production.useContext = function(Context) {
            return ReactSharedInternals.H.useContext(Context);
        };
        react_production.useDebugValue = function() {};
        react_production.useDeferredValue = function(value, initialValue) {
            return ReactSharedInternals.H.useDeferredValue(value, initialValue);
        };
        react_production.useEffect = function(create, createDeps, update) {
            var dispatcher = ReactSharedInternals.H;
            if ("function" === typeof update) throw Error("useEffect CRUD overload is not enabled in this build of React.");
            return dispatcher.useEffect(create, createDeps);
        };
        react_production.useId = function() {
            return ReactSharedInternals.H.useId();
        };
        react_production.useImperativeHandle = function(ref, create, deps) {
            return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
        };
        react_production.useInsertionEffect = function(create, deps) {
            return ReactSharedInternals.H.useInsertionEffect(create, deps);
        };
        react_production.useLayoutEffect = function(create, deps) {
            return ReactSharedInternals.H.useLayoutEffect(create, deps);
        };
        react_production.useMemo = function(create, deps) {
            return ReactSharedInternals.H.useMemo(create, deps);
        };
        react_production.useOptimistic = function(passthrough, reducer) {
            return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
        };
        react_production.useReducer = function(reducer, initialArg, init) {
            return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
        };
        react_production.useRef = function(initialValue) {
            return ReactSharedInternals.H.useRef(initialValue);
        };
        react_production.useState = function(initialState) {
            return ReactSharedInternals.H.useState(initialState);
        };
        react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
            return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        };
        react_production.useTransition = function() {
            return ReactSharedInternals.H.useTransition();
        };
        react_production.version = "19.1.1";
        return react_production;
    }
    var hasRequiredReact;
    function requireReact() {
        if (hasRequiredReact) return react.exports;
        hasRequiredReact = 1;
        {
            react.exports = requireReact_production();
        }
        return react.exports;
    }
    var reactExports = requireReact();
    const React = getDefaultExportFromCjs(reactExports);
    const React$1 = _mergeNamespaces({
        __proto__: null,
        default: React
    }, [
        reactExports
    ]);
    var client = {
        exports: {}
    };
    var reactDomClient_production = {};
    var scheduler = {
        exports: {}
    };
    var scheduler_production = {};
    var hasRequiredScheduler_production;
    function requireScheduler_production() {
        if (hasRequiredScheduler_production) return scheduler_production;
        hasRequiredScheduler_production = 1;
        (function(exports) {
            function push(heap, node) {
                var index = heap.length;
                heap.push(node);
                a: for(; 0 < index;){
                    var parentIndex = (index - 1) >>> 1, parent = heap[parentIndex];
                    if (0 < compare(parent, node)) (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
                    else break a;
                }
            }
            function peek(heap) {
                return 0 === heap.length ? null : heap[0];
            }
            function pop(heap) {
                if (0 === heap.length) return null;
                var first = heap[0], last = heap.pop();
                if (last !== first) {
                    heap[0] = last;
                    a: for(var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;){
                        var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
                        if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? ((heap[index] = right), (heap[rightIndex] = last), (index = rightIndex)) : ((heap[index] = left), (heap[leftIndex] = last), (index = leftIndex));
                        else if (rightIndex < length && 0 > compare(right, last)) (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
                        else break a;
                    }
                }
                return first;
            }
            function compare(a, b) {
                var diff = a.sortIndex - b.sortIndex;
                return 0 !== diff ? diff : a.id - b.id;
            }
            exports.unstable_now = void 0;
            if ("object" === typeof performance && "function" === typeof performance.now) {
                var localPerformance = performance;
                exports.unstable_now = function() {
                    return localPerformance.now();
                };
            } else {
                var localDate = Date, initialTime = localDate.now();
                exports.unstable_now = function() {
                    return localDate.now() - initialTime;
                };
            }
            var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
            function advanceTimers(currentTime) {
                for(var timer = peek(timerQueue); null !== timer;){
                    if (null === timer.callback) pop(timerQueue);
                    else if (timer.startTime <= currentTime) pop(timerQueue), (timer.sortIndex = timer.expirationTime), push(taskQueue, timer);
                    else break;
                    timer = peek(timerQueue);
                }
            }
            function handleTimeout(currentTime) {
                isHostTimeoutScheduled = false;
                advanceTimers(currentTime);
                if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) (isHostCallbackScheduled = true), isMessageLoopRunning || ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
                else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
            }
            var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
            function shouldYieldToHost() {
                return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
            }
            function performWorkUntilDeadline() {
                needsPaint = false;
                if (isMessageLoopRunning) {
                    var currentTime = exports.unstable_now();
                    startTime = currentTime;
                    var hasMoreWork = true;
                    try {
                        a: {
                            isHostCallbackScheduled = !1;
                            isHostTimeoutScheduled && ((isHostTimeoutScheduled = !1), localClearTimeout(taskTimeoutID), (taskTimeoutID = -1));
                            isPerformingWork = !0;
                            var previousPriorityLevel = currentPriorityLevel;
                            try {
                                b: {
                                    advanceTimers(currentTime);
                                    for(currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());){
                                        var callback = currentTask.callback;
                                        if ("function" === typeof callback) {
                                            currentTask.callback = null;
                                            currentPriorityLevel = currentTask.priorityLevel;
                                            var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                                            currentTime = exports.unstable_now();
                                            if ("function" === typeof continuationCallback) {
                                                currentTask.callback = continuationCallback;
                                                advanceTimers(currentTime);
                                                hasMoreWork = !0;
                                                break b;
                                            }
                                            currentTask === peek(taskQueue) && pop(taskQueue);
                                            advanceTimers(currentTime);
                                        } else pop(taskQueue);
                                        currentTask = peek(taskQueue);
                                    }
                                    if (null !== currentTask) hasMoreWork = !0;
                                    else {
                                        var firstTimer = peek(timerQueue);
                                        null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                                        hasMoreWork = !1;
                                    }
                                }
                                break a;
                            } finally{
                                (currentTask = null), (currentPriorityLevel = previousPriorityLevel), (isPerformingWork = !1);
                            }
                            hasMoreWork = void 0;
                        }
                    } finally{
                        hasMoreWork ? schedulePerformWorkUntilDeadline() : (isMessageLoopRunning = false);
                    }
                }
            }
            var schedulePerformWorkUntilDeadline;
            if ("function" === typeof localSetImmediate) schedulePerformWorkUntilDeadline = function() {
                localSetImmediate(performWorkUntilDeadline);
            };
            else if ("undefined" !== typeof MessageChannel) {
                var channel = new MessageChannel(), port = channel.port2;
                channel.port1.onmessage = performWorkUntilDeadline;
                schedulePerformWorkUntilDeadline = function() {
                    port.postMessage(null);
                };
            } else schedulePerformWorkUntilDeadline = function() {
                localSetTimeout(performWorkUntilDeadline, 0);
            };
            function requestHostTimeout(callback, ms) {
                taskTimeoutID = localSetTimeout(function() {
                    callback(exports.unstable_now());
                }, ms);
            }
            exports.unstable_IdlePriority = 5;
            exports.unstable_ImmediatePriority = 1;
            exports.unstable_LowPriority = 4;
            exports.unstable_NormalPriority = 3;
            exports.unstable_Profiling = null;
            exports.unstable_UserBlockingPriority = 2;
            exports.unstable_cancelCallback = function(task) {
                task.callback = null;
            };
            exports.unstable_forceFrameRate = function(fps) {
                0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
            };
            exports.unstable_getCurrentPriorityLevel = function() {
                return currentPriorityLevel;
            };
            exports.unstable_next = function(eventHandler) {
                switch(currentPriorityLevel){
                    case 1:
                    case 2:
                    case 3:
                        var priorityLevel = 3;
                        break;
                    default:
                        priorityLevel = currentPriorityLevel;
                }
                var previousPriorityLevel = currentPriorityLevel;
                currentPriorityLevel = priorityLevel;
                try {
                    return eventHandler();
                } finally{
                    currentPriorityLevel = previousPriorityLevel;
                }
            };
            exports.unstable_requestPaint = function() {
                needsPaint = true;
            };
            exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
                switch(priorityLevel){
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        priorityLevel = 3;
                }
                var previousPriorityLevel = currentPriorityLevel;
                currentPriorityLevel = priorityLevel;
                try {
                    return eventHandler();
                } finally{
                    currentPriorityLevel = previousPriorityLevel;
                }
            };
            exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
                var currentTime = exports.unstable_now();
                "object" === typeof options && null !== options ? ((options = options.delay), (options = "number" === typeof options && 0 < options ? currentTime + options : currentTime)) : (options = currentTime);
                switch(priorityLevel){
                    case 1:
                        var timeout = -1;
                        break;
                    case 2:
                        timeout = 250;
                        break;
                    case 5:
                        timeout = 1073741823;
                        break;
                    case 4:
                        timeout = 1e4;
                        break;
                    default:
                        timeout = 5e3;
                }
                timeout = options + timeout;
                priorityLevel = {
                    id: taskIdCounter++,
                    callback: callback,
                    priorityLevel: priorityLevel,
                    startTime: options,
                    expirationTime: timeout,
                    sortIndex: -1
                };
                options > currentTime ? ((priorityLevel.sortIndex = options), push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1)) : (isHostTimeoutScheduled = true), requestHostTimeout(handleTimeout, options - currentTime))) : ((priorityLevel.sortIndex = timeout), push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || ((isHostCallbackScheduled = true), isMessageLoopRunning || ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline())));
                return priorityLevel;
            };
            exports.unstable_shouldYield = shouldYieldToHost;
            exports.unstable_wrapCallback = function(callback) {
                var parentPriorityLevel = currentPriorityLevel;
                return function() {
                    var previousPriorityLevel = currentPriorityLevel;
                    currentPriorityLevel = parentPriorityLevel;
                    try {
                        return callback.apply(this, arguments);
                    } finally{
                        currentPriorityLevel = previousPriorityLevel;
                    }
                };
            };
        }(scheduler_production));
        return scheduler_production;
    }
    var hasRequiredScheduler;
    function requireScheduler() {
        if (hasRequiredScheduler) return scheduler.exports;
        hasRequiredScheduler = 1;
        {
            scheduler.exports = requireScheduler_production();
        }
        return scheduler.exports;
    }
    var reactDom = {
        exports: {}
    };
    var reactDom_production = {};
    var hasRequiredReactDom_production;
    function requireReactDom_production() {
        if (hasRequiredReactDom_production) return reactDom_production;
        hasRequiredReactDom_production = 1;
        var React = requireReact();
        function formatProdErrorMessage(code) {
            var url = "https://react.dev/errors/" + code;
            if (1 < arguments.length) {
                url += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var i = 2; i < arguments.length; i++)url += "&args[]=" + encodeURIComponent(arguments[i]);
            }
            return ("Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
        }
        function noop() {}
        var Internals = {
            d: {
                f: noop,
                r: function() {
                    throw Error(formatProdErrorMessage(522));
                },
                D: noop,
                C: noop,
                L: noop,
                m: noop,
                X: noop,
                S: noop,
                M: noop
            },
            p: 0,
            findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
        function createPortal$1(children, containerInfo, implementation) {
            var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
            return {
                $$typeof: REACT_PORTAL_TYPE,
                key: null == key ? null : "" + key,
                children: children,
                containerInfo: containerInfo,
                implementation: implementation
            };
        }
        var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        function getCrossOriginStringAs(as, input) {
            if ("font" === as) return "";
            if ("string" === typeof input) return "use-credentials" === input ? input : "";
        }
        reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        reactDom_production.createPortal = function(children, container) {
            var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
            if (!container || (1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)) throw Error(formatProdErrorMessage(299));
            return createPortal$1(children, container, null, key);
        };
        reactDom_production.flushSync = function(fn) {
            var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
            try {
                if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
            } finally{
                (ReactSharedInternals.T = previousTransition), (Internals.p = previousUpdatePriority), Internals.d.f();
            }
        };
        reactDom_production.preconnect = function(href, options) {
            "string" === typeof href && (options ? ((options = options.crossOrigin), (options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0)) : (options = null), Internals.d.C(href, options));
        };
        reactDom_production.prefetchDNS = function(href) {
            "string" === typeof href && Internals.d.D(href);
        };
        reactDom_production.preinit = function(href, options) {
            if ("string" === typeof href && options && "string" === typeof options.as) {
                var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
                "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : void 0, {
                    crossOrigin: crossOrigin,
                    integrity: integrity,
                    fetchPriority: fetchPriority
                }) : "script" === as && Internals.d.X(href, {
                    crossOrigin: crossOrigin,
                    integrity: integrity,
                    fetchPriority: fetchPriority,
                    nonce: "string" === typeof options.nonce ? options.nonce : void 0
                });
            }
        };
        reactDom_production.preinitModule = function(href, options) {
            if ("string" === typeof href) if ("object" === typeof options && null !== options) {
                if (null == options.as || "script" === options.as) {
                    var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
                    Internals.d.M(href, {
                        crossOrigin: crossOrigin,
                        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                        nonce: "string" === typeof options.nonce ? options.nonce : void 0
                    });
                }
            } else null == options && Internals.d.M(href);
        };
        reactDom_production.preload = function(href, options) {
            if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
                var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
                Internals.d.L(href, as, {
                    crossOrigin: crossOrigin,
                    integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                    nonce: "string" === typeof options.nonce ? options.nonce : void 0,
                    type: "string" === typeof options.type ? options.type : void 0,
                    fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
                    referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
                    imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
                    imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
                    media: "string" === typeof options.media ? options.media : void 0
                });
            }
        };
        reactDom_production.preloadModule = function(href, options) {
            if ("string" === typeof href) if (options) {
                var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
                Internals.d.m(href, {
                    as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
                    crossOrigin: crossOrigin,
                    integrity: "string" === typeof options.integrity ? options.integrity : void 0
                });
            } else Internals.d.m(href);
        };
        reactDom_production.requestFormReset = function(form) {
            Internals.d.r(form);
        };
        reactDom_production.unstable_batchedUpdates = function(fn, a) {
            return fn(a);
        };
        reactDom_production.useFormState = function(action, initialState, permalink) {
            return ReactSharedInternals.H.useFormState(action, initialState, permalink);
        };
        reactDom_production.useFormStatus = function() {
            return ReactSharedInternals.H.useHostTransitionStatus();
        };
        reactDom_production.version = "19.1.1";
        return reactDom_production;
    }
    var hasRequiredReactDom;
    function requireReactDom() {
        if (hasRequiredReactDom) return reactDom.exports;
        hasRequiredReactDom = 1;
        function checkDCE() {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
                return;
            }
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
            } catch (err) {
                console.error(err);
            }
        }
        {
            checkDCE();
            reactDom.exports = requireReactDom_production();
        }
        return reactDom.exports;
    }
    var hasRequiredReactDomClient_production;
    function requireReactDomClient_production() {
        if (hasRequiredReactDomClient_production) return reactDomClient_production;
        hasRequiredReactDomClient_production = 1;
        var Scheduler = requireScheduler(), React = requireReact(), ReactDOM = requireReactDom();
        function formatProdErrorMessage(code) {
            var url = "https://react.dev/errors/" + code;
            if (1 < arguments.length) {
                url += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var i = 2; i < arguments.length; i++)url += "&args[]=" + encodeURIComponent(arguments[i]);
            }
            return ("Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
        }
        function isValidContainer(node) {
            return !(!node || (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType));
        }
        function getNearestMountedFiber(fiber) {
            var node = fiber, nearestMounted = fiber;
            if (fiber.alternate) for(; node.return;)node = node.return;
            else {
                fiber = node;
                do (node = fiber), 0 !== (node.flags & 4098) && (nearestMounted = node.return), (fiber = node.return);
                while (fiber);
            }
            return 3 === node.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
            if (13 === fiber.tag) {
                var suspenseState = fiber.memoizedState;
                null === suspenseState && ((fiber = fiber.alternate), null !== fiber && (suspenseState = fiber.memoizedState));
                if (null !== suspenseState) return suspenseState.dehydrated;
            }
            return null;
        }
        function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) throw Error(formatProdErrorMessage(188));
        }
        function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
                alternate = getNearestMountedFiber(fiber);
                if (null === alternate) throw Error(formatProdErrorMessage(188));
                return alternate !== fiber ? null : fiber;
            }
            for(var a = fiber, b = alternate;;){
                var parentA = a.return;
                if (null === parentA) break;
                var parentB = parentA.alternate;
                if (null === parentB) {
                    b = parentA.return;
                    if (null !== b) {
                        a = b;
                        continue;
                    }
                    break;
                }
                if (parentA.child === parentB.child) {
                    for(parentB = parentA.child; parentB;){
                        if (parentB === a) return assertIsMounted(parentA), fiber;
                        if (parentB === b) return assertIsMounted(parentA), alternate;
                        parentB = parentB.sibling;
                    }
                    throw Error(formatProdErrorMessage(188));
                }
                if (a.return !== b.return) (a = parentA), (b = parentB);
                else {
                    for(var didFindChild = false, child$0 = parentA.child; child$0;){
                        if (child$0 === a) {
                            didFindChild = true;
                            a = parentA;
                            b = parentB;
                            break;
                        }
                        if (child$0 === b) {
                            didFindChild = true;
                            b = parentA;
                            a = parentB;
                            break;
                        }
                        child$0 = child$0.sibling;
                    }
                    if (!didFindChild) {
                        for(child$0 = parentB.child; child$0;){
                            if (child$0 === a) {
                                didFindChild = true;
                                a = parentB;
                                b = parentA;
                                break;
                            }
                            if (child$0 === b) {
                                didFindChild = true;
                                b = parentB;
                                a = parentA;
                                break;
                            }
                            child$0 = child$0.sibling;
                        }
                        if (!didFindChild) throw Error(formatProdErrorMessage(189));
                    }
                }
                if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
            }
            if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
            return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node) {
            var tag = node.tag;
            if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
            for(node = node.child; null !== node;){
                tag = findCurrentHostFiberImpl(node);
                if (null !== tag) return tag;
                node = node.sibling;
            }
            return null;
        }
        var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        function getIteratorFn(maybeIterable) {
            if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
            maybeIterable = (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) || maybeIterable["@@iterator"];
            return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
        function getComponentNameFromType(type) {
            if (null == type) return null;
            if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
            if ("string" === typeof type) return type;
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return "Fragment";
                case REACT_PROFILER_TYPE:
                    return "Profiler";
                case REACT_STRICT_MODE_TYPE:
                    return "StrictMode";
                case REACT_SUSPENSE_TYPE:
                    return "Suspense";
                case REACT_SUSPENSE_LIST_TYPE:
                    return "SuspenseList";
                case REACT_ACTIVITY_TYPE:
                    return "Activity";
            }
            if ("object" === typeof type) switch(type.$$typeof){
                case REACT_PORTAL_TYPE:
                    return "Portal";
                case REACT_CONTEXT_TYPE:
                    return (type.displayName || "Context") + ".Provider";
                case REACT_CONSUMER_TYPE:
                    return (type._context.displayName || "Context") + ".Consumer";
                case REACT_FORWARD_REF_TYPE:
                    var innerType = type.render;
                    type = type.displayName;
                    type || ((type = innerType.displayName || innerType.name || ""), (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
                    return type;
                case REACT_MEMO_TYPE:
                    return ((innerType = type.displayName || null), null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo");
                case REACT_LAZY_TYPE:
                    innerType = type._payload;
                    type = type._init;
                    try {
                        return getComponentNameFromType(type(innerType));
                    } catch (x) {}
            }
            return null;
        }
        var isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
            pending: false,
            data: null,
            method: null,
            action: null
        }, valueStack = [], index = -1;
        function createCursor(defaultValue) {
            return {
                current: defaultValue
            };
        }
        function pop(cursor) {
            0 > index || ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
        }
        function push(cursor, value) {
            index++;
            valueStack[index] = cursor.current;
            cursor.current = value;
        }
        var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
        function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance);
            push(contextFiberStackCursor, fiber);
            push(contextStackCursor, null);
            switch(nextRootInstance.nodeType){
                case 9:
                case 11:
                    fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
                    break;
                default:
                    if (((fiber = nextRootInstance.tagName), (nextRootInstance = nextRootInstance.namespaceURI))) (nextRootInstance = getOwnHostContext(nextRootInstance)), (fiber = getChildHostContextProd(nextRootInstance, fiber));
                    else switch(fiber){
                        case "svg":
                            fiber = 1;
                            break;
                        case "math":
                            fiber = 2;
                            break;
                        default:
                            fiber = 0;
                    }
            }
            pop(contextStackCursor);
            push(contextStackCursor, fiber);
        }
        function popHostContainer() {
            pop(contextStackCursor);
            pop(contextFiberStackCursor);
            pop(rootInstanceStackCursor);
        }
        function pushHostContext(fiber) {
            null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
            var context = contextStackCursor.current;
            var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
            context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
        }
        function popHostContext(fiber) {
            contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
            hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), (HostTransitionContext._currentValue = sharedNotPendingObject));
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
        function setIsStrictModeForDevtools(newIsStrictMode) {
            "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
            if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {}
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
        function clz32Fallback(x) {
            x >>>= 0;
            return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
        }
        var nextTransitionLane = 256, nextRetryLane = 4194304;
        function getHighestPriorityLanes(lanes) {
            var pendingSyncLanes = lanes & 42;
            if (0 !== pendingSyncLanes) return pendingSyncLanes;
            switch(lanes & -lanes){
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                    return 64;
                case 128:
                    return 128;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return lanes & 4194048;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return lanes & 62914560;
                case 67108864:
                    return 67108864;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 0;
                default:
                    return lanes;
            }
        }
        function getNextLanes(root, wipLanes, rootHasPendingCommit) {
            var pendingLanes = root.pendingLanes;
            if (0 === pendingLanes) return 0;
            var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;
            root = root.warmLanes;
            var nonIdlePendingLanes = pendingLanes & 134217727;
            0 !== nonIdlePendingLanes ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes), 0 !== pendingLanes ? (nextLanes = getHighestPriorityLanes(pendingLanes)) : ((pingedLanes &= nonIdlePendingLanes), 0 !== pingedLanes ? (nextLanes = getHighestPriorityLanes(pingedLanes)) : rootHasPendingCommit || ((rootHasPendingCommit = nonIdlePendingLanes & ~root), 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes), 0 !== nonIdlePendingLanes ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes)) : 0 !== pingedLanes ? (nextLanes = getHighestPriorityLanes(pingedLanes)) : rootHasPendingCommit || ((rootHasPendingCommit = pendingLanes & ~root), 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
            return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && ((suspendedLanes = nextLanes & -nextLanes), (rootHasPendingCommit = wipLanes & -wipLanes), suspendedLanes >= rootHasPendingCommit || (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048))) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root, renderLanes) {
            return (0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes));
        }
        function computeExpirationTime(lane, currentTime) {
            switch(lane){
                case 1:
                case 2:
                case 4:
                case 8:
                case 64:
                    return currentTime + 250;
                case 16:
                case 32:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return currentTime + 5e3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return -1;
                case 67108864:
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                    return -1;
                default:
                    return -1;
            }
        }
        function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
            return lane;
        }
        function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
            return lane;
        }
        function createLaneMap(initial) {
            for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);
            return laneMap;
        }
        function markRootUpdated$1(root, updateLane) {
            root.pendingLanes |= updateLane;
            268435456 !== updateLane && ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
        }
        function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
            var previouslyPendingLanes = root.pendingLanes;
            root.pendingLanes = remainingLanes;
            root.suspendedLanes = 0;
            root.pingedLanes = 0;
            root.warmLanes = 0;
            root.expiredLanes &= remainingLanes;
            root.entangledLanes &= remainingLanes;
            root.errorRecoveryDisabledLanes &= remainingLanes;
            root.shellSuspendCounter = 0;
            var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;
            for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){
                var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
                entanglements[index$5] = 0;
                expirationTimes[index$5] = -1;
                var hiddenUpdatesForLane = hiddenUpdates[index$5];
                if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++){
                    var update = hiddenUpdatesForLane[index$5];
                    null !== update && (update.lane &= -536870913);
                }
                remainingLanes &= ~lane;
            }
            0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
            0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
            root.pendingLanes |= spawnedLane;
            root.suspendedLanes &= ~spawnedLane;
            var spawnedLaneIndex = 31 - clz32(spawnedLane);
            root.entangledLanes |= spawnedLane;
            root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | (entangledLanes & 4194090);
        }
        function markRootEntangled(root, entangledLanes) {
            var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
            for(root = root.entanglements; rootEntangledLanes;){
                var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
                (lane & entangledLanes) | (root[index$6] & entangledLanes) && (root[index$6] |= entangledLanes);
                rootEntangledLanes &= ~lane;
            }
        }
        function getBumpedLaneForHydrationByLane(lane) {
            switch(lane){
                case 2:
                    lane = 1;
                    break;
                case 8:
                    lane = 4;
                    break;
                case 32:
                    lane = 16;
                    break;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    lane = 128;
                    break;
                case 268435456:
                    lane = 134217728;
                    break;
                default:
                    lane = 0;
            }
            return lane;
        }
        function lanesToEventPriority(lanes) {
            lanes &= -lanes;
            return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
        }
        function resolveUpdatePriority() {
            var updatePriority = ReactDOMSharedInternals.p;
            if (0 !== updatePriority) return updatePriority;
            updatePriority = window.event;
            return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
            var previousPriority = ReactDOMSharedInternals.p;
            try {
                return (ReactDOMSharedInternals.p = priority), fn();
            } finally{
                ReactDOMSharedInternals.p = previousPriority;
            }
        }
        var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
        function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) return targetInst;
            for(var parentNode = targetNode.parentNode; parentNode;){
                if ((targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey])) {
                    parentNode = targetInst.alternate;
                    if (null !== targetInst.child || (null !== parentNode && null !== parentNode.child)) for(targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;){
                        if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
                        targetNode = getParentSuspenseInstance(targetNode);
                    }
                    return targetInst;
                }
                targetNode = parentNode;
                parentNode = targetNode.parentNode;
            }
            return null;
        }
        function getInstanceFromNode(node) {
            if ((node = node[internalInstanceKey] || node[internalContainerInstanceKey])) {
                var tag = node.tag;
                if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
            }
            return null;
        }
        function getNodeFromInstance(inst) {
            var tag = inst.tag;
            if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
            throw Error(formatProdErrorMessage(33));
        }
        function getResourcesFromRoot(root) {
            var resources = root[internalRootNodeResourcesKey];
            resources || (resources = root[internalRootNodeResourcesKey] = {
                hoistableStyles: new Map(),
                hoistableScripts: new Map()
            });
            return resources;
        }
        function markNodeAsHoistable(node) {
            node[internalHoistableMarker] = true;
        }
        var allNativeEvents = new Set(), registrationNameDependencies = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
            registrationNameDependencies[registrationName] = dependencies;
            for(registrationName = 0; registrationName < dependencies.length; registrationName++)allNativeEvents.add(dependencies[registrationName]);
        }
        var VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return true;
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return (validatedAttributeNameCache[attributeName] = true);
            illegalAttributeNameCache[attributeName] = true;
            return false;
        }
        function setValueForAttribute(node, name, value) {
            if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);
            else {
                switch(typeof value){
                    case "undefined":
                    case "function":
                    case "symbol":
                        node.removeAttribute(name);
                        return;
                    case "boolean":
                        var prefix$8 = name.toLowerCase().slice(0, 5);
                        if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
                            node.removeAttribute(name);
                            return;
                        }
                }
                node.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node, name, value) {
            if (null === value) node.removeAttribute(name);
            else {
                switch(typeof value){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        node.removeAttribute(name);
                        return;
                }
                node.setAttribute(name, "" + value);
            }
        }
        function setValueForNamespacedAttribute(node, namespace, name, value) {
            if (null === value) node.removeAttribute(name);
            else {
                switch(typeof value){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        node.removeAttribute(name);
                        return;
                }
                node.setAttributeNS(namespace, name, "" + value);
            }
        }
        var prefix, suffix;
        function describeBuiltInComponentFrame(name) {
            if (void 0 === prefix) try {
                throw Error();
            } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = (match && match[1]) || "";
                suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
            return "\n" + prefix + name + suffix;
        }
        var reentry = false;
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) return "";
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
                var RunInRootFrame = {
                    DetermineComponentFrameRoot: function() {
                        try {
                            if (construct) {
                                var Fake = function() {
                                    throw Error();
                                };
                                Object.defineProperty(Fake.prototype, "props", {
                                    set: function() {
                                        throw Error();
                                    }
                                });
                                if ("object" === typeof Reflect && Reflect.construct) {
                                    try {
                                        Reflect.construct(Fake, []);
                                    } catch (x) {
                                        var control = x;
                                    }
                                    Reflect.construct(fn, [], Fake);
                                } else {
                                    try {
                                        Fake.call();
                                    } catch (x$9) {
                                        control = x$9;
                                    }
                                    fn.call(Fake.prototype);
                                }
                            } else {
                                try {
                                    throw Error();
                                } catch (x$10) {
                                    control = x$10;
                                }
                                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                            }
                        } catch (sample) {
                            if (sample && control && "string" === typeof sample.stack) return [
                                sample.stack,
                                control.stack
                            ];
                        }
                        return [
                            null,
                            null
                        ];
                    }
                };
                RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
                namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                    value: "DetermineComponentFrameRoot"
                });
                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
                if (sampleStack && controlStack) {
                    var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                    for(namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");)RunInRootFrame++;
                    for(; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                    if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for(RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];)namePropDescriptor--;
                    for(; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                        if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                            do if ((RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor])) {
                                var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                                fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                                return frame;
                            }
                            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                        }
                        break;
                    }
                }
            } finally{
                (reentry = false), (Error.prepareStackTrace = previousPrepareStackTrace);
            }
            return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
        }
        function describeFiber(fiber) {
            switch(fiber.tag){
                case 26:
                case 27:
                case 5:
                    return describeBuiltInComponentFrame(fiber.type);
                case 16:
                    return describeBuiltInComponentFrame("Lazy");
                case 13:
                    return describeBuiltInComponentFrame("Suspense");
                case 19:
                    return describeBuiltInComponentFrame("SuspenseList");
                case 0:
                case 15:
                    return describeNativeComponentFrame(fiber.type, false);
                case 11:
                    return describeNativeComponentFrame(fiber.type.render, false);
                case 1:
                    return describeNativeComponentFrame(fiber.type, true);
                case 31:
                    return describeBuiltInComponentFrame("Activity");
                default:
                    return "";
            }
        }
        function getStackByFiberInDevAndProd(workInProgress) {
            try {
                var info = "";
                do (info += describeFiber(workInProgress)), (workInProgress = workInProgress.return);
                while (workInProgress);
                return info;
            } catch (x) {
                return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
        }
        function getToStringValue(value) {
            switch(typeof value){
                case "bigint":
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                    return value;
                case "object":
                    return value;
                default:
                    return "";
            }
        }
        function isCheckable(elem) {
            var type = elem.type;
            return ((elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type));
        }
        function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField), currentValue = "" + node[valueField];
            if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
                var get = descriptor.get, set = descriptor.set;
                Object.defineProperty(node, valueField, {
                    configurable: true,
                    get: function() {
                        return get.call(this);
                    },
                    set: function(value) {
                        currentValue = "" + value;
                        set.call(this, value);
                    }
                });
                Object.defineProperty(node, valueField, {
                    enumerable: descriptor.enumerable
                });
                return {
                    getValue: function() {
                        return currentValue;
                    },
                    setValue: function(value) {
                        currentValue = "" + value;
                    },
                    stopTracking: function() {
                        node._valueTracker = null;
                        delete node[valueField];
                    }
                };
            }
        }
        function track(node) {
            node._valueTracker || (node._valueTracker = trackValueOnNode(node));
        }
        function updateValueIfChanged(node) {
            if (!node) return false;
            var tracker = node._valueTracker;
            if (!tracker) return true;
            var lastValue = tracker.getValue();
            var value = "";
            node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
            node = value;
            return node !== lastValue ? (tracker.setValue(node), true) : false;
        }
        function getActiveElement(doc) {
            doc = doc || ("undefined" !== typeof document ? document : void 0);
            if ("undefined" === typeof doc) return null;
            try {
                return doc.activeElement || doc.body;
            } catch (e) {
                return doc.body;
            }
        }
        var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
            return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
                return "\\" + ch.charCodeAt(0).toString(16) + " ";
            });
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
            element.name = "";
            null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (element.type = type) : element.removeAttribute("type");
            if (null != value) if ("number" === type) {
                if ((0 === value && "" === element.value) || element.value != value) element.value = "" + getToStringValue(value);
            } else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
            else ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
            null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
            null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
            null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
            null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
            null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
            if (null != value || null != defaultValue) {
                if (!(("submit" !== type && "reset" !== type) || (void 0 !== value && null !== value))) return;
                defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
                value = null != value ? "" + getToStringValue(value) : defaultValue;
                isHydrating || value === element.value || (element.value = value);
                element.defaultValue = value;
            }
            checked = null != checked ? checked : defaultChecked;
            checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
            element.checked = isHydrating ? element.checked : !!checked;
            element.defaultChecked = !!checked;
            null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
        }
        function setDefaultValue(node, type, value) {
            ("number" === type && getActiveElement(node.ownerDocument) === node) || node.defaultValue === "" + value || (node.defaultValue = "" + value);
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
            node = node.options;
            if (multiple) {
                multiple = {};
                for(var i = 0; i < propValue.length; i++)multiple["$" + propValue[i]] = true;
                for(propValue = 0; propValue < node.length; propValue++)(i = multiple.hasOwnProperty("$" + node[propValue].value)), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
            } else {
                propValue = "" + getToStringValue(propValue);
                multiple = null;
                for(i = 0; i < node.length; i++){
                    if (node[i].value === propValue) {
                        node[i].selected = true;
                        setDefaultSelected && (node[i].defaultSelected = true);
                        return;
                    }
                    null !== multiple || node[i].disabled || (multiple = node[i]);
                }
                null !== multiple && (multiple.selected = true);
            }
        }
        function updateTextarea(element, value, defaultValue) {
            if (null != value && ((value = "" + getToStringValue(value)), value !== element.value && (element.value = value), null == defaultValue)) {
                element.defaultValue !== value && (element.defaultValue = value);
                return;
            }
            element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
            if (null == value) {
                if (null != children) {
                    if (null != defaultValue) throw Error(formatProdErrorMessage(92));
                    if (isArrayImpl(children)) {
                        if (1 < children.length) throw Error(formatProdErrorMessage(93));
                        children = children[0];
                    }
                    defaultValue = children;
                }
                null == defaultValue && (defaultValue = "");
                value = defaultValue;
            }
            defaultValue = getToStringValue(value);
            element.defaultValue = defaultValue;
            children = element.textContent;
            children === defaultValue && "" !== children && null !== children && (element.value = children);
        }
        function setTextContent(node, text) {
            if (text) {
                var firstChild = node.firstChild;
                if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
                    firstChild.nodeValue = text;
                    return;
                }
            }
            node.textContent = text;
        }
        var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
        function setValueForStyle(style, styleName, value) {
            var isCustomProperty = 0 === styleName.indexOf("--");
            null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? (style.cssFloat = "") : (style[styleName] = "") : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? (style.cssFloat = value) : (style[styleName] = ("" + value).trim()) : (style[styleName] = value + "px");
        }
        function setValueForStyles(node, styles, prevStyles) {
            if (null != styles && "object" !== typeof styles) throw Error(formatProdErrorMessage(62));
            node = node.style;
            if (null != prevStyles) {
                for(var styleName in prevStyles)!prevStyles.hasOwnProperty(styleName) || (null != styles && styles.hasOwnProperty(styleName)) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? (node.cssFloat = "") : (node[styleName] = ""));
                for(var styleName$16 in styles)(styleName = styles[styleName$16]), styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
            } else for(var styleName$17 in styles)styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
        }
        function isCustomElement(tagName) {
            if (-1 === tagName.indexOf("-")) return false;
            switch(tagName){
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                    return false;
                default:
                    return true;
            }
        }
        var aliases = new Map([
            [
                "acceptCharset",
                "accept-charset"
            ],
            [
                "htmlFor",
                "for"
            ],
            [
                "httpEquiv",
                "http-equiv"
            ],
            [
                "crossOrigin",
                "crossorigin"
            ],
            [
                "accentHeight",
                "accent-height"
            ],
            [
                "alignmentBaseline",
                "alignment-baseline"
            ],
            [
                "arabicForm",
                "arabic-form"
            ],
            [
                "baselineShift",
                "baseline-shift"
            ],
            [
                "capHeight",
                "cap-height"
            ],
            [
                "clipPath",
                "clip-path"
            ],
            [
                "clipRule",
                "clip-rule"
            ],
            [
                "colorInterpolation",
                "color-interpolation"
            ],
            [
                "colorInterpolationFilters",
                "color-interpolation-filters"
            ],
            [
                "colorProfile",
                "color-profile"
            ],
            [
                "colorRendering",
                "color-rendering"
            ],
            [
                "dominantBaseline",
                "dominant-baseline"
            ],
            [
                "enableBackground",
                "enable-background"
            ],
            [
                "fillOpacity",
                "fill-opacity"
            ],
            [
                "fillRule",
                "fill-rule"
            ],
            [
                "floodColor",
                "flood-color"
            ],
            [
                "floodOpacity",
                "flood-opacity"
            ],
            [
                "fontFamily",
                "font-family"
            ],
            [
                "fontSize",
                "font-size"
            ],
            [
                "fontSizeAdjust",
                "font-size-adjust"
            ],
            [
                "fontStretch",
                "font-stretch"
            ],
            [
                "fontStyle",
                "font-style"
            ],
            [
                "fontVariant",
                "font-variant"
            ],
            [
                "fontWeight",
                "font-weight"
            ],
            [
                "glyphName",
                "glyph-name"
            ],
            [
                "glyphOrientationHorizontal",
                "glyph-orientation-horizontal"
            ],
            [
                "glyphOrientationVertical",
                "glyph-orientation-vertical"
            ],
            [
                "horizAdvX",
                "horiz-adv-x"
            ],
            [
                "horizOriginX",
                "horiz-origin-x"
            ],
            [
                "imageRendering",
                "image-rendering"
            ],
            [
                "letterSpacing",
                "letter-spacing"
            ],
            [
                "lightingColor",
                "lighting-color"
            ],
            [
                "markerEnd",
                "marker-end"
            ],
            [
                "markerMid",
                "marker-mid"
            ],
            [
                "markerStart",
                "marker-start"
            ],
            [
                "overlinePosition",
                "overline-position"
            ],
            [
                "overlineThickness",
                "overline-thickness"
            ],
            [
                "paintOrder",
                "paint-order"
            ],
            [
                "panose-1",
                "panose-1"
            ],
            [
                "pointerEvents",
                "pointer-events"
            ],
            [
                "renderingIntent",
                "rendering-intent"
            ],
            [
                "shapeRendering",
                "shape-rendering"
            ],
            [
                "stopColor",
                "stop-color"
            ],
            [
                "stopOpacity",
                "stop-opacity"
            ],
            [
                "strikethroughPosition",
                "strikethrough-position"
            ],
            [
                "strikethroughThickness",
                "strikethrough-thickness"
            ],
            [
                "strokeDasharray",
                "stroke-dasharray"
            ],
            [
                "strokeDashoffset",
                "stroke-dashoffset"
            ],
            [
                "strokeLinecap",
                "stroke-linecap"
            ],
            [
                "strokeLinejoin",
                "stroke-linejoin"
            ],
            [
                "strokeMiterlimit",
                "stroke-miterlimit"
            ],
            [
                "strokeOpacity",
                "stroke-opacity"
            ],
            [
                "strokeWidth",
                "stroke-width"
            ],
            [
                "textAnchor",
                "text-anchor"
            ],
            [
                "textDecoration",
                "text-decoration"
            ],
            [
                "textRendering",
                "text-rendering"
            ],
            [
                "transformOrigin",
                "transform-origin"
            ],
            [
                "underlinePosition",
                "underline-position"
            ],
            [
                "underlineThickness",
                "underline-thickness"
            ],
            [
                "unicodeBidi",
                "unicode-bidi"
            ],
            [
                "unicodeRange",
                "unicode-range"
            ],
            [
                "unitsPerEm",
                "units-per-em"
            ],
            [
                "vAlphabetic",
                "v-alphabetic"
            ],
            [
                "vHanging",
                "v-hanging"
            ],
            [
                "vIdeographic",
                "v-ideographic"
            ],
            [
                "vMathematical",
                "v-mathematical"
            ],
            [
                "vectorEffect",
                "vector-effect"
            ],
            [
                "vertAdvY",
                "vert-adv-y"
            ],
            [
                "vertOriginX",
                "vert-origin-x"
            ],
            [
                "vertOriginY",
                "vert-origin-y"
            ],
            [
                "wordSpacing",
                "word-spacing"
            ],
            [
                "writingMode",
                "writing-mode"
            ],
            [
                "xmlnsXlink",
                "xmlns:xlink"
            ],
            [
                "xHeight",
                "x-height"
            ]
        ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
        function sanitizeURL(url) {
            return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
        }
        var currentReplayingEvent = null;
        function getEventTarget(nativeEvent) {
            nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
            nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
            return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        var restoreTarget = null, restoreQueue = null;
        function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (internalInstance && (target = internalInstance.stateNode)) {
                var props = target[internalPropsKey] || null;
                a: switch(((target = internalInstance.stateNode), internalInstance.type)){
                    case "input":
                        updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
                        internalInstance = props.name;
                        if ("radio" === props.type && null != internalInstance) {
                            for(props = target; props.parentNode;)props = props.parentNode;
                            props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
                            for(internalInstance = 0; internalInstance < props.length; internalInstance++){
                                var otherNode = props[internalInstance];
                                if (otherNode !== target && otherNode.form === target.form) {
                                    var otherProps = otherNode[internalPropsKey] || null;
                                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                                    updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
                                }
                            }
                            for(internalInstance = 0; internalInstance < props.length; internalInstance++)(otherNode = props[internalInstance]), otherNode.form === target.form && updateValueIfChanged(otherNode);
                        }
                        break a;
                    case "textarea":
                        updateTextarea(target, props.value, props.defaultValue);
                        break a;
                    case "select":
                        (internalInstance = props.value), null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
                }
            }
        }
        var isInsideEventHandler = false;
        function batchedUpdates$1(fn, a, b) {
            if (isInsideEventHandler) return fn(a, b);
            isInsideEventHandler = true;
            try {
                var JSCompiler_inline_result = fn(a);
                return JSCompiler_inline_result;
            } finally{
                if (((isInsideEventHandler = false), null !== restoreTarget || null !== restoreQueue)) if ((flushSyncWork$1(), restoreTarget && ((a = restoreTarget), (fn = restoreQueue), (restoreQueue = restoreTarget = null), restoreStateOfTarget(a), fn))) for(a = 0; a < fn.length; a++)restoreStateOfTarget(fn[a]);
            }
        }
        function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (null === stateNode) return null;
            var props = stateNode[internalPropsKey] || null;
            if (null === props) return null;
            stateNode = props[registrationName];
            a: switch(registrationName){
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                    (props = !props.disabled) || ((inst = inst.type), (props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst)));
                    inst = !props;
                    break a;
                default:
                    inst = false;
            }
            if (inst) return null;
            if (stateNode && "function" !== typeof stateNode) throw Error(formatProdErrorMessage(231, registrationName, typeof stateNode));
            return stateNode;
        }
        var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
        if (canUseDOM) try {
            var options = {};
            Object.defineProperty(options, "passive", {
                get: function() {
                    passiveBrowserEventsSupported = !0;
                }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
        } catch (e) {
            passiveBrowserEventsSupported = false;
        }
        var root = null, startText = null, fallbackText = null;
        function getData() {
            if (fallbackText) return fallbackText;
            var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
            for(start = 0; start < startLength && startValue[start] === endValue[start]; start++);
            var minEnd = startLength - start;
            for(end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
            return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
        }
        function getEventCharCode(nativeEvent) {
            var keyCode = nativeEvent.keyCode;
            "charCode" in nativeEvent ? ((nativeEvent = nativeEvent.charCode), 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : (nativeEvent = keyCode);
            10 === nativeEvent && (nativeEvent = 13);
            return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
            return true;
        }
        function functionThatReturnsFalse() {
            return false;
        }
        function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
                this._reactName = reactName;
                this._targetInst = targetInst;
                this.type = reactEventType;
                this.nativeEvent = nativeEvent;
                this.target = nativeEventTarget;
                this.currentTarget = null;
                for(var propName in Interface)Interface.hasOwnProperty(propName) && ((reactName = Interface[propName]), (this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]));
                this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
                this.isPropagationStopped = functionThatReturnsFalse;
                return this;
            }
            assign(SyntheticBaseEvent.prototype, {
                preventDefault: function() {
                    this.defaultPrevented = true;
                    var event = this.nativeEvent;
                    event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), (this.isDefaultPrevented = functionThatReturnsTrue));
                },
                stopPropagation: function() {
                    var event = this.nativeEvent;
                    event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), (this.isPropagationStopped = functionThatReturnsTrue));
                },
                persist: function() {},
                isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
        }
        var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
                return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
        }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
                return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
            },
            movementX: function(event) {
                if ("movementX" in event) return event.movementX;
                event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? ((lastMovementX = event.screenX - lastMouseEvent.screenX), (lastMovementY = event.screenY - lastMouseEvent.screenY)) : (lastMovementY = lastMovementX = 0), (lastMouseEvent = event));
                return lastMovementX;
            },
            movementY: function(event) {
                return "movementY" in event ? event.movementY : lastMovementY;
            }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
        }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
        }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
                return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, {
            data: 0
        }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, translateToKey = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        }, modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
            var nativeEvent = this.nativeEvent;
            return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
            return modifierStateGetter;
        }
        var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: function(nativeEvent) {
                if (nativeEvent.key) {
                    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                    if ("Unidentified" !== key) return key;
                }
                return "keypress" === nativeEvent.type ? ((nativeEvent = getEventCharCode(nativeEvent)), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function(event) {
                return "keypress" === event.type ? getEventCharCode(event) : 0;
            },
            keyCode: function(event) {
                return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
            },
            which: function(event) {
                return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
            }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
                return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
                return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
            newState: 0,
            oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [
            9,
            13,
            27,
            32
        ], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
        canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || (documentMode && 8 < documentMode && 11 >= documentMode)), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch(domEventName){
                case "keyup":
                    return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
                case "keydown":
                    return 229 !== nativeEvent.keyCode;
                case "keypress":
                case "mousedown":
                case "focusout":
                    return true;
                default:
                    return false;
            }
        }
        function getDataFromCustomEvent(nativeEvent) {
            nativeEvent = nativeEvent.detail;
            return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        var isComposing = false;
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch(domEventName){
                case "compositionend":
                    return getDataFromCustomEvent(nativeEvent);
                case "keypress":
                    if (32 !== nativeEvent.which) return null;
                    hasSpaceKeypress = true;
                    return SPACEBAR_CHAR;
                case "textInput":
                    return ((domEventName = nativeEvent.data), domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName);
                default:
                    return null;
            }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) return "compositionend" === domEventName || (!canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) ? ((domEventName = getData()), (fallbackText = startText = root = null), (isComposing = false), domEventName) : null;
            switch(domEventName){
                case "paste":
                    return null;
                case "keypress":
                    if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || (nativeEvent.ctrlKey && nativeEvent.altKey)) {
                        if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
                        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
                    }
                    return null;
                case "compositionend":
                    return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
                default:
                    return null;
            }
        }
        var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
        };
        function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            restoreTarget ? restoreQueue ? restoreQueue.push(target) : (restoreQueue = [
                target
            ]) : (restoreTarget = target);
            inst = accumulateTwoPhaseListeners(inst, "onChange");
            0 < inst.length && ((nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target)), dispatchQueue.push({
                event: nativeEvent,
                listeners: inst
            }));
        }
        var activeElement$1 = null, activeElementInst$1 = null;
        function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
            if ("change" === domEventName) return targetInst;
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
            var JSCompiler_inline_result$jscomp$282;
            if (canUseDOM) {
                var isSupported$jscomp$inline_417 = "oninput" in document;
                if (!isSupported$jscomp$inline_417) {
                    var element$jscomp$inline_418 = document.createElement("div");
                    element$jscomp$inline_418.setAttribute("oninput", "return;");
                    isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
                }
                JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
            } else JSCompiler_inline_result$jscomp$282 = false;
            isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
        }
        function stopWatchingForValueChange() {
            activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), (activeElementInst$1 = activeElement$1 = null));
        }
        function handlePropertyChange(nativeEvent) {
            if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
                var dispatchQueue = [];
                createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
                batchedUpdates$1(runEventInBatch, dispatchQueue);
            }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            "focusin" === domEventName ? (stopWatchingForValueChange(), (activeElement$1 = target), (activeElementInst$1 = targetInst), activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
            if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
            if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function is(x, y) {
            return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
        }
        var objectIs = "function" === typeof Object.is ? Object.is : is;
        function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) return true;
            if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return false;
            var keysA = Object.keys(objA), keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) return false;
            for(keysB = 0; keysB < keysA.length; keysB++){
                var currentKey = keysA[keysB];
                if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return false;
            }
            return true;
        }
        function getLeafNode(node) {
            for(; node && node.firstChild;)node = node.firstChild;
            return node;
        }
        function getNodeForCharacterOffset(root, offset) {
            var node = getLeafNode(root);
            root = 0;
            for(var nodeEnd; node;){
                if (3 === node.nodeType) {
                    nodeEnd = root + node.textContent.length;
                    if (root <= offset && nodeEnd >= offset) return {
                        node: node,
                        offset: offset - root
                    };
                    root = nodeEnd;
                }
                a: {
                    for(; node;){
                        if (node.nextSibling) {
                            node = node.nextSibling;
                            break a;
                        }
                        node = node.parentNode;
                    }
                    node = void 0;
                }
                node = getLeafNode(node);
            }
        }
        function containsNode(outerNode, innerNode) {
            return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
            containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
            for(var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;){
                try {
                    var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
                } catch (err) {
                    JSCompiler_inline_result = false;
                }
                if (JSCompiler_inline_result) containerInfo = element.contentWindow;
                else break;
                element = getActiveElement(containerInfo.document);
            }
            return element;
        }
        function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return (nodeName && (("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type)) || "textarea" === nodeName || "true" === elem.contentEditable));
        }
        var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
            mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || ((doc = activeElement), "selectionStart" in doc && hasSelectionCapabilities(doc) ? (doc = {
                start: doc.selectionStart,
                end: doc.selectionEnd
            }) : ((doc = ((doc.ownerDocument && doc.ownerDocument.defaultView) || window).getSelection()), (doc = {
                anchorNode: doc.anchorNode,
                anchorOffset: doc.anchorOffset,
                focusNode: doc.focusNode,
                focusOffset: doc.focusOffset
            })), (lastSelection && shallowEqual(lastSelection, doc)) || ((lastSelection = doc), (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")), 0 < doc.length && ((nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget)), dispatchQueue.push({
                event: nativeEvent,
                listeners: doc
            }), (nativeEvent.target = activeElement))));
        }
        function makePrefixMap(styleProp, eventName) {
            var prefixes = {};
            prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes["Webkit" + styleProp] = "webkit" + eventName;
            prefixes["Moz" + styleProp] = "moz" + eventName;
            return prefixes;
        }
        var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionrun: makePrefixMap("Transition", "TransitionRun"),
            transitionstart: makePrefixMap("Transition", "TransitionStart"),
            transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style = {};
        canUseDOM && ((style = document.createElement("div").style), "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
            if (!vendorPrefixes[eventName]) return eventName;
            var prefixMap = vendorPrefixes[eventName], styleProp;
            for(styleProp in prefixMap)if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return (prefixedEventNames[eventName] = prefixMap[styleProp]);
            return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        simpleEventPluginEvents.push("scrollEnd");
        function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [
                domEventName
            ]);
        }
        var CapturedStacks = new WeakMap();
        function createCapturedValueAtFiber(value, source) {
            if ("object" === typeof value && null !== value) {
                var existing = CapturedStacks.get(value);
                if (void 0 !== existing) return existing;
                source = {
                    value: value,
                    source: source,
                    stack: getStackByFiberInDevAndProd(source)
                };
                CapturedStacks.set(value, source);
                return source;
            }
            return {
                value: value,
                source: source,
                stack: getStackByFiberInDevAndProd(source)
            };
        }
        var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
        function finishQueueingConcurrentUpdates() {
            for(var endIndex = concurrentQueuesIndex, i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0); i < endIndex;){
                var fiber = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var queue = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var update = concurrentQueues[i];
                concurrentQueues[i++] = null;
                var lane = concurrentQueues[i];
                concurrentQueues[i++] = null;
                if (null !== queue && null !== update) {
                    var pending = queue.pending;
                    null === pending ? (update.next = update) : ((update.next = pending.next), (pending.next = update));
                    queue.pending = update;
                }
                0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
            }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
            concurrentQueues[concurrentQueuesIndex++] = fiber;
            concurrentQueues[concurrentQueuesIndex++] = queue;
            concurrentQueues[concurrentQueuesIndex++] = update;
            concurrentQueues[concurrentQueuesIndex++] = lane;
            concurrentlyUpdatedLanes |= lane;
            fiber.lanes |= lane;
            fiber = fiber.alternate;
            null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            enqueueUpdate$1(fiber, queue, update, lane);
            return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
            enqueueUpdate$1(fiber, null, null, lane);
            return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
            sourceFiber.lanes |= lane;
            var alternate = sourceFiber.alternate;
            null !== alternate && (alternate.lanes |= lane);
            for(var isHidden = false, parent = sourceFiber.return; null !== parent;)(parent.childLanes |= lane), (alternate = parent.alternate), null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && ((sourceFiber = parent.stateNode), null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), (sourceFiber = parent), (parent = parent.return);
            return 3 === sourceFiber.tag ? ((parent = sourceFiber.stateNode), isHidden && null !== update && ((isHidden = 31 - clz32(lane)), (sourceFiber = parent.hiddenUpdates), (alternate = sourceFiber[isHidden]), null === alternate ? (sourceFiber[isHidden] = [
                update
            ]) : alternate.push(update), (update.lane = lane | 536870912)), parent) : null;
        }
        function getRootForUpdatedFiber(sourceFiber) {
            if (50 < nestedUpdateCount) throw (((nestedUpdateCount = 0), (rootWithNestedUpdates = null), Error(formatProdErrorMessage(185))));
            for(var parent = sourceFiber.return; null !== parent;)(sourceFiber = parent), (parent = sourceFiber.return);
            return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
        }
        var emptyContextObject = {};
        function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
            this.index = 0;
            this.refCleanup = this.ref = null;
            this.pendingProps = pendingProps;
            this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
            this.mode = mode;
            this.subtreeFlags = this.flags = 0;
            this.deletions = null;
            this.childLanes = this.lanes = 0;
            this.alternate = null;
        }
        function createFiberImplClass(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
        }
        function shouldConstruct(Component) {
            Component = Component.prototype;
            return !(!Component || !Component.isReactComponent);
        }
        function createWorkInProgress(current, pendingProps) {
            var workInProgress = current.alternate;
            null === workInProgress ? ((workInProgress = createFiberImplClass(current.tag, pendingProps, current.key, current.mode)), (workInProgress.elementType = current.elementType), (workInProgress.type = current.type), (workInProgress.stateNode = current.stateNode), (workInProgress.alternate = current), (current.alternate = workInProgress)) : ((workInProgress.pendingProps = pendingProps), (workInProgress.type = current.type), (workInProgress.flags = 0), (workInProgress.subtreeFlags = 0), (workInProgress.deletions = null));
            workInProgress.flags = current.flags & 65011712;
            workInProgress.childLanes = current.childLanes;
            workInProgress.lanes = current.lanes;
            workInProgress.child = current.child;
            workInProgress.memoizedProps = current.memoizedProps;
            workInProgress.memoizedState = current.memoizedState;
            workInProgress.updateQueue = current.updateQueue;
            pendingProps = current.dependencies;
            workInProgress.dependencies = null === pendingProps ? null : {
                lanes: pendingProps.lanes,
                firstContext: pendingProps.firstContext
            };
            workInProgress.sibling = current.sibling;
            workInProgress.index = current.index;
            workInProgress.ref = current.ref;
            workInProgress.refCleanup = current.refCleanup;
            return workInProgress;
        }
        function resetWorkInProgress(workInProgress, renderLanes) {
            workInProgress.flags &= 65011714;
            var current = workInProgress.alternate;
            null === current ? ((workInProgress.childLanes = 0), (workInProgress.lanes = renderLanes), (workInProgress.child = null), (workInProgress.subtreeFlags = 0), (workInProgress.memoizedProps = null), (workInProgress.memoizedState = null), (workInProgress.updateQueue = null), (workInProgress.dependencies = null), (workInProgress.stateNode = null)) : ((workInProgress.childLanes = current.childLanes), (workInProgress.lanes = current.lanes), (workInProgress.child = current.child), (workInProgress.subtreeFlags = 0), (workInProgress.deletions = null), (workInProgress.memoizedProps = current.memoizedProps), (workInProgress.memoizedState = current.memoizedState), (workInProgress.updateQueue = current.updateQueue), (workInProgress.type = current.type), (renderLanes = current.dependencies), (workInProgress.dependencies = null === renderLanes ? null : {
                lanes: renderLanes.lanes,
                firstContext: renderLanes.firstContext
            }));
            return workInProgress;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = 0;
            owner = type;
            if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
            else if ("string" === typeof type) fiberTag = isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
            else a: switch(type){
                case REACT_ACTIVITY_TYPE:
                    return ((type = createFiberImplClass(31, pendingProps, key, mode)), (type.elementType = REACT_ACTIVITY_TYPE), (type.lanes = lanes), type);
                case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                case REACT_STRICT_MODE_TYPE:
                    fiberTag = 8;
                    mode |= 24;
                    break;
                case REACT_PROFILER_TYPE:
                    return ((type = createFiberImplClass(12, pendingProps, key, mode | 2)), (type.elementType = REACT_PROFILER_TYPE), (type.lanes = lanes), type);
                case REACT_SUSPENSE_TYPE:
                    return ((type = createFiberImplClass(13, pendingProps, key, mode)), (type.elementType = REACT_SUSPENSE_TYPE), (type.lanes = lanes), type);
                case REACT_SUSPENSE_LIST_TYPE:
                    return ((type = createFiberImplClass(19, pendingProps, key, mode)), (type.elementType = REACT_SUSPENSE_LIST_TYPE), (type.lanes = lanes), type);
                default:
                    if ("object" === typeof type && null !== type) switch(type.$$typeof){
                        case REACT_PROVIDER_TYPE:
                        case REACT_CONTEXT_TYPE:
                            fiberTag = 10;
                            break a;
                        case REACT_CONSUMER_TYPE:
                            fiberTag = 9;
                            break a;
                        case REACT_FORWARD_REF_TYPE:
                            fiberTag = 11;
                            break a;
                        case REACT_MEMO_TYPE:
                            fiberTag = 14;
                            break a;
                        case REACT_LAZY_TYPE:
                            fiberTag = 16;
                            owner = null;
                            break a;
                    }
                    fiberTag = 29;
                    pendingProps = Error(formatProdErrorMessage(130, null === type ? "null" : typeof type, ""));
                    owner = null;
            }
            key = createFiberImplClass(fiberTag, pendingProps, key, mode);
            key.elementType = type;
            key.type = owner;
            key.lanes = lanes;
            return key;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
            elements = createFiberImplClass(7, elements, key, mode);
            elements.lanes = lanes;
            return elements;
        }
        function createFiberFromText(content, mode, lanes) {
            content = createFiberImplClass(6, content, null, mode);
            content.lanes = lanes;
            return content;
        }
        function createFiberFromPortal(portal, mode, lanes) {
            mode = createFiberImplClass(4, null !== portal.children ? portal.children : [], portal.key, mode);
            mode.lanes = lanes;
            mode.stateNode = {
                containerInfo: portal.containerInfo,
                pendingChildren: null,
                implementation: portal.implementation
            };
            return mode;
        }
        var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
        function pushTreeFork(workInProgress, totalChildren) {
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress;
            treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress, totalChildren, index) {
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress;
            var baseIdWithLeadingBit = treeContextId;
            workInProgress = treeContextOverflow;
            var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
            baseIdWithLeadingBit &= ~(1 << baseLength);
            index += 1;
            var length = 32 - clz32(totalChildren) + baseLength;
            if (30 < length) {
                var numberOfOverflowBits = baseLength - (baseLength % 5);
                length = (baseIdWithLeadingBit & ((1 << numberOfOverflowBits) - 1)).toString(32);
                baseIdWithLeadingBit >>= numberOfOverflowBits;
                baseLength -= numberOfOverflowBits;
                treeContextId = (1 << (32 - clz32(totalChildren) + baseLength)) | (index << baseLength) | baseIdWithLeadingBit;
                treeContextOverflow = length + workInProgress;
            } else (treeContextId = (1 << length) | (index << baseLength) | baseIdWithLeadingBit), (treeContextOverflow = workInProgress);
        }
        function pushMaterializedTreeId(workInProgress) {
            null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
        }
        function popTreeContext(workInProgress) {
            for(; workInProgress === treeForkProvider;)(treeForkProvider = forkStack[--forkStackIndex]), (forkStack[forkStackIndex] = null), (treeForkCount = forkStack[--forkStackIndex]), (forkStack[forkStackIndex] = null);
            for(; workInProgress === treeContextProvider;)(treeContextProvider = idStack[--idStackIndex]), (idStack[idStackIndex] = null), (treeContextOverflow = idStack[--idStackIndex]), (idStack[idStackIndex] = null), (treeContextId = idStack[--idStackIndex]), (idStack[idStackIndex] = null);
        }
        var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
        function throwOnHydrationMismatch(fiber) {
            var error = Error(formatProdErrorMessage(418, ""));
            queueHydrationError(createCapturedValueAtFiber(error, fiber));
            throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
            var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
            instance[internalInstanceKey] = fiber;
            instance[internalPropsKey] = props;
            switch(type){
                case "dialog":
                    listenToNonDelegatedEvent("cancel", instance);
                    listenToNonDelegatedEvent("close", instance);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    listenToNonDelegatedEvent("load", instance);
                    break;
                case "video":
                case "audio":
                    for(type = 0; type < mediaEventTypes.length; type++)listenToNonDelegatedEvent(mediaEventTypes[type], instance);
                    break;
                case "source":
                    listenToNonDelegatedEvent("error", instance);
                    break;
                case "img":
                case "image":
                case "link":
                    listenToNonDelegatedEvent("error", instance);
                    listenToNonDelegatedEvent("load", instance);
                    break;
                case "details":
                    listenToNonDelegatedEvent("toggle", instance);
                    break;
                case "input":
                    listenToNonDelegatedEvent("invalid", instance);
                    initInput(instance, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, true);
                    track(instance);
                    break;
                case "select":
                    listenToNonDelegatedEvent("invalid", instance);
                    break;
                case "textarea":
                    listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
            }
            type = props.children;
            ("string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type) || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), (instance = true)) : (instance = false);
            instance || throwOnHydrationMismatch(fiber);
        }
        function popToNextHostParent(fiber) {
            for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){
                case 5:
                case 13:
                    rootOrSingletonContext = false;
                    return;
                case 27:
                case 3:
                    rootOrSingletonContext = true;
                    return;
                default:
                    hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) return false;
            if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = true), false;
            var tag = fiber.tag, JSCompiler_temp;
            if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
                if ((JSCompiler_temp = 5 === tag)) (JSCompiler_temp = fiber.type), (JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps));
                JSCompiler_temp = !JSCompiler_temp;
            }
            JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
            popToNextHostParent(fiber);
            if (13 === tag) {
                fiber = fiber.memoizedState;
                fiber = null !== fiber ? fiber.dehydrated : null;
                if (!fiber) throw Error(formatProdErrorMessage(317));
                a: {
                    fiber = fiber.nextSibling;
                    for(tag = 0; fiber;){
                        if (8 === fiber.nodeType) if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {
                            if (0 === tag) {
                                nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                                break a;
                            }
                            tag--;
                        } else ("$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp) || tag++;
                        fiber = fiber.nextSibling;
                    }
                    nextHydratableInstance = null;
                }
            } else 27 === tag ? ((tag = nextHydratableInstance), isSingletonScope(fiber.type) ? ((fiber = previousHydratableOnEnteringScopedSingleton), (previousHydratableOnEnteringScopedSingleton = null), (nextHydratableInstance = fiber)) : (nextHydratableInstance = tag)) : (nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null);
            return true;
        }
        function resetHydrationState() {
            nextHydratableInstance = hydrationParentFiber = null;
            isHydrating = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
            var queuedErrors = hydrationErrors;
            null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? (workInProgressRootRecoverableErrors = queuedErrors) : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), (hydrationErrors = null));
            return queuedErrors;
        }
        function queueHydrationError(error) {
            null === hydrationErrors ? (hydrationErrors = [
                error
            ]) : hydrationErrors.push(error);
        }
        var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
        function pushProvider(providerFiber, context, nextValue) {
            push(valueCursor, context._currentValue);
            context._currentValue = nextValue;
        }
        function popProvider(context) {
            context._currentValue = valueCursor.current;
            pop(valueCursor);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
            for(; null !== parent;){
                var alternate = parent.alternate;
                (parent.childLanes & renderLanes) !== renderLanes ? ((parent.childLanes |= renderLanes), null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
                if (parent === propagationRoot) break;
                parent = parent.return;
            }
        }
        function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
            var fiber = workInProgress.child;
            null !== fiber && (fiber.return = workInProgress);
            for(; null !== fiber;){
                var list = fiber.dependencies;
                if (null !== list) {
                    var nextFiber = fiber.child;
                    list = list.firstContext;
                    a: for(; null !== list;){
                        var dependency = list;
                        list = fiber;
                        for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {
                            list.lanes |= renderLanes;
                            dependency = list.alternate;
                            null !== dependency && (dependency.lanes |= renderLanes);
                            scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
                            forcePropagateEntireTree || (nextFiber = null);
                            break a;
                        }
                        list = dependency.next;
                    }
                } else if (18 === fiber.tag) {
                    nextFiber = fiber.return;
                    if (null === nextFiber) throw Error(formatProdErrorMessage(341));
                    nextFiber.lanes |= renderLanes;
                    list = nextFiber.alternate;
                    null !== list && (list.lanes |= renderLanes);
                    scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
                    nextFiber = null;
                } else nextFiber = fiber.child;
                if (null !== nextFiber) nextFiber.return = fiber;
                else for(nextFiber = fiber; null !== nextFiber;){
                    if (nextFiber === workInProgress) {
                        nextFiber = null;
                        break;
                    }
                    fiber = nextFiber.sibling;
                    if (null !== fiber) {
                        fiber.return = nextFiber.return;
                        nextFiber = fiber;
                        break;
                    }
                    nextFiber = nextFiber.return;
                }
                fiber = nextFiber;
            }
        }
        function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
            current = null;
            for(var parent = workInProgress, isInsidePropagationBailout = false; null !== parent;){
                if (!isInsidePropagationBailout) if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
                else if (0 !== (parent.flags & 262144)) break;
                if (10 === parent.tag) {
                    var currentParent = parent.alternate;
                    if (null === currentParent) throw Error(formatProdErrorMessage(387));
                    currentParent = currentParent.memoizedProps;
                    if (null !== currentParent) {
                        var context = parent.type;
                        objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : (current = [
                            context
                        ]));
                    }
                } else if (parent === hostTransitionProviderCursor.current) {
                    currentParent = parent.alternate;
                    if (null === currentParent) throw Error(formatProdErrorMessage(387));
                    currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : (current = [
                        HostTransitionContext
                    ]));
                }
                parent = parent.return;
            }
            null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
            workInProgress.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
            for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){
                if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return true;
                currentDependencies = currentDependencies.next;
            }
            return false;
        }
        function prepareToReadContext(workInProgress) {
            currentlyRenderingFiber$1 = workInProgress;
            lastContextDependency = null;
            workInProgress = workInProgress.dependencies;
            null !== workInProgress && (workInProgress.firstContext = null);
        }
        function readContext(context) {
            return readContextForConsumer(currentlyRenderingFiber$1, context);
        }
        function readContextDuringReconciliation(consumer, context) {
            null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
            return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
            var value = context._currentValue;
            context = {
                context: context,
                memoizedValue: value,
                next: null
            };
            if (null === lastContextDependency) {
                if (null === consumer) throw Error(formatProdErrorMessage(308));
                lastContextDependency = context;
                consumer.dependencies = {
                    lanes: 0,
                    firstContext: context
                };
                consumer.flags |= 524288;
            } else lastContextDependency = lastContextDependency.next = context;
            return value;
        }
        var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
            var listeners = [], signal = (this.signal = {
                aborted: false,
                addEventListener: function(type, listener) {
                    listeners.push(listener);
                }
            });
            this.abort = function() {
                signal.aborted = true;
                listeners.forEach(function(listener) {
                    return listener();
                });
            };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
            $$typeof: REACT_CONTEXT_TYPE,
            Consumer: null,
            Provider: null,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0
        };
        function createCache() {
            return {
                controller: new AbortControllerLocal(),
                data: new Map(),
                refCount: 0
            };
        }
        function releaseCache(cache) {
            cache.refCount--;
            0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
                cache.controller.abort();
            });
        }
        var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
        function entangleAsyncAction(transition, thenable) {
            if (null === currentEntangledListeners) {
                var entangledListeners = (currentEntangledListeners = []);
                currentEntangledPendingCount = 0;
                currentEntangledLane = requestTransitionLane();
                currentEntangledActionThenable = {
                    status: "pending",
                    value: void 0,
                    then: function(resolve) {
                        entangledListeners.push(resolve);
                    }
                };
            }
            currentEntangledPendingCount++;
            thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
            return thenable;
        }
        function pingEngtangledActionScope() {
            if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
                null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
                var listeners = currentEntangledListeners;
                currentEntangledListeners = null;
                currentEntangledLane = 0;
                currentEntangledActionThenable = null;
                for(var i = 0; i < listeners.length; i++)(0, listeners[i])();
            }
        }
        function chainThenableValue(thenable, result) {
            var listeners = [], thenableWithOverride = {
                status: "pending",
                value: null,
                reason: null,
                then: function(resolve) {
                    listeners.push(resolve);
                }
            };
            thenable.then(function() {
                thenableWithOverride.status = "fulfilled";
                thenableWithOverride.value = result;
                for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);
            }, function(error) {
                thenableWithOverride.status = "rejected";
                thenableWithOverride.reason = error;
                for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);
            });
            return thenableWithOverride;
        }
        var prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
            null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null);
        function peekCacheFromPool() {
            var cacheResumedFromPreviousRender = resumedCache.current;
            return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
            null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
        }
        function getSuspendedCache() {
            var cacheFromPool = peekCacheFromPool();
            return null === cacheFromPool ? null : {
                parent: CacheContext._currentValue,
                pool: cacheFromPool
            };
        }
        var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = {
            then: function() {}
        };
        function isThenableResolved(thenable) {
            thenable = thenable.status;
            return "fulfilled" === thenable || "rejected" === thenable;
        }
        function noop$3() {}
        function trackUsedThenable(thenableState, thenable, index) {
            index = thenableState[index];
            void 0 === index ? thenableState.push(thenable) : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));
            switch(thenable.status){
                case "fulfilled":
                    return thenable.value;
                case "rejected":
                    throw (((thenableState = thenable.reason), checkIfUseWrappedInAsyncCatch(thenableState), thenableState));
                default:
                    if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
                    else {
                        thenableState = workInProgressRoot;
                        if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(formatProdErrorMessage(482));
                        thenableState = thenable;
                        thenableState.status = "pending";
                        thenableState.then(function(fulfilledValue) {
                            if ("pending" === thenable.status) {
                                var fulfilledThenable = thenable;
                                fulfilledThenable.status = "fulfilled";
                                fulfilledThenable.value = fulfilledValue;
                            }
                        }, function(error) {
                            if ("pending" === thenable.status) {
                                var rejectedThenable = thenable;
                                rejectedThenable.status = "rejected";
                                rejectedThenable.reason = error;
                            }
                        });
                    }
                    switch(thenable.status){
                        case "fulfilled":
                            return thenable.value;
                        case "rejected":
                            throw (((thenableState = thenable.reason), checkIfUseWrappedInAsyncCatch(thenableState), thenableState));
                    }
                    suspendedThenable = thenable;
                    throw SuspenseException;
            }
        }
        var suspendedThenable = null;
        function getSuspendedThenable() {
            if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
            var thenable = suspendedThenable;
            suspendedThenable = null;
            return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
            if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error(formatProdErrorMessage(483));
        }
        var hasForceUpdate = false;
        function initializeUpdateQueue(fiber) {
            fiber.updateQueue = {
                baseState: fiber.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    lanes: 0,
                    hiddenCallbacks: null
                },
                callbacks: null
            };
        }
        function cloneUpdateQueue(current, workInProgress) {
            current = current.updateQueue;
            workInProgress.updateQueue === current && (workInProgress.updateQueue = {
                baseState: current.baseState,
                firstBaseUpdate: current.firstBaseUpdate,
                lastBaseUpdate: current.lastBaseUpdate,
                shared: current.shared,
                callbacks: null
            });
        }
        function createUpdate(lane) {
            return {
                lane: lane,
                tag: 0,
                payload: null,
                callback: null,
                next: null
            };
        }
        function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (null === updateQueue) return null;
            updateQueue = updateQueue.shared;
            if (0 !== (executionContext & 2)) {
                var pending = updateQueue.pending;
                null === pending ? (update.next = update) : ((update.next = pending.next), (pending.next = update));
                updateQueue.pending = update;
                update = getRootForUpdatedFiber(fiber);
                markUpdateLaneFromFiberToRoot(fiber, null, lane);
                return update;
            }
            enqueueUpdate$1(fiber, updateQueue, update, lane);
            return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root, fiber, lane) {
            fiber = fiber.updateQueue;
            if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
                var queueLanes = fiber.lanes;
                queueLanes &= root.pendingLanes;
                lane |= queueLanes;
                fiber.lanes = lane;
                markRootEntangled(root, lane);
            }
        }
        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
            var queue = workInProgress.updateQueue, current = workInProgress.alternate;
            if (null !== current && ((current = current.updateQueue), queue === current)) {
                var newFirst = null, newLast = null;
                queue = queue.firstBaseUpdate;
                if (null !== queue) {
                    do {
                        var clone = {
                            lane: queue.lane,
                            tag: queue.tag,
                            payload: queue.payload,
                            callback: null,
                            next: null
                        };
                        null === newLast ? (newFirst = newLast = clone) : (newLast = newLast.next = clone);
                        queue = queue.next;
                    }while (null !== queue);
                    null === newLast ? (newFirst = newLast = capturedUpdate) : (newLast = newLast.next = capturedUpdate);
                } else newFirst = newLast = capturedUpdate;
                queue = {
                    baseState: current.baseState,
                    firstBaseUpdate: newFirst,
                    lastBaseUpdate: newLast,
                    shared: current.shared,
                    callbacks: current.callbacks
                };
                workInProgress.updateQueue = queue;
                return;
            }
            workInProgress = queue.lastBaseUpdate;
            null === workInProgress ? (queue.firstBaseUpdate = capturedUpdate) : (workInProgress.next = capturedUpdate);
            queue.lastBaseUpdate = capturedUpdate;
        }
        var didReadFromEntangledAsyncAction = false;
        function suspendIfUpdateReadFromEntangledAsyncAction() {
            if (didReadFromEntangledAsyncAction) {
                var entangledActionThenable = currentEntangledActionThenable;
                if (null !== entangledActionThenable) throw entangledActionThenable;
            }
        }
        function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes) {
            didReadFromEntangledAsyncAction = false;
            var queue = workInProgress$jscomp$0.updateQueue;
            hasForceUpdate = false;
            var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
            if (null !== pendingQueue) {
                queue.shared.pending = null;
                var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = null;
                null === lastBaseUpdate ? (firstBaseUpdate = firstPendingUpdate) : (lastBaseUpdate.next = firstPendingUpdate);
                lastBaseUpdate = lastPendingUpdate;
                var current = workInProgress$jscomp$0.alternate;
                null !== current && ((current = current.updateQueue), (pendingQueue = current.lastBaseUpdate), pendingQueue !== lastBaseUpdate && (null === pendingQueue ? (current.firstBaseUpdate = firstPendingUpdate) : (pendingQueue.next = firstPendingUpdate), (current.lastBaseUpdate = lastPendingUpdate)));
            }
            if (null !== firstBaseUpdate) {
                var newState = queue.baseState;
                lastBaseUpdate = 0;
                current = firstPendingUpdate = lastPendingUpdate = null;
                pendingQueue = firstBaseUpdate;
                do {
                    var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
                    if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                        0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                        null !== current && (current = current.next = {
                            lane: 0,
                            tag: pendingQueue.tag,
                            payload: pendingQueue.payload,
                            callback: null,
                            next: null
                        });
                        a: {
                            var workInProgress = workInProgress$jscomp$0, update = pendingQueue;
                            updateLane = props;
                            var instance = instance$jscomp$0;
                            switch(update.tag){
                                case 1:
                                    workInProgress = update.payload;
                                    if ("function" === typeof workInProgress) {
                                        newState = workInProgress.call(instance, newState, updateLane);
                                        break a;
                                    }
                                    newState = workInProgress;
                                    break a;
                                case 3:
                                    workInProgress.flags = (workInProgress.flags & -65537) | 128;
                                case 0:
                                    workInProgress = update.payload;
                                    updateLane = "function" === typeof workInProgress ? workInProgress.call(instance, newState, updateLane) : workInProgress;
                                    if (null === updateLane || void 0 === updateLane) break a;
                                    newState = assign({}, newState, updateLane);
                                    break a;
                                case 2:
                                    hasForceUpdate = true;
                            }
                        }
                        updateLane = pendingQueue.callback;
                        null !== updateLane && ((workInProgress$jscomp$0.flags |= 64), isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), (isHiddenUpdate = queue.callbacks), null === isHiddenUpdate ? (queue.callbacks = [
                            updateLane
                        ]) : isHiddenUpdate.push(updateLane));
                    } else (isHiddenUpdate = {
                        lane: updateLane,
                        tag: pendingQueue.tag,
                        payload: pendingQueue.payload,
                        callback: pendingQueue.callback,
                        next: null
                    }), null === current ? ((firstPendingUpdate = current = isHiddenUpdate), (lastPendingUpdate = newState)) : (current = current.next = isHiddenUpdate), (lastBaseUpdate |= updateLane);
                    pendingQueue = pendingQueue.next;
                    if (null === pendingQueue) if (((pendingQueue = queue.shared.pending), null === pendingQueue)) break;
                    else (isHiddenUpdate = pendingQueue), (pendingQueue = isHiddenUpdate.next), (isHiddenUpdate.next = null), (queue.lastBaseUpdate = isHiddenUpdate), (queue.shared.pending = null);
                }while (1);
                null === current && (lastPendingUpdate = newState);
                queue.baseState = lastPendingUpdate;
                queue.firstBaseUpdate = firstPendingUpdate;
                queue.lastBaseUpdate = current;
                null === firstBaseUpdate && (queue.shared.lanes = 0);
                workInProgressRootSkippedLanes |= lastBaseUpdate;
                workInProgress$jscomp$0.lanes = lastBaseUpdate;
                workInProgress$jscomp$0.memoizedState = newState;
            }
        }
        function callCallback(callback, context) {
            if ("function" !== typeof callback) throw Error(formatProdErrorMessage(191, callback));
            callback.call(context);
        }
        function commitCallbacks(updateQueue, context) {
            var callbacks = updateQueue.callbacks;
            if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);
        }
        var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
        function pushHiddenContext(fiber, context) {
            fiber = entangledRenderLanes;
            push(prevEntangledRenderLanesCursor, fiber);
            push(currentTreeHiddenStackCursor, context);
            entangledRenderLanes = fiber | context.baseLanes;
        }
        function reuseHiddenContextOnStack() {
            push(prevEntangledRenderLanesCursor, entangledRenderLanes);
            push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
        }
        function popHiddenContext() {
            entangledRenderLanes = prevEntangledRenderLanesCursor.current;
            pop(currentTreeHiddenStackCursor);
            pop(prevEntangledRenderLanesCursor);
        }
        var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0;
        function throwInvalidHookError() {
            throw Error(formatProdErrorMessage(321));
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
            if (null === prevDeps) return false;
            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return false;
            return true;
        }
        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber = workInProgress;
            workInProgress.memoizedState = null;
            workInProgress.updateQueue = null;
            workInProgress.lanes = 0;
            ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
            shouldDoubleInvokeUserFnsInHooksDEV = false;
            nextRenderLanes = Component(props, secondArg);
            shouldDoubleInvokeUserFnsInHooksDEV = false;
            didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(workInProgress, Component, props, secondArg));
            finishRenderingHooks(current);
            return nextRenderLanes;
        }
        function finishRenderingHooks(current) {
            ReactSharedInternals.H = ContextOnlyDispatcher;
            var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
            renderLanes = 0;
            workInProgressHook = currentHook = currentlyRenderingFiber = null;
            didScheduleRenderPhaseUpdate = false;
            thenableIndexCounter$1 = 0;
            thenableState$1 = null;
            if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
            null === current || didReceiveUpdate || ((current = current.dependencies), null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
        }
        function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
            currentlyRenderingFiber = workInProgress;
            var numberOfReRenders = 0;
            do {
                didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
                thenableIndexCounter$1 = 0;
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
                numberOfReRenders += 1;
                workInProgressHook = currentHook = null;
                if (null != workInProgress.updateQueue) {
                    var children = workInProgress.updateQueue;
                    children.lastEffect = null;
                    children.events = null;
                    children.stores = null;
                    null != children.memoCache && (children.memoCache.index = 0);
                }
                ReactSharedInternals.H = HooksDispatcherOnRerender;
                children = Component(props, secondArg);
            }while (didScheduleRenderPhaseUpdateDuringThisPass);
            return children;
        }
        function TransitionAwareHostComponent() {
            var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
            maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
            dispatcher = dispatcher.useState()[0];
            (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
            return maybeThenable;
        }
        function checkDidRenderIdHook() {
            var didRenderIdHook = 0 !== localIdCounter;
            localIdCounter = 0;
            return didRenderIdHook;
        }
        function bailoutHooks(current, workInProgress, lanes) {
            workInProgress.updateQueue = current.updateQueue;
            workInProgress.flags &= -2053;
            current.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress) {
            if (didScheduleRenderPhaseUpdate) {
                for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){
                    var queue = workInProgress.queue;
                    null !== queue && (queue.pending = null);
                    workInProgress = workInProgress.next;
                }
                didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = 0;
            workInProgressHook = currentHook = currentlyRenderingFiber = null;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            thenableIndexCounter$1 = localIdCounter = 0;
            thenableState$1 = null;
        }
        function mountWorkInProgressHook() {
            var hook = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            null === workInProgressHook ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook) : (workInProgressHook = workInProgressHook.next = hook);
            return workInProgressHook;
        }
        function updateWorkInProgressHook() {
            if (null === currentHook) {
                var nextCurrentHook = currentlyRenderingFiber.alternate;
                nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
            } else nextCurrentHook = currentHook.next;
            var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
            if (null !== nextWorkInProgressHook) (workInProgressHook = nextWorkInProgressHook), (currentHook = nextCurrentHook);
            else {
                if (null === nextCurrentHook) {
                    if (null === currentlyRenderingFiber.alternate) throw Error(formatProdErrorMessage(467));
                    throw Error(formatProdErrorMessage(310));
                }
                currentHook = nextCurrentHook;
                nextCurrentHook = {
                    memoizedState: currentHook.memoizedState,
                    baseState: currentHook.baseState,
                    baseQueue: currentHook.baseQueue,
                    queue: currentHook.queue,
                    next: null
                };
                null === workInProgressHook ? (currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook) : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
            }
            return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
            return {
                lastEffect: null,
                events: null,
                stores: null,
                memoCache: null
            };
        }
        function useThenable(thenable) {
            var index = thenableIndexCounter$1;
            thenableIndexCounter$1 += 1;
            null === thenableState$1 && (thenableState$1 = []);
            thenable = trackUsedThenable(thenableState$1, thenable, index);
            index = currentlyRenderingFiber;
            null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && ((index = index.alternate), (ReactSharedInternals.H = null === index || null === index.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate));
            return thenable;
        }
        function use(usable) {
            if (null !== usable && "object" === typeof usable) {
                if ("function" === typeof usable.then) return useThenable(usable);
                if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
            }
            throw Error(formatProdErrorMessage(438, String(usable)));
        }
        function useMemoCache(size) {
            var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
            null !== updateQueue && (memoCache = updateQueue.memoCache);
            if (null == memoCache) {
                var current = currentlyRenderingFiber.alternate;
                null !== current && ((current = current.updateQueue), null !== current && ((current = current.memoCache), null != current && (memoCache = {
                    data: current.data.map(function(array) {
                        return array.slice();
                    }),
                    index: 0
                })));
            }
            null == memoCache && (memoCache = {
                data: [],
                index: 0
            });
            null === updateQueue && ((updateQueue = createFunctionComponentUpdateQueue()), (currentlyRenderingFiber.updateQueue = updateQueue));
            updateQueue.memoCache = memoCache;
            updateQueue = memoCache.data[memoCache.index];
            if (void 0 === updateQueue) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
            memoCache.index++;
            return updateQueue;
        }
        function basicStateReducer(state, action) {
            return "function" === typeof action ? action(state) : action;
        }
        function updateReducer(reducer) {
            var hook = updateWorkInProgressHook();
            return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current, reducer) {
            var queue = hook.queue;
            if (null === queue) throw Error(formatProdErrorMessage(311));
            queue.lastRenderedReducer = reducer;
            var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
            if (null !== pendingQueue) {
                if (null !== baseQueue) {
                    var baseFirst = baseQueue.next;
                    baseQueue.next = pendingQueue.next;
                    pendingQueue.next = baseFirst;
                }
                current.baseQueue = baseQueue = pendingQueue;
                queue.pending = null;
            }
            pendingQueue = hook.baseState;
            if (null === baseQueue) hook.memoizedState = pendingQueue;
            else {
                current = baseQueue.next;
                var newBaseQueueFirst = (baseFirst = null), newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
                do {
                    var updateLane = update.lane & -536870913;
                    if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                        var revertLane = update.revertLane;
                        if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                            lane: 0,
                            revertLane: 0,
                            action: update.action,
                            hasEagerState: update.hasEagerState,
                            eagerState: update.eagerState,
                            next: null
                        }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
                        else if ((renderLanes & revertLane) === revertLane) {
                            update = update.next;
                            revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
                            continue;
                        } else (updateLane = {
                            lane: 0,
                            revertLane: update.revertLane,
                            action: update.action,
                            hasEagerState: update.hasEagerState,
                            eagerState: update.eagerState,
                            next: null
                        }), null === newBaseQueueLast ? ((newBaseQueueFirst = newBaseQueueLast = updateLane), (baseFirst = pendingQueue)) : (newBaseQueueLast = newBaseQueueLast.next = updateLane), (currentlyRenderingFiber.lanes |= revertLane), (workInProgressRootSkippedLanes |= revertLane);
                        updateLane = update.action;
                        shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                        pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
                    } else (revertLane = {
                        lane: updateLane,
                        revertLane: update.revertLane,
                        action: update.action,
                        hasEagerState: update.hasEagerState,
                        eagerState: update.eagerState,
                        next: null
                    }), null === newBaseQueueLast ? ((newBaseQueueFirst = newBaseQueueLast = revertLane), (baseFirst = pendingQueue)) : (newBaseQueueLast = newBaseQueueLast.next = revertLane), (currentlyRenderingFiber.lanes |= updateLane), (workInProgressRootSkippedLanes |= updateLane);
                    update = update.next;
                }while (null !== update && update !== current);
                null === newBaseQueueLast ? (baseFirst = pendingQueue) : (newBaseQueueLast.next = newBaseQueueFirst);
                if (!objectIs(pendingQueue, hook.memoizedState) && ((didReceiveUpdate = true), didReadFromEntangledAsyncAction$32 && ((reducer = currentEntangledActionThenable), null !== reducer))) throw reducer;
                hook.memoizedState = pendingQueue;
                hook.baseState = baseFirst;
                hook.baseQueue = newBaseQueueLast;
                queue.lastRenderedState = pendingQueue;
            }
            null === baseQueue && (queue.lanes = 0);
            return [
                hook.memoizedState,
                queue.dispatch
            ];
        }
        function rerenderReducer(reducer) {
            var hook = updateWorkInProgressHook(), queue = hook.queue;
            if (null === queue) throw Error(formatProdErrorMessage(311));
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
            if (null !== lastRenderPhaseUpdate) {
                queue.pending = null;
                var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
                do (newState = reducer(newState, update.action)), (update = update.next);
                while (update !== lastRenderPhaseUpdate);
                objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
                hook.memoizedState = newState;
                null === hook.baseQueue && (hook.baseState = newState);
                queue.lastRenderedState = newState;
            }
            return [
                newState,
                dispatch
            ];
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
            if (isHydrating$jscomp$0) {
                if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
                getServerSnapshot = getServerSnapshot();
            } else getServerSnapshot = getSnapshot();
            var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
            snapshotChanged && ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = true));
            hook = hook.queue;
            var create = subscribeToStore.bind(null, fiber, hook, subscribe);
            updateEffectImpl(2048, 8, create, [
                subscribe
            ]);
            if (hook.getSnapshot !== getSnapshot || snapshotChanged || (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)) {
                fiber.flags |= 2048;
                pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
                if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
                isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
            }
            return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= 16384;
            fiber = {
                getSnapshot: getSnapshot,
                value: renderedSnapshot
            };
            getSnapshot = currentlyRenderingFiber.updateQueue;
            null === getSnapshot ? ((getSnapshot = createFunctionComponentUpdateQueue()), (currentlyRenderingFiber.updateQueue = getSnapshot), (getSnapshot.stores = [
                fiber
            ])) : ((renderedSnapshot = getSnapshot.stores), null === renderedSnapshot ? (getSnapshot.stores = [
                fiber
            ]) : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
            return subscribe(function() {
                checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
            });
        }
        function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            inst = inst.value;
            try {
                var nextValue = latestGetSnapshot();
                return !objectIs(inst, nextValue);
            } catch (error) {
                return true;
            }
        }
        function forceStoreRerender(fiber) {
            var root = enqueueConcurrentRenderForLane(fiber, 2);
            null !== root && scheduleUpdateOnFiber(root, fiber, 2);
        }
        function mountStateImpl(initialState) {
            var hook = mountWorkInProgressHook();
            if ("function" === typeof initialState) {
                var initialStateInitializer = initialState;
                initialState = initialStateInitializer();
                if (shouldDoubleInvokeUserFnsInHooksDEV) {
                    setIsStrictModeForDevtools(true);
                    try {
                        initialStateInitializer();
                    } finally{
                        setIsStrictModeForDevtools(false);
                    }
                }
            }
            hook.memoizedState = hook.baseState = initialState;
            hook.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: basicStateReducer,
                lastRenderedState: initialState
            };
            return hook;
        }
        function updateOptimisticImpl(hook, current, passthrough, reducer) {
            hook.baseState = passthrough;
            return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
            if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
            fiber = actionQueue.action;
            if (null !== fiber) {
                var actionNode = {
                    payload: payload,
                    action: fiber,
                    next: null,
                    isTransition: true,
                    status: "pending",
                    value: null,
                    reason: null,
                    listeners: [],
                    then: function(listener) {
                        actionNode.listeners.push(listener);
                    }
                };
                null !== ReactSharedInternals.T ? setPendingState(true) : (actionNode.isTransition = false);
                setState(actionNode);
                setPendingState = actionQueue.pending;
                null === setPendingState ? ((actionNode.next = actionQueue.pending = actionNode), runActionStateAction(actionQueue, actionNode)) : ((actionNode.next = setPendingState.next), (actionQueue.pending = setPendingState.next = actionNode));
            }
        }
        function runActionStateAction(actionQueue, node) {
            var action = node.action, payload = node.payload, prevState = actionQueue.state;
            if (node.isTransition) {
                var prevTransition = ReactSharedInternals.T, currentTransition = {};
                ReactSharedInternals.T = currentTransition;
                try {
                    var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
                    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                    handleActionReturnValue(actionQueue, node, returnValue);
                } catch (error) {
                    onActionError(actionQueue, node, error);
                } finally{
                    ReactSharedInternals.T = prevTransition;
                }
            } else try {
                (prevTransition = action(prevState, payload)), handleActionReturnValue(actionQueue, node, prevTransition);
            } catch (error$38) {
                onActionError(actionQueue, node, error$38);
            }
        }
        function handleActionReturnValue(actionQueue, node, returnValue) {
            null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(function(nextState) {
                onActionSuccess(actionQueue, node, nextState);
            }, function(error) {
                return onActionError(actionQueue, node, error);
            }) : onActionSuccess(actionQueue, node, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
            actionNode.status = "fulfilled";
            actionNode.value = nextState;
            notifyActionListeners(actionNode);
            actionQueue.state = nextState;
            actionNode = actionQueue.pending;
            null !== actionNode && ((nextState = actionNode.next), nextState === actionNode ? (actionQueue.pending = null) : ((nextState = nextState.next), (actionNode.next = nextState), runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
            var last = actionQueue.pending;
            actionQueue.pending = null;
            if (null !== last) {
                last = last.next;
                do (actionNode.status = "rejected"), (actionNode.reason = error), notifyActionListeners(actionNode), (actionNode = actionNode.next);
                while (actionNode !== last);
            }
            actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
            actionNode = actionNode.listeners;
            for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
            return newState;
        }
        function mountActionState(action, initialStateProp) {
            if (isHydrating) {
                var ssrFormState = workInProgressRoot.formState;
                if (null !== ssrFormState) {
                    a: {
                        var JSCompiler_inline_result = currentlyRenderingFiber;
                        if (isHydrating) {
                            if (nextHydratableInstance) {
                                b: {
                                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                                    for(var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType;){
                                        if (!inRootOrSingleton) {
                                            JSCompiler_inline_result$jscomp$0 = null;
                                            break b;
                                        }
                                        JSCompiler_inline_result$jscomp$0 = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
                                        if (null === JSCompiler_inline_result$jscomp$0) {
                                            JSCompiler_inline_result$jscomp$0 = null;
                                            break b;
                                        }
                                    }
                                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                                }
                                if (JSCompiler_inline_result$jscomp$0) {
                                    nextHydratableInstance = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
                                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                                    break a;
                                }
                            }
                            throwOnHydrationMismatch(JSCompiler_inline_result);
                        }
                        JSCompiler_inline_result = false;
                    }
                    JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
                }
            }
            ssrFormState = mountWorkInProgressHook();
            ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
            JSCompiler_inline_result = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: actionStateReducer,
                lastRenderedState: initialStateProp
            };
            ssrFormState.queue = JSCompiler_inline_result;
            ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result);
            JSCompiler_inline_result.dispatch = ssrFormState;
            JSCompiler_inline_result = mountStateImpl(false);
            inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, false, JSCompiler_inline_result.queue);
            JSCompiler_inline_result = mountWorkInProgressHook();
            JSCompiler_inline_result$jscomp$0 = {
                state: initialStateProp,
                dispatch: null,
                action: action,
                pending: null
            };
            JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
            ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result$jscomp$0, inRootOrSingleton, ssrFormState);
            JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
            JSCompiler_inline_result.memoizedState = action;
            return [
                initialStateProp,
                ssrFormState,
                false
            ];
        }
        function updateActionState(action) {
            var stateHook = updateWorkInProgressHook();
            return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
            currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
            stateHook = updateReducer(basicStateReducer)[0];
            if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then) try {
                var state = useThenable(currentStateHook);
            } catch (x) {
                if (x === SuspenseException) throw SuspenseActionException;
                throw x;
            }
            else state = currentStateHook;
            currentStateHook = updateWorkInProgressHook();
            var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
            action !== currentStateHook.memoizedState && ((currentlyRenderingFiber.flags |= 2048), pushSimpleEffect(9, createEffectInstance(), actionStateActionEffect.bind(null, actionQueue, action), null));
            return [
                state,
                dispatch,
                stateHook
            ];
        }
        function actionStateActionEffect(actionQueue, action) {
            actionQueue.action = action;
        }
        function rerenderActionState(action) {
            var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
            if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
            updateWorkInProgressHook();
            stateHook = stateHook.memoizedState;
            currentStateHook = updateWorkInProgressHook();
            var dispatch = currentStateHook.queue.dispatch;
            currentStateHook.memoizedState = action;
            return [
                stateHook,
                dispatch,
                false
            ];
        }
        function pushSimpleEffect(tag, inst, create, createDeps) {
            tag = {
                tag: tag,
                create: create,
                deps: createDeps,
                inst: inst,
                next: null
            };
            inst = currentlyRenderingFiber.updateQueue;
            null === inst && ((inst = createFunctionComponentUpdateQueue()), (currentlyRenderingFiber.updateQueue = inst));
            create = inst.lastEffect;
            null === create ? (inst.lastEffect = tag.next = tag) : ((createDeps = create.next), (create.next = tag), (tag.next = createDeps), (inst.lastEffect = tag));
            return tag;
        }
        function createEffectInstance() {
            return {
                destroy: void 0,
                resource: void 0
            };
        }
        function updateRef() {
            return updateWorkInProgressHook().memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
            var hook = mountWorkInProgressHook();
            createDeps = void 0 === createDeps ? null : createDeps;
            currentlyRenderingFiber.flags |= fiberFlags;
            hook.memoizedState = pushSimpleEffect(1 | hookFlags, createEffectInstance(), create, createDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var inst = hook.memoizedState.inst;
            null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps)) : ((currentlyRenderingFiber.flags |= fiberFlags), (hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create, deps)));
        }
        function mountEffect(create, createDeps) {
            mountEffectImpl(8390656, 8, create, createDeps);
        }
        function updateEffect(create, createDeps) {
            updateEffectImpl(2048, 8, create, createDeps);
        }
        function updateInsertionEffect(create, deps) {
            return updateEffectImpl(4, 2, create, deps);
        }
        function updateLayoutEffect(create, deps) {
            return updateEffectImpl(4, 4, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
            if ("function" === typeof ref) {
                create = create();
                var refCleanup = ref(create);
                return function() {
                    "function" === typeof refCleanup ? refCleanup() : ref(null);
                };
            }
            if (null !== ref && void 0 !== ref) return ((create = create()), (ref.current = create), function() {
                ref.current = null;
            });
        }
        function updateImperativeHandle(ref, create, deps) {
            deps = null !== deps && void 0 !== deps ? deps.concat([
                ref
            ]) : null;
            updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
        }
        function mountDebugValue() {}
        function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var prevState = hook.memoizedState;
            if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
            hook.memoizedState = [
                callback,
                deps
            ];
            return callback;
        }
        function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            deps = void 0 === deps ? null : deps;
            var prevState = hook.memoizedState;
            if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
            prevState = nextCreate();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(true);
                try {
                    nextCreate();
                } finally{
                    setIsStrictModeForDevtools(false);
                }
            }
            hook.memoizedState = [
                prevState,
                deps
            ];
            return prevState;
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
            if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return (hook.memoizedState = value);
            hook.memoizedState = initialValue;
            hook = requestDeferredLane();
            currentlyRenderingFiber.lanes |= hook;
            workInProgressRootSkippedLanes |= hook;
            return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
            if (objectIs(value, prevValue)) return value;
            if (null !== currentTreeHiddenStackCursor.current) return ((hook = mountDeferredValueImpl(hook, value, initialValue)), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook);
            if (0 === (renderLanes & 42)) return (didReceiveUpdate = true), (hook.memoizedState = value);
            hook = requestDeferredLane();
            currentlyRenderingFiber.lanes |= hook;
            workInProgressRootSkippedLanes |= hook;
            return prevValue;
        }
        function startTransition(fiber, queue, pendingState, finishedState, callback) {
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            dispatchOptimisticSetState(fiber, false, queue, pendingState);
            try {
                var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
                if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
                    var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
                    dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
                } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
            } catch (error) {
                dispatchSetStateInternal(fiber, queue, {
                    then: function() {},
                    status: "rejected",
                    reason: error
                }, requestUpdateLane());
            } finally{
                (ReactDOMSharedInternals.p = previousPriority), (ReactSharedInternals.T = prevTransition);
            }
        }
        function noop$2() {}
        function startHostTransition(formFiber, pendingState, action, formData) {
            if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
            var queue = ensureFormComponentIsStateful(formFiber).queue;
            startTransition(formFiber, queue, pendingState, sharedNotPendingObject, null === action ? noop$2 : function() {
                requestFormReset$1(formFiber);
                return action(formData);
            });
        }
        function ensureFormComponentIsStateful(formFiber) {
            var existingStateHook = formFiber.memoizedState;
            if (null !== existingStateHook) return existingStateHook;
            existingStateHook = {
                memoizedState: sharedNotPendingObject,
                baseState: sharedNotPendingObject,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: basicStateReducer,
                    lastRenderedState: sharedNotPendingObject
                },
                next: null
            };
            var initialResetState = {};
            existingStateHook.next = {
                memoizedState: initialResetState,
                baseState: initialResetState,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: basicStateReducer,
                    lastRenderedState: initialResetState
                },
                next: null
            };
            formFiber.memoizedState = existingStateHook;
            formFiber = formFiber.alternate;
            null !== formFiber && (formFiber.memoizedState = existingStateHook);
            return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
            dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
        }
        function useHostTransitionStatus() {
            return readContext(HostTransitionContext);
        }
        function updateId() {
            return updateWorkInProgressHook().memoizedState;
        }
        function updateRefresh() {
            return updateWorkInProgressHook().memoizedState;
        }
        function refreshCache(fiber) {
            for(var provider = fiber.return; null !== provider;){
                switch(provider.tag){
                    case 24:
                    case 3:
                        var lane = requestUpdateLane();
                        fiber = createUpdate(lane);
                        var root$41 = enqueueUpdate(provider, fiber, lane);
                        null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
                        provider = {
                            cache: createCache()
                        };
                        fiber.payload = provider;
                        return;
                }
                provider = provider.return;
            }
        }
        function dispatchReducerAction(fiber, queue, action) {
            var lane = requestUpdateLane();
            action = {
                lane: lane,
                revertLane: 0,
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
        }
        function dispatchSetState(fiber, queue, action) {
            var lane = requestUpdateLane();
            dispatchSetStateInternal(fiber, queue, action, lane);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
            var update = {
                lane: lane,
                revertLane: 0,
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
            else {
                var alternate = fiber.alternate;
                if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && ((alternate = queue.lastRenderedReducer), null !== alternate)) try {
                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                    update.hasEagerState = !0;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) return (enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1);
                } catch (error) {} finally{}
                action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
                if (null !== action) return (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true);
            }
            return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
            action = {
                lane: 2,
                revertLane: requestTransitionLane(),
                action: action,
                hasEagerState: false,
                eagerState: null,
                next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
                if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
            } else (throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2)), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
        }
        function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return (fiber === currentlyRenderingFiber || (null !== alternate && alternate === currentlyRenderingFiber));
        }
        function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            null === pending ? (update.next = update) : ((update.next = pending.next), (pending.next = update));
            queue.pending = update;
        }
        function entangleTransitionUpdate(root, queue, lane) {
            if (0 !== (lane & 4194048)) {
                var queueLanes = queue.lanes;
                queueLanes &= root.pendingLanes;
                lane |= queueLanes;
                queue.lanes = lane;
                markRootEntangled(root, lane);
            }
        }
        var ContextOnlyDispatcher = {
            readContext: readContext,
            use: use,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            useHostTransitionStatus: throwInvalidHookError,
            useFormState: throwInvalidHookError,
            useActionState: throwInvalidHookError,
            useOptimistic: throwInvalidHookError,
            useMemoCache: throwInvalidHookError,
            useCacheRefresh: throwInvalidHookError
        }, HooksDispatcherOnMount = {
            readContext: readContext,
            use: use,
            useCallback: function(callback, deps) {
                mountWorkInProgressHook().memoizedState = [
                    callback,
                    void 0 === deps ? null : deps
                ];
                return callback;
            },
            useContext: readContext,
            useEffect: mountEffect,
            useImperativeHandle: function(ref, create, deps) {
                deps = null !== deps && void 0 !== deps ? deps.concat([
                    ref
                ]) : null;
                mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create, ref), deps);
            },
            useLayoutEffect: function(create, deps) {
                return mountEffectImpl(4194308, 4, create, deps);
            },
            useInsertionEffect: function(create, deps) {
                mountEffectImpl(4, 2, create, deps);
            },
            useMemo: function(nextCreate, deps) {
                var hook = mountWorkInProgressHook();
                deps = void 0 === deps ? null : deps;
                var nextValue = nextCreate();
                if (shouldDoubleInvokeUserFnsInHooksDEV) {
                    setIsStrictModeForDevtools(true);
                    try {
                        nextCreate();
                    } finally{
                        setIsStrictModeForDevtools(false);
                    }
                }
                hook.memoizedState = [
                    nextValue,
                    deps
                ];
                return nextValue;
            },
            useReducer: function(reducer, initialArg, init) {
                var hook = mountWorkInProgressHook();
                if (void 0 !== init) {
                    var initialState = init(initialArg);
                    if (shouldDoubleInvokeUserFnsInHooksDEV) {
                        setIsStrictModeForDevtools(true);
                        try {
                            init(initialArg);
                        } finally{
                            setIsStrictModeForDevtools(false);
                        }
                    }
                } else initialState = initialArg;
                hook.memoizedState = hook.baseState = initialState;
                reducer = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: reducer,
                    lastRenderedState: initialState
                };
                hook.queue = reducer;
                reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
                return [
                    hook.memoizedState,
                    reducer
                ];
            },
            useRef: function(initialValue) {
                var hook = mountWorkInProgressHook();
                initialValue = {
                    current: initialValue
                };
                return (hook.memoizedState = initialValue);
            },
            useState: function(initialState) {
                initialState = mountStateImpl(initialState);
                var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
                queue.dispatch = dispatch;
                return [
                    initialState.memoizedState,
                    dispatch
                ];
            },
            useDebugValue: mountDebugValue,
            useDeferredValue: function(value, initialValue) {
                var hook = mountWorkInProgressHook();
                return mountDeferredValueImpl(hook, value, initialValue);
            },
            useTransition: function() {
                var stateHook = mountStateImpl(false);
                stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, true, false);
                mountWorkInProgressHook().memoizedState = stateHook;
                return [
                    false,
                    stateHook
                ];
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
                if (isHydrating) {
                    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
                    getServerSnapshot = getServerSnapshot();
                } else {
                    getServerSnapshot = getSnapshot();
                    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
                    0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
                }
                hook.memoizedState = getServerSnapshot;
                var inst = {
                    value: getServerSnapshot,
                    getSnapshot: getSnapshot
                };
                hook.queue = inst;
                mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
                    subscribe
                ]);
                fiber.flags |= 2048;
                pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot), null);
                return getServerSnapshot;
            },
            useId: function() {
                var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
                if (isHydrating) {
                    var JSCompiler_inline_result = treeContextOverflow;
                    var idWithLeadingBit = treeContextId;
                    JSCompiler_inline_result = (idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))).toString(32) + JSCompiler_inline_result;
                    identifierPrefix = "\u00ab" + identifierPrefix + "R" + JSCompiler_inline_result;
                    JSCompiler_inline_result = localIdCounter++;
                    0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
                    identifierPrefix += "\u00bb";
                } else (JSCompiler_inline_result = globalClientIdCounter++), (identifierPrefix = "\u00ab" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "\u00bb");
                return (hook.memoizedState = identifierPrefix);
            },
            useHostTransitionStatus: useHostTransitionStatus,
            useFormState: mountActionState,
            useActionState: mountActionState,
            useOptimistic: function(passthrough) {
                var hook = mountWorkInProgressHook();
                hook.memoizedState = hook.baseState = passthrough;
                var queue = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: null,
                    lastRenderedState: null
                };
                hook.queue = queue;
                hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, true, queue);
                queue.dispatch = hook;
                return [
                    passthrough,
                    hook
                ];
            },
            useMemoCache: useMemoCache,
            useCacheRefresh: function() {
                return (mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber));
            }
        }, HooksDispatcherOnUpdate = {
            readContext: readContext,
            use: use,
            useCallback: updateCallback,
            useContext: readContext,
            useEffect: updateEffect,
            useImperativeHandle: updateImperativeHandle,
            useInsertionEffect: updateInsertionEffect,
            useLayoutEffect: updateLayoutEffect,
            useMemo: updateMemo,
            useReducer: updateReducer,
            useRef: updateRef,
            useState: function() {
                return updateReducer(basicStateReducer);
            },
            useDebugValue: mountDebugValue,
            useDeferredValue: function(value, initialValue) {
                var hook = updateWorkInProgressHook();
                return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
            },
            useTransition: function() {
                var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
                return [
                    "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
                    start
                ];
            },
            useSyncExternalStore: updateSyncExternalStore,
            useId: updateId,
            useHostTransitionStatus: useHostTransitionStatus,
            useFormState: updateActionState,
            useActionState: updateActionState,
            useOptimistic: function(passthrough, reducer) {
                var hook = updateWorkInProgressHook();
                return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
            },
            useMemoCache: useMemoCache,
            useCacheRefresh: updateRefresh
        }, HooksDispatcherOnRerender = {
            readContext: readContext,
            use: use,
            useCallback: updateCallback,
            useContext: readContext,
            useEffect: updateEffect,
            useImperativeHandle: updateImperativeHandle,
            useInsertionEffect: updateInsertionEffect,
            useLayoutEffect: updateLayoutEffect,
            useMemo: updateMemo,
            useReducer: rerenderReducer,
            useRef: updateRef,
            useState: function() {
                return rerenderReducer(basicStateReducer);
            },
            useDebugValue: mountDebugValue,
            useDeferredValue: function(value, initialValue) {
                var hook = updateWorkInProgressHook();
                return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
            },
            useTransition: function() {
                var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
                return [
                    "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
                    start
                ];
            },
            useSyncExternalStore: updateSyncExternalStore,
            useId: updateId,
            useHostTransitionStatus: useHostTransitionStatus,
            useFormState: rerenderActionState,
            useActionState: rerenderActionState,
            useOptimistic: function(passthrough, reducer) {
                var hook = updateWorkInProgressHook();
                if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
                hook.baseState = passthrough;
                return [
                    passthrough,
                    hook.queue.dispatch
                ];
            },
            useMemoCache: useMemoCache,
            useCacheRefresh: updateRefresh
        }, thenableState = null, thenableIndexCounter = 0;
        function unwrapThenable(thenable) {
            var index = thenableIndexCounter;
            thenableIndexCounter += 1;
            null === thenableState && (thenableState = []);
            return trackUsedThenable(thenableState, thenable, index);
        }
        function coerceRef(workInProgress, element) {
            element = element.props.ref;
            workInProgress.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
            if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error(formatProdErrorMessage(525));
            returnFiber = Object.prototype.toString.call(newChild);
            throw Error(formatProdErrorMessage(31, "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber));
        }
        function resolveLazy(lazyType) {
            var init = lazyType._init;
            return init(lazyType._payload);
        }
        function createChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
                if (shouldTrackSideEffects) {
                    var deletions = returnFiber.deletions;
                    null === deletions ? ((returnFiber.deletions = [
                        childToDelete
                    ]), (returnFiber.flags |= 16)) : deletions.push(childToDelete);
                }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
                if (!shouldTrackSideEffects) return null;
                for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), (currentFirstChild = currentFirstChild.sibling);
                return null;
            }
            function mapRemainingChildren(currentFirstChild) {
                for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), (currentFirstChild = currentFirstChild.sibling);
                return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
                fiber = createWorkInProgress(fiber, pendingProps);
                fiber.index = 0;
                fiber.sibling = null;
                return fiber;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
                newFiber.index = newIndex;
                if (!shouldTrackSideEffects) return (newFiber.flags |= 1048576), lastPlacedIndex;
                newIndex = newFiber.alternate;
                if (null !== newIndex) return ((newIndex = newIndex.index), newIndex < lastPlacedIndex ? ((newFiber.flags |= 67108866), lastPlacedIndex) : newIndex);
                newFiber.flags |= 67108866;
                return lastPlacedIndex;
            }
            function placeSingleChild(newFiber) {
                shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
                return newFiber;
            }
            function updateTextNode(returnFiber, current, textContent, lanes) {
                if (null === current || 6 !== current.tag) return ((current = createFiberFromText(textContent, returnFiber.mode, lanes)), (current.return = returnFiber), current);
                current = useFiber(current, textContent);
                current.return = returnFiber;
                return current;
            }
            function updateElement(returnFiber, current, element, lanes) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
                if (null !== current && (current.elementType === elementType || ("object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))) return ((current = useFiber(current, element.props)), coerceRef(current, element), (current.return = returnFiber), current);
                current = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
                coerceRef(current, element);
                current.return = returnFiber;
                return current;
            }
            function updatePortal(returnFiber, current, portal, lanes) {
                if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return ((current = createFiberFromPortal(portal, returnFiber.mode, lanes)), (current.return = returnFiber), current);
                current = useFiber(current, portal.children || []);
                current.return = returnFiber;
                return current;
            }
            function updateFragment(returnFiber, current, fragment, lanes, key) {
                if (null === current || 7 !== current.tag) return ((current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key)), (current.return = returnFiber), current);
                current = useFiber(current, fragment);
                current.return = returnFiber;
                return current;
            }
            function createChild(returnFiber, newChild, lanes) {
                if (("string" === typeof newChild && "" !== newChild) || "number" === typeof newChild || "bigint" === typeof newChild) return ((newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes)), (newChild.return = returnFiber), newChild);
                if ("object" === typeof newChild && null !== newChild) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            return ((lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes)), coerceRef(lanes, newChild), (lanes.return = returnFiber), lanes);
                        case REACT_PORTAL_TYPE:
                            return ((newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes)), (newChild.return = returnFiber), newChild);
                        case REACT_LAZY_TYPE:
                            var init = newChild._init;
                            newChild = init(newChild._payload);
                            return createChild(returnFiber, newChild, lanes);
                    }
                    if (isArrayImpl(newChild) || getIteratorFn(newChild)) return ((newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null)), (newChild.return = returnFiber), newChild);
                    if ("function" === typeof newChild.then) return createChild(returnFiber, unwrapThenable(newChild), lanes);
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
                var key = null !== oldFiber ? oldFiber.key : null;
                if (("string" === typeof newChild && "" !== newChild) || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
                if ("object" === typeof newChild && null !== newChild) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
                        case REACT_PORTAL_TYPE:
                            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                        case REACT_LAZY_TYPE:
                            return ((key = newChild._init), (newChild = key(newChild._payload)), updateSlot(returnFiber, oldFiber, newChild, lanes));
                    }
                    if (isArrayImpl(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
                    if ("function" === typeof newChild.then) return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
                if (("string" === typeof newChild && "" !== newChild) || "number" === typeof newChild || "bigint" === typeof newChild) return ((existingChildren = existingChildren.get(newIdx) || null), updateTextNode(returnFiber, existingChildren, "" + newChild, lanes));
                if ("object" === typeof newChild && null !== newChild) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            return ((existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null), updateElement(returnFiber, existingChildren, newChild, lanes));
                        case REACT_PORTAL_TYPE:
                            return ((existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null), updatePortal(returnFiber, existingChildren, newChild, lanes));
                        case REACT_LAZY_TYPE:
                            var init = newChild._init;
                            newChild = init(newChild._payload);
                            return updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
                    }
                    if (isArrayImpl(newChild) || getIteratorFn(newChild)) return ((existingChildren = existingChildren.get(newIdx) || null), updateFragment(returnFiber, existingChildren, newChild, lanes, null));
                    if ("function" === typeof newChild.then) return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes);
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                return null;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
                for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = (currentFirstChild = 0), nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){
                    oldFiber.index > newIdx ? ((nextOldFiber = oldFiber), (oldFiber = null)) : (nextOldFiber = oldFiber.sibling);
                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                    if (null === newFiber) {
                        null === oldFiber && (oldFiber = nextOldFiber);
                        break;
                    }
                    shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                    currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                    null === previousNewFiber ? (resultingFirstChild = newFiber) : (previousNewFiber.sibling = newFiber);
                    previousNewFiber = newFiber;
                    oldFiber = nextOldFiber;
                }
                if (newIdx === newChildren.length) return (deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild);
                if (null === oldFiber) {
                    for(; newIdx < newChildren.length; newIdx++)(oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)), null !== oldFiber && ((currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx)), null === previousNewFiber ? (resultingFirstChild = oldFiber) : (previousNewFiber.sibling = oldFiber), (previousNewFiber = oldFiber));
                    isHydrating && pushTreeFork(returnFiber, newIdx);
                    return resultingFirstChild;
                }
                for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)(nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes)), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), (currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx)), null === previousNewFiber ? (resultingFirstChild = nextOldFiber) : (previousNewFiber.sibling = nextOldFiber), (previousNewFiber = nextOldFiber));
                shouldTrackSideEffects && oldFiber.forEach(function(child) {
                    return deleteChild(returnFiber, child);
                });
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
                if (null == newChildren) throw Error(formatProdErrorMessage(151));
                for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = (currentFirstChild = 0), nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){
                    oldFiber.index > newIdx ? ((nextOldFiber = oldFiber), (oldFiber = null)) : (nextOldFiber = oldFiber.sibling);
                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                    if (null === newFiber) {
                        null === oldFiber && (oldFiber = nextOldFiber);
                        break;
                    }
                    shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
                    currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
                    null === previousNewFiber ? (resultingFirstChild = newFiber) : (previousNewFiber.sibling = newFiber);
                    previousNewFiber = newFiber;
                    oldFiber = nextOldFiber;
                }
                if (step.done) return (deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild);
                if (null === oldFiber) {
                    for(; !step.done; newIdx++, step = newChildren.next())(step = createChild(returnFiber, step.value, lanes)), null !== step && ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)), null === previousNewFiber ? (resultingFirstChild = step) : (previousNewFiber.sibling = step), (previousNewFiber = step));
                    isHydrating && pushTreeFork(returnFiber, newIdx);
                    return resultingFirstChild;
                }
                for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())(step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), (currentFirstChild = placeChild(step, currentFirstChild, newIdx)), null === previousNewFiber ? (resultingFirstChild = step) : (previousNewFiber.sibling = step), (previousNewFiber = step));
                shouldTrackSideEffects && oldFiber.forEach(function(child) {
                    return deleteChild(returnFiber, child);
                });
                isHydrating && pushTreeFork(returnFiber, newIdx);
                return resultingFirstChild;
            }
            function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
                "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
                if ("object" === typeof newChild && null !== newChild) {
                    switch(newChild.$$typeof){
                        case REACT_ELEMENT_TYPE:
                            a: {
                                for(var key = newChild.key; null !== currentFirstChild;){
                                    if (currentFirstChild.key === key) {
                                        key = newChild.type;
                                        if (key === REACT_FRAGMENT_TYPE) {
                                            if (7 === currentFirstChild.tag) {
                                                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                                                lanes = useFiber(currentFirstChild, newChild.props.children);
                                                lanes.return = returnFiber;
                                                returnFiber = lanes;
                                                break a;
                                            }
                                        } else if (currentFirstChild.elementType === key || ("object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type)) {
                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                                            lanes = useFiber(currentFirstChild, newChild.props);
                                            coerceRef(lanes, newChild);
                                            lanes.return = returnFiber;
                                            returnFiber = lanes;
                                            break a;
                                        }
                                        deleteRemainingChildren(returnFiber, currentFirstChild);
                                        break;
                                    } else deleteChild(returnFiber, currentFirstChild);
                                    currentFirstChild = currentFirstChild.sibling;
                                }
                                newChild.type === REACT_FRAGMENT_TYPE ? ((lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key)), (lanes.return = returnFiber), (returnFiber = lanes)) : ((lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes)), coerceRef(lanes, newChild), (lanes.return = returnFiber), (returnFiber = lanes));
                            }
                            return placeSingleChild(returnFiber);
                        case REACT_PORTAL_TYPE:
                            a: {
                                for(key = newChild.key; null !== currentFirstChild;){
                                    if (currentFirstChild.key === key) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                                        lanes = useFiber(currentFirstChild, newChild.children || []);
                                        lanes.return = returnFiber;
                                        returnFiber = lanes;
                                        break a;
                                    } else {
                                        deleteRemainingChildren(returnFiber, currentFirstChild);
                                        break;
                                    }
                                    else deleteChild(returnFiber, currentFirstChild);
                                    currentFirstChild = currentFirstChild.sibling;
                                }
                                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                                lanes.return = returnFiber;
                                returnFiber = lanes;
                            }
                            return placeSingleChild(returnFiber);
                        case REACT_LAZY_TYPE:
                            return ((key = newChild._init), (newChild = key(newChild._payload)), reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes));
                    }
                    if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                    if (getIteratorFn(newChild)) {
                        key = getIteratorFn(newChild);
                        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
                        newChild = key.call(newChild);
                        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                    }
                    if ("function" === typeof newChild.then) return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes);
                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
                    throwOnInvalidObjectType(returnFiber, newChild);
                }
                return ("string" === typeof newChild && "" !== newChild) || "number" === typeof newChild || "bigint" === typeof newChild ? ((newChild = "" + newChild), null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), (lanes = useFiber(currentFirstChild, newChild)), (lanes.return = returnFiber), (returnFiber = lanes)) : (deleteRemainingChildren(returnFiber, currentFirstChild), (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)), (lanes.return = returnFiber), (returnFiber = lanes)), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return function(returnFiber, currentFirstChild, newChild, lanes) {
                try {
                    thenableIndexCounter = 0;
                    var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
                    thenableState = null;
                    return firstChildFiber;
                } catch (x) {
                    if (x === SuspenseException || x === SuspenseActionException) throw x;
                    var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
                    fiber.lanes = lanes;
                    fiber.return = returnFiber;
                    return fiber;
                } finally{}
            };
        }
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
        function pushPrimaryTreeSuspenseHandler(handler) {
            var current = handler.alternate;
            push(suspenseStackCursor, suspenseStackCursor.current & 1);
            push(suspenseHandlerStackCursor, handler);
            null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? (shellBoundary = handler) : null !== current.memoizedState && (shellBoundary = handler));
        }
        function pushOffscreenSuspenseHandler(fiber) {
            if (22 === fiber.tag) {
                if ((push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary)) {
                    var current = fiber.alternate;
                    null !== current && null !== current.memoizedState && (shellBoundary = fiber);
                }
            } else reuseSuspenseHandlerOnStack();
        }
        function reuseSuspenseHandlerOnStack() {
            push(suspenseStackCursor, suspenseStackCursor.current);
            push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
        }
        function popSuspenseHandler(fiber) {
            pop(suspenseHandlerStackCursor);
            shellBoundary === fiber && (shellBoundary = null);
            pop(suspenseStackCursor);
        }
        var suspenseStackCursor = createCursor(0);
        function findFirstSuspended(row) {
            for(var node = row; null !== node;){
                if (13 === node.tag) {
                    var state = node.memoizedState;
                    if (null !== state && ((state = state.dehydrated), null === state || "$?" === state.data || isSuspenseInstanceFallback(state))) return node;
                } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
                    if (0 !== (node.flags & 128)) return node;
                } else if (null !== node.child) {
                    node.child.return = node;
                    node = node.child;
                    continue;
                }
                if (node === row) break;
                for(; null === node.sibling;){
                    if (null === node.return || node.return === row) return null;
                    node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
            }
            return null;
        }
        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
            ctor = workInProgress.memoizedState;
            getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
            getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
            workInProgress.memoizedState = getDerivedStateFromProps;
            0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
        }
        var classComponentUpdater = {
            enqueueSetState: function(inst, payload, callback) {
                inst = inst._reactInternals;
                var lane = requestUpdateLane(), update = createUpdate(lane);
                update.payload = payload;
                void 0 !== callback && null !== callback && (update.callback = callback);
                payload = enqueueUpdate(inst, update, lane);
                null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            },
            enqueueReplaceState: function(inst, payload, callback) {
                inst = inst._reactInternals;
                var lane = requestUpdateLane(), update = createUpdate(lane);
                update.tag = 1;
                update.payload = payload;
                void 0 !== callback && null !== callback && (update.callback = callback);
                payload = enqueueUpdate(inst, update, lane);
                null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            },
            enqueueForceUpdate: function(inst, callback) {
                inst = inst._reactInternals;
                var lane = requestUpdateLane(), update = createUpdate(lane);
                update.tag = 2;
                void 0 !== callback && null !== callback && (update.callback = callback);
                callback = enqueueUpdate(inst, update, lane);
                null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
            }
        };
        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
            workInProgress = workInProgress.stateNode;
            return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
            workInProgress = instance.state;
            "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
            "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
        function resolveClassComponentProps(Component, baseProps) {
            var newProps = baseProps;
            if ("ref" in baseProps) {
                newProps = {};
                for(var propName in baseProps)"ref" !== propName && (newProps[propName] = baseProps[propName]);
            }
            if ((Component = Component.defaultProps)) {
                newProps === baseProps && (newProps = assign({}, newProps));
                for(var propName$73 in Component)void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
            }
            return newProps;
        }
        var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
            if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
                var event = new window.ErrorEvent("error", {
                    bubbles: true,
                    cancelable: true,
                    message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
                    error: error
                });
                if (!window.dispatchEvent(event)) return;
            } else if ("object" === typeof process && "function" === typeof process.emit) {
                process.emit("uncaughtException", error);
                return;
            }
            console.error(error);
        };
        function defaultOnUncaughtError(error) {
            reportGlobalError(error);
        }
        function defaultOnCaughtError(error) {
            console.error(error);
        }
        function defaultOnRecoverableError(error) {
            reportGlobalError(error);
        }
        function logUncaughtError(root, errorInfo) {
            try {
                var onUncaughtError = root.onUncaughtError;
                onUncaughtError(errorInfo.value, {
                    componentStack: errorInfo.stack
                });
            } catch (e$74) {
                setTimeout(function() {
                    throw e$74;
                });
            }
        }
        function logCaughtError(root, boundary, errorInfo) {
            try {
                var onCaughtError = root.onCaughtError;
                onCaughtError(errorInfo.value, {
                    componentStack: errorInfo.stack,
                    errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
                });
            } catch (e$75) {
                setTimeout(function() {
                    throw e$75;
                });
            }
        }
        function createRootErrorUpdate(root, errorInfo, lane) {
            lane = createUpdate(lane);
            lane.tag = 3;
            lane.payload = {
                element: null
            };
            lane.callback = function() {
                logUncaughtError(root, errorInfo);
            };
            return lane;
        }
        function createClassErrorUpdate(lane) {
            lane = createUpdate(lane);
            lane.tag = 3;
            return lane;
        }
        function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if ("function" === typeof getDerivedStateFromError) {
                var error = errorInfo.value;
                update.payload = function() {
                    return getDerivedStateFromError(error);
                };
                update.callback = function() {
                    logCaughtError(root, fiber, errorInfo);
                };
            }
            var inst = fiber.stateNode;
            null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
                logCaughtError(root, fiber, errorInfo);
                "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? (legacyErrorBoundariesThatAlreadyFailed = new Set([
                    this
                ])) : legacyErrorBoundariesThatAlreadyFailed.add(this));
                var stack = errorInfo.stack;
                this.componentDidCatch(errorInfo.value, {
                    componentStack: null !== stack ? stack : ""
                });
            });
        }
        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= 32768;
            if (null !== value && "object" === typeof value && "function" === typeof value.then) {
                returnFiber = sourceFiber.alternate;
                null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, true);
                sourceFiber = suspenseHandlerStackCursor.current;
                if (null !== sourceFiber) {
                    switch(sourceFiber.tag){
                        case 13:
                            return (null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), (sourceFiber.flags &= -257), (sourceFiber.flags |= 65536), (sourceFiber.lanes = rootRenderLanes), value === noopSuspenseyCommitThenable ? (sourceFiber.flags |= 16384) : ((returnFiber = sourceFiber.updateQueue), null === returnFiber ? (sourceFiber.updateQueue = new Set([
                                value
                            ])) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), false);
                        case 22:
                            return ((sourceFiber.flags |= 65536), value === noopSuspenseyCommitThenable ? (sourceFiber.flags |= 16384) : ((returnFiber = sourceFiber.updateQueue), null === returnFiber ? ((returnFiber = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([
                                    value
                                ])
                            }), (sourceFiber.updateQueue = returnFiber)) : ((sourceFiber = returnFiber.retryQueue), null === sourceFiber ? (returnFiber.retryQueue = new Set([
                                value
                            ])) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), false);
                    }
                    throw Error(formatProdErrorMessage(435, sourceFiber.tag));
                }
                attachPingListener(root, value, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return false;
            }
            if (isHydrating) return ((returnFiber = suspenseHandlerStackCursor.current), null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), (returnFiber.flags |= 65536), (returnFiber.lanes = rootRenderLanes), value !== HydrationMismatchException && ((root = Error(formatProdErrorMessage(422), {
                cause: value
            })), queueHydrationError(createCapturedValueAtFiber(root, sourceFiber)))) : (value !== HydrationMismatchException && ((returnFiber = Error(formatProdErrorMessage(423), {
                cause: value
            })), queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))), (root = root.current.alternate), (root.flags |= 65536), (rootRenderLanes &= -rootRenderLanes), (root.lanes |= rootRenderLanes), (value = createCapturedValueAtFiber(value, sourceFiber)), (rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes)), enqueueCapturedUpdate(root, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false);
            var wrapperError = Error(formatProdErrorMessage(520), {
                cause: value
            });
            wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
            null === workInProgressRootConcurrentErrors ? (workInProgressRootConcurrentErrors = [
                wrapperError
            ]) : workInProgressRootConcurrentErrors.push(wrapperError);
            4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
            if (null === returnFiber) return true;
            value = createCapturedValueAtFiber(value, sourceFiber);
            sourceFiber = returnFiber;
            do {
                switch(sourceFiber.tag){
                    case 3:
                        return ((sourceFiber.flags |= 65536), (root = rootRenderLanes & -rootRenderLanes), (sourceFiber.lanes |= root), (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)), enqueueCapturedUpdate(sourceFiber, root), false);
                    case 1:
                        if (((returnFiber = sourceFiber.type), (wrapperError = sourceFiber.stateNode), 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || (null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))) return ((sourceFiber.flags |= 65536), (rootRenderLanes &= -rootRenderLanes), (sourceFiber.lanes |= rootRenderLanes), (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false);
                }
                sourceFiber = sourceFiber.return;
            }while (null !== sourceFiber);
            return false;
        }
        var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
            workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
        }
        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
            Component = Component.render;
            var ref = workInProgress.ref;
            if ("ref" in nextProps) {
                var propsWithoutRef = {};
                for(var key in nextProps)"ref" !== key && (propsWithoutRef[key] = nextProps[key]);
            } else propsWithoutRef = nextProps;
            prepareToReadContext(workInProgress);
            nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
            key = checkDidRenderIdHook();
            if (null !== current && !didReceiveUpdate) return (bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes));
            isHydrating && key && pushMaterializedTreeId(workInProgress);
            workInProgress.flags |= 1;
            reconcileChildren(current, workInProgress, nextProps, renderLanes);
            return workInProgress.child;
        }
        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
            if (null === current) {
                var type = Component.type;
                if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return ((workInProgress.tag = 15), (workInProgress.type = type), updateSimpleMemoComponent(current, workInProgress, type, nextProps, renderLanes));
                current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
                current.ref = workInProgress.ref;
                current.return = workInProgress;
                return (workInProgress.child = current);
            }
            type = current.child;
            if (!checkScheduledUpdateOrContext(current, renderLanes)) {
                var prevProps = type.memoizedProps;
                Component = Component.compare;
                Component = null !== Component ? Component : shallowEqual;
                if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
            }
            workInProgress.flags |= 1;
            current = createWorkInProgress(type, nextProps);
            current.ref = workInProgress.ref;
            current.return = workInProgress;
            return (workInProgress.child = current);
        }
        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
            if (null !== current) {
                var prevProps = current.memoizedProps;
                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref) if (((didReceiveUpdate = false), (workInProgress.pendingProps = nextProps = prevProps), checkScheduledUpdateOrContext(current, renderLanes))) 0 !== (current.flags & 131072) && (didReceiveUpdate = true);
                else return ((workInProgress.lanes = current.lanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes));
            }
            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
        }
        function updateOffscreenComponent(current, workInProgress, renderLanes) {
            var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
            if ("hidden" === nextProps.mode) {
                if (0 !== (workInProgress.flags & 128)) {
                    nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
                    if (null !== current) {
                        nextChildren = workInProgress.child = current.child;
                        for(prevState = 0; null !== nextChildren;)(prevState = prevState | nextChildren.lanes | nextChildren.childLanes), (nextChildren = nextChildren.sibling);
                        workInProgress.childLanes = prevState & ~nextProps;
                    } else (workInProgress.childLanes = 0), (workInProgress.child = null);
                    return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
                }
                if (0 !== (renderLanes & 536870912)) (workInProgress.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                }), null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress);
                else return ((workInProgress.lanes = workInProgress.childLanes = 536870912), deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes));
            } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(), (workInProgress.memoizedState = null)) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
            var JSCompiler_inline_result = peekCacheFromPool();
            JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
                parent: CacheContext._currentValue,
                pool: JSCompiler_inline_result
            };
            workInProgress.memoizedState = {
                baseLanes: nextBaseLanes,
                cachePool: JSCompiler_inline_result
            };
            null !== current && pushTransition(workInProgress, null);
            reuseHiddenContextOnStack();
            pushOffscreenSuspenseHandler(workInProgress);
            null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, true);
            return null;
        }
        function markRef(current, workInProgress) {
            var ref = workInProgress.ref;
            if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 4194816);
            else {
                if ("function" !== typeof ref && "object" !== typeof ref) throw Error(formatProdErrorMessage(284));
                if (null === current || current.ref !== ref) workInProgress.flags |= 4194816;
            }
        }
        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
            prepareToReadContext(workInProgress);
            Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);
            nextProps = checkDidRenderIdHook();
            if (null !== current && !didReceiveUpdate) return (bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes));
            isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
            workInProgress.flags |= 1;
            reconcileChildren(current, workInProgress, Component, renderLanes);
            return workInProgress.child;
        }
        function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
            prepareToReadContext(workInProgress);
            workInProgress.updateQueue = null;
            nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
            finishRenderingHooks(current);
            Component = checkDidRenderIdHook();
            if (null !== current && !didReceiveUpdate) return (bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes));
            isHydrating && Component && pushMaterializedTreeId(workInProgress);
            workInProgress.flags |= 1;
            reconcileChildren(current, workInProgress, nextProps, renderLanes);
            return workInProgress.child;
        }
        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
            prepareToReadContext(workInProgress);
            if (null === workInProgress.stateNode) {
                var context = emptyContextObject, contextType = Component.contextType;
                "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
                context = new Component(nextProps, context);
                workInProgress.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
                context.updater = classComponentUpdater;
                workInProgress.stateNode = context;
                context._reactInternals = workInProgress;
                context = workInProgress.stateNode;
                context.props = nextProps;
                context.state = workInProgress.memoizedState;
                context.refs = {};
                initializeUpdateQueue(workInProgress);
                contextType = Component.contextType;
                context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
                context.state = workInProgress.memoizedState;
                contextType = Component.getDerivedStateFromProps;
                "function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, Component, contextType, nextProps), (context.state = workInProgress.memoizedState));
                "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || ("function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount) || ((contextType = context.state), "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress, nextProps, context, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), (context.state = workInProgress.memoizedState));
                "function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308);
                nextProps = true;
            } else if (null === current) {
                context = workInProgress.stateNode;
                var unresolvedOldProps = workInProgress.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
                context.props = oldProps;
                var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
                contextType = emptyContextObject;
                "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
                var getDerivedStateFromProps = Component.getDerivedStateFromProps;
                contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
                unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
                contextType$jscomp$0 || ("function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps) || ((unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, context, nextProps, contextType));
                hasForceUpdate = false;
                var oldState = workInProgress.memoizedState;
                context.state = oldState;
                processUpdateQueue(workInProgress, nextProps, context, renderLanes);
                suspendIfUpdateReadFromEntangledAsyncAction();
                oldContext = workInProgress.memoizedState;
                unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), (oldContext = workInProgress.memoizedState)), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (contextType$jscomp$0 || ("function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount) || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.memoizedProps = nextProps), (workInProgress.memoizedState = oldContext)), (context.props = nextProps), (context.state = oldContext), (context.context = contextType), (nextProps = oldProps)) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), (nextProps = false));
            } else {
                context = workInProgress.stateNode;
                cloneUpdateQueue(current, workInProgress);
                contextType = workInProgress.memoizedProps;
                contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
                context.props = contextType$jscomp$0;
                getDerivedStateFromProps = workInProgress.pendingProps;
                oldState = context.context;
                oldContext = Component.contextType;
                oldProps = emptyContextObject;
                "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
                unresolvedOldProps = Component.getDerivedStateFromProps;
                (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || ("function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps) || ((contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(workInProgress, context, nextProps, oldProps));
                hasForceUpdate = false;
                oldState = workInProgress.memoizedState;
                context.state = oldState;
                processUpdateQueue(workInProgress, nextProps, context, renderLanes);
                suspendIfUpdateReadFromEntangledAsyncAction();
                var newState = workInProgress.memoizedState;
                contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || (null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), (newState = workInProgress.memoizedState)), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, contextType$jscomp$0, nextProps, oldState, newState, oldProps) || (null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies))) ? (oldContext || ("function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate) || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)), "function" === typeof context.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || (contextType === current.memoizedProps && oldState === current.memoizedState) || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || (contextType === current.memoizedProps && oldState === current.memoizedState) || (workInProgress.flags |= 1024), (workInProgress.memoizedProps = nextProps), (workInProgress.memoizedState = newState)), (context.props = nextProps), (context.state = newState), (context.context = oldProps), (nextProps = contextType$jscomp$0)) : ("function" !== typeof context.componentDidUpdate || (contextType === current.memoizedProps && oldState === current.memoizedState) || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || (contextType === current.memoizedProps && oldState === current.memoizedState) || (workInProgress.flags |= 1024), (nextProps = false));
            }
            context = nextProps;
            markRef(current, workInProgress);
            nextProps = 0 !== (workInProgress.flags & 128);
            context || nextProps ? ((context = workInProgress.stateNode), (Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render()), (workInProgress.flags |= 1), null !== current && nextProps ? ((workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes)), (workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes))) : reconcileChildren(current, workInProgress, Component, renderLanes), (workInProgress.memoizedState = context.state), (current = workInProgress.child)) : (current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes));
            return current;
        }
        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
            resetHydrationState();
            workInProgress.flags |= 256;
            reconcileChildren(current, workInProgress, nextChildren, renderLanes);
            return workInProgress.child;
        }
        var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0,
            hydrationErrors: null
        };
        function mountSuspenseOffscreenState(renderLanes) {
            return {
                baseLanes: renderLanes,
                cachePool: getSuspendedCache()
            };
        }
        function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
            current = null !== current ? current.childLanes & ~renderLanes : 0;
            primaryTreeDidDefer && (current |= workInProgressDeferredLane);
            return current;
        }
        function updateSuspenseComponent(current, workInProgress, renderLanes) {
            var nextProps = workInProgress.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;
            (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
            JSCompiler_temp && ((showFallback = true), (workInProgress.flags &= -129));
            JSCompiler_temp = 0 !== (workInProgress.flags & 32);
            workInProgress.flags &= -33;
            if (null === current) {
                if (isHydrating) {
                    showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack();
                    if (isHydrating) {
                        var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
                        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {
                            c: {
                                JSCompiler_temp$jscomp$0 = nextInstance;
                                for(nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType;){
                                    if (!nextInstance) {
                                        nextInstance = null;
                                        break c;
                                    }
                                    JSCompiler_temp$jscomp$0 = getNextHydratable(JSCompiler_temp$jscomp$0.nextSibling);
                                    if (null === JSCompiler_temp$jscomp$0) {
                                        nextInstance = null;
                                        break c;
                                    }
                                }
                                nextInstance = JSCompiler_temp$jscomp$0;
                            }
                            null !== nextInstance ? ((workInProgress.memoizedState = {
                                dehydrated: nextInstance,
                                treeContext: null !== treeContextProvider ? {
                                    id: treeContextId,
                                    overflow: treeContextOverflow
                                } : null,
                                retryLane: 536870912,
                                hydrationErrors: null
                            }), (JSCompiler_temp$jscomp$0 = createFiberImplClass(18, null, null, 0)), (JSCompiler_temp$jscomp$0.stateNode = nextInstance), (JSCompiler_temp$jscomp$0.return = workInProgress), (workInProgress.child = JSCompiler_temp$jscomp$0), (hydrationParentFiber = workInProgress), (nextHydratableInstance = null), (JSCompiler_temp$jscomp$0 = true)) : (JSCompiler_temp$jscomp$0 = false);
                        }
                        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
                    }
                    nextInstance = workInProgress.memoizedState;
                    if (null !== nextInstance && ((nextInstance = nextInstance.dehydrated), null !== nextInstance)) return (isSuspenseInstanceFallback(nextInstance) ? (workInProgress.lanes = 32) : (workInProgress.lanes = 536870912), null);
                    popSuspenseHandler(workInProgress);
                }
                nextInstance = nextProps.children;
                nextProps = nextProps.fallback;
                if (showFallback) return (reuseSuspenseHandlerOnStack(), (showFallback = workInProgress.mode), (nextInstance = mountWorkInProgressOffscreenFiber({
                    mode: "hidden",
                    children: nextInstance
                }, showFallback)), (nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null)), (nextInstance.return = workInProgress), (nextProps.return = workInProgress), (nextInstance.sibling = nextProps), (workInProgress.child = nextInstance), (showFallback = workInProgress.child), (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)), (showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes)), (workInProgress.memoizedState = SUSPENDED_MARKER), nextProps);
                pushPrimaryTreeSuspenseHandler(workInProgress);
                return mountSuspensePrimaryChildren(workInProgress, nextInstance);
            }
            JSCompiler_temp$jscomp$0 = current.memoizedState;
            if (null !== JSCompiler_temp$jscomp$0 && ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated), null !== nextInstance)) {
                if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), (workInProgress.flags &= -257), (workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes))) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(), (workInProgress.child = current.child), (workInProgress.flags |= 128), (workInProgress = null)) : (reuseSuspenseHandlerOnStack(), (showFallback = nextProps.fallback), (nextInstance = workInProgress.mode), (nextProps = mountWorkInProgressOffscreenFiber({
                    mode: "visible",
                    children: nextProps.children
                }, nextInstance)), (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null)), (showFallback.flags |= 2), (nextProps.return = workInProgress), (showFallback.return = workInProgress), (nextProps.sibling = showFallback), (workInProgress.child = nextProps), reconcileChildFibers(workInProgress, current.child, null, renderLanes), (nextProps = workInProgress.child), (nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes)), (nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes)), (workInProgress.memoizedState = SUSPENDED_MARKER), (workInProgress = showFallback));
                else if ((pushPrimaryTreeSuspenseHandler(workInProgress), isSuspenseInstanceFallback(nextInstance))) {
                    JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
                    if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
                    JSCompiler_temp = digest;
                    nextProps = Error(formatProdErrorMessage(419));
                    nextProps.stack = "";
                    nextProps.digest = JSCompiler_temp;
                    queueHydrationError({
                        value: nextProps,
                        source: null,
                        stack: null
                    });
                    workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
                } else if ((didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, false), (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)), didReceiveUpdate || JSCompiler_temp)) {
                    JSCompiler_temp = workInProgressRoot;
                    if (null !== JSCompiler_temp && ((nextProps = renderLanes & -renderLanes), (nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps)), (nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps), 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)) throw (((JSCompiler_temp$jscomp$0.retryLane = nextProps), enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException));
                    "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
                    workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
                } else "$?" === nextInstance.data ? ((workInProgress.flags |= 192), (workInProgress.child = current.child), (workInProgress = null)) : ((current = JSCompiler_temp$jscomp$0.treeContext), (nextHydratableInstance = getNextHydratable(nextInstance.nextSibling)), (hydrationParentFiber = workInProgress), (isHydrating = true), (hydrationErrors = null), (rootOrSingletonContext = false), null !== current && ((idStack[idStackIndex++] = treeContextId), (idStack[idStackIndex++] = treeContextOverflow), (idStack[idStackIndex++] = treeContextProvider), (treeContextId = current.id), (treeContextOverflow = current.overflow), (treeContextProvider = workInProgress)), (workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children)), (workInProgress.flags |= 4096));
                return workInProgress;
            }
            if (showFallback) return (reuseSuspenseHandlerOnStack(), (showFallback = nextProps.fallback), (nextInstance = workInProgress.mode), (JSCompiler_temp$jscomp$0 = current.child), (digest = JSCompiler_temp$jscomp$0.sibling), (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
                mode: "hidden",
                children: nextProps.children
            })), (nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712), null !== digest ? (showFallback = createWorkInProgress(digest, showFallback)) : ((showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null)), (showFallback.flags |= 2)), (showFallback.return = workInProgress), (nextProps.return = workInProgress), (nextProps.sibling = showFallback), (workInProgress.child = nextProps), (nextProps = showFallback), (showFallback = workInProgress.child), (nextInstance = current.child.memoizedState), null === nextInstance ? (nextInstance = mountSuspenseOffscreenState(renderLanes)) : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool), null !== JSCompiler_temp$jscomp$0 ? ((digest = CacheContext._currentValue), (JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? {
                parent: digest,
                pool: digest
            } : JSCompiler_temp$jscomp$0)) : (JSCompiler_temp$jscomp$0 = getSuspendedCache()), (nextInstance = {
                baseLanes: nextInstance.baseLanes | renderLanes,
                cachePool: JSCompiler_temp$jscomp$0
            })), (showFallback.memoizedState = nextInstance), (showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes)), (workInProgress.memoizedState = SUSPENDED_MARKER), nextProps);
            pushPrimaryTreeSuspenseHandler(workInProgress);
            renderLanes = current.child;
            current = renderLanes.sibling;
            renderLanes = createWorkInProgress(renderLanes, {
                mode: "visible",
                children: nextProps.children
            });
            renderLanes.return = workInProgress;
            renderLanes.sibling = null;
            null !== current && ((JSCompiler_temp = workInProgress.deletions), null === JSCompiler_temp ? ((workInProgress.deletions = [
                current
            ]), (workInProgress.flags |= 16)) : JSCompiler_temp.push(current));
            workInProgress.child = renderLanes;
            workInProgress.memoizedState = null;
            return renderLanes;
        }
        function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
            primaryChildren = mountWorkInProgressOffscreenFiber({
                mode: "visible",
                children: primaryChildren
            }, workInProgress.mode);
            primaryChildren.return = workInProgress;
            return (workInProgress.child = primaryChildren);
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
            offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
            offscreenProps.lanes = 0;
            offscreenProps.stateNode = {
                _visibility: 1,
                _pendingMarkers: null,
                _retryCache: null,
                _transitions: null
            };
            return offscreenProps;
        }
        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
            reconcileChildFibers(workInProgress, current.child, null, renderLanes);
            current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
            current.flags |= 2;
            workInProgress.memoizedState = null;
            return current;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
            fiber.lanes |= renderLanes;
            var alternate = fiber.alternate;
            null !== alternate && (alternate.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
        }
        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress.memoizedState;
            null === renderState ? (workInProgress.memoizedState = {
                isBackwards: isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail: tail,
                tailMode: tailMode
            }) : ((renderState.isBackwards = isBackwards), (renderState.rendering = null), (renderState.renderingStartTime = 0), (renderState.last = lastContentRow), (renderState.tail = tail), (renderState.tailMode = tailMode));
        }
        function updateSuspenseListComponent(current, workInProgress, renderLanes) {
            var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
            reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
            nextProps = suspenseStackCursor.current;
            if (0 !== (nextProps & 2)) (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);
            else {
                if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){
                    if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
                    else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
                    else if (null !== current.child) {
                        current.child.return = current;
                        current = current.child;
                        continue;
                    }
                    if (current === workInProgress) break a;
                    for(; null === current.sibling;){
                        if (null === current.return || current.return === workInProgress) break a;
                        current = current.return;
                    }
                    current.sibling.return = current.return;
                    current = current.sibling;
                }
                nextProps &= 1;
            }
            push(suspenseStackCursor, nextProps);
            switch(revealOrder){
                case "forwards":
                    renderLanes = workInProgress.child;
                    for(revealOrder = null; null !== renderLanes;)(current = renderLanes.alternate), null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), (renderLanes = renderLanes.sibling);
                    renderLanes = revealOrder;
                    null === renderLanes ? ((revealOrder = workInProgress.child), (workInProgress.child = null)) : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
                    initSuspenseListRenderState(workInProgress, false, revealOrder, renderLanes, tailMode);
                    break;
                case "backwards":
                    renderLanes = null;
                    revealOrder = workInProgress.child;
                    for(workInProgress.child = null; null !== revealOrder;){
                        current = revealOrder.alternate;
                        if (null !== current && null === findFirstSuspended(current)) {
                            workInProgress.child = revealOrder;
                            break;
                        }
                        current = revealOrder.sibling;
                        revealOrder.sibling = renderLanes;
                        renderLanes = revealOrder;
                        revealOrder = current;
                    }
                    initSuspenseListRenderState(workInProgress, true, renderLanes, null, tailMode);
                    break;
                case "together":
                    initSuspenseListRenderState(workInProgress, false, null, null, void 0);
                    break;
                default:
                    workInProgress.memoizedState = null;
            }
            return workInProgress.child;
        }
        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
            null !== current && (workInProgress.dependencies = current.dependencies);
            workInProgressRootSkippedLanes |= workInProgress.lanes;
            if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {
                if ((propagateParentContextChanges(current, workInProgress, renderLanes, false), 0 === (renderLanes & workInProgress.childLanes))) return null;
            } else return null;
            if (null !== current && workInProgress.child !== current.child) throw Error(formatProdErrorMessage(153));
            if (null !== workInProgress.child) {
                current = workInProgress.child;
                renderLanes = createWorkInProgress(current, current.pendingProps);
                workInProgress.child = renderLanes;
                for(renderLanes.return = workInProgress; null !== current.sibling;)(current = current.sibling), (renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps)), (renderLanes.return = workInProgress);
                renderLanes.sibling = null;
            }
            return workInProgress.child;
        }
        function checkScheduledUpdateOrContext(current, renderLanes) {
            if (0 !== (current.lanes & renderLanes)) return true;
            current = current.dependencies;
            return null !== current && checkIfContextChanged(current) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
            switch(workInProgress.tag){
                case 3:
                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                    pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
                    resetHydrationState();
                    break;
                case 27:
                case 5:
                    pushHostContext(workInProgress);
                    break;
                case 4:
                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                    break;
                case 10:
                    pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
                    break;
                case 13:
                    var state = workInProgress.memoizedState;
                    if (null !== state) {
                        if (null !== state.dehydrated) return (pushPrimaryTreeSuspenseHandler(workInProgress), (workInProgress.flags |= 128), null);
                        if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
                        pushPrimaryTreeSuspenseHandler(workInProgress);
                        current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                        return null !== current ? current.sibling : null;
                    }
                    pushPrimaryTreeSuspenseHandler(workInProgress);
                    break;
                case 19:
                    var didSuspendBefore = 0 !== (current.flags & 128);
                    state = 0 !== (renderLanes & workInProgress.childLanes);
                    state || (propagateParentContextChanges(current, workInProgress, renderLanes, false), (state = 0 !== (renderLanes & workInProgress.childLanes)));
                    if (didSuspendBefore) {
                        if (state) return updateSuspenseListComponent(current, workInProgress, renderLanes);
                        workInProgress.flags |= 128;
                    }
                    didSuspendBefore = workInProgress.memoizedState;
                    null !== didSuspendBefore && ((didSuspendBefore.rendering = null), (didSuspendBefore.tail = null), (didSuspendBefore.lastEffect = null));
                    push(suspenseStackCursor, suspenseStackCursor.current);
                    if (state) break;
                    else return null;
                case 22:
                case 23:
                    return ((workInProgress.lanes = 0), updateOffscreenComponent(current, workInProgress, renderLanes));
                case 24:
                    pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
            }
            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
        }
        function beginWork(current, workInProgress, renderLanes) {
            if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps) didReceiveUpdate = true;
            else {
                if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return ((didReceiveUpdate = false), attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes));
                didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
            }
            else (didReceiveUpdate = false), isHydrating && 0 !== (workInProgress.flags & 1048576) && pushTreeId(workInProgress, treeForkCount, workInProgress.index);
            workInProgress.lanes = 0;
            switch(workInProgress.tag){
                case 16:
                    a: {
                        current = workInProgress.pendingProps;
                        var lazyComponent = workInProgress.elementType, init = lazyComponent._init;
                        lazyComponent = init(lazyComponent._payload);
                        workInProgress.type = lazyComponent;
                        if ("function" === typeof lazyComponent) shouldConstruct(lazyComponent) ? ((current = resolveClassComponentProps(lazyComponent, current)), (workInProgress.tag = 1), (workInProgress = updateClassComponent(null, workInProgress, lazyComponent, current, renderLanes))) : ((workInProgress.tag = 0), (workInProgress = updateFunctionComponent(null, workInProgress, lazyComponent, current, renderLanes)));
                        else {
                            if (void 0 !== lazyComponent && null !== lazyComponent) if (((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)) {
                                workInProgress.tag = 11;
                                workInProgress = updateForwardRef(null, workInProgress, lazyComponent, current, renderLanes);
                                break a;
                            } else if (init === REACT_MEMO_TYPE) {
                                workInProgress.tag = 14;
                                workInProgress = updateMemoComponent(null, workInProgress, lazyComponent, current, renderLanes);
                                break a;
                            }
                            workInProgress = getComponentNameFromType(lazyComponent) || lazyComponent;
                            throw Error(formatProdErrorMessage(306, workInProgress, ""));
                        }
                    }
                    return workInProgress;
                case 0:
                    return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
                case 1:
                    return ((lazyComponent = workInProgress.type), (init = resolveClassComponentProps(lazyComponent, workInProgress.pendingProps)), updateClassComponent(current, workInProgress, lazyComponent, init, renderLanes));
                case 3:
                    a: {
                        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
                        if (null === current) throw Error(formatProdErrorMessage(387));
                        lazyComponent = workInProgress.pendingProps;
                        var prevState = workInProgress.memoizedState;
                        init = prevState.element;
                        cloneUpdateQueue(current, workInProgress);
                        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);
                        var nextState = workInProgress.memoizedState;
                        lazyComponent = nextState.cache;
                        pushProvider(workInProgress, CacheContext, lazyComponent);
                        lazyComponent !== prevState.cache && propagateContextChanges(workInProgress, [
                            CacheContext
                        ], renderLanes, true);
                        suspendIfUpdateReadFromEntangledAsyncAction();
                        lazyComponent = nextState.element;
                        if (prevState.isDehydrated) if (((prevState = {
                            element: lazyComponent,
                            isDehydrated: false,
                            cache: nextState.cache
                        }), (workInProgress.updateQueue.baseState = prevState), (workInProgress.memoizedState = prevState), workInProgress.flags & 256)) {
                            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, lazyComponent, renderLanes);
                            break a;
                        } else if (lazyComponent !== init) {
                            init = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), workInProgress);
                            queueHydrationError(init);
                            workInProgress = mountHostRootWithoutHydrating(current, workInProgress, lazyComponent, renderLanes);
                            break a;
                        } else {
                            current = workInProgress.stateNode.containerInfo;
                            switch(current.nodeType){
                                case 9:
                                    current = current.body;
                                    break;
                                default:
                                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                            }
                            nextHydratableInstance = getNextHydratable(current.firstChild);
                            hydrationParentFiber = workInProgress;
                            isHydrating = true;
                            hydrationErrors = null;
                            rootOrSingletonContext = true;
                            renderLanes = mountChildFibers(workInProgress, null, lazyComponent, renderLanes);
                            for(workInProgress.child = renderLanes; renderLanes;)(renderLanes.flags = (renderLanes.flags & -3) | 4096), (renderLanes = renderLanes.sibling);
                        }
                        else {
                            resetHydrationState();
                            if (lazyComponent === init) {
                                workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
                                break a;
                            }
                            reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
                        }
                        workInProgress = workInProgress.child;
                    }
                    return workInProgress;
                case 26:
                    return (markRef(current, workInProgress), null === current ? (renderLanes = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? (workInProgress.memoizedState = renderLanes) : isHydrating || ((renderLanes = workInProgress.type), (current = workInProgress.pendingProps), (lazyComponent = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(renderLanes)), (lazyComponent[internalInstanceKey] = workInProgress), (lazyComponent[internalPropsKey] = current), setInitialProperties(lazyComponent, renderLanes, current), markNodeAsHoistable(lazyComponent), (workInProgress.stateNode = lazyComponent)) : (workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState)), null);
                case 27:
                    return (pushHostContext(workInProgress), null === current && isHydrating && ((lazyComponent = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, rootInstanceStackCursor.current)), (hydrationParentFiber = workInProgress), (rootOrSingletonContext = true), (init = nextHydratableInstance), isSingletonScope(workInProgress.type) ? ((previousHydratableOnEnteringScopedSingleton = init), (nextHydratableInstance = getNextHydratable(lazyComponent.firstChild))) : (nextHydratableInstance = init)), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), markRef(current, workInProgress), null === current && (workInProgress.flags |= 4194304), workInProgress.child);
                case 5:
                    if (null === current && isHydrating) {
                        if ((init = lazyComponent = nextHydratableInstance)) (lazyComponent = canHydrateInstance(lazyComponent, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext)), null !== lazyComponent ? ((workInProgress.stateNode = lazyComponent), (hydrationParentFiber = workInProgress), (nextHydratableInstance = getNextHydratable(lazyComponent.firstChild)), (rootOrSingletonContext = false), (init = true)) : (init = false);
                        init || throwOnHydrationMismatch(workInProgress);
                    }
                    pushHostContext(workInProgress);
                    init = workInProgress.type;
                    prevState = workInProgress.pendingProps;
                    nextState = null !== current ? current.memoizedProps : null;
                    lazyComponent = prevState.children;
                    shouldSetTextContent(init, prevState) ? (lazyComponent = null) : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress.flags |= 32);
                    null !== workInProgress.memoizedState && ((init = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes)), (HostTransitionContext._currentValue = init));
                    markRef(current, workInProgress);
                    reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
                    return workInProgress.child;
                case 6:
                    if (null === current && isHydrating) {
                        if ((current = renderLanes = nextHydratableInstance)) (renderLanes = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext)), null !== renderLanes ? ((workInProgress.stateNode = renderLanes), (hydrationParentFiber = workInProgress), (nextHydratableInstance = null), (current = true)) : (current = false);
                        current || throwOnHydrationMismatch(workInProgress);
                    }
                    return null;
                case 13:
                    return updateSuspenseComponent(current, workInProgress, renderLanes);
                case 4:
                    return (pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), (lazyComponent = workInProgress.pendingProps), null === current ? (workInProgress.child = reconcileChildFibers(workInProgress, null, lazyComponent, renderLanes)) : reconcileChildren(current, workInProgress, lazyComponent, renderLanes), workInProgress.child);
                case 11:
                    return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
                case 7:
                    return (reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child);
                case 8:
                    return (reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child);
                case 12:
                    return (reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child);
                case 10:
                    return ((lazyComponent = workInProgress.pendingProps), pushProvider(workInProgress, workInProgress.type, lazyComponent.value), reconcileChildren(current, workInProgress, lazyComponent.children, renderLanes), workInProgress.child);
                case 9:
                    return ((init = workInProgress.type._context), (lazyComponent = workInProgress.pendingProps.children), prepareToReadContext(workInProgress), (init = readContext(init)), (lazyComponent = lazyComponent(init)), (workInProgress.flags |= 1), reconcileChildren(current, workInProgress, lazyComponent, renderLanes), workInProgress.child);
                case 14:
                    return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
                case 15:
                    return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
                case 19:
                    return updateSuspenseListComponent(current, workInProgress, renderLanes);
                case 31:
                    return ((lazyComponent = workInProgress.pendingProps), (renderLanes = workInProgress.mode), (lazyComponent = {
                        mode: lazyComponent.mode,
                        children: lazyComponent.children
                    }), null === current ? ((renderLanes = mountWorkInProgressOffscreenFiber(lazyComponent, renderLanes)), (renderLanes.ref = workInProgress.ref), (workInProgress.child = renderLanes), (renderLanes.return = workInProgress), (workInProgress = renderLanes)) : ((renderLanes = createWorkInProgress(current.child, lazyComponent)), (renderLanes.ref = workInProgress.ref), (workInProgress.child = renderLanes), (renderLanes.return = workInProgress), (workInProgress = renderLanes)), workInProgress);
                case 22:
                    return updateOffscreenComponent(current, workInProgress, renderLanes);
                case 24:
                    return (prepareToReadContext(workInProgress), (lazyComponent = readContext(CacheContext)), null === current ? ((init = peekCacheFromPool()), null === init && ((init = workInProgressRoot), (prevState = createCache()), (init.pooledCache = prevState), prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes), (init = prevState)), (workInProgress.memoizedState = {
                        parent: lazyComponent,
                        cache: init
                    }), initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, init)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), (init = current.memoizedState), (prevState = workInProgress.memoizedState), init.parent !== lazyComponent ? ((init = {
                        parent: lazyComponent,
                        cache: lazyComponent
                    }), (workInProgress.memoizedState = init), 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = init), pushProvider(workInProgress, CacheContext, lazyComponent)) : ((lazyComponent = prevState.cache), pushProvider(workInProgress, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(workInProgress, [
                        CacheContext
                    ], renderLanes, true))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child);
                case 29:
                    throw workInProgress.pendingProps;
            }
            throw Error(formatProdErrorMessage(156, workInProgress.tag));
        }
        function markUpdate(workInProgress) {
            workInProgress.flags |= 4;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
            if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4)) workInProgress.flags &= -16777217;
            else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {
                resource = suspenseHandlerStackCursor.current;
                if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : ((workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912)) || resource !== shellBoundary)) throw (((suspendedThenable = noopSuspenseyCommitThenable), SuspenseyCommitException));
                workInProgress.flags |= 8192;
            }
        }
        function scheduleRetryEffect(workInProgress, retryQueue) {
            null !== retryQueue && (workInProgress.flags |= 4);
            workInProgress.flags & 16384 && ((retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912), (workInProgress.lanes |= retryQueue), (workInProgressSuspendedRetryLanes |= retryQueue));
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (!isHydrating) switch(renderState.tailMode){
                case "hidden":
                    hasRenderedATailFallback = renderState.tail;
                    for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
                    null === lastTailNode ? (renderState.tail = null) : (lastTailNode.sibling = null);
                    break;
                case "collapsed":
                    lastTailNode = renderState.tail;
                    for(var lastTailNode$113 = null; null !== lastTailNode;)null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), (lastTailNode = lastTailNode.sibling);
                    null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? (renderState.tail = null) : (renderState.tail.sibling = null) : (lastTailNode$113.sibling = null);
            }
        }
        function bubbleProperties(completedWork) {
            var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
            if (didBailout) for(var child$114 = completedWork.child; null !== child$114;)(newChildLanes |= child$114.lanes | child$114.childLanes), (subtreeFlags |= child$114.subtreeFlags & 65011712), (subtreeFlags |= child$114.flags & 65011712), (child$114.return = completedWork), (child$114 = child$114.sibling);
            else for(child$114 = completedWork.child; null !== child$114;)(newChildLanes |= child$114.lanes | child$114.childLanes), (subtreeFlags |= child$114.subtreeFlags), (subtreeFlags |= child$114.flags), (child$114.return = completedWork), (child$114 = child$114.sibling);
            completedWork.subtreeFlags |= subtreeFlags;
            completedWork.childLanes = newChildLanes;
            return didBailout;
        }
        function completeWork(current, workInProgress, renderLanes) {
            var newProps = workInProgress.pendingProps;
            popTreeContext(workInProgress);
            switch(workInProgress.tag){
                case 31:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return bubbleProperties(workInProgress), null;
                case 1:
                    return bubbleProperties(workInProgress), null;
                case 3:
                    renderLanes = workInProgress.stateNode;
                    newProps = null;
                    null !== current && (newProps = current.memoizedState.cache);
                    workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);
                    popProvider(CacheContext);
                    popHostContainer();
                    renderLanes.pendingContext && ((renderLanes.context = renderLanes.pendingContext), (renderLanes.pendingContext = null));
                    if (null === current || null === current.child) popHydrationState(workInProgress) ? markUpdate(workInProgress) : null === current || (current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256)) || ((workInProgress.flags |= 1024), upgradeHydrationErrorsToRecoverable());
                    bubbleProperties(workInProgress);
                    return null;
                case 26:
                    return ((renderLanes = workInProgress.memoizedState), null === current ? (markUpdate(workInProgress), null !== renderLanes ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), (workInProgress.flags &= -16777217))) : renderLanes ? renderLanes !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), (workInProgress.flags &= -16777217)) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), (workInProgress.flags &= -16777217)), null);
                case 27:
                    popHostContext(workInProgress);
                    renderLanes = rootInstanceStackCursor.current;
                    var type = workInProgress.type;
                    if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
                    else {
                        if (!newProps) {
                            if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
                            bubbleProperties(workInProgress);
                            return null;
                        }
                        current = contextStackCursor.current;
                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress) : ((current = resolveSingletonInstance(type, newProps, renderLanes)), (workInProgress.stateNode = current), markUpdate(workInProgress));
                    }
                    bubbleProperties(workInProgress);
                    return null;
                case 5:
                    popHostContext(workInProgress);
                    renderLanes = workInProgress.type;
                    if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
                    else {
                        if (!newProps) {
                            if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
                            bubbleProperties(workInProgress);
                            return null;
                        }
                        current = contextStackCursor.current;
                        if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress);
                        else {
                            type = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);
                            switch(current){
                                case 1:
                                    current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes);
                                    break;
                                case 2:
                                    current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes);
                                    break;
                                default:
                                    switch(renderLanes){
                                        case "svg":
                                            current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes);
                                            break;
                                        case "math":
                                            current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes);
                                            break;
                                        case "script":
                                            current = type.createElement("div");
                                            current.innerHTML = "<script>\x3c/script>";
                                            current = current.removeChild(current.firstChild);
                                            break;
                                        case "select":
                                            current = "string" === typeof newProps.is ? type.createElement("select", {
                                                is: newProps.is
                                            }) : type.createElement("select");
                                            newProps.multiple ? (current.multiple = true) : newProps.size && (current.size = newProps.size);
                                            break;
                                        default:
                                            current = "string" === typeof newProps.is ? type.createElement(renderLanes, {
                                                is: newProps.is
                                            }) : type.createElement(renderLanes);
                                    }
                            }
                            current[internalInstanceKey] = workInProgress;
                            current[internalPropsKey] = newProps;
                            a: for(type = workInProgress.child; null !== type;){
                                if (5 === type.tag || 6 === type.tag) current.appendChild(type.stateNode);
                                else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                                    type.child.return = type;
                                    type = type.child;
                                    continue;
                                }
                                if (type === workInProgress) break a;
                                for(; null === type.sibling;){
                                    if (null === type.return || type.return === workInProgress) break a;
                                    type = type.return;
                                }
                                type.sibling.return = type.return;
                                type = type.sibling;
                            }
                            workInProgress.stateNode = current;
                            a: switch((setInitialProperties(current, renderLanes, newProps), renderLanes)){
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    current = !!newProps.autoFocus;
                                    break a;
                                case "img":
                                    current = true;
                                    break a;
                                default:
                                    current = false;
                            }
                            current && markUpdate(workInProgress);
                        }
                    }
                    bubbleProperties(workInProgress);
                    workInProgress.flags &= -16777217;
                    return null;
                case 6:
                    if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);
                    else {
                        if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
                        current = rootInstanceStackCursor.current;
                        if (popHydrationState(workInProgress)) {
                            current = workInProgress.stateNode;
                            renderLanes = workInProgress.memoizedProps;
                            newProps = null;
                            type = hydrationParentFiber;
                            if (null !== type) switch(type.tag){
                                case 27:
                                case 5:
                                    newProps = type.memoizedProps;
                            }
                            current[internalInstanceKey] = workInProgress;
                            current = current.nodeValue === renderLanes || (null !== newProps && true === newProps.suppressHydrationWarning) || checkForUnmatchedText(current.nodeValue, renderLanes) ? true : false;
                            current || throwOnHydrationMismatch(workInProgress);
                        } else (current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps)), (current[internalInstanceKey] = workInProgress), (workInProgress.stateNode = current);
                    }
                    bubbleProperties(workInProgress);
                    return null;
                case 13:
                    newProps = workInProgress.memoizedState;
                    if (null === current || (null !== current.memoizedState && null !== current.memoizedState.dehydrated)) {
                        type = popHydrationState(workInProgress);
                        if (null !== newProps && null !== newProps.dehydrated) {
                            if (null === current) {
                                if (!type) throw Error(formatProdErrorMessage(318));
                                type = workInProgress.memoizedState;
                                type = null !== type ? type.dehydrated : null;
                                if (!type) throw Error(formatProdErrorMessage(317));
                                type[internalInstanceKey] = workInProgress;
                            } else resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), (workInProgress.flags |= 4);
                            bubbleProperties(workInProgress);
                            type = false;
                        } else (type = upgradeHydrationErrorsToRecoverable()), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), (type = true);
                        if (!type) {
                            if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
                            popSuspenseHandler(workInProgress);
                            return null;
                        }
                    }
                    popSuspenseHandler(workInProgress);
                    if (0 !== (workInProgress.flags & 128)) return (workInProgress.lanes = renderLanes), workInProgress;
                    renderLanes = null !== newProps;
                    current = null !== current && null !== current.memoizedState;
                    if (renderLanes) {
                        newProps = workInProgress.child;
                        type = null;
                        null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
                        var cache$127 = null;
                        null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
                        cache$127 !== type && (newProps.flags |= 2048);
                    }
                    renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);
                    scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
                    bubbleProperties(workInProgress);
                    return null;
                case 4:
                    return (popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null);
                case 10:
                    return (popProvider(workInProgress.type), bubbleProperties(workInProgress), null);
                case 19:
                    pop(suspenseStackCursor);
                    type = workInProgress.memoizedState;
                    if (null === type) return bubbleProperties(workInProgress), null;
                    newProps = 0 !== (workInProgress.flags & 128);
                    cache$127 = type.rendering;
                    if (null === cache$127) if (newProps) cutOffTailIfNeeded(type, false);
                    else {
                        if (0 !== workInProgressRootExitStatus || (null !== current && 0 !== (current.flags & 128))) for(current = workInProgress.child; null !== current;){
                            cache$127 = findFirstSuspended(current);
                            if (null !== cache$127) {
                                workInProgress.flags |= 128;
                                cutOffTailIfNeeded(type, false);
                                current = cache$127.updateQueue;
                                workInProgress.updateQueue = current;
                                scheduleRetryEffect(workInProgress, current);
                                workInProgress.subtreeFlags = 0;
                                current = renderLanes;
                                for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), (renderLanes = renderLanes.sibling);
                                push(suspenseStackCursor, (suspenseStackCursor.current & 1) | 2);
                                return workInProgress.child;
                            }
                            current = current.sibling;
                        }
                        null !== type.tail && now() > workInProgressRootRenderTargetTime && ((workInProgress.flags |= 128), (newProps = true), cutOffTailIfNeeded(type, false), (workInProgress.lanes = 4194304));
                    }
                    else {
                        if (!newProps) if (((current = findFirstSuspended(cache$127)), null !== current)) {
                            if (((workInProgress.flags |= 128), (newProps = true), (current = current.updateQueue), (workInProgress.updateQueue = current), scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)) return bubbleProperties(workInProgress), null;
                        } else 2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && ((workInProgress.flags |= 128), (newProps = true), cutOffTailIfNeeded(type, false), (workInProgress.lanes = 4194304));
                        type.isBackwards ? ((cache$127.sibling = workInProgress.child), (workInProgress.child = cache$127)) : ((current = type.last), null !== current ? (current.sibling = cache$127) : (workInProgress.child = cache$127), (type.last = cache$127));
                    }
                    if (null !== type.tail) return ((workInProgress = type.tail), (type.rendering = workInProgress), (type.tail = workInProgress.sibling), (type.renderingStartTime = now()), (workInProgress.sibling = null), (current = suspenseStackCursor.current), push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1), workInProgress);
                    bubbleProperties(workInProgress);
                    return null;
                case 22:
                case 23:
                    return (popSuspenseHandler(workInProgress), popHiddenContext(), (newProps = null !== workInProgress.memoizedState), null !== current ? (null !== current.memoizedState) !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), (renderLanes = workInProgress.updateQueue), null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), (renderLanes = null), null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), (newProps = null), null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache), null);
                case 24:
                    return ((renderLanes = null), null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress), null);
                case 25:
                    return null;
                case 30:
                    return null;
            }
            throw Error(formatProdErrorMessage(156, workInProgress.tag));
        }
        function unwindWork(current, workInProgress) {
            popTreeContext(workInProgress);
            switch(workInProgress.tag){
                case 1:
                    return ((current = workInProgress.flags), current & 65536 ? ((workInProgress.flags = (current & -65537) | 128), workInProgress) : null);
                case 3:
                    return (popProvider(CacheContext), popHostContainer(), (current = workInProgress.flags), 0 !== (current & 65536) && 0 === (current & 128) ? ((workInProgress.flags = (current & -65537) | 128), workInProgress) : null);
                case 26:
                case 27:
                case 5:
                    return popHostContext(workInProgress), null;
                case 13:
                    popSuspenseHandler(workInProgress);
                    current = workInProgress.memoizedState;
                    if (null !== current && null !== current.dehydrated) {
                        if (null === workInProgress.alternate) throw Error(formatProdErrorMessage(340));
                        resetHydrationState();
                    }
                    current = workInProgress.flags;
                    return current & 65536 ? ((workInProgress.flags = (current & -65537) | 128), workInProgress) : null;
                case 19:
                    return pop(suspenseStackCursor), null;
                case 4:
                    return popHostContainer(), null;
                case 10:
                    return popProvider(workInProgress.type), null;
                case 22:
                case 23:
                    return (popSuspenseHandler(workInProgress), popHiddenContext(), null !== current && pop(resumedCache), (current = workInProgress.flags), current & 65536 ? ((workInProgress.flags = (current & -65537) | 128), workInProgress) : null);
                case 24:
                    return popProvider(CacheContext), null;
                case 25:
                    return null;
                default:
                    return null;
            }
        }
        function unwindInterruptedWork(current, interruptedWork) {
            popTreeContext(interruptedWork);
            switch(interruptedWork.tag){
                case 3:
                    popProvider(CacheContext);
                    popHostContainer();
                    break;
                case 26:
                case 27:
                case 5:
                    popHostContext(interruptedWork);
                    break;
                case 4:
                    popHostContainer();
                    break;
                case 13:
                    popSuspenseHandler(interruptedWork);
                    break;
                case 19:
                    pop(suspenseStackCursor);
                    break;
                case 10:
                    popProvider(interruptedWork.type);
                    break;
                case 22:
                case 23:
                    popSuspenseHandler(interruptedWork);
                    popHiddenContext();
                    null !== current && pop(resumedCache);
                    break;
                case 24:
                    popProvider(CacheContext);
            }
        }
        function commitHookEffectListMount(flags, finishedWork) {
            try {
                var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
                if (null !== lastEffect) {
                    var firstEffect = lastEffect.next;
                    updateQueue = firstEffect;
                    do {
                        if ((updateQueue.tag & flags) === flags) {
                            lastEffect = void 0;
                            var create = updateQueue.create, inst = updateQueue.inst;
                            lastEffect = create();
                            inst.destroy = lastEffect;
                        }
                        updateQueue = updateQueue.next;
                    }while (updateQueue !== firstEffect);
                }
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
            try {
                var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
                if (null !== lastEffect) {
                    var firstEffect = lastEffect.next;
                    updateQueue = firstEffect;
                    do {
                        if ((updateQueue.tag & flags) === flags) {
                            var inst = updateQueue.inst, destroy = inst.destroy;
                            if (void 0 !== destroy) {
                                inst.destroy = void 0;
                                lastEffect = finishedWork;
                                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                                try {
                                    destroy_();
                                } catch (error) {
                                    captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
                                }
                            }
                        }
                        updateQueue = updateQueue.next;
                    }while (updateQueue !== firstEffect);
                }
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function commitClassCallbacks(finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            if (null !== updateQueue) {
                var instance = finishedWork.stateNode;
                try {
                    commitCallbacks(updateQueue, instance);
                } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
            }
        }
        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
            instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
            instance.state = current.memoizedState;
            try {
                instance.componentWillUnmount();
            } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
        function safelyAttachRef(current, nearestMountedAncestor) {
            try {
                var ref = current.ref;
                if (null !== ref) {
                    switch(current.tag){
                        case 26:
                        case 27:
                        case 5:
                            var instanceToUse = current.stateNode;
                            break;
                        case 30:
                            instanceToUse = current.stateNode;
                            break;
                        default:
                            instanceToUse = current.stateNode;
                    }
                    "function" === typeof ref ? (current.refCleanup = ref(instanceToUse)) : (ref.current = instanceToUse);
                }
            } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            }
        }
        function safelyDetachRef(current, nearestMountedAncestor) {
            var ref = current.ref, refCleanup = current.refCleanup;
            if (null !== ref) if ("function" === typeof refCleanup) try {
                refCleanup();
            } catch (error) {
                captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally{
                (current.refCleanup = null), (current = current.alternate), null != current && (current.refCleanup = null);
            }
            else if ("function" === typeof ref) try {
                ref(null);
            } catch (error$143) {
                captureCommitPhaseError(current, nearestMountedAncestor, error$143);
            }
            else ref.current = null;
        }
        function commitHostMount(finishedWork) {
            var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
            try {
                a: switch(type){
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        props.autoFocus && instance.focus();
                        break a;
                    case "img":
                        props.src ? (instance.src = props.src) : props.srcSet && (instance.srcset = props.srcSet);
                }
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
            try {
                var domElement = finishedWork.stateNode;
                updateProperties(domElement, finishedWork.type, oldProps, newProps);
                domElement[internalPropsKey] = newProps;
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function isHostParent(fiber) {
            return (5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || (27 === fiber.tag && isSingletonScope(fiber.type)) || 4 === fiber.tag);
        }
        function getHostSibling(fiber) {
            a: for(;;){
                for(; null === fiber.sibling;){
                    if (null === fiber.return || isHostParent(fiber.return)) return null;
                    fiber = fiber.return;
                }
                fiber.sibling.return = fiber.return;
                for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;){
                    if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
                    if (fiber.flags & 2) continue a;
                    if (null === fiber.child || 4 === fiber.tag) continue a;
                    else (fiber.child.return = fiber), (fiber = fiber.child);
                }
                if (!(fiber.flags & 2)) return fiber.stateNode;
            }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            if (5 === tag || 6 === tag) (node = node.stateNode), before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : ((before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent), before.appendChild(node), (parent = parent._reactRootContainer), (null !== parent && void 0 !== parent) || null !== before.onclick || (before.onclick = noop$1));
            else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && ((parent = node.stateNode), (before = null)), (node = node.child), null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), (node = node.sibling);
        }
        function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            if (5 === tag || 6 === tag) (node = node.stateNode), before ? parent.insertBefore(node, before) : parent.appendChild(node);
            else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), (node = node.child), null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
        }
        function commitHostSingletonAcquisition(finishedWork) {
            var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
            try {
                for(var type = finishedWork.type, attributes = singleton.attributes; attributes.length;)singleton.removeAttributeNode(attributes[0]);
                setInitialProperties(singleton, type, props);
                singleton[internalInstanceKey] = finishedWork;
                singleton[internalPropsKey] = props;
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
        function commitBeforeMutationEffects(root, firstChild) {
            root = root.containerInfo;
            eventsEnabled = _enabled;
            root = getActiveElementDeep(root);
            if (hasSelectionCapabilities(root)) {
                if ("selectionStart" in root) var JSCompiler_temp = {
                    start: root.selectionStart,
                    end: root.selectionEnd
                };
                else a: {
                    JSCompiler_temp = ((JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView) || window;
                    var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                    if (selection && 0 !== selection.rangeCount) {
                        JSCompiler_temp = selection.anchorNode;
                        var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                        selection = selection.focusOffset;
                        try {
                            JSCompiler_temp.nodeType, focusNode.nodeType;
                        } catch (e$20) {
                            JSCompiler_temp = null;
                            break a;
                        }
                        var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root, parentNode = null;
                        b: for(;;){
                            for(var next;;){
                                node !== JSCompiler_temp || (0 !== anchorOffset && 3 !== node.nodeType) || (start = length + anchorOffset);
                                node !== focusNode || (0 !== selection && 3 !== node.nodeType) || (end = length + selection);
                                3 === node.nodeType && (length += node.nodeValue.length);
                                if (null === (next = node.firstChild)) break;
                                parentNode = node;
                                node = next;
                            }
                            for(;;){
                                if (node === root) break b;
                                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                                if (null !== (next = node.nextSibling)) break;
                                node = parentNode;
                                parentNode = node.parentNode;
                            }
                            node = next;
                        }
                        JSCompiler_temp = -1 === start || -1 === end ? null : {
                            start: start,
                            end: end
                        };
                    } else JSCompiler_temp = null;
                }
                JSCompiler_temp = JSCompiler_temp || {
                    start: 0,
                    end: 0
                };
            } else JSCompiler_temp = null;
            selectionInformation = {
                focusedElem: root,
                selectionRange: JSCompiler_temp
            };
            _enabled = false;
            for(nextEffect = firstChild; null !== nextEffect;)if (((firstChild = nextEffect), (root = firstChild.child), 0 !== (firstChild.subtreeFlags & 1024) && null !== root)) (root.return = firstChild), (nextEffect = root);
            else for(; null !== nextEffect;){
                firstChild = nextEffect;
                focusNode = firstChild.alternate;
                root = firstChild.flags;
                switch(firstChild.tag){
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if (0 !== (root & 1024) && null !== focusNode) {
                            root = void 0;
                            JSCompiler_temp = firstChild;
                            anchorOffset = focusNode.memoizedProps;
                            focusNode = focusNode.memoizedState;
                            selection = JSCompiler_temp.stateNode;
                            try {
                                var resolvedPrevProps = resolveClassComponentProps(JSCompiler_temp.type, anchorOffset, JSCompiler_temp.elementType === JSCompiler_temp.type);
                                root = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode);
                                selection.__reactInternalSnapshotBeforeUpdate = root;
                            } catch (error) {
                                captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error);
                            }
                        }
                        break;
                    case 3:
                        if (0 !== (root & 1024)) if (((root = firstChild.stateNode.containerInfo), (JSCompiler_temp = root.nodeType), 9 === JSCompiler_temp)) clearContainerSparingly(root);
                        else if (1 === JSCompiler_temp) switch(root.nodeName){
                            case "HEAD":
                            case "HTML":
                            case "BODY":
                                clearContainerSparingly(root);
                                break;
                            default:
                                root.textContent = "";
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
                }
                root = firstChild.sibling;
                if (null !== root) {
                    root.return = firstChild.return;
                    nextEffect = root;
                    break;
                }
                nextEffect = firstChild.return;
            }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
            var flags = finishedWork.flags;
            switch(finishedWork.tag){
                case 0:
                case 11:
                case 15:
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    flags & 4 && commitHookEffectListMount(5, finishedWork);
                    break;
                case 1:
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    if (flags & 4) if (((finishedRoot = finishedWork.stateNode), null === current)) try {
                        finishedRoot.componentDidMount();
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                    else {
                        var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
                        current = current.memoizedState;
                        try {
                            finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
                        } catch (error$142) {
                            captureCommitPhaseError(finishedWork, finishedWork.return, error$142);
                        }
                    }
                    flags & 64 && commitClassCallbacks(finishedWork);
                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                    break;
                case 3:
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    if (flags & 64 && ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)) {
                        current = null;
                        if (null !== finishedWork.child) switch(finishedWork.child.tag){
                            case 27:
                            case 5:
                                current = finishedWork.child.stateNode;
                                break;
                            case 1:
                                current = finishedWork.child.stateNode;
                        }
                        try {
                            commitCallbacks(finishedRoot, current);
                        } catch (error) {
                            captureCommitPhaseError(finishedWork, finishedWork.return, error);
                        }
                    }
                    break;
                case 27:
                    null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
                case 26:
                case 5:
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    null === current && flags & 4 && commitHostMount(finishedWork);
                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
                    break;
                case 12:
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    break;
                case 13:
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                    flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                    flags & 64 && ((finishedRoot = finishedWork.memoizedState), null !== finishedRoot && ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot && ((finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork)), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
                    break;
                case 22:
                    flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
                    if (!flags) {
                        current = (null !== current && null !== current.memoizedState) || offscreenSubtreeWasHidden;
                        prevProps = offscreenSubtreeIsHidden;
                        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                        offscreenSubtreeIsHidden = flags;
                        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                        offscreenSubtreeIsHidden = prevProps;
                        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                    }
                    break;
                case 30:
                    break;
                default:
                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            }
        }
        function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            null !== alternate && ((fiber.alternate = null), detachFiberAfterEffects(alternate));
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            5 === fiber.tag && ((alternate = fiber.stateNode), null !== alternate && detachDeletedInstance(alternate));
            fiber.stateNode = null;
            fiber.return = null;
            fiber.dependencies = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.stateNode = null;
            fiber.updateQueue = null;
        }
        var hostParent = null, hostParentIsContainer = false;
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), (parent = parent.sibling);
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
                injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {}
            switch(deletedFiber.tag){
                case 26:
                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && ((deletedFiber = deletedFiber.stateNode), deletedFiber.parentNode.removeChild(deletedFiber));
                    break;
                case 27:
                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
                    isSingletonScope(deletedFiber.type) && ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = false));
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    releaseSingletonInstance(deletedFiber.stateNode);
                    hostParent = prevHostParent;
                    hostParentIsContainer = prevHostParentIsContainer;
                    break;
                case 5:
                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
                case 6:
                    prevHostParent = hostParent;
                    prevHostParentIsContainer = hostParentIsContainer;
                    hostParent = null;
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    hostParent = prevHostParent;
                    hostParentIsContainer = prevHostParentIsContainer;
                    if (null !== hostParent) if (hostParentIsContainer) try {
                        (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                    } catch (error) {
                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                    }
                    else try {
                        hostParent.removeChild(deletedFiber.stateNode);
                    } catch (error) {
                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
                    }
                    break;
                case 18:
                    null !== hostParent && (hostParentIsContainer ? ((finishedRoot = hostParent), clearSuspenseBoundary(9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
                    break;
                case 4:
                    prevHostParent = hostParent;
                    prevHostParentIsContainer = hostParentIsContainer;
                    hostParent = deletedFiber.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    hostParent = prevHostParent;
                    hostParentIsContainer = prevHostParentIsContainer;
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
                    offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    break;
                case 1:
                    offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), (prevHostParent = deletedFiber.stateNode), "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    break;
                case 21:
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    break;
                case 22:
                    offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                    offscreenSubtreeWasHidden = prevHostParent;
                    break;
                default:
                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            if (null === finishedWork.memoizedState && ((finishedRoot = finishedWork.alternate), null !== finishedRoot && ((finishedRoot = finishedRoot.memoizedState), null !== finishedRoot && ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))) try {
                retryIfBlockedOn(finishedRoot);
            } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
            switch(finishedWork.tag){
                case 13:
                case 19:
                    var retryCache = finishedWork.stateNode;
                    null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
                    return retryCache;
                case 22:
                    return ((finishedWork = finishedWork.stateNode), (retryCache = finishedWork._retryCache), null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache);
                default:
                    throw Error(formatProdErrorMessage(435, finishedWork.tag));
            }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
            var retryCache = getRetryCache(finishedWork);
            wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
            });
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
            var deletions = parentFiber.deletions;
            if (null !== deletions) for(var i = 0; i < deletions.length; i++){
                var childToDelete = deletions[i], root = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
                a: for(; null !== parent;){
                    switch(parent.tag){
                        case 27:
                            if (isSingletonScope(parent.type)) {
                                hostParent = parent.stateNode;
                                hostParentIsContainer = false;
                                break a;
                            }
                            break;
                        case 5:
                            hostParent = parent.stateNode;
                            hostParentIsContainer = false;
                            break a;
                        case 3:
                        case 4:
                            hostParent = parent.stateNode.containerInfo;
                            hostParentIsContainer = true;
                            break a;
                    }
                    parent = parent.return;
                }
                if (null === hostParent) throw Error(formatProdErrorMessage(160));
                commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
                hostParent = null;
                hostParentIsContainer = false;
                root = childToDelete.alternate;
                null !== root && (root.return = null);
                childToDelete.return = null;
            }
            if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), (parentFiber = parentFiber.sibling);
        }
        var currentHoistableRoot = null;
        function commitMutationEffectsOnFiber(finishedWork, root) {
            var current = finishedWork.alternate, flags = finishedWork.flags;
            switch(finishedWork.tag){
                case 0:
                case 11:
                case 14:
                case 15:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
                    break;
                case 1:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                    flags & 64 && offscreenSubtreeIsHidden && ((finishedWork = finishedWork.updateQueue), null !== finishedWork && ((flags = finishedWork.callbacks), null !== flags && ((current = finishedWork.shared.hiddenCallbacks), (finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags)))));
                    break;
                case 26:
                    var hoistableRoot = currentHoistableRoot;
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                    if (flags & 4) {
                        var currentResource = null !== current ? current.memoizedState : null;
                        flags = finishedWork.memoizedState;
                        if (null === current) if (null === flags) if (null === finishedWork.stateNode) {
                            a: {
                                flags = finishedWork.type;
                                current = finishedWork.memoizedProps;
                                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                                b: switch(flags){
                                    case "title":
                                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop")) (currentResource = hoistableRoot.createElement(flags)), hoistableRoot.head.insertBefore(currentResource, hoistableRoot.querySelector("head > title"));
                                        setInitialProperties(currentResource, flags, current);
                                        currentResource[internalInstanceKey] = finishedWork;
                                        markNodeAsHoistable(currentResource);
                                        flags = currentResource;
                                        break a;
                                    case "link":
                                        var maybeNodes = getHydratableHoistableCache("link", "href", hoistableRoot).get(flags + (current.href || ""));
                                        if (maybeNodes) for(var i = 0; i < maybeNodes.length; i++)if (((currentResource = maybeNodes[i]), currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin))) {
                                            maybeNodes.splice(i, 1);
                                            break b;
                                        }
                                        currentResource = hoistableRoot.createElement(flags);
                                        setInitialProperties(currentResource, flags, current);
                                        hoistableRoot.head.appendChild(currentResource);
                                        break;
                                    case "meta":
                                        if ((maybeNodes = getHydratableHoistableCache("meta", "content", hoistableRoot).get(flags + (current.content || "")))) for(i = 0; i < maybeNodes.length; i++)if (((currentResource = maybeNodes[i]), currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet))) {
                                            maybeNodes.splice(i, 1);
                                            break b;
                                        }
                                        currentResource = hoistableRoot.createElement(flags);
                                        setInitialProperties(currentResource, flags, current);
                                        hoistableRoot.head.appendChild(currentResource);
                                        break;
                                    default:
                                        throw Error(formatProdErrorMessage(468, flags));
                                }
                                currentResource[internalInstanceKey] = finishedWork;
                                markNodeAsHoistable(currentResource);
                                flags = currentResource;
                            }
                            finishedWork.stateNode = flags;
                        } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
                        else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
                        else currentResource !== flags ? (null === currentResource ? null !== current.stateNode && ((current = current.stateNode), current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
                    }
                    break;
                case 27:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                    null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
                    break;
                case 5:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
                    if (finishedWork.flags & 32) {
                        hoistableRoot = finishedWork.stateNode;
                        try {
                            setTextContent(hoistableRoot, "");
                        } catch (error) {
                            captureCommitPhaseError(finishedWork, finishedWork.return, error);
                        }
                    }
                    flags & 4 && null != finishedWork.stateNode && ((hoistableRoot = finishedWork.memoizedProps), commitHostUpdate(finishedWork, hoistableRoot, null !== current ? current.memoizedProps : hoistableRoot));
                    flags & 1024 && (needsFormReset = true);
                    break;
                case 6:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    if (flags & 4) {
                        if (null === finishedWork.stateNode) throw Error(formatProdErrorMessage(162));
                        flags = finishedWork.memoizedProps;
                        current = finishedWork.stateNode;
                        try {
                            current.nodeValue = flags;
                        } catch (error) {
                            captureCommitPhaseError(finishedWork, finishedWork.return, error);
                        }
                    }
                    break;
                case 3:
                    tagCaches = null;
                    hoistableRoot = currentHoistableRoot;
                    currentHoistableRoot = getHoistableRoot(root.containerInfo);
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    currentHoistableRoot = hoistableRoot;
                    commitReconciliationEffects(finishedWork);
                    if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
                        retryIfBlockedOn(root.containerInfo);
                    } catch (error) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error);
                    }
                    needsFormReset && ((needsFormReset = false), recursivelyResetForms(finishedWork));
                    break;
                case 4:
                    flags = currentHoistableRoot;
                    currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    currentHoistableRoot = flags;
                    break;
                case 12:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    break;
                case 13:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    finishedWork.child.flags & 8192 && (null !== finishedWork.memoizedState) !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
                    flags & 4 && ((flags = finishedWork.updateQueue), null !== flags && ((finishedWork.updateQueue = null), attachSuspenseRetryListeners(finishedWork, flags)));
                    break;
                case 22:
                    hoistableRoot = null !== finishedWork.memoizedState;
                    var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                    commitReconciliationEffects(finishedWork);
                    if (flags & 8192) a: for(root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root = finishedWork;;){
                        if (5 === root.tag || 26 === root.tag) {
                            if (null === current) {
                                wasHidden = current = root;
                                try {
                                    if (((currentResource = wasHidden.stateNode), hoistableRoot)) (maybeNodes = currentResource.style), "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : (maybeNodes.display = "none");
                                    else {
                                        i = wasHidden.stateNode;
                                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                                    }
                                } catch (error) {
                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                                }
                            }
                        } else if (6 === root.tag) {
                            if (null === current) {
                                wasHidden = root;
                                try {
                                    wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                                } catch (error) {
                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                                }
                            }
                        } else if (((22 !== root.tag && 23 !== root.tag) || null === root.memoizedState || root === finishedWork) && null !== root.child) {
                            root.child.return = root;
                            root = root.child;
                            continue;
                        }
                        if (root === finishedWork) break a;
                        for(; null === root.sibling;){
                            if (null === root.return || root.return === finishedWork) break a;
                            current === root && (current = null);
                            root = root.return;
                        }
                        current === root && (current = null);
                        root.sibling.return = root.return;
                        root = root.sibling;
                    }
                    flags & 4 && ((flags = finishedWork.updateQueue), null !== flags && ((current = flags.retryQueue), null !== current && ((flags.retryQueue = null), attachSuspenseRetryListeners(finishedWork, current))));
                    break;
                case 19:
                    recursivelyTraverseMutationEffects(root, finishedWork);
                    commitReconciliationEffects(finishedWork);
                    flags & 4 && ((flags = finishedWork.updateQueue), null !== flags && ((finishedWork.updateQueue = null), attachSuspenseRetryListeners(finishedWork, flags)));
                    break;
                case 30:
                    break;
                case 21:
                    break;
                default:
                    recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
            }
        }
        function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & 2) {
                try {
                    for(var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;){
                        if (isHostParent(parentFiber)) {
                            hostParentFiber = parentFiber;
                            break;
                        }
                        parentFiber = parentFiber.return;
                    }
                    if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
                    switch(hostParentFiber.tag){
                        case 27:
                            var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                            insertOrAppendPlacementNode(finishedWork, before, parent);
                            break;
                        case 5:
                            var parent$144 = hostParentFiber.stateNode;
                            hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), (hostParentFiber.flags &= -33));
                            var before$145 = getHostSibling(finishedWork);
                            insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
                            break;
                        case 3:
                        case 4:
                            var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
                            insertOrAppendPlacementNodeIntoContainer(finishedWork, before$147, parent$146);
                            break;
                        default:
                            throw Error(formatProdErrorMessage(161));
                    }
                } catch (error) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
                finishedWork.flags &= -3;
            }
            flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
            if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){
                var fiber = parentFiber;
                recursivelyResetForms(fiber);
                5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
                parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseLayoutEffects(root, parentFiber) {
            if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), (parentFiber = parentFiber.sibling);
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
            for(parentFiber = parentFiber.child; null !== parentFiber;){
                var finishedWork = parentFiber;
                switch(finishedWork.tag){
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
                        recursivelyTraverseDisappearLayoutEffects(finishedWork);
                        break;
                    case 1:
                        safelyDetachRef(finishedWork, finishedWork.return);
                        var instance = finishedWork.stateNode;
                        "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
                        recursivelyTraverseDisappearLayoutEffects(finishedWork);
                        break;
                    case 27:
                        releaseSingletonInstance(finishedWork.stateNode);
                    case 26:
                    case 5:
                        safelyDetachRef(finishedWork, finishedWork.return);
                        recursivelyTraverseDisappearLayoutEffects(finishedWork);
                        break;
                    case 22:
                        null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
                        break;
                    case 30:
                        recursivelyTraverseDisappearLayoutEffects(finishedWork);
                        break;
                    default:
                        recursivelyTraverseDisappearLayoutEffects(finishedWork);
                }
                parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
            includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
            for(parentFiber = parentFiber.child; null !== parentFiber;){
                var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
                switch(finishedWork.tag){
                    case 0:
                    case 11:
                    case 15:
                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                        commitHookEffectListMount(4, finishedWork);
                        break;
                    case 1:
                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                        current = finishedWork;
                        finishedRoot = current.stateNode;
                        if ("function" === typeof finishedRoot.componentDidMount) try {
                            finishedRoot.componentDidMount();
                        } catch (error) {
                            captureCommitPhaseError(current, current.return, error);
                        }
                        current = finishedWork;
                        finishedRoot = current.updateQueue;
                        if (null !== finishedRoot) {
                            var instance = current.stateNode;
                            try {
                                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                                if (null !== hiddenCallbacks) for(finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)callCallback(hiddenCallbacks[finishedRoot], instance);
                            } catch (error) {
                                captureCommitPhaseError(current, current.return, error);
                            }
                        }
                        includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
                        safelyAttachRef(finishedWork, finishedWork.return);
                        break;
                    case 27:
                        commitHostSingletonAcquisition(finishedWork);
                    case 26:
                    case 5:
                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                        includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
                        safelyAttachRef(finishedWork, finishedWork.return);
                        break;
                    case 12:
                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                        break;
                    case 13:
                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                        includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                        break;
                    case 22:
                        null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                        safelyAttachRef(finishedWork, finishedWork.return);
                        break;
                    case 30:
                        break;
                    default:
                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
                }
                parentFiber = parentFiber.sibling;
            }
        }
        function commitOffscreenPassiveMountEffects(current, finishedWork) {
            var previousCache = null;
            null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
            current = null;
            null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
            current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current, finishedWork) {
            current = null;
            null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
            finishedWork = finishedWork.memoizedState.cache;
            finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
        }
        function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
            if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), (parentFiber = parentFiber.sibling);
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            var flags = finishedWork.flags;
            switch(finishedWork.tag){
                case 0:
                case 11:
                case 15:
                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                    flags & 2048 && commitHookEffectListMount(9, finishedWork);
                    break;
                case 1:
                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                    break;
                case 3:
                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                    flags & 2048 && ((finishedRoot = null), null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), (finishedWork = finishedWork.memoizedState.cache), finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
                    break;
                case 12:
                    if (flags & 2048) {
                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                        finishedRoot = finishedWork.stateNode;
                        try {
                            var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                            "function" === typeof onPostCommit && onPostCommit(id, null === finishedWork.alternate ? "mount" : "update", finishedRoot.passiveEffectDuration, -0);
                        } catch (error) {
                            captureCommitPhaseError(finishedWork, finishedWork.return, error);
                        }
                    } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                    break;
                case 13:
                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                    break;
                case 23:
                    break;
                case 22:
                    _finishedWork$memoize2 = finishedWork.stateNode;
                    id = finishedWork.alternate;
                    null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : ((_finishedWork$memoize2._visibility |= 2), recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
                    flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
                    break;
                case 24:
                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                    break;
                default:
                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
            }
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
            includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
            for(parentFiber = parentFiber.child; null !== parentFiber;){
                var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
                switch(finishedWork.tag){
                    case 0:
                    case 11:
                    case 15:
                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
                        commitHookEffectListMount(8, finishedWork);
                        break;
                    case 23:
                        break;
                    case 22:
                        var instance = finishedWork.stateNode;
                        null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : ((instance._visibility |= 2), recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
                        includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
                        break;
                    case 24:
                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
                        includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                        break;
                    default:
                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
                }
                parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
            if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){
                var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
                switch(finishedWork.tag){
                    case 22:
                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                        flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
                        break;
                    case 24:
                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                        break;
                    default:
                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                }
                parentFiber = parentFiber.sibling;
            }
        }
        var suspenseyCommitFlag = 8192;
        function recursivelyAccumulateSuspenseyCommit(parentFiber) {
            if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), (parentFiber = parentFiber.sibling);
        }
        function accumulateSuspenseyCommitOnFiber(fiber) {
            switch(fiber.tag){
                case 26:
                    recursivelyAccumulateSuspenseyCommit(fiber);
                    fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
                    break;
                case 5:
                    recursivelyAccumulateSuspenseyCommit(fiber);
                    break;
                case 3:
                case 4:
                    var previousHoistableRoot = currentHoistableRoot;
                    currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
                    recursivelyAccumulateSuspenseyCommit(fiber);
                    currentHoistableRoot = previousHoistableRoot;
                    break;
                case 22:
                    null === fiber.memoizedState && ((previousHoistableRoot = fiber.alternate), null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? ((previousHoistableRoot = suspenseyCommitFlag), (suspenseyCommitFlag = 16777216), recursivelyAccumulateSuspenseyCommit(fiber), (suspenseyCommitFlag = previousHoistableRoot)) : recursivelyAccumulateSuspenseyCommit(fiber));
                    break;
                default:
                    recursivelyAccumulateSuspenseyCommit(fiber);
            }
        }
        function detachAlternateSiblings(parentFiber) {
            var previousFiber = parentFiber.alternate;
            if (null !== previousFiber && ((parentFiber = previousFiber.child), null !== parentFiber)) {
                previousFiber.child = null;
                do (previousFiber = parentFiber.sibling), (parentFiber.sibling = null), (parentFiber = previousFiber);
                while (null !== parentFiber);
            }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
            var deletions = parentFiber.deletions;
            if (0 !== (parentFiber.flags & 16)) {
                if (null !== deletions) for(var i = 0; i < deletions.length; i++){
                    var childToDelete = deletions[i];
                    nextEffect = childToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
                }
                detachAlternateSiblings(parentFiber);
            }
            if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), (parentFiber = parentFiber.sibling);
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
            switch(finishedWork.tag){
                case 0:
                case 11:
                case 15:
                    recursivelyTraversePassiveUnmountEffects(finishedWork);
                    finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
                    break;
                case 3:
                    recursivelyTraversePassiveUnmountEffects(finishedWork);
                    break;
                case 12:
                    recursivelyTraversePassiveUnmountEffects(finishedWork);
                    break;
                case 22:
                    var instance = finishedWork.stateNode;
                    null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? ((instance._visibility &= -3), recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
                    break;
                default:
                    recursivelyTraversePassiveUnmountEffects(finishedWork);
            }
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
            var deletions = parentFiber.deletions;
            if (0 !== (parentFiber.flags & 16)) {
                if (null !== deletions) for(var i = 0; i < deletions.length; i++){
                    var childToDelete = deletions[i];
                    nextEffect = childToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
                }
                detachAlternateSiblings(parentFiber);
            }
            for(parentFiber = parentFiber.child; null !== parentFiber;){
                deletions = parentFiber;
                switch(deletions.tag){
                    case 0:
                    case 11:
                    case 15:
                        commitHookEffectListUnmount(8, deletions, deletions.return);
                        recursivelyTraverseDisconnectPassiveEffects(deletions);
                        break;
                    case 22:
                        i = deletions.stateNode;
                        i._visibility & 2 && ((i._visibility &= -3), recursivelyTraverseDisconnectPassiveEffects(deletions));
                        break;
                    default:
                        recursivelyTraverseDisconnectPassiveEffects(deletions);
                }
                parentFiber = parentFiber.sibling;
            }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            for(; null !== nextEffect;){
                var fiber = nextEffect;
                switch(fiber.tag){
                    case 0:
                    case 11:
                    case 15:
                        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
                        break;
                    case 23:
                    case 22:
                        if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                            var cache = fiber.memoizedState.cachePool.pool;
                            null != cache && cache.refCount++;
                        }
                        break;
                    case 24:
                        releaseCache(fiber.memoizedState.cache);
                }
                cache = fiber.child;
                if (null !== cache) (cache.return = fiber), (nextEffect = cache);
                else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){
                    cache = nextEffect;
                    var sibling = cache.sibling, returnFiber = cache.return;
                    detachFiberAfterEffects(cache);
                    if (cache === fiber) {
                        nextEffect = null;
                        break a;
                    }
                    if (null !== sibling) {
                        sibling.return = returnFiber;
                        nextEffect = sibling;
                        break a;
                    }
                    nextEffect = returnFiber;
                }
            }
        }
        var DefaultAsyncDispatcher = {
            getCacheForType: function(resourceType) {
                var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
                void 0 === cacheForType && ((cacheForType = resourceType()), cache.data.set(resourceType, cacheForType));
                return cacheForType;
            }
        }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
        function requestUpdateLane() {
            if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
            if (null !== ReactSharedInternals.T) {
                var actionScopeLane = currentEntangledLane;
                return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
            }
            return resolveUpdatePriority();
        }
        function requestDeferredLane() {
            0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
            var suspenseHandler = suspenseHandlerStackCursor.current;
            null !== suspenseHandler && (suspenseHandler.flags |= 32);
            return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root, fiber, lane) {
            if ((root === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason)) || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
            markRootUpdated$1(root, lane);
            if (0 === (executionContext & 2) || root !== workInProgressRoot) root === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root);
        }
        function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
            if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
            var shouldTimeSlice = (!forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes)) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
            do {
                if (0 === exitStatus) {
                    workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
                    break;
                } else {
                    forceSync = root$jscomp$0.current.alternate;
                    if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                        exitStatus = renderRootSync(root$jscomp$0, lanes, false);
                        renderWasConcurrent = false;
                        continue;
                    }
                    if (2 === exitStatus) {
                        renderWasConcurrent = lanes;
                        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent) var JSCompiler_inline_result = 0;
                        else (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913), (JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0);
                        if (0 !== JSCompiler_inline_result) {
                            lanes = JSCompiler_inline_result;
                            a: {
                                var root = root$jscomp$0;
                                exitStatus = workInProgressRootConcurrentErrors;
                                var wasRootDehydrated = root.current.memoizedState.isDehydrated;
                                wasRootDehydrated && (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
                                JSCompiler_inline_result = renderRootSync(root, JSCompiler_inline_result, false);
                                if (2 !== JSCompiler_inline_result) {
                                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                                        root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                                        workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                                        exitStatus = 4;
                                        break a;
                                    }
                                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                                    workInProgressRootRecoverableErrors = exitStatus;
                                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? (workInProgressRootRecoverableErrors = renderWasConcurrent) : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, renderWasConcurrent));
                                }
                                exitStatus = JSCompiler_inline_result;
                            }
                            renderWasConcurrent = false;
                            if (2 !== exitStatus) continue;
                        }
                    }
                    if (1 === exitStatus) {
                        prepareFreshStack(root$jscomp$0, 0);
                        markRootSuspended(root$jscomp$0, lanes, 0, true);
                        break;
                    }
                    a: {
                        shouldTimeSlice = root$jscomp$0;
                        renderWasConcurrent = exitStatus;
                        switch(renderWasConcurrent){
                            case 0:
                            case 1:
                                throw Error(formatProdErrorMessage(345));
                            case 4:
                                if ((lanes & 4194048) !== lanes) break;
                            case 6:
                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                                break a;
                            case 2:
                                workInProgressRootRecoverableErrors = null;
                                break;
                            case 3:
                            case 5:
                                break;
                            default:
                                throw Error(formatProdErrorMessage(329));
                        }
                        if ((lanes & 62914560) === lanes && ((exitStatus = globalMostRecentFallbackTime + 300 - now()), 10 < exitStatus)) {
                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                            if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 2, -0, 0), exitStatus);
                            break a;
                        }
                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 0, -0, 0);
                    }
                }
                break;
            }while (1);
            ensureRootIsScheduled(root$jscomp$0);
        }
        function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
            root.timeoutHandle = -1;
            suspendedCommitReason = finishedWork.subtreeFlags;
            if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) if (((suspendedState = {
                stylesheets: null,
                count: 0,
                unsuspend: noop
            }), accumulateSuspenseyCommitOnFiber(finishedWork), (suspendedCommitReason = waitForCommitToBeReady()), null !== suspendedCommitReason)) {
                root.cancelPendingCommit = suspendedCommitReason(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, 1, completedRenderStartTime, completedRenderEndTime));
                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
                return;
            }
            commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
            for(var node = finishedWork;;){
                var tag = node.tag;
                if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && ((tag = node.updateQueue), null !== tag && ((tag = tag.stores), null !== tag))) for(var i = 0; i < tag.length; i++){
                    var check = tag[i], getSnapshot = check.getSnapshot;
                    check = check.value;
                    try {
                        if (!objectIs(getSnapshot(), check)) return !1;
                    } catch (error) {
                        return false;
                    }
                }
                tag = node.child;
                if (node.subtreeFlags & 16384 && null !== tag) (tag.return = node), (node = tag);
                else {
                    if (node === finishedWork) break;
                    for(; null === node.sibling;){
                        if (null === node.return || node.return === finishedWork) return true;
                        node = node.return;
                    }
                    node.sibling.return = node.return;
                    node = node.sibling;
                }
            }
            return true;
        }
        function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
            suspendedLanes &= ~workInProgressRootPingedLanes;
            suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
            root.suspendedLanes |= suspendedLanes;
            root.pingedLanes &= ~suspendedLanes;
            didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
            didAttemptEntireTree = root.expirationTimes;
            for(var lanes = suspendedLanes; 0 < lanes;){
                var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
                didAttemptEntireTree[index$4] = -1;
                lanes &= ~lane;
            }
            0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
            return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
        }
        function resetWorkInProgressStack() {
            if (null !== workInProgress) {
                if (0 === workInProgressSuspendedReason) var interruptedWork = workInProgress.return;
                else (interruptedWork = workInProgress), (lastContextDependency = currentlyRenderingFiber$1 = null), resetHooksOnUnwind(interruptedWork), (thenableState = null), (thenableIndexCounter = 0), (interruptedWork = workInProgress);
                for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), (interruptedWork = interruptedWork.return);
                workInProgress = null;
            }
        }
        function prepareFreshStack(root, lanes) {
            var timeoutHandle = root.timeoutHandle;
            -1 !== timeoutHandle && ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
            timeoutHandle = root.cancelPendingCommit;
            null !== timeoutHandle && ((root.cancelPendingCommit = null), timeoutHandle());
            resetWorkInProgressStack();
            workInProgressRoot = root;
            workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
            workInProgressRootRenderLanes = lanes;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            workInProgressRootDidSkipSuspendedSiblings = false;
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
            workInProgressRootDidAttachPingListener = false;
            workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
            workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
            workInProgressRootDidIncludeRecursiveRenderUpdate = false;
            0 !== (lanes & 8) && (lanes |= lanes & 32);
            var allEntangledLanes = root.entangledLanes;
            if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){
                var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
                lanes |= root[index$2];
                allEntangledLanes &= ~lane;
            }
            entangledRenderLanes = lanes;
            finishQueueingConcurrentUpdates();
            return timeoutHandle;
        }
        function handleThrow(root, thrownValue) {
            currentlyRenderingFiber = null;
            ReactSharedInternals.H = ContextOnlyDispatcher;
            thrownValue === SuspenseException || thrownValue === SuspenseActionException ? ((thrownValue = getSuspendedThenable()), (workInProgressSuspendedReason = 3)) : thrownValue === SuspenseyCommitException ? ((thrownValue = getSuspendedThenable()), (workInProgressSuspendedReason = 4)) : (workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1);
            workInProgressThrownValue = thrownValue;
            null === workInProgress && ((workInProgressRootExitStatus = 1), logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current)));
        }
        function pushDispatcher() {
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = ContextOnlyDispatcher;
            return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
            var prevAsyncDispatcher = ReactSharedInternals.A;
            ReactSharedInternals.A = DefaultAsyncDispatcher;
            return prevAsyncDispatcher;
        }
        function renderDidSuspendDelayIfPossible() {
            workInProgressRootExitStatus = 4;
            workInProgressRootDidSkipSuspendedSiblings || ((workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current) || (workInProgressRootIsPrerendering = true);
            (0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
        }
        function renderRootSync(root, lanes, shouldYieldForPrerendering) {
            var prevExecutionContext = executionContext;
            executionContext |= 2;
            var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) (workInProgressTransitions = null), prepareFreshStack(root, lanes);
            lanes = false;
            var exitStatus = workInProgressRootExitStatus;
            a: do try {
                if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
                    var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                    switch(workInProgressSuspendedReason){
                        case 8:
                            resetWorkInProgressStack();
                            exitStatus = 6;
                            break a;
                        case 3:
                        case 2:
                        case 9:
                        case 6:
                            null === suspenseHandlerStackCursor.current && (lanes = !0);
                            var reason = workInProgressSuspendedReason;
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                            if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                                exitStatus = 0;
                                break a;
                            }
                            break;
                        default:
                            (reason = workInProgressSuspendedReason), (workInProgressSuspendedReason = 0), (workInProgressThrownValue = null), throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
                    }
                }
                workLoopSync();
                exitStatus = workInProgressRootExitStatus;
                break;
            } catch (thrownValue$167) {
                handleThrow(root, thrownValue$167);
            }
            while (1);
            lanes && root.shellSuspendCounter++;
            lastContextDependency = currentlyRenderingFiber$1 = null;
            executionContext = prevExecutionContext;
            ReactSharedInternals.H = prevDispatcher;
            ReactSharedInternals.A = prevAsyncDispatcher;
            null === workInProgress && ((workInProgressRoot = null), (workInProgressRootRenderLanes = 0), finishQueueingConcurrentUpdates());
            return exitStatus;
        }
        function workLoopSync() {
            for(; null !== workInProgress;)performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= 2;
            var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
            workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes ? ((workInProgressTransitions = null), (workInProgressRootRenderTargetTime = now() + 500), prepareFreshStack(root, lanes)) : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes));
            a: do try {
                if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
                    lanes = workInProgress;
                    var thrownValue = workInProgressThrownValue;
                    b: switch(workInProgressSuspendedReason){
                        case 1:
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
                            break;
                        case 2:
                        case 9:
                            if (isThenableResolved(thrownValue)) {
                                workInProgressSuspendedReason = 0;
                                workInProgressThrownValue = null;
                                replaySuspendedUnitOfWork(lanes);
                                break;
                            }
                            lanes = function() {
                                (2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason) || workInProgressRoot !== root || (workInProgressSuspendedReason = 7);
                                ensureRootIsScheduled(root);
                            };
                            thrownValue.then(lanes, lanes);
                            break a;
                        case 3:
                            workInProgressSuspendedReason = 7;
                            break a;
                        case 4:
                            workInProgressSuspendedReason = 5;
                            break a;
                        case 7:
                            isThenableResolved(thrownValue) ? ((workInProgressSuspendedReason = 0), (workInProgressThrownValue = null), replaySuspendedUnitOfWork(lanes)) : ((workInProgressSuspendedReason = 0), (workInProgressThrownValue = null), throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
                            break;
                        case 5:
                            var resource = null;
                            switch(workInProgress.tag){
                                case 26:
                                    resource = workInProgress.memoizedState;
                                case 5:
                                case 27:
                                    var hostFiber = workInProgress;
                                    if (resource ? preloadResource(resource) : 1) {
                                        workInProgressSuspendedReason = 0;
                                        workInProgressThrownValue = null;
                                        var sibling = hostFiber.sibling;
                                        if (null !== sibling) workInProgress = sibling;
                                        else {
                                            var returnFiber = hostFiber.return;
                                            null !== returnFiber ? ((workInProgress = returnFiber), completeUnitOfWork(returnFiber)) : (workInProgress = null);
                                        }
                                        break b;
                                    }
                            }
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
                            break;
                        case 6:
                            workInProgressSuspendedReason = 0;
                            workInProgressThrownValue = null;
                            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
                            break;
                        case 8:
                            resetWorkInProgressStack();
                            workInProgressRootExitStatus = 6;
                            break a;
                        default:
                            throw Error(formatProdErrorMessage(462));
                    }
                }
                workLoopConcurrentByScheduler();
                break;
            } catch (thrownValue$169) {
                handleThrow(root, thrownValue$169);
            }
            while (1);
            lastContextDependency = currentlyRenderingFiber$1 = null;
            ReactSharedInternals.H = prevDispatcher;
            ReactSharedInternals.A = prevAsyncDispatcher;
            executionContext = prevExecutionContext;
            if (null !== workInProgress) return 0;
            workInProgressRoot = null;
            workInProgressRootRenderLanes = 0;
            finishQueueingConcurrentUpdates();
            return workInProgressRootExitStatus;
        }
        function workLoopConcurrentByScheduler() {
            for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
            var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
            var next = unitOfWork;
            var current = next.alternate;
            switch(next.tag){
                case 15:
                case 0:
                    next = replayFunctionComponent(current, next, next.pendingProps, next.type, void 0, workInProgressRootRenderLanes);
                    break;
                case 11:
                    next = replayFunctionComponent(current, next, next.pendingProps, next.type.render, next.ref, workInProgressRootRenderLanes);
                    break;
                case 5:
                    resetHooksOnUnwind(next);
                default:
                    unwindInterruptedWork(current, next), (next = workInProgress = resetWorkInProgress(next, entangledRenderLanes)), (next = beginWork(current, next, entangledRenderLanes));
            }
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
        }
        function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
            lastContextDependency = currentlyRenderingFiber$1 = null;
            resetHooksOnUnwind(unitOfWork);
            thenableState = null;
            thenableIndexCounter = 0;
            var returnFiber = unitOfWork.return;
            try {
                if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
                    workInProgressRootExitStatus = 1;
                    logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
                    workInProgress = null;
                    return;
                }
            } catch (error) {
                if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
                workInProgressRootExitStatus = 1;
                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
                workInProgress = null;
                return;
            }
            if (unitOfWork.flags & 32768) {
                if (isHydrating || 1 === suspendedReason) root = true;
                else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = false;
                else if (((workInProgressRootDidSkipSuspendedSiblings = root = true), 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)) (suspendedReason = suspenseHandlerStackCursor.current), null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
                unwindUnitOfWork(unitOfWork, root);
            } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
                if (0 !== (completedWork.flags & 32768)) {
                    unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
                    return;
                }
                unitOfWork = completedWork.return;
                var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
                if (null !== next) {
                    workInProgress = next;
                    return;
                }
                completedWork = completedWork.sibling;
                if (null !== completedWork) {
                    workInProgress = completedWork;
                    return;
                }
                workInProgress = completedWork = unitOfWork;
            }while (null !== completedWork);
            0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
            do {
                var next = unwindWork(unitOfWork.alternate, unitOfWork);
                if (null !== next) {
                    next.flags &= 32767;
                    workInProgress = next;
                    return;
                }
                next = unitOfWork.return;
                null !== next && ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
                if (!skipSiblings && ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)) {
                    workInProgress = unitOfWork;
                    return;
                }
                workInProgress = unitOfWork = next;
            }while (null !== unitOfWork);
            workInProgressRootExitStatus = 6;
            workInProgress = null;
        }
        function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
            root.cancelPendingCommit = null;
            do flushPendingEffects();
            while (0 !== pendingEffectsStatus);
            if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
            if (null !== finishedWork) {
                if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
                didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
                didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
                markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
                root === workInProgressRoot && ((workInProgress = workInProgressRoot = null), (workInProgressRootRenderLanes = 0));
                pendingFinishedWork = finishedWork;
                pendingEffectsRoot = root;
                pendingEffectsLanes = lanes;
                pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
                pendingPassiveTransitions = transitions;
                pendingRecoverableErrors = recoverableErrors;
                0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? ((root.callbackNode = null), (root.callbackPriority = 0), scheduleCallback$1(NormalPriority$1, function() {
                    flushPassiveEffects();
                    return null;
                })) : ((root.callbackNode = null), (root.callbackPriority = 0));
                recoverableErrors = 0 !== (finishedWork.flags & 13878);
                if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
                    recoverableErrors = ReactSharedInternals.T;
                    ReactSharedInternals.T = null;
                    transitions = ReactDOMSharedInternals.p;
                    ReactDOMSharedInternals.p = 2;
                    spawnedLane = executionContext;
                    executionContext |= 4;
                    try {
                        commitBeforeMutationEffects(root, finishedWork, lanes);
                    } finally{
                        (executionContext = spawnedLane), (ReactDOMSharedInternals.p = transitions), (ReactSharedInternals.T = recoverableErrors);
                    }
                }
                pendingEffectsStatus = 1;
                flushMutationEffects();
                flushLayoutEffects();
                flushSpawnedWork();
            }
        }
        function flushMutationEffects() {
            if (1 === pendingEffectsStatus) {
                pendingEffectsStatus = 0;
                var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
                if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
                    rootMutationHasEffect = ReactSharedInternals.T;
                    ReactSharedInternals.T = null;
                    var previousPriority = ReactDOMSharedInternals.p;
                    ReactDOMSharedInternals.p = 2;
                    var prevExecutionContext = executionContext;
                    executionContext |= 4;
                    try {
                        commitMutationEffectsOnFiber(finishedWork, root);
                        var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
                        if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
                            if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                                var start = priorSelectionRange.start, end = priorSelectionRange.end;
                                void 0 === end && (end = start);
                                if ("selectionStart" in priorFocusedElem) (priorFocusedElem.selectionStart = start), (priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length));
                                else {
                                    var doc = priorFocusedElem.ownerDocument || document, win = (doc && doc.defaultView) || window;
                                    if (win.getSelection) {
                                        var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                                        !selection.extend && start$jscomp$0 > end$jscomp$0 && ((curFocusedElem = end$jscomp$0), (end$jscomp$0 = start$jscomp$0), (start$jscomp$0 = curFocusedElem));
                                        var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0), endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
                                        if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                                            var range = doc.createRange();
                                            range.setStart(startMarker.node, startMarker.offset);
                                            selection.removeAllRanges();
                                            start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                                        }
                                    }
                                }
                            }
                            doc = [];
                            for(selection = priorFocusedElem; (selection = selection.parentNode);)1 === selection.nodeType && doc.push({
                                element: selection,
                                left: selection.scrollLeft,
                                top: selection.scrollTop
                            });
                            "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                            for(priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++){
                                var info = doc[priorFocusedElem];
                                info.element.scrollLeft = info.left;
                                info.element.scrollTop = info.top;
                            }
                        }
                        _enabled = !!eventsEnabled;
                        selectionInformation = eventsEnabled = null;
                    } finally{
                        (executionContext = prevExecutionContext), (ReactDOMSharedInternals.p = previousPriority), (ReactSharedInternals.T = rootMutationHasEffect);
                    }
                }
                root.current = finishedWork;
                pendingEffectsStatus = 2;
            }
        }
        function flushLayoutEffects() {
            if (2 === pendingEffectsStatus) {
                pendingEffectsStatus = 0;
                var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
                if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
                    rootHasLayoutEffect = ReactSharedInternals.T;
                    ReactSharedInternals.T = null;
                    var previousPriority = ReactDOMSharedInternals.p;
                    ReactDOMSharedInternals.p = 2;
                    var prevExecutionContext = executionContext;
                    executionContext |= 4;
                    try {
                        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
                    } finally{
                        (executionContext = prevExecutionContext), (ReactDOMSharedInternals.p = previousPriority), (ReactSharedInternals.T = rootHasLayoutEffect);
                    }
                }
                pendingEffectsStatus = 3;
            }
        }
        function flushSpawnedWork() {
            if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
                pendingEffectsStatus = 0;
                requestPaint();
                var root = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
                0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (pendingEffectsStatus = 5) : ((pendingEffectsStatus = 0), (pendingFinishedWork = pendingEffectsRoot = null), releaseRootPooledCache(root, root.pendingLanes));
                var remainingLanes = root.pendingLanes;
                0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
                lanesToEventPriority(lanes);
                finishedWork = finishedWork.stateNode;
                if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
                    injectedHook.onCommitFiberRoot(rendererID, finishedWork, void 0, 128 === (finishedWork.current.flags & 128));
                } catch (err) {}
                if (null !== recoverableErrors) {
                    finishedWork = ReactSharedInternals.T;
                    remainingLanes = ReactDOMSharedInternals.p;
                    ReactDOMSharedInternals.p = 2;
                    ReactSharedInternals.T = null;
                    try {
                        for(var onRecoverableError = root.onRecoverableError, i = 0; i < recoverableErrors.length; i++){
                            var recoverableError = recoverableErrors[i];
                            onRecoverableError(recoverableError.value, {
                                componentStack: recoverableError.stack
                            });
                        }
                    } finally{
                        (ReactSharedInternals.T = finishedWork), (ReactDOMSharedInternals.p = remainingLanes);
                    }
                }
                0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
                ensureRootIsScheduled(root);
                remainingLanes = root.pendingLanes;
                0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)) : (nestedUpdateCount = 0);
                flushSyncWorkAcrossRoots_impl(0);
            }
        }
        function releaseRootPooledCache(root, remainingLanes) {
            0 === (root.pooledCacheLanes &= remainingLanes) && ((remainingLanes = root.pooledCache), null != remainingLanes && ((root.pooledCache = null), releaseCache(remainingLanes)));
        }
        function flushPendingEffects(wasDelayedCommit) {
            flushMutationEffects();
            flushLayoutEffects();
            flushSpawnedWork();
            return flushPassiveEffects();
        }
        function flushPassiveEffects() {
            if (5 !== pendingEffectsStatus) return false;
            var root = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
            pendingEffectsRemainingLanes = 0;
            var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
            try {
                ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
                ReactSharedInternals.T = null;
                renderPriority = pendingPassiveTransitions;
                pendingPassiveTransitions = null;
                var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
                pendingEffectsStatus = 0;
                pendingFinishedWork = pendingEffectsRoot = null;
                pendingEffectsLanes = 0;
                if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
                var prevExecutionContext = executionContext;
                executionContext |= 4;
                commitPassiveUnmountOnFiber(root$jscomp$0.current);
                commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, renderPriority);
                executionContext = prevExecutionContext;
                flushSyncWorkAcrossRoots_impl(0, !1);
                if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
                    injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
                } catch (err) {}
                return !0;
            } finally{
                (ReactDOMSharedInternals.p = previousPriority), (ReactSharedInternals.T = prevTransition), releaseRootPooledCache(root, remainingLanes);
            }
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
            sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
            rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
            null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
            if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
            else for(; null !== nearestMountedAncestor;){
                if (3 === nearestMountedAncestor.tag) {
                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
                    break;
                } else if (1 === nearestMountedAncestor.tag) {
                    var instance = nearestMountedAncestor.stateNode;
                    if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || ("function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance)))) {
                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                        error = createClassErrorUpdate(2);
                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                        break;
                    }
                }
                nearestMountedAncestor = nearestMountedAncestor.return;
            }
        }
        function attachPingListener(root, wakeable, lanes) {
            var pingCache = root.pingCache;
            if (null === pingCache) {
                pingCache = root.pingCache = new PossiblyWeakMap();
                var threadIDs = new Set();
                pingCache.set(wakeable, threadIDs);
            } else (threadIDs = pingCache.get(wakeable)), void 0 === threadIDs && ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
            threadIDs.has(lanes) || ((workInProgressRootDidAttachPingListener = true), threadIDs.add(lanes), (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)), wakeable.then(root, root));
        }
        function pingSuspendedRoot(root, wakeable, pingedLanes) {
            var pingCache = root.pingCache;
            null !== pingCache && pingCache.delete(wakeable);
            root.pingedLanes |= root.suspendedLanes & pingedLanes;
            root.warmLanes &= ~pingedLanes;
            workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || (3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime) ? 0 === (executionContext & 2) && prepareFreshStack(root, 0) : (workInProgressRootPingedLanes |= pingedLanes), workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
            ensureRootIsScheduled(root);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
            0 === retryLane && (retryLane = claimNextRetryLane());
            boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = 0;
            switch(boundaryFiber.tag){
                case 13:
                    var retryCache = boundaryFiber.stateNode;
                    var suspenseState = boundaryFiber.memoizedState;
                    null !== suspenseState && (retryLane = suspenseState.retryLane);
                    break;
                case 19:
                    retryCache = boundaryFiber.stateNode;
                    break;
                case 22:
                    retryCache = boundaryFiber.stateNode._retryCache;
                    break;
                default:
                    throw Error(formatProdErrorMessage(314));
            }
            null !== retryCache && retryCache.delete(wakeable);
            retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function scheduleCallback$1(priorityLevel, callback) {
            return scheduleCallback$3(priorityLevel, callback);
        }
        var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
        function ensureRootIsScheduled(root) {
            root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? (firstScheduledRoot = lastScheduledRoot = root) : (lastScheduledRoot = lastScheduledRoot.next = root));
            mightHavePendingSyncWork = true;
            didScheduleMicrotask || ((didScheduleMicrotask = true), scheduleImmediateRootScheduleTask());
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
            if (!isFlushingWork && mightHavePendingSyncWork) {
                isFlushingWork = true;
                do {
                    var didPerformSomeWork = false;
                    for(var root$174 = firstScheduledRoot; null !== root$174;){
                        if (0 !== syncTransitionLanes) {
                            var pendingLanes = root$174.pendingLanes;
                            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                            else {
                                var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
                                JSCompiler_inline_result = (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
                                JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                                JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? (JSCompiler_inline_result & 201326741) | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                            }
                            0 !== JSCompiler_inline_result && ((didPerformSomeWork = true), performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
                        } else (JSCompiler_inline_result = workInProgressRootRenderLanes), (JSCompiler_inline_result = getNextLanes(root$174, root$174 === workInProgressRoot ? JSCompiler_inline_result : 0, null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle)), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || ((didPerformSomeWork = true), performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
                        root$174 = root$174.next;
                    }
                }while (didPerformSomeWork);
                isFlushingWork = false;
            }
        }
        function processRootScheduleInImmediateTask() {
            processRootScheduleInMicrotask();
        }
        function processRootScheduleInMicrotask() {
            mightHavePendingSyncWork = didScheduleMicrotask = false;
            var syncTransitionLanes = 0;
            0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), (currentEventTransitionLane = 0));
            for(var currentTime = now(), prev = null, root = firstScheduledRoot; null !== root;){
                var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
                if (0 === nextLanes) (root.next = null), null === prev ? (firstScheduledRoot = next) : (prev.next = next), null === next && (lastScheduledRoot = prev);
                else if (((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))) mightHavePendingSyncWork = true;
                root = next;
            }
            flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
        }
        function scheduleTaskForRootDuringMicrotask(root, currentTime) {
            for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){
                var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
                if (-1 === expirationTime) {
                    if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
                } else expirationTime <= currentTime && (root.expiredLanes |= lane);
                lanes &= ~lane;
            }
            currentTime = workInProgressRoot;
            suspendedLanes = workInProgressRootRenderLanes;
            suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, null !== root.cancelPendingCommit || -1 !== root.timeoutHandle);
            pingedLanes = root.callbackNode;
            if (0 === suspendedLanes || (root === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason)) || null !== root.cancelPendingCommit) return (null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), (root.callbackNode = null), (root.callbackPriority = 0));
            if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
                currentTime = suspendedLanes & -suspendedLanes;
                if (currentTime === root.callbackPriority) return currentTime;
                null !== pingedLanes && cancelCallback$1(pingedLanes);
                switch(lanesToEventPriority(suspendedLanes)){
                    case 2:
                    case 8:
                        suspendedLanes = UserBlockingPriority;
                        break;
                    case 32:
                        suspendedLanes = NormalPriority$1;
                        break;
                    case 268435456:
                        suspendedLanes = IdlePriority;
                        break;
                    default:
                        suspendedLanes = NormalPriority$1;
                }
                pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
                suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
                root.callbackPriority = currentTime;
                root.callbackNode = suspendedLanes;
                return currentTime;
            }
            null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
            root.callbackPriority = 2;
            root.callbackNode = null;
            return 2;
        }
        function performWorkOnRootViaSchedulerTask(root, didTimeout) {
            if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) return (root.callbackNode = null), (root.callbackPriority = 0), null;
            var originalCallbackNode = root.callbackNode;
            if (flushPendingEffects() && root.callbackNode !== originalCallbackNode) return null;
            var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
            workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root.cancelPendingCommit || -1 !== root.timeoutHandle);
            if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
            performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
            scheduleTaskForRootDuringMicrotask(root, now());
            return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
        }
        function performSyncWorkOnRoot(root, lanes) {
            if (flushPendingEffects()) return null;
            performWorkOnRoot(root, lanes, true);
        }
        function scheduleImmediateRootScheduleTask() {
            scheduleMicrotask(function() {
                0 !== (executionContext & 6) ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
            });
        }
        function requestTransitionLane() {
            0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
            return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
            return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
            var temp = submitter.ownerDocument.createElement("input");
            temp.name = submitter.name;
            temp.value = submitter.value;
            form.id && temp.setAttribute("form", form.id);
            submitter.parentNode.insertBefore(temp, submitter);
            form = new FormData(form);
            temp.parentNode.removeChild(temp);
            return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
            if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
                var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action), submitter = nativeEvent.submitter;
                submitter && ((domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction")), null !== domEventName && ((action = domEventName), (submitter = null)));
                var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                    event: event,
                    listeners: [
                        {
                            instance: null,
                            listener: function() {
                                if (nativeEvent.defaultPrevented) {
                                    if (0 !== currentEventTransitionLane) {
                                        var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                                        startHostTransition(maybeTargetInst, {
                                            pending: true,
                                            data: formData,
                                            method: nativeEventTarget.method,
                                            action: action
                                        }, null, formData);
                                    }
                                } else "function" === typeof action && (event.preventDefault(), (formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget)), startHostTransition(maybeTargetInst, {
                                    pending: true,
                                    data: formData,
                                    method: nativeEventTarget.method,
                                    action: action
                                }, action, formData));
                            },
                            currentTarget: nativeEventTarget
                        }
                    ]
                });
            }
        }
        for(var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++){
            var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
            registerSimpleEvent(domEventName$jscomp$inline_1530, "on" + capitalizedEvent$jscomp$inline_1531);
        }
        registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
        registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
        registerSimpleEvent(ANIMATION_START, "onAnimationStart");
        registerSimpleEvent("dblclick", "onDoubleClick");
        registerSimpleEvent("focusin", "onFocus");
        registerSimpleEvent("focusout", "onBlur");
        registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
        registerSimpleEvent(TRANSITION_START, "onTransitionStart");
        registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
        registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        registerDirectEvent("onMouseEnter", [
            "mouseout",
            "mouseover"
        ]);
        registerDirectEvent("onMouseLeave", [
            "mouseout",
            "mouseover"
        ]);
        registerDirectEvent("onPointerEnter", [
            "pointerout",
            "pointerover"
        ]);
        registerDirectEvent("onPointerLeave", [
            "pointerout",
            "pointerover"
        ]);
        registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
        registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
        registerTwoPhaseEvent("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste"
        ]);
        registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
        registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
        registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            eventSystemFlags = 0 !== (eventSystemFlags & 4);
            for(var i = 0; i < dispatchQueue.length; i++){
                var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
                _dispatchQueue$i = _dispatchQueue$i.listeners;
                a: {
                    var previousInstance = void 0;
                    if (eventSystemFlags) for(var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--){
                        var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                        _dispatchListeners$i = _dispatchListeners$i.listener;
                        if (instance !== previousInstance && event.isPropagationStopped()) break a;
                        previousInstance = _dispatchListeners$i;
                        event.currentTarget = currentTarget;
                        try {
                            previousInstance(event);
                        } catch (error) {
                            reportGlobalError(error);
                        }
                        event.currentTarget = null;
                        previousInstance = instance;
                    }
                    else for(i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++){
                        _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                        instance = _dispatchListeners$i.instance;
                        currentTarget = _dispatchListeners$i.currentTarget;
                        _dispatchListeners$i = _dispatchListeners$i.listener;
                        if (instance !== previousInstance && event.isPropagationStopped()) break a;
                        previousInstance = _dispatchListeners$i;
                        event.currentTarget = currentTarget;
                        try {
                            previousInstance(event);
                        } catch (error) {
                            reportGlobalError(error);
                        }
                        event.currentTarget = null;
                        previousInstance = instance;
                    }
                }
            }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
            var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
            void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set());
            var listenerSetKey = domEventName + "__bubble";
            JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            var eventSystemFlags = 0;
            isCapturePhaseListener && (eventSystemFlags |= 4);
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
                rootContainerElement[listeningMarker] = true;
                allNativeEvents.forEach(function(domEventName) {
                    "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
                });
                var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
                null === ownerDocument || ownerDocument[listeningMarker] || ((ownerDocument[listeningMarker] = true), listenToNativeEvent("selectionchange", false, ownerDocument));
            }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
            switch(getEventPriority(domEventName)){
                case 2:
                    var listenerWrapper = dispatchDiscreteEvent;
                    break;
                case 8:
                    listenerWrapper = dispatchContinuousEvent;
                    break;
                default:
                    listenerWrapper = dispatchEvent;
            }
            eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
            listenerWrapper = void 0;
            !passiveBrowserEventsSupported || ("touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName) || (listenerWrapper = true);
            isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
                capture: true,
                passive: listenerWrapper
            }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
                passive: listenerWrapper
            }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
            var ancestorInst = targetInst$jscomp$0;
            if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for(;;){
                if (null === targetInst$jscomp$0) return;
                var nodeTag = targetInst$jscomp$0.tag;
                if (3 === nodeTag || 4 === nodeTag) {
                    var container = targetInst$jscomp$0.stateNode.containerInfo;
                    if (container === targetContainer) break;
                    if (4 === nodeTag) for(nodeTag = targetInst$jscomp$0.return; null !== nodeTag;){
                        var grandTag = nodeTag.tag;
                        if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer) return;
                        nodeTag = nodeTag.return;
                    }
                    for(; null !== container;){
                        nodeTag = getClosestInstanceFromNode(container);
                        if (null === nodeTag) return;
                        grandTag = nodeTag.tag;
                        if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                            targetInst$jscomp$0 = ancestorInst = nodeTag;
                            continue a;
                        }
                        container = container.parentNode;
                    }
                }
                targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
            batchedUpdates$1(function() {
                var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
                a: {
                    var reactName = topLevelEventsToReactNames.get(domEventName);
                    if (void 0 !== reactName) {
                        var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                        switch(domEventName){
                            case "keypress":
                                if (0 === getEventCharCode(nativeEvent)) break a;
                            case "keydown":
                            case "keyup":
                                SyntheticEventCtor = SyntheticKeyboardEvent;
                                break;
                            case "focusin":
                                reactEventType = "focus";
                                SyntheticEventCtor = SyntheticFocusEvent;
                                break;
                            case "focusout":
                                reactEventType = "blur";
                                SyntheticEventCtor = SyntheticFocusEvent;
                                break;
                            case "beforeblur":
                            case "afterblur":
                                SyntheticEventCtor = SyntheticFocusEvent;
                                break;
                            case "click":
                                if (2 === nativeEvent.button) break a;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                SyntheticEventCtor = SyntheticMouseEvent;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                SyntheticEventCtor = SyntheticDragEvent;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                SyntheticEventCtor = SyntheticTouchEvent;
                                break;
                            case ANIMATION_END:
                            case ANIMATION_ITERATION:
                            case ANIMATION_START:
                                SyntheticEventCtor = SyntheticAnimationEvent;
                                break;
                            case TRANSITION_END:
                                SyntheticEventCtor = SyntheticTransitionEvent;
                                break;
                            case "scroll":
                            case "scrollend":
                                SyntheticEventCtor = SyntheticUIEvent;
                                break;
                            case "wheel":
                                SyntheticEventCtor = SyntheticWheelEvent;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                SyntheticEventCtor = SyntheticClipboardEvent;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                SyntheticEventCtor = SyntheticPointerEvent;
                                break;
                            case "toggle":
                            case "beforetoggle":
                                SyntheticEventCtor = SyntheticToggleEvent;
                        }
                        var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                        inCapturePhase = [];
                        for(var instance = targetInst, lastHostComponent; null !== instance;){
                            var _instance = instance;
                            lastHostComponent = _instance.stateNode;
                            _instance = _instance.tag;
                            (5 !== _instance && 26 !== _instance && 27 !== _instance) || null === lastHostComponent || null === reactEventName || ((_instance = getListener(instance, reactEventName)), null != _instance && inCapturePhase.push(createDispatchListener(instance, _instance, lastHostComponent)));
                            if (accumulateTargetOnly) break;
                            instance = instance.return;
                        }
                        0 < inCapturePhase.length && ((reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget)), dispatchQueue.push({
                            event: reactName,
                            listeners: inCapturePhase
                        }));
                    }
                }
                if (0 === (eventSystemFlags & 7)) {
                    a: {
                        reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                        SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                        if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
                        if (SyntheticEventCtor || reactName) {
                            reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                            if (SyntheticEventCtor) {
                                if (((reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement), (SyntheticEventCtor = targetInst), (reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null), null !== reactEventType && ((accumulateTargetOnly = getNearestMountedFiber(reactEventType)), (inCapturePhase = reactEventType.tag), reactEventType !== accumulateTargetOnly || (5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)))) reactEventType = null;
                            } else (SyntheticEventCtor = null), (reactEventType = targetInst);
                            if (SyntheticEventCtor !== reactEventType) {
                                inCapturePhase = SyntheticMouseEvent;
                                _instance = "onMouseLeave";
                                reactEventName = "onMouseEnter";
                                instance = "mouse";
                                if ("pointerout" === domEventName || "pointerover" === domEventName) (inCapturePhase = SyntheticPointerEvent), (_instance = "onPointerLeave"), (reactEventName = "onPointerEnter"), (instance = "pointer");
                                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                                reactName = new inCapturePhase(_instance, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
                                reactName.target = accumulateTargetOnly;
                                reactName.relatedTarget = lastHostComponent;
                                _instance = null;
                                getClosestInstanceFromNode(nativeEventTarget) === targetInst && ((inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget)), (inCapturePhase.target = lastHostComponent), (inCapturePhase.relatedTarget = accumulateTargetOnly), (_instance = inCapturePhase));
                                accumulateTargetOnly = _instance;
                                if (SyntheticEventCtor && reactEventType) b: {
                                    inCapturePhase = SyntheticEventCtor;
                                    reactEventName = reactEventType;
                                    instance = 0;
                                    for(lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))instance++;
                                    lastHostComponent = 0;
                                    for(_instance = reactEventName; _instance; _instance = getParent(_instance))lastHostComponent++;
                                    for(; 0 < instance - lastHostComponent;)(inCapturePhase = getParent(inCapturePhase)), instance--;
                                    for(; 0 < lastHostComponent - instance;)(reactEventName = getParent(reactEventName)), lastHostComponent--;
                                    for(; instance--;){
                                        if (inCapturePhase === reactEventName || (null !== reactEventName && inCapturePhase === reactEventName.alternate)) break b;
                                        inCapturePhase = getParent(inCapturePhase);
                                        reactEventName = getParent(reactEventName);
                                    }
                                    inCapturePhase = null;
                                }
                                else inCapturePhase = null;
                                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);
                                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);
                            }
                        }
                    }
                    a: {
                        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                        SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                        if ("select" === SyntheticEventCtor || ("input" === SyntheticEventCtor && "file" === reactName.type)) var getTargetInstFunc = getTargetInstForChangeEvent;
                        else if (isTextInputElement(reactName)) if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                        else {
                            getTargetInstFunc = getTargetInstForInputEventPolyfill;
                            var handleEventFunc = handleEventsForInputEventPolyfill;
                        }
                        else (SyntheticEventCtor = reactName.nodeName), !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || ("checkbox" !== reactName.type && "radio" !== reactName.type) ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : (getTargetInstFunc = getTargetInstForClickEvent);
                        if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                            createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
                            break a;
                        }
                        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                        "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
                    }
                    handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
                    switch(domEventName){
                        case "focusin":
                            if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) (activeElement = handleEventFunc), (activeElementInst = targetInst), (lastSelection = null);
                            break;
                        case "focusout":
                            lastSelection = activeElementInst = activeElement = null;
                            break;
                        case "mousedown":
                            mouseDown = !0;
                            break;
                        case "contextmenu":
                        case "mouseup":
                        case "dragend":
                            mouseDown = !1;
                            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                            break;
                        case "selectionchange":
                            if (skipSelectionChangeEvent) break;
                        case "keydown":
                        case "keyup":
                            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                    }
                    var fallbackData;
                    if (canUseCompositionEvent) b: {
                        switch(domEventName){
                            case "compositionstart":
                                var eventType = "onCompositionStart";
                                break b;
                            case "compositionend":
                                eventType = "onCompositionEnd";
                                break b;
                            case "compositionupdate":
                                eventType = "onCompositionUpdate";
                                break b;
                        }
                        eventType = void 0;
                    }
                    else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
                    eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : ((root = nativeEventTarget), (startText = "value" in root ? root.value : root.textContent), (isComposing = !0))), (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)), 0 < handleEventFunc.length && ((eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget)), dispatchQueue.push({
                        event: eventType,
                        listeners: handleEventFunc
                    }), fallbackData ? (eventType.data = fallbackData) : ((fallbackData = getDataFromCustomEvent(nativeEvent)), null !== fallbackData && (eventType.data = fallbackData))));
                    if ((fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))) (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")), 0 < eventType.length && ((handleEventFunc = new SyntheticCompositionEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget)), dispatchQueue.push({
                        event: handleEventFunc,
                        listeners: eventType
                    }), (handleEventFunc.data = fallbackData));
                    extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
                }
                processDispatchQueue(dispatchQueue, eventSystemFlags);
            });
        }
        function createDispatchListener(instance, listener, currentTarget) {
            return {
                instance: instance,
                listener: listener,
                currentTarget: currentTarget
            };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
            for(var captureName = reactName + "Capture", listeners = []; null !== targetFiber;){
                var _instance2 = targetFiber, stateNode = _instance2.stateNode;
                _instance2 = _instance2.tag;
                (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) || null === stateNode || ((_instance2 = getListener(targetFiber, captureName)), null != _instance2 && listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)), (_instance2 = getListener(targetFiber, reactName)), null != _instance2 && listeners.push(createDispatchListener(targetFiber, _instance2, stateNode)));
                if (3 === targetFiber.tag) return listeners;
                targetFiber = targetFiber.return;
            }
            return [];
        }
        function getParent(inst) {
            if (null === inst) return null;
            do inst = inst.return;
            while (inst && 5 !== inst.tag && 27 !== inst.tag);
            return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            for(var registrationName = event._reactName, listeners = []; null !== target && target !== common;){
                var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
                _instance3 = _instance3.tag;
                if (null !== alternate && alternate === common) break;
                (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) || null === stateNode || ((alternate = stateNode), inCapturePhase ? ((stateNode = getListener(target, registrationName)), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || ((stateNode = getListener(target, registrationName)), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
                target = target.return;
            }
            0 !== listeners.length && dispatchQueue.push({
                event: event,
                listeners: listeners
            });
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
            return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
            clientText = normalizeMarkupForTextOrAttribute(clientText);
            return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function noop$1() {}
        function setProp(domElement, tag, key, value, props, prevValue) {
            switch(key){
                case "children":
                    "string" === typeof value ? "body" === tag || ("textarea" === tag && "" === value) || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
                    break;
                case "className":
                    setValueForKnownAttribute(domElement, "class", value);
                    break;
                case "tabIndex":
                    setValueForKnownAttribute(domElement, "tabindex", value);
                    break;
                case "dir":
                case "role":
                case "viewBox":
                case "width":
                case "height":
                    setValueForKnownAttribute(domElement, key, value);
                    break;
                case "style":
                    setValueForStyles(domElement, value, prevValue);
                    break;
                case "data":
                    if ("object" !== tag) {
                        setValueForKnownAttribute(domElement, "data", value);
                        break;
                    }
                case "src":
                case "href":
                    if ("" === value && ("a" !== tag || "href" !== key)) {
                        domElement.removeAttribute(key);
                        break;
                    }
                    if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                        domElement.removeAttribute(key);
                        break;
                    }
                    value = sanitizeURL("" + value);
                    domElement.setAttribute(key, value);
                    break;
                case "action":
                case "formAction":
                    if ("function" === typeof value) {
                        domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                        break;
                    } else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
                    if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                        domElement.removeAttribute(key);
                        break;
                    }
                    value = sanitizeURL("" + value);
                    domElement.setAttribute(key, value);
                    break;
                case "onClick":
                    null != value && (domElement.onclick = noop$1);
                    break;
                case "onScroll":
                    null != value && listenToNonDelegatedEvent("scroll", domElement);
                    break;
                case "onScrollEnd":
                    null != value && listenToNonDelegatedEvent("scrollend", domElement);
                    break;
                case "dangerouslySetInnerHTML":
                    if (null != value) {
                        if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
                        key = value.__html;
                        if (null != key) {
                            if (null != props.children) throw Error(formatProdErrorMessage(60));
                            domElement.innerHTML = key;
                        }
                    }
                    break;
                case "multiple":
                    domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
                    break;
                case "muted":
                    domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                    break;
                case "autoFocus":
                    break;
                case "xlinkHref":
                    if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                        domElement.removeAttribute("xlink:href");
                        break;
                    }
                    key = sanitizeURL("" + value);
                    domElement.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", key);
                    break;
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                    null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
                    break;
                case "inert":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                    value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
                    break;
                case "capture":
                case "download":
                    true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
                    break;
                case "cols":
                case "rows":
                case "size":
                case "span":
                    null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
                    break;
                case "rowSpan":
                case "start":
                    null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
                    break;
                case "popover":
                    listenToNonDelegatedEvent("beforetoggle", domElement);
                    listenToNonDelegatedEvent("toggle", domElement);
                    setValueForAttribute(domElement, "popover", value);
                    break;
                case "xlinkActuate":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:actuate", value);
                    break;
                case "xlinkArcrole":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:arcrole", value);
                    break;
                case "xlinkRole":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:role", value);
                    break;
                case "xlinkShow":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:show", value);
                    break;
                case "xlinkTitle":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:title", value);
                    break;
                case "xlinkType":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:type", value);
                    break;
                case "xmlBase":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:base", value);
                    break;
                case "xmlLang":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:lang", value);
                    break;
                case "xmlSpace":
                    setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:space", value);
                    break;
                case "is":
                    setValueForAttribute(domElement, "is", value);
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    if (!(2 < key.length) || ("o" !== key[0] && "O" !== key[0]) || ("n" !== key[1] && "N" !== key[1])) (key = aliases.get(key) || key), setValueForAttribute(domElement, key, value);
            }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
            switch(key){
                case "style":
                    setValueForStyles(domElement, value, prevValue);
                    break;
                case "dangerouslySetInnerHTML":
                    if (null != value) {
                        if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
                        key = value.__html;
                        if (null != key) {
                            if (null != props.children) throw Error(formatProdErrorMessage(60));
                            domElement.innerHTML = key;
                        }
                    }
                    break;
                case "children":
                    "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
                    break;
                case "onScroll":
                    null != value && listenToNonDelegatedEvent("scroll", domElement);
                    break;
                case "onScrollEnd":
                    null != value && listenToNonDelegatedEvent("scrollend", domElement);
                    break;
                case "onClick":
                    null != value && (domElement.onclick = noop$1);
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "innerHTML":
                case "ref":
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    if (!registrationNameDependencies.hasOwnProperty(key)) a: {
                        if ("o" === key[0] && "n" === key[1] && ((props = key.endsWith("Capture")), (tag = key.slice(2, props ? key.length - 7 : void 0)), (prevValue = domElement[internalPropsKey] || null), (prevValue = null != prevValue ? prevValue[key] : null), "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                            "function" !== typeof prevValue && null !== prevValue && (key in domElement ? (domElement[key] = null) : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                            domElement.addEventListener(tag, value, props);
                            break a;
                        }
                        key in domElement ? (domElement[key] = value) : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                    }
            }
        }
        function setInitialProperties(domElement, tag, props) {
            switch(tag){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "img":
                    listenToNonDelegatedEvent("error", domElement);
                    listenToNonDelegatedEvent("load", domElement);
                    var hasSrc = false, hasSrcSet = false, propKey;
                    for(propKey in props)if (props.hasOwnProperty(propKey)) {
                        var propValue = props[propKey];
                        if (null != propValue) switch(propKey){
                            case "src":
                                hasSrc = true;
                                break;
                            case "srcSet":
                                hasSrcSet = true;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                throw Error(formatProdErrorMessage(137, tag));
                            default:
                                setProp(domElement, tag, propKey, propValue, props, null);
                        }
                    }
                    hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
                    hasSrc && setProp(domElement, tag, "src", props.src, props, null);
                    return;
                case "input":
                    listenToNonDelegatedEvent("invalid", domElement);
                    var defaultValue = (propKey = propValue = hasSrcSet = null), checked = null, defaultChecked = null;
                    for(hasSrc in props)if (props.hasOwnProperty(hasSrc)) {
                        var propValue$188 = props[hasSrc];
                        if (null != propValue$188) switch(hasSrc){
                            case "name":
                                hasSrcSet = propValue$188;
                                break;
                            case "type":
                                propValue = propValue$188;
                                break;
                            case "checked":
                                checked = propValue$188;
                                break;
                            case "defaultChecked":
                                defaultChecked = propValue$188;
                                break;
                            case "value":
                                propKey = propValue$188;
                                break;
                            case "defaultValue":
                                defaultValue = propValue$188;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (null != propValue$188) throw Error(formatProdErrorMessage(137, tag));
                                break;
                            default:
                                setProp(domElement, tag, hasSrc, propValue$188, props, null);
                        }
                    }
                    initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, false);
                    track(domElement);
                    return;
                case "select":
                    listenToNonDelegatedEvent("invalid", domElement);
                    hasSrc = propValue = propKey = null;
                    for(hasSrcSet in props)if (props.hasOwnProperty(hasSrcSet) && ((defaultValue = props[hasSrcSet]), null != defaultValue)) switch(hasSrcSet){
                        case "value":
                            propKey = defaultValue;
                            break;
                        case "defaultValue":
                            propValue = defaultValue;
                            break;
                        case "multiple":
                            hasSrc = defaultValue;
                        default:
                            setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                    }
                    tag = propKey;
                    props = propValue;
                    domElement.multiple = !!hasSrc;
                    null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
                    return;
                case "textarea":
                    listenToNonDelegatedEvent("invalid", domElement);
                    propKey = hasSrcSet = hasSrc = null;
                    for(propValue in props)if (props.hasOwnProperty(propValue) && ((defaultValue = props[propValue]), null != defaultValue)) switch(propValue){
                        case "value":
                            hasSrc = defaultValue;
                            break;
                        case "defaultValue":
                            hasSrcSet = defaultValue;
                            break;
                        case "children":
                            propKey = defaultValue;
                            break;
                        case "dangerouslySetInnerHTML":
                            if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                            break;
                        default:
                            setProp(domElement, tag, propValue, defaultValue, props, null);
                    }
                    initTextarea(domElement, hasSrc, hasSrcSet, propKey);
                    track(domElement);
                    return;
                case "option":
                    for(checked in props)if (props.hasOwnProperty(checked) && ((hasSrc = props[checked]), null != hasSrc)) switch(checked){
                        case "selected":
                            domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                            break;
                        default:
                            setProp(domElement, tag, checked, hasSrc, props, null);
                    }
                    return;
                case "dialog":
                    listenToNonDelegatedEvent("beforetoggle", domElement);
                    listenToNonDelegatedEvent("toggle", domElement);
                    listenToNonDelegatedEvent("cancel", domElement);
                    listenToNonDelegatedEvent("close", domElement);
                    break;
                case "iframe":
                case "object":
                    listenToNonDelegatedEvent("load", domElement);
                    break;
                case "video":
                case "audio":
                    for(hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
                    break;
                case "image":
                    listenToNonDelegatedEvent("error", domElement);
                    listenToNonDelegatedEvent("load", domElement);
                    break;
                case "details":
                    listenToNonDelegatedEvent("toggle", domElement);
                    break;
                case "embed":
                case "source":
                case "link":
                    listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
                case "area":
                case "base":
                case "br":
                case "col":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "track":
                case "wbr":
                case "menuitem":
                    for(defaultChecked in props)if (props.hasOwnProperty(defaultChecked) && ((hasSrc = props[defaultChecked]), null != hasSrc)) switch(defaultChecked){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(formatProdErrorMessage(137, tag));
                        default:
                            setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                    }
                    return;
                default:
                    if (isCustomElement(tag)) {
                        for(propValue$188 in props)props.hasOwnProperty(propValue$188) && ((hasSrc = props[propValue$188]), void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, propValue$188, hasSrc, props, void 0));
                        return;
                    }
            }
            for(defaultValue in props)props.hasOwnProperty(defaultValue) && ((hasSrc = props[defaultValue]), null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
            switch(tag){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "input":
                    var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
                    for(propKey in lastProps){
                        var lastProp = lastProps[propKey];
                        if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch(propKey){
                            case "checked":
                                break;
                            case "value":
                                break;
                            case "defaultValue":
                                lastDefaultValue = lastProp;
                            default:
                                nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                        }
                    }
                    for(var propKey$205 in nextProps){
                        var propKey = nextProps[propKey$205];
                        lastProp = lastProps[propKey$205];
                        if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp)) switch(propKey$205){
                            case "type":
                                type = propKey;
                                break;
                            case "name":
                                name = propKey;
                                break;
                            case "checked":
                                checked = propKey;
                                break;
                            case "defaultChecked":
                                defaultChecked = propKey;
                                break;
                            case "value":
                                value = propKey;
                                break;
                            case "defaultValue":
                                defaultValue = propKey;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (null != propKey) throw Error(formatProdErrorMessage(137, tag));
                                break;
                            default:
                                propKey !== lastProp && setProp(domElement, tag, propKey$205, propKey, nextProps, lastProp);
                        }
                    }
                    updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
                    return;
                case "select":
                    propKey = value = defaultValue = propKey$205 = null;
                    for(type in lastProps)if (((lastDefaultValue = lastProps[type]), lastProps.hasOwnProperty(type) && null != lastDefaultValue)) switch(type){
                        case "value":
                            break;
                        case "multiple":
                            propKey = lastDefaultValue;
                        default:
                            nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
                    }
                    for(name in nextProps)if (((type = nextProps[name]), (lastDefaultValue = lastProps[name]), nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))) switch(name){
                        case "value":
                            propKey$205 = type;
                            break;
                        case "defaultValue":
                            defaultValue = type;
                            break;
                        case "multiple":
                            value = type;
                        default:
                            type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
                    }
                    tag = defaultValue;
                    lastProps = value;
                    nextProps = propKey;
                    null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
                    return;
                case "textarea":
                    propKey = propKey$205 = null;
                    for(defaultValue in lastProps)if (((name = lastProps[defaultValue]), lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))) switch(defaultValue){
                        case "value":
                            break;
                        case "children":
                            break;
                        default:
                            setProp(domElement, tag, defaultValue, null, nextProps, name);
                    }
                    for(value in nextProps)if (((name = nextProps[value]), (type = lastProps[value]), nextProps.hasOwnProperty(value) && (null != name || null != type))) switch(value){
                        case "value":
                            propKey$205 = name;
                            break;
                        case "defaultValue":
                            propKey = name;
                            break;
                        case "children":
                            break;
                        case "dangerouslySetInnerHTML":
                            if (null != name) throw Error(formatProdErrorMessage(91));
                            break;
                        default:
                            name !== type && setProp(domElement, tag, value, name, nextProps, type);
                    }
                    updateTextarea(domElement, propKey$205, propKey);
                    return;
                case "option":
                    for(var propKey$221 in lastProps)if (((propKey$205 = lastProps[propKey$221]), lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))) switch(propKey$221){
                        case "selected":
                            domElement.selected = false;
                            break;
                        default:
                            setProp(domElement, tag, propKey$221, null, nextProps, propKey$205);
                    }
                    for(lastDefaultValue in nextProps)if (((propKey$205 = nextProps[lastDefaultValue]), (propKey = lastProps[lastDefaultValue]), nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))) switch(lastDefaultValue){
                        case "selected":
                            domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                            break;
                        default:
                            setProp(domElement, tag, lastDefaultValue, propKey$205, nextProps, propKey);
                    }
                    return;
                case "img":
                case "link":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                case "menuitem":
                    for(var propKey$226 in lastProps)(propKey$205 = lastProps[propKey$226]), lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
                    for(checked in nextProps)if (((propKey$205 = nextProps[checked]), (propKey = lastProps[checked]), nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))) switch(checked){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (null != propKey$205) throw Error(formatProdErrorMessage(137, tag));
                            break;
                        default:
                            setProp(domElement, tag, checked, propKey$205, nextProps, propKey);
                    }
                    return;
                default:
                    if (isCustomElement(tag)) {
                        for(var propKey$231 in lastProps)(propKey$205 = lastProps[propKey$231]), lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(domElement, tag, propKey$231, void 0, nextProps, propKey$205);
                        for(defaultChecked in nextProps)(propKey$205 = nextProps[defaultChecked]), (propKey = lastProps[defaultChecked]), !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || (void 0 === propKey$205 && void 0 === propKey) || setPropOnCustomElement(domElement, tag, defaultChecked, propKey$205, nextProps, propKey);
                        return;
                    }
            }
            for(var propKey$236 in lastProps)(propKey$205 = lastProps[propKey$236]), lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
            for(lastProp in nextProps)(propKey$205 = nextProps[lastProp]), (propKey = lastProps[lastProp]), !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || (null == propKey$205 && null == propKey) || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
        }
        var eventsEnabled = null, selectionInformation = null;
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
            switch(namespaceURI){
                case "http://www.w3.org/2000/svg":
                    return 1;
                case "http://www.w3.org/1998/Math/MathML":
                    return 2;
                default:
                    return 0;
            }
        }
        function getChildHostContextProd(parentNamespace, type) {
            if (0 === parentNamespace) switch(type){
                case "svg":
                    return 1;
                case "math":
                    return 2;
                default:
                    return 0;
            }
            return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
            return ("textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || ("object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html));
        }
        var currentPopstateTransitionEvent = null;
        function shouldAttemptEagerTransition() {
            var event = window.event;
            if (event && "popstate" === event.type) {
                if (event === currentPopstateTransitionEvent) return false;
                currentPopstateTransitionEvent = event;
                return true;
            }
            currentPopstateTransitionEvent = null;
            return false;
        }
        var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error) {
            setTimeout(function() {
                throw error;
            });
        }
        function isSingletonScope(type) {
            return "head" === type;
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
            do {
                var nextNode = node.nextSibling;
                parentInstance.removeChild(node);
                if (nextNode && 8 === nextNode.nodeType) if (((node = nextNode.data), "/$" === node)) {
                    if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                        node = possiblePreambleContribution;
                        var ownerDocument = parentInstance.ownerDocument;
                        node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
                        node & 2 && releaseSingletonInstance(ownerDocument.body);
                        if (node & 4) for(node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument;){
                            var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
                            ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || ("LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase()) || node.removeChild(ownerDocument);
                            ownerDocument = nextNode$jscomp$0;
                        }
                    }
                    if (0 === depth) {
                        parentInstance.removeChild(nextNode);
                        retryIfBlockedOn(suspenseInstance);
                        return;
                    }
                    depth--;
                } else "$" === node || "$?" === node || "$!" === node ? depth++ : (possiblePreambleContribution = node.charCodeAt(0) - 48);
                else possiblePreambleContribution = 0;
                node = nextNode;
            }while (node);
            retryIfBlockedOn(suspenseInstance);
        }
        function clearContainerSparingly(container) {
            var nextNode = container.firstChild;
            nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
            for(; nextNode;){
                var node = nextNode;
                nextNode = nextNode.nextSibling;
                switch(node.nodeName){
                    case "HTML":
                    case "HEAD":
                    case "BODY":
                        clearContainerSparingly(node);
                        detachDeletedInstance(node);
                        continue;
                    case "SCRIPT":
                    case "STYLE":
                        continue;
                    case "LINK":
                        if ("stylesheet" === node.rel.toLowerCase()) continue;
                }
                container.removeChild(node);
            }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
            for(; 1 === instance.nodeType;){
                var anyProps = props;
                if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
                    if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
                } else if (!inRootOrSingleton) if ("input" === type && "hidden" === instance.type) {
                    var name = null == anyProps.name ? null : "" + anyProps.name;
                    if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
                } else return instance;
                else if (!instance[internalHoistableMarker]) switch(type){
                    case "meta":
                        if (!instance.hasAttribute("itemprop")) break;
                        return instance;
                    case "link":
                        name = instance.getAttribute("rel");
                        if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;
                        else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
                        return instance;
                    case "style":
                        if (instance.hasAttribute("data-precedence")) break;
                        return instance;
                    case "script":
                        name = instance.getAttribute("src");
                        if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
                        return instance;
                    default:
                        return instance;
                }
                instance = getNextHydratable(instance.nextSibling);
                if (null === instance) break;
            }
            return null;
        }
        function canHydrateTextInstance(instance, text, inRootOrSingleton) {
            if ("" === text) return null;
            for(; 3 !== instance.nodeType;){
                if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
                instance = getNextHydratable(instance.nextSibling);
                if (null === instance) return null;
            }
            return instance;
        }
        function isSuspenseInstanceFallback(instance) {
            return ("$!" === instance.data || ("$?" === instance.data && "complete" === instance.ownerDocument.readyState));
        }
        function registerSuspenseInstanceRetry(instance, callback) {
            var ownerDocument = instance.ownerDocument;
            if ("$?" !== instance.data || "complete" === ownerDocument.readyState) callback();
            else {
                var listener = function() {
                    callback();
                    ownerDocument.removeEventListener("DOMContentLoaded", listener);
                };
                ownerDocument.addEventListener("DOMContentLoaded", listener);
                instance._reactRetry = listener;
            }
        }
        function getNextHydratable(node) {
            for(; null != node; node = node.nextSibling){
                var nodeType = node.nodeType;
                if (1 === nodeType || 3 === nodeType) break;
                if (8 === nodeType) {
                    nodeType = node.data;
                    if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType) break;
                    if ("/$" === nodeType) return null;
                }
            }
            return node;
        }
        var previousHydratableOnEnteringScopedSingleton = null;
        function getParentSuspenseInstance(targetInstance) {
            targetInstance = targetInstance.previousSibling;
            for(var depth = 0; targetInstance;){
                if (8 === targetInstance.nodeType) {
                    var data = targetInstance.data;
                    if ("$" === data || "$!" === data || "$?" === data) {
                        if (0 === depth) return targetInstance;
                        depth--;
                    } else "/$" === data && depth++;
                }
                targetInstance = targetInstance.previousSibling;
            }
            return null;
        }
        function resolveSingletonInstance(type, props, rootContainerInstance) {
            props = getOwnerDocumentFromRootContainer(rootContainerInstance);
            switch(type){
                case "html":
                    type = props.documentElement;
                    if (!type) throw Error(formatProdErrorMessage(452));
                    return type;
                case "head":
                    type = props.head;
                    if (!type) throw Error(formatProdErrorMessage(453));
                    return type;
                case "body":
                    type = props.body;
                    if (!type) throw Error(formatProdErrorMessage(454));
                    return type;
                default:
                    throw Error(formatProdErrorMessage(451));
            }
        }
        function releaseSingletonInstance(instance) {
            for(var attributes = instance.attributes; attributes.length;)instance.removeAttributeNode(attributes[0]);
            detachDeletedInstance(instance);
        }
        var preloadPropsMap = new Map(), preconnectsSet = new Set();
        function getHoistableRoot(container) {
            return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
        }
        var previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
            f: flushSyncWork,
            r: requestFormReset,
            D: prefetchDNS,
            C: preconnect,
            L: preload,
            m: preloadModule,
            X: preinitScript,
            S: preinitStyle,
            M: preinitModuleScript
        };
        function flushSyncWork() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
        }
        function requestFormReset(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
        }
        var globalDocument = "undefined" === typeof document ? null : document;
        function preconnectAs(rel, href, crossOrigin) {
            var ownerDocument = globalDocument;
            if (ownerDocument && "string" === typeof href && href) {
                var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
                limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
                "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
                preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), (rel = {
                    rel: rel,
                    crossOrigin: crossOrigin,
                    href: href
                }), null === ownerDocument.querySelector(limitedEscapedHref) && ((href = ownerDocument.createElement("link")), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
            }
        }
        function prefetchDNS(href) {
            previousDispatcher.D(href);
            preconnectAs("dns-prefetch", href, null);
        }
        function preconnect(href, crossOrigin) {
            previousDispatcher.C(href, crossOrigin);
            preconnectAs("preconnect", href, crossOrigin);
        }
        function preload(href, as, options) {
            previousDispatcher.L(href, as, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href && as) {
                var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
                "image" === as ? options && options.imageSrcSet ? ((preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]'), "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : (preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]') : (preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]');
                var key = preloadSelector;
                switch(as){
                    case "style":
                        key = getStyleKey(href);
                        break;
                    case "script":
                        key = getScriptKey(href);
                }
                preloadPropsMap.has(key) || ((href = assign({
                    rel: "preload",
                    href: "image" === as && options && options.imageSrcSet ? void 0 : href,
                    as: as
                }, options)), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || ("style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) || ("script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key))) || ((as = ownerDocument.createElement("link")), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
        }
        function preloadModule(href, options) {
            previousDispatcher.m(href, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
                var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
                switch(as){
                    case "audioworklet":
                    case "paintworklet":
                    case "serviceworker":
                    case "sharedworker":
                    case "worker":
                    case "script":
                        key = getScriptKey(href);
                }
                if (!preloadPropsMap.has(key) && ((href = assign({
                    rel: "modulepreload",
                    href: href
                }, options)), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
                    switch(as){
                        case "audioworklet":
                        case "paintworklet":
                        case "serviceworker":
                        case "sharedworker":
                        case "worker":
                        case "script":
                            if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
                    }
                    as = ownerDocument.createElement("link");
                    setInitialProperties(as, "link", href);
                    markNodeAsHoistable(as);
                    ownerDocument.head.appendChild(as);
                }
            }
        }
        function preinitStyle(href, precedence, options) {
            previousDispatcher.S(href, precedence, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && href) {
                var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
                precedence = precedence || "default";
                var resource = styles.get(key);
                if (!resource) {
                    var state = {
                        loading: 0,
                        preload: null
                    };
                    if ((resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key)))) state.loading = 5;
                    else {
                        href = assign({
                            rel: "stylesheet",
                            href: href,
                            "data-precedence": precedence
                        }, options);
                        (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
                        var link = (resource = ownerDocument.createElement("link"));
                        markNodeAsHoistable(link);
                        setInitialProperties(link, "link", href);
                        link._p = new Promise(function(resolve, reject) {
                            link.onload = resolve;
                            link.onerror = reject;
                        });
                        link.addEventListener("load", function() {
                            state.loading |= 1;
                        });
                        link.addEventListener("error", function() {
                            state.loading |= 2;
                        });
                        state.loading |= 4;
                        insertStylesheet(resource, precedence, ownerDocument);
                    }
                    resource = {
                        type: "stylesheet",
                        instance: resource,
                        count: 1,
                        state: state
                    };
                    styles.set(key, resource);
                }
            }
        }
        function preinitScript(src, options) {
            previousDispatcher.X(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))), resource || ((src = assign({
                    src: src,
                    async: true
                }, options)), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), (resource = ownerDocument.createElement("script")), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), (resource = {
                    type: "script",
                    instance: resource,
                    count: 1,
                    state: null
                }), scripts.set(key, resource));
            }
        }
        function preinitModuleScript(src, options) {
            previousDispatcher.M(src, options);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
                var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
                resource || ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))), resource || ((src = assign({
                    src: src,
                    async: true,
                    type: "module"
                }, options)), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), (resource = ownerDocument.createElement("script")), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), (resource = {
                    type: "script",
                    instance: resource,
                    count: 1,
                    state: null
                }), scripts.set(key, resource));
            }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
            var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
            if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
            switch(type){
                case "meta":
                case "title":
                    return null;
                case "style":
                    return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? ((currentProps = getStyleKey(pendingProps.href)), (pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles), (currentResource = pendingProps.get(currentProps)), currentResource || ((currentResource = {
                        type: "style",
                        instance: null,
                        count: 0,
                        state: null
                    }), pendingProps.set(currentProps, currentResource)), currentResource) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                case "link":
                    if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                        type = getStyleKey(pendingProps.href);
                        var styles$244 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, resource$245 = styles$244.get(type);
                        resource$245 || ((JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result), (resource$245 = {
                            type: "stylesheet",
                            instance: null,
                            count: 0,
                            state: {
                                loading: 0,
                                preload: null
                            }
                        }), styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type))) && !styles$244._p && ((resource$245.instance = styles$244), (resource$245.state.loading = 5)), preloadPropsMap.has(type) || ((pendingProps = {
                            rel: "preload",
                            as: "style",
                            href: pendingProps.href,
                            crossOrigin: pendingProps.crossOrigin,
                            integrity: pendingProps.integrity,
                            media: pendingProps.media,
                            hrefLang: pendingProps.hrefLang,
                            referrerPolicy: pendingProps.referrerPolicy
                        }), preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(JSCompiler_inline_result, type, pendingProps, resource$245.state)));
                        if (currentProps && null === currentResource) throw Error(formatProdErrorMessage(528, ""));
                        return resource$245;
                    }
                    if (currentProps && null !== currentResource) throw Error(formatProdErrorMessage(529, ""));
                    return null;
                case "script":
                    return ((currentProps = pendingProps.async), (pendingProps = pendingProps.src), "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? ((currentProps = getScriptKey(pendingProps)), (pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts), (currentResource = pendingProps.get(currentProps)), currentResource || ((currentResource = {
                        type: "script",
                        instance: null,
                        count: 0,
                        state: null
                    }), pendingProps.set(currentProps, currentResource)), currentResource) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    });
                default:
                    throw Error(formatProdErrorMessage(444, type));
            }
        }
        function getStyleKey(href) {
            return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
            return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
            return assign({}, rawProps, {
                "data-precedence": rawProps.precedence,
                precedence: null
            });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
            ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? (state.loading = 1) : ((key = ownerDocument.createElement("link")), (state.preload = key), key.addEventListener("load", function() {
                return (state.loading |= 1);
            }), key.addEventListener("error", function() {
                return (state.loading |= 2);
            }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
            return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
            return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
            resource.count++;
            if (null === resource.instance) switch(resource.type){
                case "style":
                    var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
                    if (instance) return ((resource.instance = instance), markNodeAsHoistable(instance), instance);
                    var styleProps = assign({}, props, {
                        "data-href": props.href,
                        "data-precedence": props.precedence,
                        href: null,
                        precedence: null
                    });
                    instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                    markNodeAsHoistable(instance);
                    setInitialProperties(instance, "style", styleProps);
                    insertStylesheet(instance, props.precedence, hoistableRoot);
                    return (resource.instance = instance);
                case "stylesheet":
                    styleProps = getStyleKey(props.href);
                    var instance$250 = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
                    if (instance$250) return ((resource.state.loading |= 4), (resource.instance = instance$250), markNodeAsHoistable(instance$250), instance$250);
                    instance = stylesheetPropsFromRawProps(props);
                    (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                    instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                    markNodeAsHoistable(instance$250);
                    var linkInstance = instance$250;
                    linkInstance._p = new Promise(function(resolve, reject) {
                        linkInstance.onload = resolve;
                        linkInstance.onerror = reject;
                    });
                    setInitialProperties(instance$250, "link", instance);
                    resource.state.loading |= 4;
                    insertStylesheet(instance$250, props.precedence, hoistableRoot);
                    return (resource.instance = instance$250);
                case "script":
                    instance$250 = getScriptKey(props.src);
                    if ((styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$250)))) return ((resource.instance = styleProps), markNodeAsHoistable(styleProps), styleProps);
                    instance = props;
                    if ((styleProps = preloadPropsMap.get(instance$250))) (instance = assign({}, props)), adoptPreloadPropsForScript(instance, styleProps);
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    styleProps = hoistableRoot.createElement("script");
                    markNodeAsHoistable(styleProps);
                    setInitialProperties(styleProps, "link", instance);
                    hoistableRoot.head.appendChild(styleProps);
                    return (resource.instance = styleProps);
                case "void":
                    return null;
                default:
                    throw Error(formatProdErrorMessage(443, resource.type));
            }
            else "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && ((instance = resource.instance), (resource.state.loading |= 4), insertStylesheet(instance, props.precedence, hoistableRoot));
            return resource.instance;
        }
        function insertStylesheet(instance, precedence, root) {
            for(var nodes = root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++){
                var node = nodes[i];
                if (node.dataset.precedence === precedence) prior = node;
                else if (prior !== last) break;
            }
            prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : ((precedence = 9 === root.nodeType ? root.head : root), precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
            null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
            null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
            null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
            null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
            null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
            null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        var tagCaches = null;
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
            if (null === tagCaches) {
                var cache = new Map();
                var caches = (tagCaches = new Map());
                caches.set(ownerDocument, cache);
            } else (caches = tagCaches), (cache = caches.get(ownerDocument)), cache || ((cache = new Map()), caches.set(ownerDocument, cache));
            if (cache.has(type)) return cache;
            cache.set(type, null);
            ownerDocument = ownerDocument.getElementsByTagName(type);
            for(caches = 0; caches < ownerDocument.length; caches++){
                var node = ownerDocument[caches];
                if (!(node[internalHoistableMarker] || node[internalInstanceKey] || ("link" === type && "stylesheet" === node.getAttribute("rel"))) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
                    var nodeKey = node.getAttribute(keyAttribute) || "";
                    nodeKey = type + nodeKey;
                    var existing = cache.get(nodeKey);
                    existing ? existing.push(node) : cache.set(nodeKey, [
                        node
                    ]);
                }
            }
            return cache;
        }
        function mountHoistable(hoistableRoot, type, instance) {
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
        }
        function isHostHoistableType(type, props, hostContext) {
            if (1 === hostContext || null != props.itemProp) return false;
            switch(type){
                case "meta":
                case "title":
                    return true;
                case "style":
                    if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) break;
                    return true;
                case "link":
                    if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) break;
                    switch(props.rel){
                        case "stylesheet":
                            return ((type = props.disabled), "string" === typeof props.precedence && null == type);
                        default:
                            return true;
                    }
                case "script":
                    if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src) return true;
            }
            return false;
        }
        function preloadResource(resource) {
            return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
        }
        var suspendedState = null;
        function noop() {}
        function suspendResource(hoistableRoot, resource, props) {
            if (null === suspendedState) throw Error(formatProdErrorMessage(475));
            var state = suspendedState;
            if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
                if (null === resource.instance) {
                    var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
                    if (instance) {
                        hoistableRoot = instance._p;
                        null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, (state = onUnsuspend.bind(state)), hoistableRoot.then(state, state));
                        resource.state.loading |= 4;
                        resource.instance = instance;
                        markNodeAsHoistable(instance);
                        return;
                    }
                    instance = hoistableRoot.ownerDocument || hoistableRoot;
                    props = stylesheetPropsFromRawProps(props);
                    (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
                    instance = instance.createElement("link");
                    markNodeAsHoistable(instance);
                    var linkInstance = instance;
                    linkInstance._p = new Promise(function(resolve, reject) {
                        linkInstance.onload = resolve;
                        linkInstance.onerror = reject;
                    });
                    setInitialProperties(instance, "link", props);
                    resource.instance = instance;
                }
                null === state.stylesheets && (state.stylesheets = new Map());
                state.stylesheets.set(resource, hoistableRoot);
                (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, (resource = onUnsuspend.bind(state)), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
            }
        }
        function waitForCommitToBeReady() {
            if (null === suspendedState) throw Error(formatProdErrorMessage(475));
            var state = suspendedState;
            state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
            return 0 < state.count ? function(commit) {
                var stylesheetTimer = setTimeout(function() {
                    state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
                    if (state.unsuspend) {
                        var unsuspend = state.unsuspend;
                        state.unsuspend = null;
                        unsuspend();
                    }
                }, 6e4);
                state.unsuspend = commit;
                return function() {
                    state.unsuspend = null;
                    clearTimeout(stylesheetTimer);
                };
            } : null;
        }
        function onUnsuspend() {
            this.count--;
            if (0 === this.count) if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
                var unsuspend = this.unsuspend;
                this.unsuspend = null;
                unsuspend();
            }
        }
        var precedencesByRoot = null;
        function insertSuspendedStylesheets(state, resources) {
            state.stylesheets = null;
            null !== state.unsuspend && (state.count++, (precedencesByRoot = new Map()), resources.forEach(insertStylesheetIntoRoot, state), (precedencesByRoot = null), onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root, resource) {
            if (!(resource.state.loading & 4)) {
                var precedences = precedencesByRoot.get(root);
                if (precedences) var last = precedences.get(null);
                else {
                    precedences = new Map();
                    precedencesByRoot.set(root, precedences);
                    for(var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++){
                        var node = nodes[i];
                        if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), (last = node);
                    }
                    last && precedences.set(null, last);
                }
                nodes = resource.instance;
                node = nodes.getAttribute("data-precedence");
                i = precedences.get(node) || last;
                i === last && precedences.set(null, nodes);
                precedences.set(node, nodes);
                this.count++;
                last = onUnsuspend.bind(this);
                nodes.addEventListener("load", last);
                nodes.addEventListener("error", last);
                i ? i.parentNode.insertBefore(nodes, i.nextSibling) : ((root = 9 === root.nodeType ? root.head : root), root.insertBefore(nodes, root.firstChild));
                resource.state.loading |= 4;
            }
        }
        var HostTransitionContext = {
            $$typeof: REACT_CONTEXT_TYPE,
            Provider: null,
            Consumer: null,
            _currentValue: sharedNotPendingObject,
            _currentValue2: sharedNotPendingObject,
            _threadCount: 0
        };
        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
            this.tag = 1;
            this.containerInfo = containerInfo;
            this.pingCache = this.current = this.pendingChildren = null;
            this.timeoutHandle = -1;
            this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
            this.callbackPriority = 0;
            this.expirationTimes = createLaneMap(-1);
            this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
            this.entanglements = createLaneMap(0);
            this.hiddenUpdates = createLaneMap(null);
            this.identifierPrefix = identifierPrefix;
            this.onUncaughtError = onUncaughtError;
            this.onCaughtError = onCaughtError;
            this.onRecoverableError = onRecoverableError;
            this.pooledCache = null;
            this.pooledCacheLanes = 0;
            this.formState = formState;
            this.incompleteTransitions = new Map();
        }
        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
            containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
            tag = 1;
            true === isStrictMode && (tag |= 24);
            isStrictMode = createFiberImplClass(3, null, null, tag);
            containerInfo.current = isStrictMode;
            isStrictMode.stateNode = containerInfo;
            tag = createCache();
            tag.refCount++;
            containerInfo.pooledCache = tag;
            tag.refCount++;
            isStrictMode.memoizedState = {
                element: initialChildren,
                isDehydrated: hydrate,
                cache: tag
            };
            initializeUpdateQueue(isStrictMode);
            return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
            if (!parentComponent) return emptyContextObject;
            parentComponent = emptyContextObject;
            return parentComponent;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
            parentComponent = getContextForSubtree(parentComponent);
            null === container.context ? (container.context = parentComponent) : (container.pendingContext = parentComponent);
            container = createUpdate(lane);
            container.payload = {
                element: element
            };
            callback = void 0 === callback ? null : callback;
            null !== callback && (container.callback = callback);
            element = enqueueUpdate(rootFiber, container, lane);
            null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
            fiber = fiber.memoizedState;
            if (null !== fiber && null !== fiber.dehydrated) {
                var a = fiber.retryLane;
                fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
            }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
            if (13 === fiber.tag) {
                var root = enqueueConcurrentRenderForLane(fiber, 67108864);
                null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
                markRetryLaneIfNotHydrated(fiber, 67108864);
            }
        }
        var _enabled = true;
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var prevTransition = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            try {
                (ReactDOMSharedInternals.p = 2), dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally{
                (ReactDOMSharedInternals.p = previousPriority), (ReactSharedInternals.T = prevTransition);
            }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var prevTransition = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            try {
                (ReactDOMSharedInternals.p = 8), dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally{
                (ReactDOMSharedInternals.p = previousPriority), (ReactSharedInternals.T = prevTransition);
            }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (_enabled) {
                var blockedOn = findInstanceBlockingEvent(nativeEvent);
                if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
                else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();
                else if ((clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName))) {
                    for(; null !== blockedOn;){
                        var fiber = getInstanceFromNode(blockedOn);
                        if (null !== fiber) switch(fiber.tag){
                            case 3:
                                fiber = fiber.stateNode;
                                if (fiber.current.memoizedState.isDehydrated) {
                                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                                    if (0 !== lanes) {
                                        var root = fiber;
                                        root.pendingLanes |= 2;
                                        for(root.entangledLanes |= 2; lanes;){
                                            var lane = 1 << (31 - clz32(lanes));
                                            root.entanglements[1] |= lane;
                                            lanes &= ~lane;
                                        }
                                        ensureRootIsScheduled(fiber);
                                        0 === (executionContext & 6) && ((workInProgressRootRenderTargetTime = now() + 500), flushSyncWorkAcrossRoots_impl(0));
                                    }
                                }
                                break;
                            case 13:
                                (root = enqueueConcurrentRenderForLane(fiber, 2)), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                        }
                        fiber = findInstanceBlockingEvent(nativeEvent);
                        null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                        if (fiber === blockedOn) break;
                        blockedOn = fiber;
                    }
                    null !== blockedOn && nativeEvent.stopPropagation();
                } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
            }
        }
        function findInstanceBlockingEvent(nativeEvent) {
            nativeEvent = getEventTarget(nativeEvent);
            return findInstanceBlockingTarget(nativeEvent);
        }
        var return_targetInst = null;
        function findInstanceBlockingTarget(targetNode) {
            return_targetInst = null;
            targetNode = getClosestInstanceFromNode(targetNode);
            if (null !== targetNode) {
                var nearestMounted = getNearestMountedFiber(targetNode);
                if (null === nearestMounted) targetNode = null;
                else {
                    var tag = nearestMounted.tag;
                    if (13 === tag) {
                        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                        if (null !== targetNode) return targetNode;
                        targetNode = null;
                    } else if (3 === tag) {
                        if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                        targetNode = null;
                    } else nearestMounted !== targetNode && (targetNode = null);
                }
            }
            return_targetInst = targetNode;
            return null;
        }
        function getEventPriority(domEventName) {
            switch(domEventName){
                case "beforetoggle":
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "toggle":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                    return 2;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                    return 8;
                case "message":
                    switch(getCurrentPriorityLevel()){
                        case ImmediatePriority:
                            return 2;
                        case UserBlockingPriority:
                            return 8;
                        case NormalPriority$1:
                        case LowPriority:
                            return 32;
                        case IdlePriority:
                            return 268435456;
                        default:
                            return 32;
                    }
                default:
                    return 32;
            }
        }
        var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map(), queuedPointerCaptures = new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
        function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch(domEventName){
                case "focusin":
                case "focusout":
                    queuedFocus = null;
                    break;
                case "dragenter":
                case "dragleave":
                    queuedDrag = null;
                    break;
                case "mouseover":
                case "mouseout":
                    queuedMouse = null;
                    break;
                case "pointerover":
                case "pointerout":
                    queuedPointers.delete(nativeEvent.pointerId);
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                    queuedPointerCaptures.delete(nativeEvent.pointerId);
            }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return ((existingQueuedEvent = {
                blockedOn: blockedOn,
                domEventName: domEventName,
                eventSystemFlags: eventSystemFlags,
                nativeEvent: nativeEvent,
                targetContainers: [
                    targetContainer
                ]
            }), null !== blockedOn && ((blockedOn = getInstanceFromNode(blockedOn)), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent);
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            blockedOn = existingQueuedEvent.targetContainers;
            null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
            return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch(domEventName){
                case "focusin":
                    return ((queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true);
                case "dragenter":
                    return ((queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true);
                case "mouseover":
                    return ((queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true);
                case "pointerover":
                    var pointerId = nativeEvent.pointerId;
                    queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
                    return true;
                case "gotpointercapture":
                    return ((pointerId = nativeEvent.pointerId), queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true);
            }
            return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (null !== targetInst) {
                var nearestMounted = getNearestMountedFiber(targetInst);
                if (null !== nearestMounted) if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
                    if (((targetInst = getSuspenseInstanceFromFiber(nearestMounted)), null !== targetInst)) {
                        queuedTarget.blockedOn = targetInst;
                        runWithPriority(queuedTarget.priority, function() {
                            if (13 === nearestMounted.tag) {
                                var lane = requestUpdateLane();
                                lane = getBumpedLaneForHydrationByLane(lane);
                                var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
                                null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
                                markRetryLaneIfNotHydrated(nearestMounted, lane);
                            }
                        });
                        return;
                    }
                } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                    queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                    return;
                }
            }
            queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (null !== queuedEvent.blockedOn) return false;
            for(var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;){
                var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
                if (null === nextBlockedOn) {
                    nextBlockedOn = queuedEvent.nativeEvent;
                    var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn);
                    currentReplayingEvent = nativeEventClone;
                    nextBlockedOn.target.dispatchEvent(nativeEventClone);
                    currentReplayingEvent = null;
                } else return ((targetContainers = getInstanceFromNode(nextBlockedOn)), null !== targetContainers && attemptContinuousHydration(targetContainers), (queuedEvent.blockedOn = nextBlockedOn), false);
                targetContainers.shift();
            }
            return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
            attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
        }
        function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
            null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
            null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            queuedEvent.blockedOn === unblocked && ((queuedEvent.blockedOn = null), hasScheduledReplayAttempt || ((hasScheduledReplayAttempt = true), Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
        }
        var lastScheduledReplayQueue = null;
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
            lastScheduledReplayQueue !== formReplayingQueue && ((lastScheduledReplayQueue = formReplayingQueue), Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
                lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
                for(var i = 0; i < formReplayingQueue.length; i += 3){
                    var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                    if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;
                    else break;
                    var formInst = getInstanceFromNode(form);
                    null !== formInst && (formReplayingQueue.splice(i, 3), (i -= 3), startHostTransition(formInst, {
                        pending: true,
                        data: formData,
                        method: form.method,
                        action: submitterOrAction
                    }, submitterOrAction, formData));
                }
            }));
        }
        function retryIfBlockedOn(unblocked) {
            function unblock(queuedEvent) {
                return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
            }
            null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for(var i = 0; i < queuedExplicitHydrationTargets.length; i++){
                var queuedTarget = queuedExplicitHydrationTargets[i];
                queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
            }
            for(; 0 < queuedExplicitHydrationTargets.length && ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);)attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
            i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
            if (null != i) for(queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3){
                var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
                if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);
                else if (formProps) {
                    var action = null;
                    if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) if (((form = submitterOrAction), (formProps = submitterOrAction[internalPropsKey] || null))) action = formProps.formAction;
                    else {
                        if (null !== findInstanceBlockingTarget(form)) continue;
                    }
                    else action = formProps.action;
                    "function" === typeof action ? (i[queuedTarget + 1] = action) : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
                    scheduleReplayQueueIfNeeded(i);
                }
            }
        }
        function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root = this._internalRoot;
            if (null === root) throw Error(formatProdErrorMessage(409));
            var current = root.current, lane = requestUpdateLane();
            updateContainerImpl(current, lane, children, root, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            var root = this._internalRoot;
            if (null !== root) {
                this._internalRoot = null;
                var container = root.containerInfo;
                updateContainerImpl(root.current, 2, null, root, null, null);
                flushSyncWork$1();
                container[internalContainerInstanceKey] = null;
            }
        };
        function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
            if (target) {
                var updatePriority = resolveUpdatePriority();
                target = {
                    blockedOn: null,
                    target: target,
                    priority: updatePriority
                };
                for(var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
                queuedExplicitHydrationTargets.splice(i, 0, target);
                0 === i && attemptExplicitHydrationTarget(target);
            }
        };
        var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
        if ("19.1.1" !== isomorphicReactPackageVersion$jscomp$inline_1785) throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1785, "19.1.1"));
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
            var fiber = componentOrElement._reactInternals;
            if (void 0 === fiber) {
                if ("function" === typeof componentOrElement.render) throw Error(formatProdErrorMessage(188));
                componentOrElement = Object.keys(componentOrElement).join(",");
                throw Error(formatProdErrorMessage(268, componentOrElement));
            }
            componentOrElement = findCurrentFiberUsingSlowPath(fiber);
            componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
            componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
            return componentOrElement;
        };
        var internals$jscomp$inline_2256 = {
            bundleType: 0,
            version: "19.1.1",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            reconcilerVersion: "19.1.1"
        };
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
            var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber) try {
                (rendererID = hook$jscomp$inline_2257.inject(internals$jscomp$inline_2256)), (injectedHook = hook$jscomp$inline_2257);
            } catch (err) {}
        }
        reactDomClient_production.createRoot = function(container, options) {
            if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
            var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
            null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
            options = createFiberRoot(container, 1, false, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
            container[internalContainerInstanceKey] = options.current;
            listenToAllSupportedEvents(container);
            return new ReactDOMRoot(options);
        };
        reactDomClient_production.hydrateRoot = function(container, initialChildren, options) {
            if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
            var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
            null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
            initialChildren = createFiberRoot(container, 1, true, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
            initialChildren.context = getContextForSubtree(null);
            options = initialChildren.current;
            isStrictMode = requestUpdateLane();
            isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
            identifierPrefix = createUpdate(isStrictMode);
            identifierPrefix.callback = null;
            enqueueUpdate(options, identifierPrefix, isStrictMode);
            options = isStrictMode;
            initialChildren.current.lanes = options;
            markRootUpdated$1(initialChildren, options);
            ensureRootIsScheduled(initialChildren);
            container[internalContainerInstanceKey] = initialChildren.current;
            listenToAllSupportedEvents(container);
            return new ReactDOMHydrationRoot(initialChildren);
        };
        reactDomClient_production.version = "19.1.1";
        return reactDomClient_production;
    }
    var hasRequiredClient;
    function requireClient() {
        if (hasRequiredClient) return client.exports;
        hasRequiredClient = 1;
        function checkDCE() {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
                return;
            }
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
            } catch (err) {
                console.error(err);
            }
        }
        {
            checkDCE();
            client.exports = requireReactDomClient_production();
        }
        return client.exports;
    }
    var clientExports = requireClient();
    var dist = {};
    var hasRequiredDist;
    function requireDist() {
        if (hasRequiredDist) return dist;
        hasRequiredDist = 1;
        Object.defineProperty(dist, "__esModule", {
            value: true
        });
        dist.parse = parse;
        dist.serialize = serialize;
        const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
        const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
        const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
        const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
        const __toString = Object.prototype.toString;
        const NullObject = (()=>{
            const C = function() {};
            C.prototype = Object.create(null);
            return C;
        })();
        function parse(str, options) {
            const obj = new NullObject();
            const len = str.length;
            if (len < 2) return obj;
            const dec = options?.decode || decode;
            let index = 0;
            do {
                const eqIdx = str.indexOf("=", index);
                if (eqIdx === -1) break;
                const colonIdx = str.indexOf(";", index);
                const endIdx = colonIdx === -1 ? len : colonIdx;
                if (eqIdx > endIdx) {
                    index = str.lastIndexOf(";", eqIdx - 1) + 1;
                    continue;
                }
                const keyStartIdx = startIndex(str, index, eqIdx);
                const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
                const key = str.slice(keyStartIdx, keyEndIdx);
                if (obj[key] === undefined) {
                    let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
                    let valEndIdx = endIndex(str, endIdx, valStartIdx);
                    const value = dec(str.slice(valStartIdx, valEndIdx));
                    obj[key] = value;
                }
                index = endIdx + 1;
            }while (index < len);
            return obj;
        }
        function startIndex(str, index, max) {
            do {
                const code = str.charCodeAt(index);
                if (code !== 0x20 && code !== 0x09) return index;
            }while (++index < max);
            return max;
        }
        function endIndex(str, index, min) {
            while(index > min){
                const code = str.charCodeAt(--index);
                if (code !== 0x20 && code !== 0x09) return index + 1;
            }
            return min;
        }
        function serialize(name, val, options) {
            const enc = options?.encode || encodeURIComponent;
            if (!cookieNameRegExp.test(name)) {
                throw new TypeError(`argument name is invalid: ${name}`);
            }
            const value = enc(val);
            if (!cookieValueRegExp.test(value)) {
                throw new TypeError(`argument val is invalid: ${val}`);
            }
            let str = name + "=" + value;
            if (!options) return str;
            if (options.maxAge !== undefined) {
                if (!Number.isInteger(options.maxAge)) {
                    throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
                }
                str += "; Max-Age=" + options.maxAge;
            }
            if (options.domain) {
                if (!domainValueRegExp.test(options.domain)) {
                    throw new TypeError(`option domain is invalid: ${options.domain}`);
                }
                str += "; Domain=" + options.domain;
            }
            if (options.path) {
                if (!pathValueRegExp.test(options.path)) {
                    throw new TypeError(`option path is invalid: ${options.path}`);
                }
                str += "; Path=" + options.path;
            }
            if (options.expires) {
                if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
                    throw new TypeError(`option expires is invalid: ${options.expires}`);
                }
                str += "; Expires=" + options.expires.toUTCString();
            }
            if (options.httpOnly) {
                str += "; HttpOnly";
            }
            if (options.secure) {
                str += "; Secure";
            }
            if (options.partitioned) {
                str += "; Partitioned";
            }
            if (options.priority) {
                const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
                switch(priority){
                    case "low":
                        str += "; Priority=Low";
                        break;
                    case "medium":
                        str += "; Priority=Medium";
                        break;
                    case "high":
                        str += "; Priority=High";
                        break;
                    default:
                        throw new TypeError(`option priority is invalid: ${options.priority}`);
                }
            }
            if (options.sameSite) {
                const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
                switch(sameSite){
                    case true:
                    case "strict":
                        str += "; SameSite=Strict";
                        break;
                    case "lax":
                        str += "; SameSite=Lax";
                        break;
                    case "none":
                        str += "; SameSite=None";
                        break;
                    default:
                        throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
                }
            }
            return str;
        }
        function decode(str) {
            if (str.indexOf("%") === -1) return str;
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        function isDate(val) {
            return __toString.call(val) === "[object Date]";
        }
        return dist;
    }
    requireDist();
    var PopStateEventType = "popstate";
    function createBrowserHistory(options = {}) {
        function createBrowserLocation(window2, globalHistory) {
            let { pathname, search, hash } = window2.location;
            return createLocation("", {
                pathname,
                search,
                hash
            }, globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
        }
        function createBrowserHref(window2, to) {
            return typeof to === "string" ? to : createPath(to);
        }
        return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function invariant$5(value, message) {
        if (value === false || value === null || typeof value === "undefined") {
            throw new Error(message);
        }
    }
    function warning(cond, message) {
        if (!cond) {
            if (typeof console !== "undefined") console.warn(message);
            try {
                throw new Error(message);
            } catch (e) {}
        }
    }
    function createKey() {
        return Math.random().toString(36).substring(2, 10);
    }
    function getHistoryState(location, index) {
        return {
            usr: location.state,
            key: location.key,
            idx: index
        };
    }
    function createLocation(current, to, state = null, key) {
        let location = {
            pathname: typeof current === "string" ? current : current.pathname,
            search: "",
            hash: "",
            ...typeof to === "string" ? parsePath$1(to) : to,
            state,
            key: to && to.key || key || createKey()
        };
        return location;
    }
    function createPath({ pathname = "/", search = "", hash = "" }) {
        if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
        if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
        return pathname;
    }
    function parsePath$1(path) {
        let parsedPath = {};
        if (path) {
            let hashIndex = path.indexOf("#");
            if (hashIndex >= 0) {
                parsedPath.hash = path.substring(hashIndex);
                path = path.substring(0, hashIndex);
            }
            let searchIndex = path.indexOf("?");
            if (searchIndex >= 0) {
                parsedPath.search = path.substring(searchIndex);
                path = path.substring(0, searchIndex);
            }
            if (path) {
                parsedPath.pathname = path;
            }
        }
        return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
        let { window: window2 = document.defaultView, v5Compat = false } = options;
        let globalHistory = window2.history;
        let action = "POP";
        let listener = null;
        let index = getIndex();
        if (index == null) {
            index = 0;
            globalHistory.replaceState({
                ...globalHistory.state,
                idx: index
            }, "");
        }
        function getIndex() {
            let state = globalHistory.state || {
                idx: null
            };
            return state.idx;
        }
        function handlePop() {
            action = "POP";
            let nextIndex = getIndex();
            let delta = nextIndex == null ? null : nextIndex - index;
            index = nextIndex;
            if (listener) {
                listener({
                    action,
                    location: history.location,
                    delta
                });
            }
        }
        function push(to, state) {
            action = "PUSH";
            let location = createLocation(history.location, to, state);
            index = getIndex() + 1;
            let historyState = getHistoryState(location, index);
            let url = history.createHref(location);
            try {
                globalHistory.pushState(historyState, "", url);
            } catch (error) {
                if (error instanceof DOMException && error.name === "DataCloneError") {
                    throw error;
                }
                window2.location.assign(url);
            }
            if (v5Compat && listener) {
                listener({
                    action,
                    location: history.location,
                    delta: 1
                });
            }
        }
        function replace2(to, state) {
            action = "REPLACE";
            let location = createLocation(history.location, to, state);
            index = getIndex();
            let historyState = getHistoryState(location, index);
            let url = history.createHref(location);
            globalHistory.replaceState(historyState, "", url);
            if (v5Compat && listener) {
                listener({
                    action,
                    location: history.location,
                    delta: 0
                });
            }
        }
        function createURL(to) {
            return createBrowserURLImpl(to);
        }
        let history = {
            get action () {
                return action;
            },
            get location () {
                return getLocation(window2, globalHistory);
            },
            listen (fn) {
                if (listener) {
                    throw new Error("A history only accepts one active listener");
                }
                window2.addEventListener(PopStateEventType, handlePop);
                listener = fn;
                return ()=>{
                    window2.removeEventListener(PopStateEventType, handlePop);
                    listener = null;
                };
            },
            createHref (to) {
                return createHref2(window2, to);
            },
            createURL,
            encodeLocation (to) {
                let url = createURL(to);
                return {
                    pathname: url.pathname,
                    search: url.search,
                    hash: url.hash
                };
            },
            push,
            replace: replace2,
            go (n) {
                return globalHistory.go(n);
            }
        };
        return history;
    }
    function createBrowserURLImpl(to, isAbsolute = false) {
        let base = "http://localhost";
        if (typeof window !== "undefined") {
            base = window.location.origin !== "null" ? window.location.origin : window.location.href;
        }
        invariant$5(base, "No window.location.(origin|href) available to create URL");
        let href2 = typeof to === "string" ? to : createPath(to);
        href2 = href2.replace(/ $/, "%20");
        if (!isAbsolute && href2.startsWith("//")) {
            href2 = base + href2;
        }
        return new URL(href2, base);
    }
    function matchRoutes(routes, locationArg, basename = "/") {
        return matchRoutesImpl(routes, locationArg, basename, false);
    }
    function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
        let location = typeof locationArg === "string" ? parsePath$1(locationArg) : locationArg;
        let pathname = stripBasename(location.pathname || "/", basename);
        if (pathname == null) {
            return null;
        }
        let branches = flattenRoutes(routes);
        rankRouteBranches(branches);
        let matches = null;
        for(let i = 0; matches == null && i < branches.length; ++i){
            let decoded = decodePath(pathname);
            matches = matchRouteBranch(branches[i], decoded, allowPartial);
        }
        return matches;
    }
    function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
        let flattenRoute = (route, index, relativePath)=>{
            let meta = {
                relativePath: relativePath === void 0 ? route.path || "" : relativePath,
                caseSensitive: route.caseSensitive === true,
                childrenIndex: index,
                route
            };
            if (meta.relativePath.startsWith("/")) {
                invariant$5(meta.relativePath.startsWith(parentPath), `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`);
                meta.relativePath = meta.relativePath.slice(parentPath.length);
            }
            let path = joinPaths([
                parentPath,
                meta.relativePath
            ]);
            let routesMeta = parentsMeta.concat(meta);
            if (route.children && route.children.length > 0) {
                invariant$5(route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path "${path}".`);
                flattenRoutes(route.children, branches, routesMeta, path);
            }
            if (route.path == null && !route.index) {
                return;
            }
            branches.push({
                path,
                score: computeScore(path, route.index),
                routesMeta
            });
        };
        routes.forEach((route, index)=>{
            if (route.path === "" || !route.path?.includes("?")) {
                flattenRoute(route, index);
            } else {
                for (let exploded of explodeOptionalSegments(route.path)){
                    flattenRoute(route, index, exploded);
                }
            }
        });
        return branches;
    }
    function explodeOptionalSegments(path) {
        let segments = path.split("/");
        if (segments.length === 0) return [];
        let [first, ...rest] = segments;
        let isOptional = first.endsWith("?");
        let required = first.replace(/\?$/, "");
        if (rest.length === 0) {
            return isOptional ? [
                required,
                ""
            ] : [
                required
            ];
        }
        let restExploded = explodeOptionalSegments(rest.join("/"));
        let result = [];
        result.push(...restExploded.map((subpath)=>subpath === "" ? required : [
                required,
                subpath
            ].join("/")));
        if (isOptional) {
            result.push(...restExploded);
        }
        return result.map((exploded)=>path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
        branches.sort((a, b)=>a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));
    }
    var paramRe = /^:[\w-]+$/;
    var dynamicSegmentValue = 3;
    var indexRouteValue = 2;
    var emptySegmentValue = 1;
    var staticSegmentValue = 10;
    var splatPenalty = -2;
    var isSplat = (s)=>s === "*";
    function computeScore(path, index) {
        let segments = path.split("/");
        let initialScore = segments.length;
        if (segments.some(isSplat)) {
            initialScore += splatPenalty;
        }
        if (index) {
            initialScore += indexRouteValue;
        }
        return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b) {
        let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);
        return siblings ? (a[a.length - 1] - b[b.length - 1]) : (0);
    }
    function matchRouteBranch(branch, pathname, allowPartial = false) {
        let { routesMeta } = branch;
        let matchedParams = {};
        let matchedPathname = "/";
        let matches = [];
        for(let i = 0; i < routesMeta.length; ++i){
            let meta = routesMeta[i];
            let end = i === routesMeta.length - 1;
            let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
            let match = matchPath({
                path: meta.relativePath,
                caseSensitive: meta.caseSensitive,
                end
            }, remainingPathname);
            let route = meta.route;
            if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
                match = matchPath({
                    path: meta.relativePath,
                    caseSensitive: meta.caseSensitive,
                    end: false
                }, remainingPathname);
            }
            if (!match) {
                return null;
            }
            Object.assign(matchedParams, match.params);
            matches.push({
                params: matchedParams,
                pathname: joinPaths([
                    matchedPathname,
                    match.pathname
                ]),
                pathnameBase: normalizePathname(joinPaths([
                    matchedPathname,
                    match.pathnameBase
                ])),
                route
            });
            if (match.pathnameBase !== "/") {
                matchedPathname = joinPaths([
                    matchedPathname,
                    match.pathnameBase
                ]);
            }
        }
        return matches;
    }
    function matchPath(pattern, pathname) {
        if (typeof pattern === "string") {
            pattern = {
                path: pattern,
                caseSensitive: false,
                end: true
            };
        }
        let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
        let match = pathname.match(matcher);
        if (!match) return null;
        let matchedPathname = match[0];
        let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
        let captureGroups = match.slice(1);
        let params = compiledParams.reduce((memo2, { paramName, isOptional }, index)=>{
            if (paramName === "*") {
                let splatValue = captureGroups[index] || "";
                pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
            }
            const value = captureGroups[index];
            if (isOptional && !value) {
                memo2[paramName] = void 0;
            } else {
                memo2[paramName] = (value || "").replace(/%2F/g, "/");
            }
            return memo2;
        }, {});
        return {
            params,
            pathname: matchedPathname,
            pathnameBase,
            pattern
        };
    }
    function compilePath(path, caseSensitive = false, end = true) {
        warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`);
        let params = [];
        let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional)=>{
            params.push({
                paramName,
                isOptional: isOptional != null
            });
            return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
        });
        if (path.endsWith("*")) {
            params.push({
                paramName: "*"
            });
            regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
        } else if (end) {
            regexpSource += "\\/*$";
        } else if (path !== "" && path !== "/") {
            regexpSource += "(?:(?=\\/|$))";
        } else ;
        let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
        return [
            matcher,
            params
        ];
    }
    function decodePath(value) {
        try {
            return value.split("/").map((v)=>decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
        } catch (error) {
            warning(false, `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);
            return value;
        }
    }
    function stripBasename(pathname, basename) {
        if (basename === "/") return pathname;
        if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
            return null;
        }
        let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
        let nextChar = pathname.charAt(startIndex);
        if (nextChar && nextChar !== "/") {
            return null;
        }
        return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname = "/") {
        let { pathname: toPathname, search = "", hash = "" } = typeof to === "string" ? parsePath$1(to) : to;
        let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
        return {
            pathname,
            search: normalizeSearch(search),
            hash: normalizeHash(hash)
        };
    }
    function resolvePathname(relativePath, fromPathname) {
        let segments = fromPathname.replace(/\/+$/, "").split("/");
        let relativeSegments = relativePath.split("/");
        relativeSegments.forEach((segment)=>{
            if (segment === "..") {
                if (segments.length > 1) segments.pop();
            } else if (segment !== ".") {
                segments.push(segment);
            }
        });
        return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
        return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(path)}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
    }
    function getPathContributingMatches(matches) {
        return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);
    }
    function getResolveToMatches(matches) {
        let pathMatches = getPathContributingMatches(matches);
        return pathMatches.map((match, idx)=>idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
        let to;
        if (typeof toArg === "string") {
            to = parsePath$1(toArg);
        } else {
            to = {
                ...toArg
            };
            invariant$5(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
            invariant$5(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
            invariant$5(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
        }
        let isEmptyPath = toArg === "" || to.pathname === "";
        let toPathname = isEmptyPath ? "/" : to.pathname;
        let from;
        if (toPathname == null) {
            from = locationPathname;
        } else {
            let routePathnameIndex = routePathnames.length - 1;
            if (!isPathRelative && toPathname.startsWith("..")) {
                let toSegments = toPathname.split("/");
                while(toSegments[0] === ".."){
                    toSegments.shift();
                    routePathnameIndex -= 1;
                }
                to.pathname = toSegments.join("/");
            }
            from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
        }
        let path = resolvePath(to, from);
        let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
        let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
        if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
            path.pathname += "/";
        }
        return path;
    }
    var joinPaths = (paths)=>paths.join("/").replace(/\/\/+/g, "/");
    var normalizePathname = (pathname)=>pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    var normalizeSearch = (search)=>!search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    var normalizeHash = (hash)=>!hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function isRouteErrorResponse(error) {
        return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    var validMutationMethodsArr = [
        "POST",
        "PUT",
        "PATCH",
        "DELETE"
    ];
    new Set(validMutationMethodsArr);
    var validRequestMethodsArr = [
        "GET",
        ...validMutationMethodsArr
    ];
    new Set(validRequestMethodsArr);
    var DataRouterContext = reactExports.createContext(null);
    DataRouterContext.displayName = "DataRouter";
    var DataRouterStateContext = reactExports.createContext(null);
    DataRouterStateContext.displayName = "DataRouterState";
    var ViewTransitionContext = reactExports.createContext({
        isTransitioning: false
    });
    ViewTransitionContext.displayName = "ViewTransition";
    var FetchersContext = reactExports.createContext(new Map());
    FetchersContext.displayName = "Fetchers";
    var AwaitContext = reactExports.createContext(null);
    AwaitContext.displayName = "Await";
    var NavigationContext = reactExports.createContext(null);
    NavigationContext.displayName = "Navigation";
    var LocationContext = reactExports.createContext(null);
    LocationContext.displayName = "Location";
    var RouteContext = reactExports.createContext({
        outlet: null,
        matches: [],
        isDataRoute: false
    });
    RouteContext.displayName = "Route";
    var RouteErrorContext = reactExports.createContext(null);
    RouteErrorContext.displayName = "RouteError";
    function useHref(to, { relative } = {}) {
        invariant$5(useInRouterContext(), `useHref() may be used only in the context of a <Router> component.`);
        let { basename, navigator } = reactExports.useContext(NavigationContext);
        let { hash, pathname, search } = useResolvedPath(to, {
            relative
        });
        let joinedPathname = pathname;
        if (basename !== "/") {
            joinedPathname = pathname === "/" ? basename : joinPaths([
                basename,
                pathname
            ]);
        }
        return navigator.createHref({
            pathname: joinedPathname,
            search,
            hash
        });
    }
    function useInRouterContext() {
        return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
        invariant$5(useInRouterContext(), `useLocation() may be used only in the context of a <Router> component.`);
        return reactExports.useContext(LocationContext).location;
    }
    var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
    function useIsomorphicLayoutEffect(cb) {
        let isStatic = reactExports.useContext(NavigationContext).static;
        if (!isStatic) {
            reactExports.useLayoutEffect(cb);
        }
    }
    function useNavigate() {
        let { isDataRoute } = reactExports.useContext(RouteContext);
        return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
        invariant$5(useInRouterContext(), `useNavigate() may be used only in the context of a <Router> component.`);
        let dataRouterContext = reactExports.useContext(DataRouterContext);
        let { basename, navigator } = reactExports.useContext(NavigationContext);
        let { matches } = reactExports.useContext(RouteContext);
        let { pathname: locationPathname } = useLocation();
        let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
        let activeRef = reactExports.useRef(false);
        useIsomorphicLayoutEffect(()=>{
            activeRef.current = true;
        });
        let navigate = reactExports.useCallback((to, options = {})=>{
            warning(activeRef.current, navigateEffectWarning);
            if (!activeRef.current) return;
            if (typeof to === "number") {
                navigator.go(to);
                return;
            }
            let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
            if (dataRouterContext == null && basename !== "/") {
                path.pathname = path.pathname === "/" ? basename : joinPaths([
                    basename,
                    path.pathname
                ]);
            }
            (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
        }, [
            basename,
            navigator,
            routePathnamesJson,
            locationPathname,
            dataRouterContext
        ]);
        return navigate;
    }
    reactExports.createContext(null);
    function useParams() {
        let { matches } = reactExports.useContext(RouteContext);
        let routeMatch = matches[matches.length - 1];
        return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to, { relative } = {}) {
        let { matches } = reactExports.useContext(RouteContext);
        let { pathname: locationPathname } = useLocation();
        let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
        return reactExports.useMemo(()=>resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [
            to,
            routePathnamesJson,
            locationPathname,
            relative
        ]);
    }
    function useRoutes(routes, locationArg) {
        return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
        invariant$5(useInRouterContext(), `useRoutes() may be used only in the context of a <Router> component.`);
        let { navigator } = reactExports.useContext(NavigationContext);
        let { matches: parentMatches } = reactExports.useContext(RouteContext);
        let routeMatch = parentMatches[parentMatches.length - 1];
        let parentParams = routeMatch ? routeMatch.params : {};
        let parentPathname = routeMatch ? routeMatch.pathname : "/";
        let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
        let parentRoute = routeMatch && routeMatch.route;
        {
            let parentPath = parentRoute && parentRoute.path || "";
            warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`);
        }
        let locationFromContext = useLocation();
        let location;
        if (locationArg) {
            let parsedLocationArg = typeof locationArg === "string" ? parsePath$1(locationArg) : locationArg;
            invariant$5(parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`);
            location = parsedLocationArg;
        } else {
            location = locationFromContext;
        }
        let pathname = location.pathname || "/";
        let remainingPathname = pathname;
        if (parentPathnameBase !== "/") {
            let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
            let segments = pathname.replace(/^\//, "").split("/");
            remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
        }
        let matches = matchRoutes(routes, {
            pathname: remainingPathname
        });
        {
            warning(parentRoute || matches != null, `No routes matched location "${location.pathname}${location.search}${location.hash}" `);
            warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
        }
        let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {
                params: Object.assign({}, parentParams, match.params),
                pathname: joinPaths([
                    parentPathnameBase,
                    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname
                ]),
                pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
                    parentPathnameBase,
                    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
                ])
            })), parentMatches, dataRouterState, future);
        if (locationArg && renderedMatches) {
            return reactExports.createElement(LocationContext.Provider, {
                value: {
                    location: {
                        pathname: "/",
                        search: "",
                        hash: "",
                        state: null,
                        key: "default",
                        ...location
                    },
                    navigationType: "POP"
                }
            }, renderedMatches);
        }
        return renderedMatches;
    }
    function DefaultErrorComponent() {
        let error = useRouteError();
        let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
        let stack = error instanceof Error ? error.stack : null;
        let lightgrey = "rgba(200,200,200, 0.5)";
        let preStyles = {
            padding: "0.5rem",
            backgroundColor: lightgrey
        };
        let codeStyles = {
            padding: "2px 4px",
            backgroundColor: lightgrey
        };
        let devInfo = null;
        {
            console.error("Error handled by React Router default ErrorBoundary:", error);
            devInfo = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("p", null, "💿 Hey developer 👋"), reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", reactExports.createElement("code", {
                style: codeStyles
            }, "ErrorBoundary"), " or", " ", reactExports.createElement("code", {
                style: codeStyles
            }, "errorElement"), " prop on your route."));
        }
        return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
            style: {
                fontStyle: "italic"
            }
        }, message), stack ? reactExports.createElement("pre", {
            style: preStyles
        }, stack) : null, devInfo);
    }
    var defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
    var RenderErrorBoundary = class extends reactExports.Component {
        constructor(props){
            super(props);
            this.state = {
                location: props.location,
                revalidation: props.revalidation,
                error: props.error
            };
        }
        static getDerivedStateFromError(error) {
            return {
                error
            };
        }
        static getDerivedStateFromProps(props, state) {
            if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
                return {
                    error: props.error,
                    location: props.location,
                    revalidation: props.revalidation
                };
            }
            return {
                error: props.error !== void 0 ? props.error : state.error,
                location: state.location,
                revalidation: props.revalidation || state.revalidation
            };
        }
        componentDidCatch(error, errorInfo) {
            console.error("React Router caught the following error during render", error, errorInfo);
        }
        render() {
            return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
                value: this.props.routeContext
            }, reactExports.createElement(RouteErrorContext.Provider, {
                value: this.state.error,
                children: this.props.component
            })) : this.props.children;
        }
    };
    function RenderedRoute({ routeContext, match, children }) {
        let dataRouterContext = reactExports.useContext(DataRouterContext);
        if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
            dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
        }
        return reactExports.createElement(RouteContext.Provider, {
            value: routeContext
        }, children);
    }
    function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
        if (matches == null) {
            if (!dataRouterState) {
                return null;
            }
            if (dataRouterState.errors) {
                matches = dataRouterState.matches;
            } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
                matches = dataRouterState.matches;
            } else {
                return null;
            }
        }
        let renderedMatches = matches;
        let errors = dataRouterState?.errors;
        if (errors != null) {
            let errorIndex = renderedMatches.findIndex((m)=>m.route.id && errors?.[m.route.id] !== void 0);
            invariant$5(errorIndex >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(",")}`);
            renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
        }
        let renderFallback = false;
        let fallbackIndex = -1;
        if (dataRouterState) {
            for(let i = 0; i < renderedMatches.length; i++){
                let match = renderedMatches[i];
                if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
                    fallbackIndex = i;
                }
                if (match.route.id) {
                    let { loaderData, errors: errors2 } = dataRouterState;
                    let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
                    if (match.route.lazy || needsToRunLoader) {
                        renderFallback = true;
                        if (fallbackIndex >= 0) {
                            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
                        } else {
                            renderedMatches = [
                                renderedMatches[0]
                            ];
                        }
                        break;
                    }
                }
            }
        }
        return renderedMatches.reduceRight((outlet, match, index)=>{
            let error;
            let shouldRenderHydrateFallback = false;
            let errorElement = null;
            let hydrateFallbackElement = null;
            if (dataRouterState) {
                error = errors && match.route.id ? errors[match.route.id] : void 0;
                errorElement = match.route.errorElement || defaultErrorElement;
                if (renderFallback) {
                    if (fallbackIndex < 0 && index === 0) {
                        warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
                        shouldRenderHydrateFallback = true;
                        hydrateFallbackElement = null;
                    } else if (fallbackIndex === index) {
                        shouldRenderHydrateFallback = true;
                        hydrateFallbackElement = match.route.hydrateFallbackElement || null;
                    }
                }
            }
            let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
            let getChildren = ()=>{
                let children;
                if (error) {
                    children = errorElement;
                } else if (shouldRenderHydrateFallback) {
                    children = hydrateFallbackElement;
                } else if (match.route.Component) {
                    children = reactExports.createElement(match.route.Component, null);
                } else if (match.route.element) {
                    children = match.route.element;
                } else {
                    children = outlet;
                }
                return reactExports.createElement(RenderedRoute, {
                    match,
                    routeContext: {
                        outlet,
                        matches: matches2,
                        isDataRoute: dataRouterState != null
                    },
                    children
                });
            };
            return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? reactExports.createElement(RenderErrorBoundary, {
                location: dataRouterState.location,
                revalidation: dataRouterState.revalidation,
                component: errorElement,
                error,
                children: getChildren(),
                routeContext: {
                    outlet: null,
                    matches: matches2,
                    isDataRoute: true
                }
            }) : getChildren();
        }, null);
    }
    function getDataRouterConsoleError(hookName) {
        return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext(hookName) {
        let ctx = reactExports.useContext(DataRouterContext);
        invariant$5(ctx, getDataRouterConsoleError(hookName));
        return ctx;
    }
    function useDataRouterState(hookName) {
        let state = reactExports.useContext(DataRouterStateContext);
        invariant$5(state, getDataRouterConsoleError(hookName));
        return state;
    }
    function useRouteContext(hookName) {
        let route = reactExports.useContext(RouteContext);
        invariant$5(route, getDataRouterConsoleError(hookName));
        return route;
    }
    function useCurrentRouteId(hookName) {
        let route = useRouteContext(hookName);
        let thisRoute = route.matches[route.matches.length - 1];
        invariant$5(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique "id"`);
        return thisRoute.route.id;
    }
    function useRouteId() {
        return useCurrentRouteId("useRouteId");
    }
    function useRouteError() {
        let error = reactExports.useContext(RouteErrorContext);
        let state = useDataRouterState("useRouteError");
        let routeId = useCurrentRouteId("useRouteError");
        if (error !== void 0) {
            return error;
        }
        return state.errors?.[routeId];
    }
    function useNavigateStable() {
        let { router } = useDataRouterContext("useNavigate");
        let id = useCurrentRouteId("useNavigate");
        let activeRef = reactExports.useRef(false);
        useIsomorphicLayoutEffect(()=>{
            activeRef.current = true;
        });
        let navigate = reactExports.useCallback(async (to, options = {})=>{
            warning(activeRef.current, navigateEffectWarning);
            if (!activeRef.current) return;
            if (typeof to === "number") {
                router.navigate(to);
            } else {
                await router.navigate(to, {
                    fromRouteId: id,
                    ...options
                });
            }
        }, [
            router,
            id
        ]);
        return navigate;
    }
    var alreadyWarned = {};
    function warningOnce(key, cond, message) {
        if (!cond && !alreadyWarned[key]) {
            alreadyWarned[key] = true;
            warning(false, message);
        }
    }
    reactExports.memo(DataRoutes);
    function DataRoutes({ routes, future, state }) {
        return useRoutesImpl(routes, void 0, state, future);
    }
    function Route(_props) {
        invariant$5(false, `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`);
    }
    function Router({ basename: basenameProp = "/", children = null, location: locationProp, navigationType = "POP", navigator, static: staticProp = false }) {
        invariant$5(!useInRouterContext(), `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`);
        let basename = basenameProp.replace(/^\/*/, "/");
        let navigationContext = reactExports.useMemo(()=>({
                basename,
                navigator,
                static: staticProp,
                future: {}
            }), [
            basename,
            navigator,
            staticProp
        ]);
        if (typeof locationProp === "string") {
            locationProp = parsePath$1(locationProp);
        }
        let { pathname = "/", search = "", hash = "", state = null, key = "default" } = locationProp;
        let locationContext = reactExports.useMemo(()=>{
            let trailingPathname = stripBasename(pathname, basename);
            if (trailingPathname == null) {
                return null;
            }
            return {
                location: {
                    pathname: trailingPathname,
                    search,
                    hash,
                    state,
                    key
                },
                navigationType
            };
        }, [
            basename,
            pathname,
            search,
            hash,
            state,
            key,
            navigationType
        ]);
        warning(locationContext != null, `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`);
        if (locationContext == null) {
            return null;
        }
        return reactExports.createElement(NavigationContext.Provider, {
            value: navigationContext
        }, reactExports.createElement(LocationContext.Provider, {
            children,
            value: locationContext
        }));
    }
    function Routes({ children, location }) {
        return useRoutes(createRoutesFromChildren(children), location);
    }
    function createRoutesFromChildren(children, parentPath = []) {
        let routes = [];
        reactExports.Children.forEach(children, (element, index)=>{
            if (!reactExports.isValidElement(element)) {
                return;
            }
            let treePath = [
                ...parentPath,
                index
            ];
            if (element.type === reactExports.Fragment) {
                routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
                return;
            }
            invariant$5(element.type === Route, `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`);
            invariant$5(!element.props.index || !element.props.children, "An index route cannot have child routes.");
            let route = {
                id: element.props.id || treePath.join("-"),
                caseSensitive: element.props.caseSensitive,
                element: element.props.element,
                Component: element.props.Component,
                index: element.props.index,
                path: element.props.path,
                loader: element.props.loader,
                action: element.props.action,
                hydrateFallbackElement: element.props.hydrateFallbackElement,
                HydrateFallback: element.props.HydrateFallback,
                errorElement: element.props.errorElement,
                ErrorBoundary: element.props.ErrorBoundary,
                hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
                shouldRevalidate: element.props.shouldRevalidate,
                handle: element.props.handle,
                lazy: element.props.lazy
            };
            if (element.props.children) {
                route.children = createRoutesFromChildren(element.props.children, treePath);
            }
            routes.push(route);
        });
        return routes;
    }
    var defaultMethod = "get";
    var defaultEncType = "application/x-www-form-urlencoded";
    function isHtmlElement(object) {
        return object != null && typeof object.tagName === "string";
    }
    function isButtonElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
    }
    function isFormElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
    }
    function isInputElement(object) {
        return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
    }
    function isModifiedEvent(event) {
        return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
        return event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event);
    }
    function createSearchParams(init = "") {
        return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key)=>{
            let value = init[key];
            return memo2.concat(Array.isArray(value) ? value.map((v)=>[
                    key,
                    v
                ]) : [
                [
                    key,
                    value
                ]
            ]);
        }, []));
    }
    function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
        let searchParams = createSearchParams(locationSearch);
        if (defaultSearchParams) {
            defaultSearchParams.forEach((_, key)=>{
                if (!searchParams.has(key)) {
                    defaultSearchParams.getAll(key).forEach((value)=>{
                        searchParams.append(key, value);
                    });
                }
            });
        }
        return searchParams;
    }
    var _formDataSupportsSubmitter = null;
    function isFormDataSubmitterSupported() {
        if (_formDataSupportsSubmitter === null) {
            try {
                new FormData(document.createElement("form"), 0);
                _formDataSupportsSubmitter = false;
            } catch (e) {
                _formDataSupportsSubmitter = true;
            }
        }
        return _formDataSupportsSubmitter;
    }
    var supportedFormEncTypes = new Set([
        "application/x-www-form-urlencoded",
        "multipart/form-data",
        "text/plain"
    ]);
    function getFormEncType(encType) {
        if (encType != null && !supportedFormEncTypes.has(encType)) {
            warning(false, `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`);
            return null;
        }
        return encType;
    }
    function getFormSubmissionInfo(target, basename) {
        let method;
        let action;
        let encType;
        let formData;
        let body;
        if (isFormElement(target)) {
            let attr = target.getAttribute("action");
            action = attr ? stripBasename(attr, basename) : null;
            method = target.getAttribute("method") || defaultMethod;
            encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
            formData = new FormData(target);
        } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
            let form = target.form;
            if (form == null) {
                throw new Error(`Cannot submit a <button> or <input type="submit"> without a <form>`);
            }
            let attr = target.getAttribute("formaction") || form.getAttribute("action");
            action = attr ? stripBasename(attr, basename) : null;
            method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
            encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
            formData = new FormData(form, target);
            if (!isFormDataSubmitterSupported()) {
                let { name, type, value } = target;
                if (type === "image") {
                    let prefix = name ? `${name}.` : "";
                    formData.append(`${prefix}x`, "0");
                    formData.append(`${prefix}y`, "0");
                } else if (name) {
                    formData.append(name, value);
                }
            }
        } else if (isHtmlElement(target)) {
            throw new Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`);
        } else {
            method = defaultMethod;
            action = null;
            encType = defaultEncType;
            body = target;
        }
        if (formData && encType === "text/plain") {
            body = formData;
            formData = void 0;
        }
        return {
            action,
            method: method.toLowerCase(),
            encType,
            formData,
            body
        };
    }
    function invariant2(value, message) {
        if (value === false || value === null || typeof value === "undefined") {
            throw new Error(message);
        }
    }
    async function loadRouteModule(route, routeModulesCache) {
        if (route.id in routeModulesCache) {
            return routeModulesCache[route.id];
        }
        try {
            let routeModule = await import(route.module).then(async (m)=>{
                await m.__tla;
                return m;
            });
            routeModulesCache[route.id] = routeModule;
            return routeModule;
        } catch (error) {
            console.error(`Error loading route module \`${route.module}\`, reloading page...`);
            console.error(error);
            if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && void 0) ;
            window.location.reload();
            return new Promise(()=>{});
        }
    }
    function isHtmlLinkDescriptor(object) {
        if (object == null) {
            return false;
        }
        if (object.href == null) {
            return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
        }
        return typeof object.rel === "string" && typeof object.href === "string";
    }
    async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
        let links = await Promise.all(matches.map(async (match)=>{
            let route = manifest.routes[match.route.id];
            if (route) {
                let mod = await loadRouteModule(route, routeModules);
                return mod.links ? mod.links() : [];
            }
            return [];
        }));
        return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter((link)=>link.rel === "stylesheet" || link.rel === "preload").map((link)=>link.rel === "stylesheet" ? {
                ...link,
                rel: "prefetch",
                as: "style"
            } : {
                ...link,
                rel: "prefetch"
            }));
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
        let isNew = (match, index)=>{
            if (!currentMatches[index]) return true;
            return match.route.id !== currentMatches[index].route.id;
        };
        let matchPathChanged = (match, index)=>{
            return (currentMatches[index].pathname !== match.pathname || currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]);
        };
        if (mode === "assets") {
            return nextMatches.filter((match, index)=>isNew(match, index) || matchPathChanged(match, index));
        }
        if (mode === "data") {
            return nextMatches.filter((match, index)=>{
                let manifestRoute = manifest.routes[match.route.id];
                if (!manifestRoute || !manifestRoute.hasLoader) {
                    return false;
                }
                if (isNew(match, index) || matchPathChanged(match, index)) {
                    return true;
                }
                if (match.route.shouldRevalidate) {
                    let routeChoice = match.route.shouldRevalidate({
                        currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
                        currentParams: currentMatches[0]?.params || {},
                        nextUrl: new URL(page, window.origin),
                        nextParams: match.params,
                        defaultShouldRevalidate: true
                    });
                    if (typeof routeChoice === "boolean") {
                        return routeChoice;
                    }
                }
                return true;
            });
        }
        return [];
    }
    function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
        return dedupeHrefs(matches.map((match)=>{
            let route = manifest.routes[match.route.id];
            if (!route) return [];
            let hrefs = [
                route.module
            ];
            if (route.clientActionModule) {
                hrefs = hrefs.concat(route.clientActionModule);
            }
            if (route.clientLoaderModule) {
                hrefs = hrefs.concat(route.clientLoaderModule);
            }
            if (includeHydrateFallback && route.hydrateFallbackModule) {
                hrefs = hrefs.concat(route.hydrateFallbackModule);
            }
            if (route.imports) {
                hrefs = hrefs.concat(route.imports);
            }
            return hrefs;
        }).flat(1));
    }
    function dedupeHrefs(hrefs) {
        return [
            ...new Set(hrefs)
        ];
    }
    function sortKeys(obj) {
        let sorted = {};
        let keys = Object.keys(obj).sort();
        for (let key of keys){
            sorted[key] = obj[key];
        }
        return sorted;
    }
    function dedupeLinkDescriptors(descriptors, preloads) {
        let set = new Set();
        new Set(preloads);
        return descriptors.reduce((deduped, descriptor)=>{
            let key = JSON.stringify(sortKeys(descriptor));
            if (!set.has(key)) {
                set.add(key);
                deduped.push({
                    key,
                    link: descriptor
                });
            }
            return deduped;
        }, []);
    }
    Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
    var NO_BODY_STATUS_CODES = new Set([
        100,
        101,
        204,
        205
    ]);
    function singleFetchUrl(reqUrl, basename) {
        let url = typeof reqUrl === "string" ? new URL(reqUrl, typeof window === "undefined" ? "server://singlefetch/" : window.location.origin) : reqUrl;
        if (url.pathname === "/") {
            url.pathname = "_root.data";
        } else if (basename && stripBasename(url.pathname, basename) === "/") {
            url.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
        } else {
            url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
        }
        return url;
    }
    function useDataRouterContext2() {
        let context = reactExports.useContext(DataRouterContext);
        invariant2(context, "You must render this element inside a <DataRouterContext.Provider> element");
        return context;
    }
    function useDataRouterStateContext() {
        let context = reactExports.useContext(DataRouterStateContext);
        invariant2(context, "You must render this element inside a <DataRouterStateContext.Provider> element");
        return context;
    }
    var FrameworkContext = reactExports.createContext(void 0);
    FrameworkContext.displayName = "FrameworkContext";
    function useFrameworkContext() {
        let context = reactExports.useContext(FrameworkContext);
        invariant2(context, "You must render this element inside a <HydratedRouter> element");
        return context;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
        let frameworkContext = reactExports.useContext(FrameworkContext);
        let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
        let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
        let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
        let ref = reactExports.useRef(null);
        reactExports.useEffect(()=>{
            if (prefetch === "render") {
                setShouldPrefetch(true);
            }
            if (prefetch === "viewport") {
                let callback = (entries)=>{
                    entries.forEach((entry)=>{
                        setShouldPrefetch(entry.isIntersecting);
                    });
                };
                let observer = new IntersectionObserver(callback, {
                    threshold: 0.5
                });
                if (ref.current) observer.observe(ref.current);
                return ()=>{
                    observer.disconnect();
                };
            }
        }, [
            prefetch
        ]);
        reactExports.useEffect(()=>{
            if (maybePrefetch) {
                let id = setTimeout(()=>{
                    setShouldPrefetch(true);
                }, 100);
                return ()=>{
                    clearTimeout(id);
                };
            }
        }, [
            maybePrefetch
        ]);
        let setIntent = ()=>{
            setMaybePrefetch(true);
        };
        let cancelIntent = ()=>{
            setMaybePrefetch(false);
            setShouldPrefetch(false);
        };
        if (!frameworkContext) {
            return [
                false,
                ref,
                {}
            ];
        }
        if (prefetch !== "intent") {
            return [
                shouldPrefetch,
                ref,
                {}
            ];
        }
        return [
            shouldPrefetch,
            ref,
            {
                onFocus: composeEventHandlers(onFocus, setIntent),
                onBlur: composeEventHandlers(onBlur, cancelIntent),
                onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
                onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
                onTouchStart: composeEventHandlers(onTouchStart, setIntent)
            }
        ];
    }
    function composeEventHandlers(theirHandler, ourHandler) {
        return (event)=>{
            theirHandler && theirHandler(event);
            if (!event.defaultPrevented) {
                ourHandler(event);
            }
        };
    }
    function PrefetchPageLinks({ page, ...dataLinkProps }) {
        let { router } = useDataRouterContext2();
        let matches = reactExports.useMemo(()=>matchRoutes(router.routes, page, router.basename), [
            router.routes,
            page,
            router.basename
        ]);
        if (!matches) {
            return null;
        }
        return reactExports.createElement(PrefetchPageLinksImpl, {
            page,
            matches,
            ...dataLinkProps
        });
    }
    function useKeyedPrefetchLinks(matches) {
        let { manifest, routeModules } = useFrameworkContext();
        let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
        reactExports.useEffect(()=>{
            let interrupted = false;
            void getKeyedPrefetchLinks(matches, manifest, routeModules).then((links)=>{
                if (!interrupted) {
                    setKeyedPrefetchLinks(links);
                }
            });
            return ()=>{
                interrupted = true;
            };
        }, [
            matches,
            manifest,
            routeModules
        ]);
        return keyedPrefetchLinks;
    }
    function PrefetchPageLinksImpl({ page, matches: nextMatches, ...linkProps }) {
        let location = useLocation();
        let { manifest, routeModules } = useFrameworkContext();
        let { basename } = useDataRouterContext2();
        let { loaderData, matches } = useDataRouterStateContext();
        let newMatchesForData = reactExports.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [
            page,
            nextMatches,
            matches,
            manifest,
            location
        ]);
        let newMatchesForAssets = reactExports.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [
            page,
            nextMatches,
            matches,
            manifest,
            location
        ]);
        let dataHrefs = reactExports.useMemo(()=>{
            if (page === location.pathname + location.search + location.hash) {
                return [];
            }
            let routesParams = new Set();
            let foundOptOutRoute = false;
            nextMatches.forEach((m)=>{
                let manifestRoute = manifest.routes[m.route.id];
                if (!manifestRoute || !manifestRoute.hasLoader) {
                    return;
                }
                if (!newMatchesForData.some((m2)=>m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
                    foundOptOutRoute = true;
                } else if (manifestRoute.hasClientLoader) {
                    foundOptOutRoute = true;
                } else {
                    routesParams.add(m.route.id);
                }
            });
            if (routesParams.size === 0) {
                return [];
            }
            let url = singleFetchUrl(page, basename);
            if (foundOptOutRoute && routesParams.size > 0) {
                url.searchParams.set("_routes", nextMatches.filter((m)=>routesParams.has(m.route.id)).map((m)=>m.route.id).join(","));
            }
            return [
                url.pathname + url.search
            ];
        }, [
            basename,
            loaderData,
            location,
            manifest,
            newMatchesForData,
            nextMatches,
            page,
            routeModules
        ]);
        let moduleHrefs = reactExports.useMemo(()=>getModuleLinkHrefs(newMatchesForAssets, manifest), [
            newMatchesForAssets,
            manifest
        ]);
        let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
        return reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href2)=>reactExports.createElement("link", {
                key: href2,
                rel: "prefetch",
                as: "fetch",
                href: href2,
                ...linkProps
            })), moduleHrefs.map((href2)=>reactExports.createElement("link", {
                key: href2,
                rel: "modulepreload",
                href: href2,
                ...linkProps
            })), keyedPrefetchLinks.map(({ key, link })=>(reactExports.createElement("link", {
                key,
                ...link
            }))));
    }
    function mergeRefs(...refs) {
        return (value)=>{
            refs.forEach((ref)=>{
                if (typeof ref === "function") {
                    ref(value);
                } else if (ref != null) {
                    ref.current = value;
                }
            });
        };
    }
    var isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    try {
        if (isBrowser$1) {
            window.__reactRouterVersion = "7.6.1";
        }
    } catch (e) {}
    function BrowserRouter({ basename, children, window: window2 }) {
        let historyRef = reactExports.useRef();
        if (historyRef.current == null) {
            historyRef.current = createBrowserHistory({
                window: window2,
                v5Compat: true
            });
        }
        let history = historyRef.current;
        let [state, setStateImpl] = reactExports.useState({
            action: history.action,
            location: history.location
        });
        let setState = reactExports.useCallback((newState)=>{
            reactExports.startTransition(()=>setStateImpl(newState));
        }, [
            setStateImpl
        ]);
        reactExports.useLayoutEffect(()=>history.listen(setState), [
            history,
            setState
        ]);
        return reactExports.createElement(Router, {
            basename,
            children,
            location: state.location,
            navigationType: state.action,
            navigator: history
        });
    }
    var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    var Link = reactExports.forwardRef(function LinkWithRef({ onClick, discover = "render", prefetch = "none", relative, reloadDocument, replace: replace2, state, target, to, preventScrollReset, viewTransition, ...rest }, forwardedRef) {
        let { basename } = reactExports.useContext(NavigationContext);
        let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
        let absoluteHref;
        let isExternal = false;
        if (typeof to === "string" && isAbsolute) {
            absoluteHref = to;
            if (isBrowser$1) {
                try {
                    let currentUrl = new URL(window.location.href);
                    let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
                    let path = stripBasename(targetUrl.pathname, basename);
                    if (targetUrl.origin === currentUrl.origin && path != null) {
                        to = path + targetUrl.search + targetUrl.hash;
                    } else {
                        isExternal = true;
                    }
                } catch (e) {
                    warning(false, `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);
                }
            }
        }
        let href2 = useHref(to, {
            relative
        });
        let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);
        let internalOnClick = useLinkClickHandler(to, {
            replace: replace2,
            state,
            target,
            preventScrollReset,
            relative,
            viewTransition
        });
        function handleClick(event) {
            if (onClick) onClick(event);
            if (!event.defaultPrevented) {
                internalOnClick(event);
            }
        }
        let link = (reactExports.createElement("a", {
            ...rest,
            ...prefetchHandlers,
            href: absoluteHref || href2,
            onClick: isExternal || reloadDocument ? onClick : handleClick,
            ref: mergeRefs(forwardedRef, prefetchRef),
            target,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }));
        return shouldPrefetch && !isAbsolute ? reactExports.createElement(reactExports.Fragment, null, link, reactExports.createElement(PrefetchPageLinks, {
            page: href2
        })) : link;
    });
    Link.displayName = "Link";
    var NavLink = reactExports.forwardRef(function NavLinkWithRef({ "aria-current": ariaCurrentProp = "page", caseSensitive = false, className: classNameProp = "", end = false, style: styleProp, to, viewTransition, children, ...rest }, ref) {
        let path = useResolvedPath(to, {
            relative: rest.relative
        });
        let location = useLocation();
        let routerState = reactExports.useContext(DataRouterStateContext);
        let { navigator, basename } = reactExports.useContext(NavigationContext);
        let isTransitioning = routerState != null && useViewTransitionState(path) && viewTransition === true;
        let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
        let locationPathname = location.pathname;
        let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
        if (!caseSensitive) {
            locationPathname = locationPathname.toLowerCase();
            nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
            toPathname = toPathname.toLowerCase();
        }
        if (nextLocationPathname && basename) {
            nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
        }
        const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
        let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
        let renderProps = {
            isActive,
            isPending,
            isTransitioning
        };
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
            className = classNameProp(renderProps);
        } else {
            className = [
                classNameProp,
                isActive ? "active" : null,
                isPending ? "pending" : null,
                isTransitioning ? "transitioning" : null
            ].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
        return reactExports.createElement(Link, {
            ...rest,
            "aria-current": ariaCurrent,
            className,
            ref,
            style,
            to,
            viewTransition
        }, typeof children === "function" ? children(renderProps) : children);
    });
    NavLink.displayName = "NavLink";
    var Form = reactExports.forwardRef(({ discover = "render", fetcherKey, navigate, reloadDocument, replace: replace2, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, viewTransition, ...props }, forwardedRef)=>{
        let submit = useSubmit();
        let formAction = useFormAction(action, {
            relative
        });
        let formMethod = method.toLowerCase() === "get" ? "get" : "post";
        let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
        let submitHandler = (event)=>{
            onSubmit && onSubmit(event);
            if (event.defaultPrevented) return;
            event.preventDefault();
            let submitter = event.nativeEvent.submitter;
            let submitMethod = submitter?.getAttribute("formmethod") || method;
            submit(submitter || event.currentTarget, {
                fetcherKey,
                method: submitMethod,
                navigate,
                replace: replace2,
                state,
                relative,
                preventScrollReset,
                viewTransition
            });
        };
        return reactExports.createElement("form", {
            ref: forwardedRef,
            method: formMethod,
            action: formAction,
            onSubmit: reloadDocument ? onSubmit : submitHandler,
            ...props,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        });
    });
    Form.displayName = "Form";
    function getDataRouterConsoleError2(hookName) {
        return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
    }
    function useDataRouterContext3(hookName) {
        let ctx = reactExports.useContext(DataRouterContext);
        invariant$5(ctx, getDataRouterConsoleError2(hookName));
        return ctx;
    }
    function useLinkClickHandler(to, { target, replace: replaceProp, state, preventScrollReset, relative, viewTransition } = {}) {
        let navigate = useNavigate();
        let location = useLocation();
        let path = useResolvedPath(to, {
            relative
        });
        return reactExports.useCallback((event)=>{
            if (shouldProcessLinkClick(event, target)) {
                event.preventDefault();
                let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
                navigate(to, {
                    replace: replace2,
                    state,
                    preventScrollReset,
                    relative,
                    viewTransition
                });
            }
        }, [
            location,
            navigate,
            path,
            replaceProp,
            state,
            target,
            to,
            preventScrollReset,
            relative,
            viewTransition
        ]);
    }
    function useSearchParams(defaultInit) {
        warning(typeof URLSearchParams !== "undefined", `You cannot use the \`useSearchParams\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`);
        let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
        let hasSetSearchParamsRef = reactExports.useRef(false);
        let location = useLocation();
        let searchParams = reactExports.useMemo(()=>(getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)), [
            location.search
        ]);
        let navigate = useNavigate();
        let setSearchParams = reactExports.useCallback((nextInit, navigateOptions)=>{
            const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
            hasSetSearchParamsRef.current = true;
            navigate("?" + newSearchParams, navigateOptions);
        }, [
            navigate,
            searchParams
        ]);
        return [
            searchParams,
            setSearchParams
        ];
    }
    var fetcherId = 0;
    var getUniqueFetcherId = ()=>`__${String(++fetcherId)}__`;
    function useSubmit() {
        let { router } = useDataRouterContext3("useSubmit");
        let { basename } = reactExports.useContext(NavigationContext);
        let currentRouteId = useRouteId();
        return reactExports.useCallback(async (target, options = {})=>{
            let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);
            if (options.navigate === false) {
                let key = options.fetcherKey || getUniqueFetcherId();
                await router.fetch(key, currentRouteId, options.action || action, {
                    preventScrollReset: options.preventScrollReset,
                    formData,
                    body,
                    formMethod: options.method || method,
                    formEncType: options.encType || encType,
                    flushSync: options.flushSync
                });
            } else {
                await router.navigate(options.action || action, {
                    preventScrollReset: options.preventScrollReset,
                    formData,
                    body,
                    formMethod: options.method || method,
                    formEncType: options.encType || encType,
                    replace: options.replace,
                    state: options.state,
                    fromRouteId: currentRouteId,
                    flushSync: options.flushSync,
                    viewTransition: options.viewTransition
                });
            }
        }, [
            router,
            basename,
            currentRouteId
        ]);
    }
    function useFormAction(action, { relative } = {}) {
        let { basename } = reactExports.useContext(NavigationContext);
        let routeContext = reactExports.useContext(RouteContext);
        invariant$5(routeContext, "useFormAction must be used inside a RouteContext");
        let [match] = routeContext.matches.slice(-1);
        let path = {
            ...useResolvedPath(action ? action : ".", {
                relative
            })
        };
        let location = useLocation();
        if (action == null) {
            path.search = location.search;
            let params = new URLSearchParams(path.search);
            let indexValues = params.getAll("index");
            let hasNakedIndexParam = indexValues.some((v)=>v === "");
            if (hasNakedIndexParam) {
                params.delete("index");
                indexValues.filter((v)=>v).forEach((v)=>params.append("index", v));
                let qs = params.toString();
                path.search = qs ? `?${qs}` : "";
            }
        }
        if ((!action || action === ".") && match.route.index) {
            path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
        }
        if (basename !== "/") {
            path.pathname = path.pathname === "/" ? basename : joinPaths([
                basename,
                path.pathname
            ]);
        }
        return createPath(path);
    }
    function useViewTransitionState(to, opts = {}) {
        let vtContext = reactExports.useContext(ViewTransitionContext);
        invariant$5(vtContext != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
        let { basename } = useDataRouterContext3("useViewTransitionState");
        let path = useResolvedPath(to, {
            relative: opts.relative
        });
        if (!vtContext.isTransitioning) {
            return false;
        }
        let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
        let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
        return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
    }
    new Set([
        ...NO_BODY_STATUS_CODES,
        304
    ]);
    var reactDomExports = requireReactDom();
    const ReactDOM = getDefaultExportFromCjs(reactDomExports);
    const common$1 = {
        black: '#000',
        white: '#fff'
    };
    const red = {
        300: '#e57373',
        400: '#ef5350',
        500: '#f44336',
        700: '#d32f2f',
        800: '#c62828'
    };
    const purple = {
        50: '#f3e5f5',
        200: '#ce93d8',
        300: '#ba68c8',
        400: '#ab47bc',
        500: '#9c27b0',
        700: '#7b1fa2'
    };
    const blue = {
        50: '#e3f2fd',
        200: '#90caf9',
        400: '#42a5f5',
        700: '#1976d2',
        800: '#1565c0'
    };
    const lightBlue = {
        300: '#4fc3f7',
        400: '#29b6f6',
        500: '#03a9f4',
        700: '#0288d1',
        900: '#01579b'
    };
    const green = {
        300: '#81c784',
        400: '#66bb6a',
        500: '#4caf50',
        700: '#388e3c',
        800: '#2e7d32',
        900: '#1b5e20'
    };
    const orange = {
        300: '#ffb74d',
        400: '#ffa726',
        500: '#ff9800',
        700: '#f57c00',
        900: '#e65100'
    };
    const grey = {
        50: '#fafafa',
        100: '#f5f5f5',
        200: '#eeeeee',
        300: '#e0e0e0',
        400: '#bdbdbd',
        500: '#9e9e9e',
        600: '#757575',
        700: '#616161',
        800: '#424242',
        900: '#212121',
        A100: '#f5f5f5',
        A200: '#eeeeee',
        A400: '#bdbdbd',
        A700: '#616161'
    };
    function formatMuiErrorMessage(code, ...args) {
        const url = new URL(`https://mui.com/production-error/?code=${code}`);
        args.forEach((arg)=>url.searchParams.append('args[]', arg));
        return `Minified MUI error #${code}; visit ${url} for the full message.`;
    }
    const THEME_ID = '$$material';
    function _extends() {
        return _extends = Object.assign ? Object.assign.bind() : function(n) {
            for(var e = 1; e < arguments.length; e++){
                var t = arguments[e];
                for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
            }
            return n;
        }, _extends.apply(null, arguments);
    }
    function sheetForTag(tag) {
        if (tag.sheet) {
            return tag.sheet;
        }
        for(var i = 0; i < document.styleSheets.length; i++){
            if (document.styleSheets[i].ownerNode === tag) {
                return document.styleSheets[i];
            }
        }
        return undefined;
    }
    function createStyleElement(options) {
        var tag = document.createElement('style');
        tag.setAttribute('data-emotion', options.key);
        if (options.nonce !== undefined) {
            tag.setAttribute('nonce', options.nonce);
        }
        tag.appendChild(document.createTextNode(''));
        tag.setAttribute('data-s', '');
        return tag;
    }
    var StyleSheet = function() {
        function StyleSheet(options) {
            var _this = this;
            this._insertTag = function(tag) {
                var before;
                if (_this.tags.length === 0) {
                    if (_this.insertionPoint) {
                        before = _this.insertionPoint.nextSibling;
                    } else if (_this.prepend) {
                        before = _this.container.firstChild;
                    } else {
                        before = _this.before;
                    }
                } else {
                    before = _this.tags[_this.tags.length - 1].nextSibling;
                }
                _this.container.insertBefore(tag, before);
                _this.tags.push(tag);
            };
            this.isSpeedy = options.speedy === undefined ? true : options.speedy;
            this.tags = [];
            this.ctr = 0;
            this.nonce = options.nonce;
            this.key = options.key;
            this.container = options.container;
            this.prepend = options.prepend;
            this.insertionPoint = options.insertionPoint;
            this.before = null;
        }
        var _proto = StyleSheet.prototype;
        _proto.hydrate = function hydrate(nodes) {
            nodes.forEach(this._insertTag);
        };
        _proto.insert = function insert(rule) {
            if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
                this._insertTag(createStyleElement(this));
            }
            var tag = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
                var sheet = sheetForTag(tag);
                try {
                    sheet.insertRule(rule, sheet.cssRules.length);
                } catch (e) {}
            } else {
                tag.appendChild(document.createTextNode(rule));
            }
            this.ctr++;
        };
        _proto.flush = function flush() {
            this.tags.forEach(function(tag) {
                var _tag$parentNode;
                return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
            });
            this.tags = [];
            this.ctr = 0;
        };
        return StyleSheet;
    }();
    var MS = '-ms-';
    var MOZ = '-moz-';
    var WEBKIT = '-webkit-';
    var COMMENT = 'comm';
    var RULESET = 'rule';
    var DECLARATION = 'decl';
    var IMPORT = '@import';
    var KEYFRAMES = '@keyframes';
    var LAYER = '@layer';
    var abs = Math.abs;
    var from$2 = String.fromCharCode;
    var assign = Object.assign;
    function hash(value, length) {
        return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0;
    }
    function trim(value) {
        return value.trim();
    }
    function match(value, pattern) {
        return (value = pattern.exec(value)) ? value[0] : value;
    }
    function replace(value, pattern, replacement) {
        return value.replace(pattern, replacement);
    }
    function indexof(value, search) {
        return value.indexOf(search);
    }
    function charat(value, index) {
        return value.charCodeAt(index) | 0;
    }
    function substr(value, begin, end) {
        return value.slice(begin, end);
    }
    function strlen(value) {
        return value.length;
    }
    function sizeof(value) {
        return value.length;
    }
    function append(value, array) {
        return array.push(value), value;
    }
    function combine(array, callback) {
        return array.map(callback).join('');
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = '';
    function node(value, root, parent, type, props, children, length) {
        return {
            value: value,
            root: root,
            parent: parent,
            type: type,
            props: props,
            children: children,
            line: line,
            column: column,
            length: length,
            return: ''
        };
    }
    function copy$1(root, props) {
        return assign(node('', null, null, '', null, null, 0), root, {
            length: -root.length
        }, props);
    }
    function char() {
        return character;
    }
    function prev() {
        character = position > 0 ? charat(characters, --position) : 0;
        if (column--, character === 10) column = 1, line--;
        return character;
    }
    function next() {
        character = position < length ? charat(characters, position++) : 0;
        if (column++, character === 10) column = 1, line++;
        return character;
    }
    function peek() {
        return charat(characters, position);
    }
    function caret() {
        return position;
    }
    function slice$1(begin, end) {
        return substr(characters, begin, end);
    }
    function token(type) {
        switch(type){
            case 0:
            case 9:
            case 10:
            case 13:
            case 32:
                return 5;
            case 33:
            case 43:
            case 44:
            case 47:
            case 62:
            case 64:
            case 126:
            case 59:
            case 123:
            case 125:
                return 4;
            case 58:
                return 3;
            case 34:
            case 39:
            case 40:
            case 91:
                return 2;
            case 41:
            case 93:
                return 1;
        }
        return 0;
    }
    function alloc(value) {
        return line = column = 1, length = strlen(characters = value), position = 0, [];
    }
    function dealloc(value) {
        return characters = '', value;
    }
    function delimit(type) {
        return trim(slice$1(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
    }
    function whitespace(type) {
        while(character = peek())if (character < 33) next();
        else break;
        return token(type) > 2 || token(character) > 3 ? '' : ' ';
    }
    function escaping(index, count) {
        while(--count && next())if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97)) break;
        return slice$1(index, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type) {
        while(next())switch(character){
            case type:
                return position;
            case 34:
            case 39:
                if (type !== 34 && type !== 39) delimiter(character);
                break;
            case 40:
                if (type === 41) delimiter(type);
                break;
            case 92:
                next();
                break;
        }
        return position;
    }
    function commenter(type, index) {
        while(next())if (type + character === 47 + 10) break;
        else if (type + character === 42 + 42 && peek() === 47) break;
        return '/*' + slice$1(index, position - 1) + '*' + from$2(type === 47 ? type : next());
    }
    function identifier(index) {
        while(!token(peek()))next();
        return slice$1(index, position);
    }
    function compile(value) {
        return dealloc(parse$2('', null, null, null, [
            ''
        ], value = alloc(value), 0, [
            0
        ], value));
    }
    function parse$2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
        var index = 0;
        var offset = 0;
        var length = pseudo;
        var atrule = 0;
        var property = 0;
        var previous = 0;
        var variable = 1;
        var scanning = 1;
        var ampersand = 1;
        var character = 0;
        var type = '';
        var props = rules;
        var children = rulesets;
        var reference = rule;
        var characters = type;
        while(scanning)switch(previous = character, character = next()){
            case 40:
                if (previous != 108 && charat(characters, length - 1) == 58) {
                    if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1) ampersand = -1;
                    break;
                }
            case 34:
            case 39:
            case 91:
                characters += delimit(character);
                break;
            case 9:
            case 10:
            case 13:
            case 32:
                characters += whitespace(previous);
                break;
            case 92:
                characters += escaping(caret() - 1, 7);
                continue;
            case 47:
                switch(peek()){
                    case 42:
                    case 47:
                        append(comment(commenter(next(), caret()), root, parent), declarations);
                        break;
                    default:
                        characters += '/';
                }
                break;
            case 123 * variable:
                points[index++] = strlen(characters) * ampersand;
            case 125 * variable:
            case 59:
            case 0:
                switch(character){
                    case 0:
                    case 125:
                        scanning = 0;
                    case 59 + offset:
                        if (ampersand == -1) characters = replace(characters, /\f/g, '');
                        if (property > 0 && (strlen(characters) - length)) append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
                        break;
                    case 59:
                        characters += ';';
                    default:
                        append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
                        if (character === 123) if (offset === 0) parse$2(characters, root, reference, reference, props, rulesets, length, points, children);
                        else switch(atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule){
                            case 100:
                            case 108:
                            case 109:
                            case 115:
                                parse$2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
                                break;
                            default:
                                parse$2(characters, reference, reference, reference, [
                                    ''
                                ], children, 0, points, children);
                        }
                }
                index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
                break;
            case 58:
                length = 1 + strlen(characters), property = previous;
            default:
                if (variable < 1) if (character == 123) --variable;
                else if (character == 125 && variable++ == 0 && prev() == 125) continue;
                switch(characters += from$2(character), character * variable){
                    case 38:
                        ampersand = offset > 0 ? 1 : (characters += '\f', -1);
                        break;
                    case 44:
                        points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
                        break;
                    case 64:
                        if (peek() === 45) characters += delimit(next());
                        atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
                        break;
                    case 45:
                        if (previous === 45 && strlen(characters) == 2) variable = 0;
                }
        }
        return rulesets;
    }
    function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {
        var post = offset - 1;
        var rule = offset === 0 ? rules : [
            ''
        ];
        var size = sizeof(rule);
        for(var i = 0, j = 0, k = 0; i < index; ++i)for(var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
        return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);
    }
    function comment(value, root, parent) {
        return node(value, root, parent, COMMENT, from$2(char()), substr(value, 2, -2), 0);
    }
    function declaration(value, root, parent, length) {
        return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);
    }
    function serialize(children, callback) {
        var output = '';
        var length = sizeof(children);
        for(var i = 0; i < length; i++)output += callback(children[i], i, children, callback) || '';
        return output;
    }
    function stringify$2(element, index, children, callback) {
        switch(element.type){
            case LAYER:
                if (element.children.length) break;
            case IMPORT:
            case DECLARATION:
                return element.return = element.return || element.value;
            case COMMENT:
                return '';
            case KEYFRAMES:
                return element.return = element.value + '{' + serialize(element.children, callback) + '}';
            case RULESET:
                element.value = element.props.join(',');
        }
        return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
    }
    function middleware(collection) {
        var length = sizeof(collection);
        return function(element, index, children, callback) {
            var output = '';
            for(var i = 0; i < length; i++)output += collection[i](element, index, children, callback) || '';
            return output;
        };
    }
    function rulesheet(callback) {
        return function(element) {
            if (!element.root) if (element = element.return) callback(element);
        };
    }
    function memoize$1(fn) {
        var cache = Object.create(null);
        return function(arg) {
            if (cache[arg] === undefined) cache[arg] = fn(arg);
            return cache[arg];
        };
    }
    var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
        var previous = 0;
        var character = 0;
        while(true){
            previous = character;
            character = peek();
            if (previous === 38 && character === 12) {
                points[index] = 1;
            }
            if (token(character)) {
                break;
            }
            next();
        }
        return slice$1(begin, position);
    };
    var toRules = function toRules(parsed, points) {
        var index = -1;
        var character = 44;
        do {
            switch(token(character)){
                case 0:
                    if (character === 38 && peek() === 12) {
                        points[index] = 1;
                    }
                    parsed[index] += identifierWithPointTracking(position - 1, points, index);
                    break;
                case 2:
                    parsed[index] += delimit(character);
                    break;
                case 4:
                    if (character === 44) {
                        parsed[++index] = peek() === 58 ? '&\f' : '';
                        points[index] = parsed[index].length;
                        break;
                    }
                default:
                    parsed[index] += from$2(character);
            }
        }while (character = next());
        return parsed;
    };
    var getRules = function getRules(value, points) {
        return dealloc(toRules(alloc(value), points));
    };
    var fixedElements = new WeakMap();
    var compat = function compat(element) {
        if (element.type !== 'rule' || !element.parent || element.length < 1) {
            return;
        }
        var value = element.value;
        var parent = element.parent;
        var isImplicitRule = element.column === parent.column && element.line === parent.line;
        while(parent.type !== 'rule'){
            parent = parent.parent;
            if (!parent) return;
        }
        if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
            return;
        }
        if (isImplicitRule) {
            return;
        }
        fixedElements.set(element, true);
        var points = [];
        var rules = getRules(value, points);
        var parentRules = parent.props;
        for(var i = 0, k = 0; i < rules.length; i++){
            for(var j = 0; j < parentRules.length; j++, k++){
                element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
            }
        }
    };
    var removeLabel = function removeLabel(element) {
        if (element.type === 'decl') {
            var value = element.value;
            if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
                element["return"] = '';
                element.value = '';
            }
        }
    };
    function prefix(value, length) {
        switch(hash(value, length)){
            case 5103:
                return WEBKIT + 'print-' + value + value;
            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921:
            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005:
            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855:
            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
                return WEBKIT + value + value;
            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
                return WEBKIT + value + MOZ + value + MS + value + value;
            case 6828:
            case 4268:
                return WEBKIT + value + MS + value + value;
            case 6165:
                return WEBKIT + value + MS + 'flex-' + value + value;
            case 5187:
                return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
            case 5443:
                return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
            case 4675:
                return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
            case 5548:
                return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
            case 5292:
                return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
            case 6060:
                return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
            case 4554:
                return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
            case 6187:
                return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
            case 5495:
            case 3959:
                return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
            case 4968:
                return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
            case 4095:
            case 3583:
            case 4068:
            case 2532:
                return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
                if (strlen(value) - 1 - length > 6) switch(charat(value, length + 1)){
                    case 109:
                        if (charat(value, length + 4) !== 45) break;
                    case 102:
                        return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
                    case 115:
                        return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
                }
                break;
            case 4949:
                if (charat(value, length + 1) !== 115) break;
            case 6444:
                switch(charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))){
                    case 107:
                        return replace(value, ':', ':' + WEBKIT) + value;
                    case 101:
                        return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
                }
                break;
            case 5936:
                switch(charat(value, length + 11)){
                    case 114:
                        return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
                    case 108:
                        return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
                    case 45:
                        return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
                }
                return WEBKIT + value + MS + value + value;
        }
        return value;
    }
    var prefixer = function prefixer(element, index, children, callback) {
        if (element.length > -1) if (!element["return"]) switch(element.type){
            case DECLARATION:
                element["return"] = prefix(element.value, element.length);
                break;
            case KEYFRAMES:
                return serialize([
                    copy$1(element, {
                        value: replace(element.value, '@', '@' + WEBKIT)
                    })
                ], callback);
            case RULESET:
                if (element.length) return combine(element.props, function(value) {
                    switch(match(value, /(::plac\w+|:read-\w+)/)){
                        case ':read-only':
                        case ':read-write':
                            return serialize([
                                copy$1(element, {
                                    props: [
                                        replace(value, /:(read-\w+)/, ':' + MOZ + '$1')
                                    ]
                                })
                            ], callback);
                        case '::placeholder':
                            return serialize([
                                copy$1(element, {
                                    props: [
                                        replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')
                                    ]
                                }),
                                copy$1(element, {
                                    props: [
                                        replace(value, /:(plac\w+)/, ':' + MOZ + '$1')
                                    ]
                                }),
                                copy$1(element, {
                                    props: [
                                        replace(value, /:(plac\w+)/, MS + 'input-$1')
                                    ]
                                })
                            ], callback);
                    }
                    return '';
                });
        }
    };
    var defaultStylisPlugins = [
        prefixer
    ];
    var createCache = function createCache(options) {
        var key = options.key;
        if (key === 'css') {
            var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
            Array.prototype.forEach.call(ssrStyles, function(node) {
                var dataEmotionAttribute = node.getAttribute('data-emotion');
                if (dataEmotionAttribute.indexOf(' ') === -1) {
                    return;
                }
                document.head.appendChild(node);
                node.setAttribute('data-s', '');
            });
        }
        var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
        var inserted = {};
        var container;
        var nodesToHydrate = [];
        {
            container = options.container || document.head;
            Array.prototype.forEach.call(document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function(node) {
                var attrib = node.getAttribute("data-emotion").split(' ');
                for(var i = 1; i < attrib.length; i++){
                    inserted[attrib[i]] = true;
                }
                nodesToHydrate.push(node);
            });
        }
        var _insert;
        var omnipresentPlugins = [
            compat,
            removeLabel
        ];
        {
            var currentSheet;
            var finalizingPlugins = [
                stringify$2,
                rulesheet(function(rule) {
                    currentSheet.insert(rule);
                })
            ];
            var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
            var stylis = function stylis(styles) {
                return serialize(compile(styles), serializer);
            };
            _insert = function insert(selector, serialized, sheet, shouldCache) {
                currentSheet = sheet;
                stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
                if (shouldCache) {
                    cache.inserted[serialized.name] = true;
                }
            };
        }
        var cache = {
            key: key,
            sheet: new StyleSheet({
                key: key,
                container: container,
                nonce: options.nonce,
                speedy: options.speedy,
                prepend: options.prepend,
                insertionPoint: options.insertionPoint
            }),
            nonce: options.nonce,
            inserted: inserted,
            registered: {},
            insert: _insert
        };
        cache.sheet.hydrate(nodesToHydrate);
        return cache;
    };
    var reactIs$1 = {
        exports: {}
    };
    var reactIs_production_min = {};
    var hasRequiredReactIs_production_min;
    function requireReactIs_production_min() {
        if (hasRequiredReactIs_production_min) return reactIs_production_min;
        hasRequiredReactIs_production_min = 1;
        var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
        function z(a) {
            if ("object" === typeof a && null !== a) {
                var u = a.$$typeof;
                switch(u){
                    case c:
                        switch(a = a.type, a){
                            case l:
                            case m:
                            case e:
                            case g:
                            case f:
                            case p:
                                return a;
                            default:
                                switch(a = a && a.$$typeof, a){
                                    case k:
                                    case n:
                                    case t:
                                    case r:
                                    case h:
                                        return a;
                                    default:
                                        return u;
                                }
                        }
                    case d:
                        return u;
                }
            }
        }
        function A(a) {
            return z(a) === m;
        }
        reactIs_production_min.AsyncMode = l;
        reactIs_production_min.ConcurrentMode = m;
        reactIs_production_min.ContextConsumer = k;
        reactIs_production_min.ContextProvider = h;
        reactIs_production_min.Element = c;
        reactIs_production_min.ForwardRef = n;
        reactIs_production_min.Fragment = e;
        reactIs_production_min.Lazy = t;
        reactIs_production_min.Memo = r;
        reactIs_production_min.Portal = d;
        reactIs_production_min.Profiler = g;
        reactIs_production_min.StrictMode = f;
        reactIs_production_min.Suspense = p;
        reactIs_production_min.isAsyncMode = function(a) {
            return A(a) || z(a) === l;
        };
        reactIs_production_min.isConcurrentMode = A;
        reactIs_production_min.isContextConsumer = function(a) {
            return z(a) === k;
        };
        reactIs_production_min.isContextProvider = function(a) {
            return z(a) === h;
        };
        reactIs_production_min.isElement = function(a) {
            return "object" === typeof a && null !== a && a.$$typeof === c;
        };
        reactIs_production_min.isForwardRef = function(a) {
            return z(a) === n;
        };
        reactIs_production_min.isFragment = function(a) {
            return z(a) === e;
        };
        reactIs_production_min.isLazy = function(a) {
            return z(a) === t;
        };
        reactIs_production_min.isMemo = function(a) {
            return z(a) === r;
        };
        reactIs_production_min.isPortal = function(a) {
            return z(a) === d;
        };
        reactIs_production_min.isProfiler = function(a) {
            return z(a) === g;
        };
        reactIs_production_min.isStrictMode = function(a) {
            return z(a) === f;
        };
        reactIs_production_min.isSuspense = function(a) {
            return z(a) === p;
        };
        reactIs_production_min.isValidElementType = function(a) {
            return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
        };
        reactIs_production_min.typeOf = z;
        return reactIs_production_min;
    }
    var hasRequiredReactIs$1;
    function requireReactIs$1() {
        if (hasRequiredReactIs$1) return reactIs$1.exports;
        hasRequiredReactIs$1 = 1;
        {
            reactIs$1.exports = requireReactIs_production_min();
        }
        return reactIs$1.exports;
    }
    var hoistNonReactStatics_cjs;
    var hasRequiredHoistNonReactStatics_cjs;
    function requireHoistNonReactStatics_cjs() {
        if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
        hasRequiredHoistNonReactStatics_cjs = 1;
        var reactIs = requireReactIs$1();
        var REACT_STATICS = {
            childContextTypes: true,
            contextType: true,
            contextTypes: true,
            defaultProps: true,
            displayName: true,
            getDefaultProps: true,
            getDerivedStateFromError: true,
            getDerivedStateFromProps: true,
            mixins: true,
            propTypes: true,
            type: true
        };
        var KNOWN_STATICS = {
            name: true,
            length: true,
            prototype: true,
            caller: true,
            callee: true,
            arguments: true,
            arity: true
        };
        var FORWARD_REF_STATICS = {
            '$$typeof': true,
            render: true,
            defaultProps: true,
            displayName: true,
            propTypes: true
        };
        var MEMO_STATICS = {
            '$$typeof': true,
            compare: true,
            defaultProps: true,
            displayName: true,
            propTypes: true,
            type: true
        };
        var TYPE_STATICS = {};
        TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
        TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
        function getStatics(component) {
            if (reactIs.isMemo(component)) {
                return MEMO_STATICS;
            }
            return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
        }
        var defineProperty = Object.defineProperty;
        var getOwnPropertyNames = Object.getOwnPropertyNames;
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var getPrototypeOf = Object.getPrototypeOf;
        var objectPrototype = Object.prototype;
        function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
            if (typeof sourceComponent !== 'string') {
                if (objectPrototype) {
                    var inheritedComponent = getPrototypeOf(sourceComponent);
                    if (inheritedComponent && inheritedComponent !== objectPrototype) {
                        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                    }
                }
                var keys = getOwnPropertyNames(sourceComponent);
                if (getOwnPropertySymbols) {
                    keys = keys.concat(getOwnPropertySymbols(sourceComponent));
                }
                var targetStatics = getStatics(targetComponent);
                var sourceStatics = getStatics(sourceComponent);
                for(var i = 0; i < keys.length; ++i){
                    var key = keys[i];
                    if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                        try {
                            defineProperty(targetComponent, key, descriptor);
                        } catch (e) {}
                    }
                }
            }
            return targetComponent;
        }
        hoistNonReactStatics_cjs = hoistNonReactStatics;
        return hoistNonReactStatics_cjs;
    }
    requireHoistNonReactStatics_cjs();
    var isBrowser = true;
    function getRegisteredStyles(registered, registeredStyles, classNames) {
        var rawClassName = '';
        classNames.split(' ').forEach(function(className) {
            if (registered[className] !== undefined) {
                registeredStyles.push(registered[className] + ";");
            } else if (className) {
                rawClassName += className + " ";
            }
        });
        return rawClassName;
    }
    var registerStyles = function registerStyles(cache, serialized, isStringTag) {
        var className = cache.key + "-" + serialized.name;
        if ((isStringTag === false || isBrowser === false) && cache.registered[className] === undefined) {
            cache.registered[className] = serialized.styles;
        }
    };
    var insertStyles = function insertStyles(cache, serialized, isStringTag) {
        registerStyles(cache, serialized, isStringTag);
        var className = cache.key + "-" + serialized.name;
        if (cache.inserted[serialized.name] === undefined) {
            var current = serialized;
            do {
                cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
                current = current.next;
            }while (current !== undefined);
        }
    };
    function murmur2(str) {
        var h = 0;
        var k, i = 0, len = str.length;
        for(; len >= 4; ++i, len -= 4){
            k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
            k = (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
            k ^= k >>> 24;
            h = (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
        }
        switch(len){
            case 3:
                h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
            case 2:
                h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
            case 1:
                h ^= str.charCodeAt(i) & 0xff;
                h = (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
        }
        h ^= h >>> 13;
        h = (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
        return ((h ^ h >>> 15) >>> 0).toString(36);
    }
    var unitlessKeys = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        scale: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    };
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    var isCustomProperty = function isCustomProperty(property) {
        return property.charCodeAt(1) === 45;
    };
    var isProcessableValue = function isProcessableValue(value) {
        return value != null && typeof value !== 'boolean';
    };
    var processStyleName = memoize$1(function(styleName) {
        return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
    });
    var processStyleValue = function processStyleValue(key, value) {
        switch(key){
            case 'animation':
            case 'animationName':
                {
                    if (typeof value === 'string') {
                        return value.replace(animationRegex, function(match, p1, p2) {
                            cursor = {
                                name: p1,
                                styles: p2,
                                next: cursor
                            };
                            return p1;
                        });
                    }
                }
        }
        if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
            return value + 'px';
        }
        return value;
    };
    function handleInterpolation(mergedProps, registered, interpolation) {
        if (interpolation == null) {
            return '';
        }
        var componentSelector = interpolation;
        if (componentSelector.__emotion_styles !== undefined) {
            return componentSelector;
        }
        switch(typeof interpolation){
            case 'boolean':
                {
                    return '';
                }
            case 'object':
                {
                    var keyframes = interpolation;
                    if (keyframes.anim === 1) {
                        cursor = {
                            name: keyframes.name,
                            styles: keyframes.styles,
                            next: cursor
                        };
                        return keyframes.name;
                    }
                    var serializedStyles = interpolation;
                    if (serializedStyles.styles !== undefined) {
                        var next = serializedStyles.next;
                        if (next !== undefined) {
                            while(next !== undefined){
                                cursor = {
                                    name: next.name,
                                    styles: next.styles,
                                    next: cursor
                                };
                                next = next.next;
                            }
                        }
                        var styles = serializedStyles.styles + ";";
                        return styles;
                    }
                    return createStringFromObject(mergedProps, registered, interpolation);
                }
            case 'function':
                {
                    if (mergedProps !== undefined) {
                        var previousCursor = cursor;
                        var result = interpolation(mergedProps);
                        cursor = previousCursor;
                        return handleInterpolation(mergedProps, registered, result);
                    }
                    break;
                }
        }
        var asString = interpolation;
        if (registered == null) {
            return asString;
        }
        var cached = registered[asString];
        return cached !== undefined ? cached : asString;
    }
    function createStringFromObject(mergedProps, registered, obj) {
        var string = '';
        if (Array.isArray(obj)) {
            for(var i = 0; i < obj.length; i++){
                string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
            }
        } else {
            for(var key in obj){
                var value = obj[key];
                if (typeof value !== 'object') {
                    var asString = value;
                    if (registered != null && registered[asString] !== undefined) {
                        string += key + "{" + registered[asString] + "}";
                    } else if (isProcessableValue(asString)) {
                        string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
                    }
                } else {
                    if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
                        for(var _i = 0; _i < value.length; _i++){
                            if (isProcessableValue(value[_i])) {
                                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
                            }
                        }
                    } else {
                        var interpolated = handleInterpolation(mergedProps, registered, value);
                        switch(key){
                            case 'animation':
                            case 'animationName':
                                {
                                    string += processStyleName(key) + ":" + interpolated + ";";
                                    break;
                                }
                            default:
                                {
                                    string += key + "{" + interpolated + "}";
                                }
                        }
                    }
                }
            }
        }
        return string;
    }
    var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
    var cursor;
    function serializeStyles(args, registered, mergedProps) {
        if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
            return args[0];
        }
        var stringMode = true;
        var styles = '';
        cursor = undefined;
        var strings = args[0];
        if (strings == null || strings.raw === undefined) {
            stringMode = false;
            styles += handleInterpolation(mergedProps, registered, strings);
        } else {
            var asTemplateStringsArr = strings;
            styles += asTemplateStringsArr[0];
        }
        for(var i = 1; i < args.length; i++){
            styles += handleInterpolation(mergedProps, registered, args[i]);
            if (stringMode) {
                var templateStringsArr = strings;
                styles += templateStringsArr[i];
            }
        }
        labelPattern.lastIndex = 0;
        var identifierName = '';
        var match;
        while((match = labelPattern.exec(styles)) !== null){
            identifierName += '-' + match[1];
        }
        var name = murmur2(styles) + identifierName;
        return {
            name: name,
            styles: styles,
            next: cursor
        };
    }
    var syncFallback = function syncFallback(create) {
        return create();
    };
    var useInsertionEffect = React$1['useInsertion' + 'Effect'] ? React$1['useInsertion' + 'Effect'] : false;
    var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
    var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
    var EmotionCacheContext = reactExports.createContext(typeof HTMLElement !== 'undefined' ? createCache({
        key: 'css'
    }) : null);
    EmotionCacheContext.Provider;
    var withEmotionCache = function withEmotionCache(func) {
        return reactExports.forwardRef(function(props, ref) {
            var cache = reactExports.useContext(EmotionCacheContext);
            return func(props, cache, ref);
        });
    };
    var ThemeContext$1 = reactExports.createContext({});
    var hasOwn$1 = {}.hasOwnProperty;
    var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
    var createEmotionProps = function createEmotionProps(type, props) {
        var newProps = {};
        for(var _key in props){
            if (hasOwn$1.call(props, _key)) {
                newProps[_key] = props[_key];
            }
        }
        newProps[typePropName] = type;
        return newProps;
    };
    var Insertion$1 = function Insertion(_ref) {
        var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
        registerStyles(cache, serialized, isStringTag);
        useInsertionEffectAlwaysWithSyncFallback(function() {
            return insertStyles(cache, serialized, isStringTag);
        });
        return null;
    };
    var Emotion = withEmotionCache(function(props, cache, ref) {
        var cssProp = props.css;
        if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
            cssProp = cache.registered[cssProp];
        }
        var WrappedComponent = props[typePropName];
        var registeredStyles = [
            cssProp
        ];
        var className = '';
        if (typeof props.className === 'string') {
            className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
        } else if (props.className != null) {
            className = props.className + " ";
        }
        var serialized = serializeStyles(registeredStyles, undefined, reactExports.useContext(ThemeContext$1));
        className += cache.key + "-" + serialized.name;
        var newProps = {};
        for(var _key2 in props){
            if (hasOwn$1.call(props, _key2) && _key2 !== 'css' && _key2 !== typePropName && (true)) {
                newProps[_key2] = props[_key2];
            }
        }
        newProps.className = className;
        if (ref) {
            newProps.ref = ref;
        }
        return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion$1, {
            cache: cache,
            serialized: serialized,
            isStringTag: typeof WrappedComponent === 'string'
        }), reactExports.createElement(WrappedComponent, newProps));
    });
    var Emotion$1 = Emotion;
    var jsx = function jsx(type, props) {
        var args = arguments;
        if (props == null || !hasOwn$1.call(props, 'css')) {
            return reactExports.createElement.apply(undefined, args);
        }
        var argsLength = args.length;
        var createElementArgArray = new Array(argsLength);
        createElementArgArray[0] = Emotion$1;
        createElementArgArray[1] = createEmotionProps(type, props);
        for(var i = 2; i < argsLength; i++){
            createElementArgArray[i] = args[i];
        }
        return reactExports.createElement.apply(null, createElementArgArray);
    };
    (function(_jsx) {
        var JSX;
        (function(_JSX) {})(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
    })(jsx || (jsx = {}));
    var Global = withEmotionCache(function(props, cache) {
        var styles = props.styles;
        var serialized = serializeStyles([
            styles
        ], undefined, reactExports.useContext(ThemeContext$1));
        var sheetRef = reactExports.useRef();
        useInsertionEffectWithLayoutFallback(function() {
            var key = cache.key + "-global";
            var sheet = new cache.sheet.constructor({
                key: key,
                nonce: cache.sheet.nonce,
                container: cache.sheet.container,
                speedy: cache.sheet.isSpeedy
            });
            var rehydrating = false;
            var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");
            if (cache.sheet.tags.length) {
                sheet.before = cache.sheet.tags[0];
            }
            if (node !== null) {
                rehydrating = true;
                node.setAttribute('data-emotion', key);
                sheet.hydrate([
                    node
                ]);
            }
            sheetRef.current = [
                sheet,
                rehydrating
            ];
            return function() {
                sheet.flush();
            };
        }, [
            cache
        ]);
        useInsertionEffectWithLayoutFallback(function() {
            var sheetRefCurrent = sheetRef.current;
            var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
            if (rehydrating) {
                sheetRefCurrent[1] = false;
                return;
            }
            if (serialized.next !== undefined) {
                insertStyles(cache, serialized.next, true);
            }
            if (sheet.tags.length) {
                var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
                sheet.before = element;
                sheet.flush();
            }
            cache.insert("", serialized, sheet, false);
        }, [
            cache,
            serialized.name
        ]);
        return null;
    });
    function css() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return serializeStyles(args);
    }
    function keyframes() {
        var insertable = css.apply(void 0, arguments);
        var name = "animation-" + insertable.name;
        return {
            name: name,
            styles: "@keyframes " + name + "{" + insertable.styles + "}",
            anim: 1,
            toString: function toString() {
                return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
            }
        };
    }
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var isPropValid = memoize$1(function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    });
    var testOmitPropsOnStringTag = isPropValid;
    var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
        return key !== 'theme';
    };
    var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
        return typeof tag === 'string' && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    };
    var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
        var shouldForwardProp;
        if (options) {
            var optionsShouldForwardProp = options.shouldForwardProp;
            shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
                return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
            } : optionsShouldForwardProp;
        }
        if (typeof shouldForwardProp !== 'function' && isReal) {
            shouldForwardProp = tag.__emotion_forwardProp;
        }
        return shouldForwardProp;
    };
    var Insertion = function Insertion(_ref) {
        var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
        registerStyles(cache, serialized, isStringTag);
        useInsertionEffectAlwaysWithSyncFallback(function() {
            return insertStyles(cache, serialized, isStringTag);
        });
        return null;
    };
    var createStyled$1 = function createStyled(tag, options) {
        var isReal = tag.__emotion_real === tag;
        var baseTag = isReal && tag.__emotion_base || tag;
        var identifierName;
        var targetClassName;
        if (options !== undefined) {
            identifierName = options.label;
            targetClassName = options.target;
        }
        var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
        var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
        var shouldUseAs = !defaultShouldForwardProp('as');
        return function() {
            var args = arguments;
            var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];
            if (identifierName !== undefined) {
                styles.push("label:" + identifierName + ";");
            }
            if (args[0] == null || args[0].raw === undefined) {
                styles.push.apply(styles, args);
            } else {
                var templateStringsArr = args[0];
                styles.push(templateStringsArr[0]);
                var len = args.length;
                var i = 1;
                for(; i < len; i++){
                    styles.push(args[i], templateStringsArr[i]);
                }
            }
            var Styled = withEmotionCache(function(props, cache, ref) {
                var FinalTag = shouldUseAs && props.as || baseTag;
                var className = '';
                var classInterpolations = [];
                var mergedProps = props;
                if (props.theme == null) {
                    mergedProps = {};
                    for(var key in props){
                        mergedProps[key] = props[key];
                    }
                    mergedProps.theme = reactExports.useContext(ThemeContext$1);
                }
                if (typeof props.className === 'string') {
                    className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
                } else if (props.className != null) {
                    className = props.className + " ";
                }
                var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
                className += cache.key + "-" + serialized.name;
                if (targetClassName !== undefined) {
                    className += " " + targetClassName;
                }
                var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
                var newProps = {};
                for(var _key in props){
                    if (shouldUseAs && _key === 'as') continue;
                    if (finalShouldForwardProp(_key)) {
                        newProps[_key] = props[_key];
                    }
                }
                newProps.className = className;
                if (ref) {
                    newProps.ref = ref;
                }
                return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion, {
                    cache: cache,
                    serialized: serialized,
                    isStringTag: typeof FinalTag === 'string'
                }), reactExports.createElement(FinalTag, newProps));
            });
            Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
            Styled.defaultProps = tag.defaultProps;
            Styled.__emotion_real = Styled;
            Styled.__emotion_base = baseTag;
            Styled.__emotion_styles = styles;
            Styled.__emotion_forwardProp = shouldForwardProp;
            Object.defineProperty(Styled, 'toString', {
                value: function value() {
                    return "." + targetClassName;
                }
            });
            Styled.withComponent = function(nextTag, nextOptions) {
                var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
                    shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
                }));
                return newStyled.apply(void 0, styles);
            };
            return Styled;
        };
    };
    var tags = [
        'a',
        'abbr',
        'address',
        'area',
        'article',
        'aside',
        'audio',
        'b',
        'base',
        'bdi',
        'bdo',
        'big',
        'blockquote',
        'body',
        'br',
        'button',
        'canvas',
        'caption',
        'cite',
        'code',
        'col',
        'colgroup',
        'data',
        'datalist',
        'dd',
        'del',
        'details',
        'dfn',
        'dialog',
        'div',
        'dl',
        'dt',
        'em',
        'embed',
        'fieldset',
        'figcaption',
        'figure',
        'footer',
        'form',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'head',
        'header',
        'hgroup',
        'hr',
        'html',
        'i',
        'iframe',
        'img',
        'input',
        'ins',
        'kbd',
        'keygen',
        'label',
        'legend',
        'li',
        'link',
        'main',
        'map',
        'mark',
        'marquee',
        'menu',
        'menuitem',
        'meta',
        'meter',
        'nav',
        'noscript',
        'object',
        'ol',
        'optgroup',
        'option',
        'output',
        'p',
        'param',
        'picture',
        'pre',
        'progress',
        'q',
        'rp',
        'rt',
        'ruby',
        's',
        'samp',
        'script',
        'section',
        'select',
        'small',
        'source',
        'span',
        'strong',
        'style',
        'sub',
        'summary',
        'sup',
        'table',
        'tbody',
        'td',
        'textarea',
        'tfoot',
        'th',
        'thead',
        'time',
        'title',
        'tr',
        'track',
        'u',
        'ul',
        'var',
        'video',
        'wbr',
        'circle',
        'clipPath',
        'defs',
        'ellipse',
        'foreignObject',
        'g',
        'image',
        'line',
        'linearGradient',
        'mask',
        'path',
        'pattern',
        'polygon',
        'polyline',
        'radialGradient',
        'rect',
        'stop',
        'svg',
        'text',
        'tspan'
    ];
    var styled$3 = createStyled$1.bind(null);
    tags.forEach(function(tagName) {
        styled$3[tagName] = styled$3(tagName);
    });
    function isEmpty$3(obj) {
        return obj === void 0 || obj === null || Object.keys(obj).length === 0;
    }
    function GlobalStyles$3(props) {
        const { styles, defaultTheme = {} } = props;
        const globalStyles = typeof styles === "function" ? (themeInput)=>styles(isEmpty$3(themeInput) ? defaultTheme : themeInput) : styles;
        return jsxRuntimeExports.jsx(Global, {
            styles: globalStyles
        });
    }
    function styled$2(tag, options) {
        const stylesFactory = styled$3(tag, options);
        return stylesFactory;
    }
    function internal_mutateStyles(tag, processor) {
        if (Array.isArray(tag.__emotion_styles)) {
            tag.__emotion_styles = processor(tag.__emotion_styles);
        }
    }
    const wrapper = [];
    function internal_serializeStyles(styles) {
        wrapper[0] = styles;
        return serializeStyles(wrapper);
    }
    var reactIs = {
        exports: {}
    };
    var reactIs_production = {};
    var hasRequiredReactIs_production;
    function requireReactIs_production() {
        if (hasRequiredReactIs_production) return reactIs_production;
        hasRequiredReactIs_production = 1;
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
        function typeOf(object) {
            if ("object" === typeof object && null !== object) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        switch(((object = object.type), object)){
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                            case REACT_SUSPENSE_LIST_TYPE:
                            case REACT_VIEW_TRANSITION_TYPE:
                                return object;
                            default:
                                switch(((object = object && object.$$typeof), object)){
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                        return object;
                                    case REACT_CONSUMER_TYPE:
                                        return object;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
        }
        reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
        reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
        reactIs_production.Element = REACT_ELEMENT_TYPE;
        reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
        reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
        reactIs_production.Lazy = REACT_LAZY_TYPE;
        reactIs_production.Memo = REACT_MEMO_TYPE;
        reactIs_production.Portal = REACT_PORTAL_TYPE;
        reactIs_production.Profiler = REACT_PROFILER_TYPE;
        reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
        reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
        reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        reactIs_production.isContextConsumer = function(object) {
            return typeOf(object) === REACT_CONSUMER_TYPE;
        };
        reactIs_production.isContextProvider = function(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        };
        reactIs_production.isElement = function(object) {
            return ("object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE);
        };
        reactIs_production.isForwardRef = function(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        };
        reactIs_production.isFragment = function(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        };
        reactIs_production.isLazy = function(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        };
        reactIs_production.isMemo = function(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        };
        reactIs_production.isPortal = function(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        };
        reactIs_production.isProfiler = function(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        };
        reactIs_production.isStrictMode = function(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        };
        reactIs_production.isSuspense = function(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        };
        reactIs_production.isSuspenseList = function(object) {
            return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        };
        reactIs_production.isValidElementType = function(type) {
            return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || ("object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId)) ? true : false;
        };
        reactIs_production.typeOf = typeOf;
        return reactIs_production;
    }
    var hasRequiredReactIs;
    function requireReactIs() {
        if (hasRequiredReactIs) return reactIs.exports;
        hasRequiredReactIs = 1;
        {
            reactIs.exports = requireReactIs_production();
        }
        return reactIs.exports;
    }
    var reactIsExports = requireReactIs();
    function isPlainObject$3(item) {
        if (typeof item !== 'object' || item === null) {
            return false;
        }
        const prototype = Object.getPrototypeOf(item);
        return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
    }
    function deepClone(source) {
        if (reactExports.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject$3(source)) {
            return source;
        }
        const output = {};
        Object.keys(source).forEach((key)=>{
            output[key] = deepClone(source[key]);
        });
        return output;
    }
    function deepmerge(target, source, options = {
        clone: true
    }) {
        const output = options.clone ? {
            ...target
        } : target;
        if (isPlainObject$3(target) && isPlainObject$3(source)) {
            Object.keys(source).forEach((key)=>{
                if (reactExports.isValidElement(source[key]) || reactIsExports.isValidElementType(source[key])) {
                    output[key] = source[key];
                } else if (isPlainObject$3(source[key]) && Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$3(target[key])) {
                    output[key] = deepmerge(target[key], source[key], options);
                } else if (options.clone) {
                    output[key] = isPlainObject$3(source[key]) ? deepClone(source[key]) : source[key];
                } else {
                    output[key] = source[key];
                }
            });
        }
        return output;
    }
    const sortBreakpointsValues = (values)=>{
        const breakpointsAsArray = Object.keys(values).map((key)=>({
                key,
                val: values[key]
            })) || [];
        breakpointsAsArray.sort((breakpoint1, breakpoint2)=>breakpoint1.val - breakpoint2.val);
        return breakpointsAsArray.reduce((acc, obj)=>{
            return {
                ...acc,
                [obj.key]: obj.val
            };
        }, {});
    };
    function createBreakpoints(breakpoints) {
        const { values = {
            xs: 0,
            sm: 600,
            md: 900,
            lg: 1200,
            xl: 1536
        }, unit = 'px', step = 5, ...other } = breakpoints;
        const sortedValues = sortBreakpointsValues(values);
        const keys = Object.keys(sortedValues);
        function up(key) {
            const value = typeof values[key] === 'number' ? values[key] : key;
            return `@media (min-width:${value}${unit})`;
        }
        function down(key) {
            const value = typeof values[key] === 'number' ? values[key] : key;
            return `@media (max-width:${value - step / 100}${unit})`;
        }
        function between(start, end) {
            const endIndex = keys.indexOf(end);
            return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
        }
        function only(key) {
            if (keys.indexOf(key) + 1 < keys.length) {
                return between(key, keys[keys.indexOf(key) + 1]);
            }
            return up(key);
        }
        function not(key) {
            const keyIndex = keys.indexOf(key);
            if (keyIndex === 0) {
                return up(keys[1]);
            }
            if (keyIndex === keys.length - 1) {
                return down(keys[keyIndex]);
            }
            return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
        }
        return {
            keys,
            values: sortedValues,
            up,
            down,
            between,
            only,
            not,
            unit,
            ...other
        };
    }
    function sortContainerQueries(theme, css) {
        if (!theme.containerQueries) {
            return css;
        }
        const sorted = Object.keys(css).filter((key)=>key.startsWith("@container")).sort((a, b)=>{
            const regex = /min-width:\s*([0-9.]+)/;
            return +(a.match(regex)?.[1] || 0) - +(b.match(regex)?.[1] || 0);
        });
        if (!sorted.length) {
            return css;
        }
        return sorted.reduce((acc, key)=>{
            const value = css[key];
            delete acc[key];
            acc[key] = value;
            return acc;
        }, {
            ...css
        });
    }
    function isCqShorthand(breakpointKeys, value) {
        return value === "@" || value.startsWith("@") && (breakpointKeys.some((key)=>value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
    }
    function getContainerQuery(theme, shorthand) {
        const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
        if (!matches) {
            return null;
        }
        const [, containerQuery, containerName] = matches;
        const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
        return theme.containerQueries(containerName).up(value);
    }
    function cssContainerQueries(themeInput) {
        const toContainerQuery = (mediaQuery, name)=>mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
        function attachCq(node2, name) {
            node2.up = (...args)=>toContainerQuery(themeInput.breakpoints.up(...args), name);
            node2.down = (...args)=>toContainerQuery(themeInput.breakpoints.down(...args), name);
            node2.between = (...args)=>toContainerQuery(themeInput.breakpoints.between(...args), name);
            node2.only = (...args)=>toContainerQuery(themeInput.breakpoints.only(...args), name);
            node2.not = (...args)=>{
                const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
                if (result.includes("not all and")) {
                    return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
                }
                return result;
            };
        }
        const node = {};
        const containerQueries = (name)=>{
            attachCq(node, name);
            return node;
        };
        attachCq(containerQueries);
        return {
            ...themeInput,
            containerQueries
        };
    }
    const shape = {
        borderRadius: 4
    };
    function merge(acc, item) {
        if (!item) {
            return acc;
        }
        return deepmerge(acc, item, {
            clone: false
        });
    }
    const values$1 = {
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536
    };
    const defaultBreakpoints = {
        keys: [
            "xs",
            "sm",
            "md",
            "lg",
            "xl"
        ],
        up: (key)=>`@media (min-width:${values$1[key]}px)`
    };
    const defaultContainerQueries = {
        containerQueries: (containerName)=>({
                up: (key)=>{
                    let result = typeof key === "number" ? key : values$1[key] || key;
                    if (typeof result === "number") {
                        result = `${result}px`;
                    }
                    return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
                }
            })
    };
    function handleBreakpoints(props, propValue, styleFromPropValue) {
        const theme = props.theme || {};
        if (Array.isArray(propValue)) {
            const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
            return propValue.reduce((acc, item, index)=>{
                acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
                return acc;
            }, {});
        }
        if (typeof propValue === "object") {
            const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
            return Object.keys(propValue).reduce((acc, breakpoint)=>{
                if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
                    const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
                    if (containerKey) {
                        acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
                    }
                } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
                    const mediaKey = themeBreakpoints.up(breakpoint);
                    acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
                } else {
                    const cssKey = breakpoint;
                    acc[cssKey] = propValue[cssKey];
                }
                return acc;
            }, {});
        }
        const output = styleFromPropValue(propValue);
        return output;
    }
    function createEmptyBreakpointObject(breakpointsInput = {}) {
        const breakpointsInOrder = breakpointsInput.keys?.reduce((acc, key)=>{
            const breakpointStyleKey = breakpointsInput.up(key);
            acc[breakpointStyleKey] = {};
            return acc;
        }, {});
        return breakpointsInOrder || {};
    }
    function removeUnusedBreakpoints(breakpointKeys, style) {
        return breakpointKeys.reduce((acc, key)=>{
            const breakpointOutput = acc[key];
            const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
            if (isBreakpointUnused) {
                delete acc[key];
            }
            return acc;
        }, style);
    }
    function capitalize(string) {
        if (typeof string !== "string") {
            throw new Error(formatMuiErrorMessage(7));
        }
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function getPath(obj, path, checkVars = true) {
        if (!path || typeof path !== "string") {
            return null;
        }
        if (obj && obj.vars && checkVars) {
            const val = `vars.${path}`.split(".").reduce((acc, item)=>acc && acc[item] ? acc[item] : null, obj);
            if (val != null) {
                return val;
            }
        }
        return path.split(".").reduce((acc, item)=>{
            if (acc && acc[item] != null) {
                return acc[item];
            }
            return null;
        }, obj);
    }
    function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
        let value;
        if (typeof themeMapping === "function") {
            value = themeMapping(propValueFinal);
        } else if (Array.isArray(themeMapping)) {
            value = themeMapping[propValueFinal] || userValue;
        } else {
            value = getPath(themeMapping, propValueFinal) || userValue;
        }
        if (transform) {
            value = transform(value, userValue, themeMapping);
        }
        return value;
    }
    function style$1(options) {
        const { prop, cssProperty = options.prop, themeKey, transform } = options;
        const fn = (props)=>{
            if (props[prop] == null) {
                return null;
            }
            const propValue = props[prop];
            const theme = props.theme;
            const themeMapping = getPath(theme, themeKey) || {};
            const styleFromPropValue = (propValueFinal)=>{
                let value = getStyleValue$1(themeMapping, transform, propValueFinal);
                if (propValueFinal === value && typeof propValueFinal === "string") {
                    value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
                }
                if (cssProperty === false) {
                    return value;
                }
                return {
                    [cssProperty]: value
                };
            };
            return handleBreakpoints(props, propValue, styleFromPropValue);
        };
        fn.propTypes = {};
        fn.filterProps = [
            prop
        ];
        return fn;
    }
    function memoize(fn) {
        const cache = {};
        return (arg)=>{
            if (cache[arg] === undefined) {
                cache[arg] = fn(arg);
            }
            return cache[arg];
        };
    }
    const properties = {
        m: "margin",
        p: "padding"
    };
    const directions = {
        t: "Top",
        r: "Right",
        b: "Bottom",
        l: "Left",
        x: [
            "Left",
            "Right"
        ],
        y: [
            "Top",
            "Bottom"
        ]
    };
    const aliases = {
        marginX: "mx",
        marginY: "my",
        paddingX: "px",
        paddingY: "py"
    };
    const getCssProperties = memoize((prop)=>{
        if (prop.length > 2) {
            if (aliases[prop]) {
                prop = aliases[prop];
            } else {
                return [
                    prop
                ];
            }
        }
        const [a, b] = prop.split("");
        const property = properties[a];
        const direction = directions[b] || "";
        return Array.isArray(direction) ? direction.map((dir)=>property + dir) : [
            property + direction
        ];
    });
    const marginKeys = [
        "m",
        "mt",
        "mr",
        "mb",
        "ml",
        "mx",
        "my",
        "margin",
        "marginTop",
        "marginRight",
        "marginBottom",
        "marginLeft",
        "marginX",
        "marginY",
        "marginInline",
        "marginInlineStart",
        "marginInlineEnd",
        "marginBlock",
        "marginBlockStart",
        "marginBlockEnd"
    ];
    const paddingKeys = [
        "p",
        "pt",
        "pr",
        "pb",
        "pl",
        "px",
        "py",
        "padding",
        "paddingTop",
        "paddingRight",
        "paddingBottom",
        "paddingLeft",
        "paddingX",
        "paddingY",
        "paddingInline",
        "paddingInlineStart",
        "paddingInlineEnd",
        "paddingBlock",
        "paddingBlockStart",
        "paddingBlockEnd"
    ];
    [
        ...marginKeys,
        ...paddingKeys
    ];
    function createUnaryUnit(theme, themeKey, defaultValue, propName) {
        const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
        if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
            return (val)=>{
                if (typeof val === "string") {
                    return val;
                }
                if (typeof themeSpacing === "string") {
                    if (themeSpacing.startsWith("var(") && val === 0) {
                        return 0;
                    }
                    if (themeSpacing.startsWith("var(") && val === 1) {
                        return themeSpacing;
                    }
                    return `calc(${val} * ${themeSpacing})`;
                }
                return themeSpacing * val;
            };
        }
        if (Array.isArray(themeSpacing)) {
            return (val)=>{
                if (typeof val === "string") {
                    return val;
                }
                const abs = Math.abs(val);
                const transformed = themeSpacing[abs];
                if (val >= 0) {
                    return transformed;
                }
                if (typeof transformed === "number") {
                    return -transformed;
                }
                if (typeof transformed === "string" && transformed.startsWith("var(")) {
                    return `calc(-1 * ${transformed})`;
                }
                return `-${transformed}`;
            };
        }
        if (typeof themeSpacing === "function") {
            return themeSpacing;
        }
        return ()=>void 0;
    }
    function createUnarySpacing(theme) {
        return createUnaryUnit(theme, "spacing", 8);
    }
    function getValue(transformer, propValue) {
        if (typeof propValue === "string" || propValue == null) {
            return propValue;
        }
        return transformer(propValue);
    }
    function getStyleFromPropValue(cssProperties, transformer) {
        return (propValue)=>cssProperties.reduce((acc, cssProperty)=>{
                acc[cssProperty] = getValue(transformer, propValue);
                return acc;
            }, {});
    }
    function resolveCssProperty(props, keys, prop, transformer) {
        if (!keys.includes(prop)) {
            return null;
        }
        const cssProperties = getCssProperties(prop);
        const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
        const propValue = props[prop];
        return handleBreakpoints(props, propValue, styleFromPropValue);
    }
    function style(props, keys) {
        const transformer = createUnarySpacing(props.theme);
        return Object.keys(props).map((prop)=>resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
    }
    function margin(props) {
        return style(props, marginKeys);
    }
    margin.propTypes = {};
    margin.filterProps = marginKeys;
    function padding(props) {
        return style(props, paddingKeys);
    }
    padding.propTypes = {};
    padding.filterProps = paddingKeys;
    function createSpacing(spacingInput = 8, transform = createUnarySpacing({
        spacing: spacingInput
    })) {
        if (spacingInput.mui) {
            return spacingInput;
        }
        const spacing = (...argsInput)=>{
            const args = argsInput.length === 0 ? [
                1
            ] : argsInput;
            return args.map((argument)=>{
                const output = transform(argument);
                return typeof output === "number" ? `${output}px` : output;
            }).join(" ");
        };
        spacing.mui = true;
        return spacing;
    }
    function compose(...styles) {
        const handlers = styles.reduce((acc, style)=>{
            style.filterProps.forEach((prop)=>{
                acc[prop] = style;
            });
            return acc;
        }, {});
        const fn = (props)=>{
            return Object.keys(props).reduce((acc, prop)=>{
                if (handlers[prop]) {
                    return merge(acc, handlers[prop](props));
                }
                return acc;
            }, {});
        };
        fn.propTypes = {};
        fn.filterProps = styles.reduce((acc, style)=>acc.concat(style.filterProps), []);
        return fn;
    }
    function borderTransform(value) {
        if (typeof value !== "number") {
            return value;
        }
        return `${value}px solid`;
    }
    function createBorderStyle(prop, transform) {
        return style$1({
            prop,
            themeKey: "borders",
            transform
        });
    }
    const border = createBorderStyle("border", borderTransform);
    const borderTop = createBorderStyle("borderTop", borderTransform);
    const borderRight = createBorderStyle("borderRight", borderTransform);
    const borderBottom = createBorderStyle("borderBottom", borderTransform);
    const borderLeft = createBorderStyle("borderLeft", borderTransform);
    const borderColor = createBorderStyle("borderColor");
    const borderTopColor = createBorderStyle("borderTopColor");
    const borderRightColor = createBorderStyle("borderRightColor");
    const borderBottomColor = createBorderStyle("borderBottomColor");
    const borderLeftColor = createBorderStyle("borderLeftColor");
    const outline = createBorderStyle("outline", borderTransform);
    const outlineColor = createBorderStyle("outlineColor");
    const borderRadius = (props)=>{
        if (props.borderRadius !== void 0 && props.borderRadius !== null) {
            const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
            const styleFromPropValue = (propValue)=>({
                    borderRadius: getValue(transformer, propValue)
                });
            return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
        }
        return null;
    };
    borderRadius.propTypes = {};
    borderRadius.filterProps = [
        "borderRadius"
    ];
    compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
    const gap = (props)=>{
        if (props.gap !== void 0 && props.gap !== null) {
            const transformer = createUnaryUnit(props.theme, "spacing", 8);
            const styleFromPropValue = (propValue)=>({
                    gap: getValue(transformer, propValue)
                });
            return handleBreakpoints(props, props.gap, styleFromPropValue);
        }
        return null;
    };
    gap.propTypes = {};
    gap.filterProps = [
        "gap"
    ];
    const columnGap = (props)=>{
        if (props.columnGap !== void 0 && props.columnGap !== null) {
            const transformer = createUnaryUnit(props.theme, "spacing", 8);
            const styleFromPropValue = (propValue)=>({
                    columnGap: getValue(transformer, propValue)
                });
            return handleBreakpoints(props, props.columnGap, styleFromPropValue);
        }
        return null;
    };
    columnGap.propTypes = {};
    columnGap.filterProps = [
        "columnGap"
    ];
    const rowGap = (props)=>{
        if (props.rowGap !== void 0 && props.rowGap !== null) {
            const transformer = createUnaryUnit(props.theme, "spacing", 8);
            const styleFromPropValue = (propValue)=>({
                    rowGap: getValue(transformer, propValue)
                });
            return handleBreakpoints(props, props.rowGap, styleFromPropValue);
        }
        return null;
    };
    rowGap.propTypes = {};
    rowGap.filterProps = [
        "rowGap"
    ];
    const gridColumn = style$1({
        prop: "gridColumn"
    });
    const gridRow = style$1({
        prop: "gridRow"
    });
    const gridAutoFlow = style$1({
        prop: "gridAutoFlow"
    });
    const gridAutoColumns = style$1({
        prop: "gridAutoColumns"
    });
    const gridAutoRows = style$1({
        prop: "gridAutoRows"
    });
    const gridTemplateColumns = style$1({
        prop: "gridTemplateColumns"
    });
    const gridTemplateRows = style$1({
        prop: "gridTemplateRows"
    });
    const gridTemplateAreas = style$1({
        prop: "gridTemplateAreas"
    });
    const gridArea = style$1({
        prop: "gridArea"
    });
    compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
    function paletteTransform(value, userValue) {
        if (userValue === 'grey') {
            return userValue;
        }
        return value;
    }
    const color = style$1({
        prop: 'color',
        themeKey: 'palette',
        transform: paletteTransform
    });
    const bgcolor = style$1({
        prop: 'bgcolor',
        cssProperty: 'backgroundColor',
        themeKey: 'palette',
        transform: paletteTransform
    });
    const backgroundColor = style$1({
        prop: 'backgroundColor',
        themeKey: 'palette',
        transform: paletteTransform
    });
    compose(color, bgcolor, backgroundColor);
    function sizingTransform(value) {
        return value <= 1 && value !== 0 ? `${value * 100}%` : value;
    }
    const width = style$1({
        prop: 'width',
        transform: sizingTransform
    });
    const maxWidth = (props)=>{
        if (props.maxWidth !== undefined && props.maxWidth !== null) {
            const styleFromPropValue = (propValue)=>{
                const breakpoint = props.theme?.breakpoints?.values?.[propValue] || values$1[propValue];
                if (!breakpoint) {
                    return {
                        maxWidth: sizingTransform(propValue)
                    };
                }
                if (props.theme?.breakpoints?.unit !== 'px') {
                    return {
                        maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
                    };
                }
                return {
                    maxWidth: breakpoint
                };
            };
            return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
        }
        return null;
    };
    maxWidth.filterProps = [
        'maxWidth'
    ];
    const minWidth = style$1({
        prop: 'minWidth',
        transform: sizingTransform
    });
    const height = style$1({
        prop: 'height',
        transform: sizingTransform
    });
    const maxHeight = style$1({
        prop: 'maxHeight',
        transform: sizingTransform
    });
    const minHeight = style$1({
        prop: 'minHeight',
        transform: sizingTransform
    });
    style$1({
        prop: 'size',
        cssProperty: 'width',
        transform: sizingTransform
    });
    style$1({
        prop: 'size',
        cssProperty: 'height',
        transform: sizingTransform
    });
    const boxSizing = style$1({
        prop: 'boxSizing'
    });
    compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
    const defaultSxConfig = {
        border: {
            themeKey: 'borders',
            transform: borderTransform
        },
        borderTop: {
            themeKey: 'borders',
            transform: borderTransform
        },
        borderRight: {
            themeKey: 'borders',
            transform: borderTransform
        },
        borderBottom: {
            themeKey: 'borders',
            transform: borderTransform
        },
        borderLeft: {
            themeKey: 'borders',
            transform: borderTransform
        },
        borderColor: {
            themeKey: 'palette'
        },
        borderTopColor: {
            themeKey: 'palette'
        },
        borderRightColor: {
            themeKey: 'palette'
        },
        borderBottomColor: {
            themeKey: 'palette'
        },
        borderLeftColor: {
            themeKey: 'palette'
        },
        outline: {
            themeKey: 'borders',
            transform: borderTransform
        },
        outlineColor: {
            themeKey: 'palette'
        },
        borderRadius: {
            themeKey: 'shape.borderRadius',
            style: borderRadius
        },
        color: {
            themeKey: 'palette',
            transform: paletteTransform
        },
        bgcolor: {
            themeKey: 'palette',
            cssProperty: 'backgroundColor',
            transform: paletteTransform
        },
        backgroundColor: {
            themeKey: 'palette',
            transform: paletteTransform
        },
        p: {
            style: padding
        },
        pt: {
            style: padding
        },
        pr: {
            style: padding
        },
        pb: {
            style: padding
        },
        pl: {
            style: padding
        },
        px: {
            style: padding
        },
        py: {
            style: padding
        },
        padding: {
            style: padding
        },
        paddingTop: {
            style: padding
        },
        paddingRight: {
            style: padding
        },
        paddingBottom: {
            style: padding
        },
        paddingLeft: {
            style: padding
        },
        paddingX: {
            style: padding
        },
        paddingY: {
            style: padding
        },
        paddingInline: {
            style: padding
        },
        paddingInlineStart: {
            style: padding
        },
        paddingInlineEnd: {
            style: padding
        },
        paddingBlock: {
            style: padding
        },
        paddingBlockStart: {
            style: padding
        },
        paddingBlockEnd: {
            style: padding
        },
        m: {
            style: margin
        },
        mt: {
            style: margin
        },
        mr: {
            style: margin
        },
        mb: {
            style: margin
        },
        ml: {
            style: margin
        },
        mx: {
            style: margin
        },
        my: {
            style: margin
        },
        margin: {
            style: margin
        },
        marginTop: {
            style: margin
        },
        marginRight: {
            style: margin
        },
        marginBottom: {
            style: margin
        },
        marginLeft: {
            style: margin
        },
        marginX: {
            style: margin
        },
        marginY: {
            style: margin
        },
        marginInline: {
            style: margin
        },
        marginInlineStart: {
            style: margin
        },
        marginInlineEnd: {
            style: margin
        },
        marginBlock: {
            style: margin
        },
        marginBlockStart: {
            style: margin
        },
        marginBlockEnd: {
            style: margin
        },
        displayPrint: {
            cssProperty: false,
            transform: (value)=>({
                    '@media print': {
                        display: value
                    }
                })
        },
        display: {},
        overflow: {},
        textOverflow: {},
        visibility: {},
        whiteSpace: {},
        flexBasis: {},
        flexDirection: {},
        flexWrap: {},
        justifyContent: {},
        alignItems: {},
        alignContent: {},
        order: {},
        flex: {},
        flexGrow: {},
        flexShrink: {},
        alignSelf: {},
        justifyItems: {},
        justifySelf: {},
        gap: {
            style: gap
        },
        rowGap: {
            style: rowGap
        },
        columnGap: {
            style: columnGap
        },
        gridColumn: {},
        gridRow: {},
        gridAutoFlow: {},
        gridAutoColumns: {},
        gridAutoRows: {},
        gridTemplateColumns: {},
        gridTemplateRows: {},
        gridTemplateAreas: {},
        gridArea: {},
        position: {},
        zIndex: {
            themeKey: 'zIndex'
        },
        top: {},
        right: {},
        bottom: {},
        left: {},
        boxShadow: {
            themeKey: 'shadows'
        },
        width: {
            transform: sizingTransform
        },
        maxWidth: {
            style: maxWidth
        },
        minWidth: {
            transform: sizingTransform
        },
        height: {
            transform: sizingTransform
        },
        maxHeight: {
            transform: sizingTransform
        },
        minHeight: {
            transform: sizingTransform
        },
        boxSizing: {},
        font: {
            themeKey: 'font'
        },
        fontFamily: {
            themeKey: 'typography'
        },
        fontSize: {
            themeKey: 'typography'
        },
        fontStyle: {
            themeKey: 'typography'
        },
        fontWeight: {
            themeKey: 'typography'
        },
        letterSpacing: {},
        textTransform: {},
        lineHeight: {},
        textAlign: {},
        typography: {
            cssProperty: false,
            themeKey: 'typography'
        }
    };
    function objectsHaveSameKeys(...objects) {
        const allKeys = objects.reduce((keys, object)=>keys.concat(Object.keys(object)), []);
        const union = new Set(allKeys);
        return objects.every((object)=>union.size === Object.keys(object).length);
    }
    function callIfFn(maybeFn, arg) {
        return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
    }
    function unstable_createStyleFunctionSx() {
        function getThemeValue(prop, val, theme, config) {
            const props = {
                [prop]: val,
                theme
            };
            const options = config[prop];
            if (!options) {
                return {
                    [prop]: val
                };
            }
            const { cssProperty = prop, themeKey, transform, style } = options;
            if (val == null) {
                return null;
            }
            if (themeKey === 'typography' && val === 'inherit') {
                return {
                    [prop]: val
                };
            }
            const themeMapping = getPath(theme, themeKey) || {};
            if (style) {
                return style(props);
            }
            const styleFromPropValue = (propValueFinal)=>{
                let value = getStyleValue$1(themeMapping, transform, propValueFinal);
                if (propValueFinal === value && typeof propValueFinal === 'string') {
                    value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
                }
                if (cssProperty === false) {
                    return value;
                }
                return {
                    [cssProperty]: value
                };
            };
            return handleBreakpoints(props, val, styleFromPropValue);
        }
        function styleFunctionSx(props) {
            const { sx, theme = {}, nested } = props || {};
            if (!sx) {
                return null;
            }
            const config = theme.unstable_sxConfig ?? defaultSxConfig;
            function traverse(sxInput) {
                let sxObject = sxInput;
                if (typeof sxInput === 'function') {
                    sxObject = sxInput(theme);
                } else if (typeof sxInput !== 'object') {
                    return sxInput;
                }
                if (!sxObject) {
                    return null;
                }
                const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
                const breakpointsKeys = Object.keys(emptyBreakpoints);
                let css = emptyBreakpoints;
                Object.keys(sxObject).forEach((styleKey)=>{
                    const value = callIfFn(sxObject[styleKey], theme);
                    if (value !== null && value !== undefined) {
                        if (typeof value === 'object') {
                            if (config[styleKey]) {
                                css = merge(css, getThemeValue(styleKey, value, theme, config));
                            } else {
                                const breakpointsValues = handleBreakpoints({
                                    theme
                                }, value, (x)=>({
                                        [styleKey]: x
                                    }));
                                if (objectsHaveSameKeys(breakpointsValues, value)) {
                                    css[styleKey] = styleFunctionSx({
                                        sx: value,
                                        theme,
                                        nested: true
                                    });
                                } else {
                                    css = merge(css, breakpointsValues);
                                }
                            }
                        } else {
                            css = merge(css, getThemeValue(styleKey, value, theme, config));
                        }
                    }
                });
                if (!nested && theme.modularCssLayers) {
                    return {
                        '@layer sx': sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css))
                    };
                }
                return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css));
            }
            return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
        }
        return styleFunctionSx;
    }
    const styleFunctionSx = unstable_createStyleFunctionSx();
    styleFunctionSx.filterProps = [
        'sx'
    ];
    function applyStyles(key, styles) {
        const theme = this;
        if (theme.vars) {
            if (!theme.colorSchemes?.[key] || typeof theme.getColorSchemeSelector !== 'function') {
                return {};
            }
            let selector = theme.getColorSchemeSelector(key);
            if (selector === '&') {
                return styles;
            }
            if (selector.includes('data-') || selector.includes('.')) {
                selector = `*:where(${selector.replace(/\s*&$/, '')}) &`;
            }
            return {
                [selector]: styles
            };
        }
        if (theme.palette.mode === key) {
            return styles;
        }
        return {};
    }
    function createTheme$1(options = {}, ...args) {
        const { breakpoints: breakpointsInput = {}, palette: paletteInput = {}, spacing: spacingInput, shape: shapeInput = {}, ...other } = options;
        const breakpoints = createBreakpoints(breakpointsInput);
        const spacing = createSpacing(spacingInput);
        let muiTheme = deepmerge({
            breakpoints,
            direction: 'ltr',
            components: {},
            palette: {
                mode: 'light',
                ...paletteInput
            },
            spacing,
            shape: {
                ...shape,
                ...shapeInput
            }
        }, other);
        muiTheme = cssContainerQueries(muiTheme);
        muiTheme.applyStyles = applyStyles;
        muiTheme = args.reduce((acc, argument)=>deepmerge(acc, argument), muiTheme);
        muiTheme.unstable_sxConfig = {
            ...defaultSxConfig,
            ...other?.unstable_sxConfig
        };
        muiTheme.unstable_sx = function sx(props) {
            return styleFunctionSx({
                sx: props,
                theme: this
            });
        };
        return muiTheme;
    }
    function isObjectEmpty$2(obj) {
        return Object.keys(obj).length === 0;
    }
    function useTheme$3(defaultTheme = null) {
        const contextTheme = reactExports.useContext(ThemeContext$1);
        return !contextTheme || isObjectEmpty$2(contextTheme) ? defaultTheme : contextTheme;
    }
    const systemDefaultTheme$1 = createTheme$1();
    function useTheme$2(defaultTheme = systemDefaultTheme$1) {
        return useTheme$3(defaultTheme);
    }
    function wrapGlobalLayer(styles) {
        const serialized = internal_serializeStyles(styles);
        if (styles !== serialized && serialized.styles) {
            if (!serialized.styles.match(/^@layer\s+[^{]*$/)) {
                serialized.styles = `@layer global{${serialized.styles}}`;
            }
            return serialized;
        }
        return styles;
    }
    function GlobalStyles$2({ styles, themeId, defaultTheme = {} }) {
        const upperTheme = useTheme$2(defaultTheme);
        const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
        let globalStyles = typeof styles === "function" ? styles(resolvedTheme) : styles;
        if (resolvedTheme.modularCssLayers) {
            if (Array.isArray(globalStyles)) {
                globalStyles = globalStyles.map((styleArg)=>{
                    if (typeof styleArg === "function") {
                        return wrapGlobalLayer(styleArg(resolvedTheme));
                    }
                    return wrapGlobalLayer(styleArg);
                });
            } else {
                globalStyles = wrapGlobalLayer(globalStyles);
            }
        }
        return jsxRuntimeExports.jsx(GlobalStyles$3, {
            styles: globalStyles
        });
    }
    const splitProps = (props)=>{
        const result = {
            systemProps: {},
            otherProps: {}
        };
        const config = props?.theme?.unstable_sxConfig ?? defaultSxConfig;
        Object.keys(props).forEach((prop)=>{
            if (config[prop]) {
                result.systemProps[prop] = props[prop];
            } else {
                result.otherProps[prop] = props[prop];
            }
        });
        return result;
    };
    function extendSxProp$1(props) {
        const { sx: inSx, ...other } = props;
        const { systemProps, otherProps } = splitProps(other);
        let finalSx;
        if (Array.isArray(inSx)) {
            finalSx = [
                systemProps,
                ...inSx
            ];
        } else if (typeof inSx === 'function') {
            finalSx = (...args)=>{
                const result = inSx(...args);
                if (!isPlainObject$3(result)) {
                    return systemProps;
                }
                return {
                    ...systemProps,
                    ...result
                };
            };
        } else {
            finalSx = {
                ...systemProps,
                ...inSx
            };
        }
        return {
            ...otherProps,
            sx: finalSx
        };
    }
    const defaultGenerator = (componentName)=>componentName;
    const createClassNameGenerator = ()=>{
        let generate = defaultGenerator;
        return {
            configure (generator) {
                generate = generator;
            },
            generate (componentName) {
                return generate(componentName);
            },
            reset () {
                generate = defaultGenerator;
            }
        };
    };
    const ClassNameGenerator = createClassNameGenerator();
    function r(e) {
        var t, f, n = "";
        if ("string" == typeof e || "number" == typeof e) n += e;
        else if ("object" == typeof e) if (Array.isArray(e)) {
            var o = e.length;
            for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
        } else for(f in e)e[f] && (n && (n += " "), n += f);
        return n;
    }
    function clsx() {
        for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
        return n;
    }
    function createBox(options = {}) {
        const { themeId, defaultTheme, defaultClassName = 'MuiBox-root', generateClassName } = options;
        const BoxRoot = styled$2('div', {
            shouldForwardProp: (prop)=>prop !== 'theme' && prop !== 'sx' && prop !== 'as'
        })(styleFunctionSx);
        const Box = reactExports.forwardRef(function Box(inProps, ref) {
            const theme = useTheme$2(defaultTheme);
            const { className, component = 'div', ...other } = extendSxProp$1(inProps);
            return jsxRuntimeExports.jsx(BoxRoot, {
                as: component,
                ref: ref,
                className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
                theme: themeId ? theme[themeId] || theme : theme,
                ...other
            });
        });
        return Box;
    }
    const globalStateClasses = {
        active: 'active',
        checked: 'checked',
        completed: 'completed',
        disabled: 'disabled',
        error: 'error',
        expanded: 'expanded',
        focused: 'focused',
        focusVisible: 'focusVisible',
        open: 'open',
        readOnly: 'readOnly',
        required: 'required',
        selected: 'selected'
    };
    function generateUtilityClass(componentName, slot, globalStatePrefix = 'Mui') {
        const globalStateClass = globalStateClasses[slot];
        return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
    }
    function generateUtilityClasses(componentName, slots, globalStatePrefix = 'Mui') {
        const result = {};
        slots.forEach((slot)=>{
            result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
        });
        return result;
    }
    function preprocessStyles(input) {
        const { variants, ...style } = input;
        const result = {
            variants,
            style: internal_serializeStyles(style),
            isProcessed: true
        };
        if (result.style === style) {
            return result;
        }
        if (variants) {
            variants.forEach((variant)=>{
                if (typeof variant.style !== 'function') {
                    variant.style = internal_serializeStyles(variant.style);
                }
            });
        }
        return result;
    }
    const systemDefaultTheme = createTheme$1();
    function shouldForwardProp(prop) {
        return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
    }
    function shallowLayer(serialized, layerName) {
        if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) {
            serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
        }
        return serialized;
    }
    function defaultOverridesResolver(slot) {
        if (!slot) {
            return null;
        }
        return (_props, styles)=>styles[slot];
    }
    function attachTheme(props, themeId, defaultTheme) {
        props.theme = isObjectEmpty$1(props.theme) ? defaultTheme : props.theme[themeId] || props.theme;
    }
    function processStyle(props, style, layerName) {
        const resolvedStyle = typeof style === "function" ? style(props) : style;
        if (Array.isArray(resolvedStyle)) {
            return resolvedStyle.flatMap((subStyle)=>processStyle(props, subStyle, layerName));
        }
        if (Array.isArray(resolvedStyle?.variants)) {
            let rootStyle;
            if (resolvedStyle.isProcessed) {
                rootStyle = layerName ? shallowLayer(resolvedStyle.style, layerName) : resolvedStyle.style;
            } else {
                const { variants, ...otherStyles } = resolvedStyle;
                rootStyle = layerName ? shallowLayer(internal_serializeStyles(otherStyles), layerName) : otherStyles;
            }
            return processStyleVariants(props, resolvedStyle.variants, [
                rootStyle
            ], layerName);
        }
        if (resolvedStyle?.isProcessed) {
            return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle.style), layerName) : resolvedStyle.style;
        }
        return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle), layerName) : resolvedStyle;
    }
    function processStyleVariants(props, variants, results = [], layerName = void 0) {
        let mergedState;
        variantLoop: for(let i = 0; i < variants.length; i += 1){
            const variant = variants[i];
            if (typeof variant.props === "function") {
                mergedState ??= {
                    ...props,
                    ...props.ownerState,
                    ownerState: props.ownerState
                };
                if (!variant.props(mergedState)) {
                    continue;
                }
            } else {
                for(const key in variant.props){
                    if (props[key] !== variant.props[key] && props.ownerState?.[key] !== variant.props[key]) {
                        continue variantLoop;
                    }
                }
            }
            if (typeof variant.style === "function") {
                mergedState ??= {
                    ...props,
                    ...props.ownerState,
                    ownerState: props.ownerState
                };
                results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style(mergedState)), layerName) : variant.style(mergedState));
            } else {
                results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style), layerName) : variant.style);
            }
        }
        return results;
    }
    function createStyled(input = {}) {
        const { themeId, defaultTheme = systemDefaultTheme, rootShouldForwardProp = shouldForwardProp, slotShouldForwardProp = shouldForwardProp } = input;
        function styleAttachTheme(props) {
            attachTheme(props, themeId, defaultTheme);
        }
        const styled = (tag, inputOptions = {})=>{
            internal_mutateStyles(tag, (styles)=>styles.filter((style)=>style !== styleFunctionSx));
            const { name: componentName, slot: componentSlot, skipVariantsResolver: inputSkipVariantsResolver, skipSx: inputSkipSx, overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)), ...options } = inputOptions;
            const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
            const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false);
            const skipSx = inputSkipSx || false;
            let shouldForwardPropOption = shouldForwardProp;
            if (componentSlot === "Root" || componentSlot === "root") {
                shouldForwardPropOption = rootShouldForwardProp;
            } else if (componentSlot) {
                shouldForwardPropOption = slotShouldForwardProp;
            } else if (isStringTag(tag)) {
                shouldForwardPropOption = void 0;
            }
            const defaultStyledResolver = styled$2(tag, {
                shouldForwardProp: shouldForwardPropOption,
                label: generateStyledLabel(),
                ...options
            });
            const transformStyle = (style)=>{
                if (style.__emotion_real === style) {
                    return style;
                }
                if (typeof style === "function") {
                    return function styleFunctionProcessor(props) {
                        return processStyle(props, style, props.theme.modularCssLayers ? layerName : void 0);
                    };
                }
                if (isPlainObject$3(style)) {
                    const serialized = preprocessStyles(style);
                    return function styleObjectProcessor(props) {
                        if (!serialized.variants) {
                            return props.theme.modularCssLayers ? shallowLayer(serialized.style, layerName) : serialized.style;
                        }
                        return processStyle(props, serialized, props.theme.modularCssLayers ? layerName : void 0);
                    };
                }
                return style;
            };
            const muiStyledResolver = (...expressionsInput)=>{
                const expressionsHead = [];
                const expressionsBody = expressionsInput.map(transformStyle);
                const expressionsTail = [];
                expressionsHead.push(styleAttachTheme);
                if (componentName && overridesResolver) {
                    expressionsTail.push(function styleThemeOverrides(props) {
                        const theme = props.theme;
                        const styleOverrides = theme.components?.[componentName]?.styleOverrides;
                        if (!styleOverrides) {
                            return null;
                        }
                        const resolvedStyleOverrides = {};
                        for(const slotKey in styleOverrides){
                            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey], props.theme.modularCssLayers ? "theme" : void 0);
                        }
                        return overridesResolver(props, resolvedStyleOverrides);
                    });
                }
                if (componentName && !skipVariantsResolver) {
                    expressionsTail.push(function styleThemeVariants(props) {
                        const theme = props.theme;
                        const themeVariants = theme?.components?.[componentName]?.variants;
                        if (!themeVariants) {
                            return null;
                        }
                        return processStyleVariants(props, themeVariants, [], props.theme.modularCssLayers ? "theme" : void 0);
                    });
                }
                if (!skipSx) {
                    expressionsTail.push(styleFunctionSx);
                }
                if (Array.isArray(expressionsBody[0])) {
                    const inputStrings = expressionsBody.shift();
                    const placeholdersHead = new Array(expressionsHead.length).fill("");
                    const placeholdersTail = new Array(expressionsTail.length).fill("");
                    let outputStrings;
                    {
                        outputStrings = [
                            ...placeholdersHead,
                            ...inputStrings,
                            ...placeholdersTail
                        ];
                        outputStrings.raw = [
                            ...placeholdersHead,
                            ...inputStrings.raw,
                            ...placeholdersTail
                        ];
                    }
                    expressionsHead.unshift(outputStrings);
                }
                const expressions = [
                    ...expressionsHead,
                    ...expressionsBody,
                    ...expressionsTail
                ];
                const Component = defaultStyledResolver(...expressions);
                if (tag.muiName) {
                    Component.muiName = tag.muiName;
                }
                return Component;
            };
            if (defaultStyledResolver.withConfig) {
                muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
            }
            return muiStyledResolver;
        };
        return styled;
    }
    function generateStyledLabel(componentName, componentSlot) {
        let label;
        return label;
    }
    function isObjectEmpty$1(object) {
        for(const _ in object){
            return false;
        }
        return true;
    }
    function isStringTag(tag) {
        return typeof tag === "string" && tag.charCodeAt(0) > 96;
    }
    function lowercaseFirstLetter(string) {
        if (!string) {
            return string;
        }
        return string.charAt(0).toLowerCase() + string.slice(1);
    }
    const styled$1 = createStyled();
    function resolveProps(defaultProps, props, mergeClassNameAndStyle = false) {
        const output = {
            ...props
        };
        for(const key in defaultProps){
            if (Object.prototype.hasOwnProperty.call(defaultProps, key)) {
                const propName = key;
                if (propName === 'components' || propName === 'slots') {
                    output[propName] = {
                        ...defaultProps[propName],
                        ...output[propName]
                    };
                } else if (propName === 'componentsProps' || propName === 'slotProps') {
                    const defaultSlotProps = defaultProps[propName];
                    const slotProps = props[propName];
                    if (!slotProps) {
                        output[propName] = defaultSlotProps || {};
                    } else if (!defaultSlotProps) {
                        output[propName] = slotProps;
                    } else {
                        output[propName] = {
                            ...slotProps
                        };
                        for(const slotKey in defaultSlotProps){
                            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
                                const slotPropName = slotKey;
                                output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName], mergeClassNameAndStyle);
                            }
                        }
                    }
                } else if (propName === 'className' && mergeClassNameAndStyle && props.className) {
                    output.className = clsx(defaultProps?.className, props?.className);
                } else if (propName === 'style' && mergeClassNameAndStyle && props.style) {
                    output.style = {
                        ...defaultProps?.style,
                        ...props?.style
                    };
                } else if (output[propName] === undefined) {
                    output[propName] = defaultProps[propName];
                }
            }
        }
        return output;
    }
    function getThemeProps$1(params) {
        const { theme, name, props } = params;
        if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
            return props;
        }
        return resolveProps(theme.components[name].defaultProps, props);
    }
    function useThemeProps({ props, name, defaultTheme, themeId }) {
        let theme = useTheme$2(defaultTheme);
        if (themeId) {
            theme = theme[themeId] || theme;
        }
        return getThemeProps$1({
            theme,
            name,
            props
        });
    }
    const useEnhancedEffect = typeof window !== 'undefined' ? reactExports.useLayoutEffect : reactExports.useEffect;
    function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
        return Math.max(min, Math.min(val, max));
    }
    function clampWrapper(value, min = 0, max = 1) {
        return clamp(value, min, max);
    }
    function hexToRgb(color) {
        color = color.slice(1);
        const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, "g");
        let colors = color.match(re);
        if (colors && colors[0].length === 1) {
            colors = colors.map((n)=>n + n);
        }
        return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index)=>{
            return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
        }).join(", ")})` : "";
    }
    function decomposeColor(color) {
        if (color.type) {
            return color;
        }
        if (color.charAt(0) === "#") {
            return decomposeColor(hexToRgb(color));
        }
        const marker = color.indexOf("(");
        const type = color.substring(0, marker);
        if (![
            "rgb",
            "rgba",
            "hsl",
            "hsla",
            "color"
        ].includes(type)) {
            throw new Error(formatMuiErrorMessage(9, color));
        }
        let values = color.substring(marker + 1, color.length - 1);
        let colorSpace;
        if (type === "color") {
            values = values.split(" ");
            colorSpace = values.shift();
            if (values.length === 4 && values[3].charAt(0) === "/") {
                values[3] = values[3].slice(1);
            }
            if (![
                "srgb",
                "display-p3",
                "a98-rgb",
                "prophoto-rgb",
                "rec-2020"
            ].includes(colorSpace)) {
                throw new Error(formatMuiErrorMessage(10, colorSpace));
            }
        } else {
            values = values.split(",");
        }
        values = values.map((value)=>parseFloat(value));
        return {
            type,
            values,
            colorSpace
        };
    }
    const colorChannel = (color)=>{
        const decomposedColor = decomposeColor(color);
        return decomposedColor.values.slice(0, 3).map((val, idx)=>decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
    };
    const private_safeColorChannel = (color, warning)=>{
        try {
            return colorChannel(color);
        } catch (error) {
            return color;
        }
    };
    function recomposeColor(color) {
        const { type, colorSpace } = color;
        let { values } = color;
        if (type.includes("rgb")) {
            values = values.map((n, i)=>i < 3 ? parseInt(n, 10) : n);
        } else if (type.includes("hsl")) {
            values[1] = `${values[1]}%`;
            values[2] = `${values[2]}%`;
        }
        if (type.includes("color")) {
            values = `${colorSpace} ${values.join(" ")}`;
        } else {
            values = `${values.join(", ")}`;
        }
        return `${type}(${values})`;
    }
    function hslToRgb(color) {
        color = decomposeColor(color);
        const { values } = color;
        const h = values[0];
        const s = values[1] / 100;
        const l = values[2] / 100;
        const a = s * Math.min(l, 1 - l);
        const f = (n, k = (n + h / 30) % 12)=>l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        let type = "rgb";
        const rgb = [
            Math.round(f(0) * 255),
            Math.round(f(8) * 255),
            Math.round(f(4) * 255)
        ];
        if (color.type === "hsla") {
            type += "a";
            rgb.push(values[3]);
        }
        return recomposeColor({
            type,
            values: rgb
        });
    }
    function getLuminance(color) {
        color = decomposeColor(color);
        let rgb = color.type === "hsl" || color.type === "hsla" ? decomposeColor(hslToRgb(color)).values : color.values;
        rgb = rgb.map((val)=>{
            if (color.type !== "color") {
                val /= 255;
            }
            return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
        });
        return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
    }
    function getContrastRatio(foreground, background) {
        const lumA = getLuminance(foreground);
        const lumB = getLuminance(background);
        return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
    }
    function alpha(color, value) {
        color = decomposeColor(color);
        value = clampWrapper(value);
        if (color.type === "rgb" || color.type === "hsl") {
            color.type += "a";
        }
        if (color.type === "color") {
            color.values[3] = `/${value}`;
        } else {
            color.values[3] = value;
        }
        return recomposeColor(color);
    }
    function private_safeAlpha(color, value, warning) {
        try {
            return alpha(color, value);
        } catch (error) {
            return color;
        }
    }
    function darken(color, coefficient) {
        color = decomposeColor(color);
        coefficient = clampWrapper(coefficient);
        if (color.type.includes("hsl")) {
            color.values[2] *= 1 - coefficient;
        } else if (color.type.includes("rgb") || color.type.includes("color")) {
            for(let i = 0; i < 3; i += 1){
                color.values[i] *= 1 - coefficient;
            }
        }
        return recomposeColor(color);
    }
    function private_safeDarken(color, coefficient, warning) {
        try {
            return darken(color, coefficient);
        } catch (error) {
            return color;
        }
    }
    function lighten(color, coefficient) {
        color = decomposeColor(color);
        coefficient = clampWrapper(coefficient);
        if (color.type.includes("hsl")) {
            color.values[2] += (100 - color.values[2]) * coefficient;
        } else if (color.type.includes("rgb")) {
            for(let i = 0; i < 3; i += 1){
                color.values[i] += (255 - color.values[i]) * coefficient;
            }
        } else if (color.type.includes("color")) {
            for(let i = 0; i < 3; i += 1){
                color.values[i] += (1 - color.values[i]) * coefficient;
            }
        }
        return recomposeColor(color);
    }
    function private_safeLighten(color, coefficient, warning) {
        try {
            return lighten(color, coefficient);
        } catch (error) {
            return color;
        }
    }
    function emphasize(color, coefficient = 0.15) {
        return getLuminance(color) > 0.5 ? darken(color, coefficient) : lighten(color, coefficient);
    }
    function private_safeEmphasize(color, coefficient, warning) {
        try {
            return emphasize(color, coefficient);
        } catch (error) {
            return color;
        }
    }
    const ThemeContext = reactExports.createContext(null);
    function useTheme$1() {
        const theme = reactExports.useContext(ThemeContext);
        return theme;
    }
    const hasSymbol$1 = typeof Symbol === 'function' && Symbol.for;
    const nested = hasSymbol$1 ? Symbol.for('mui.nested') : '__THEME_NESTED__';
    function mergeOuterLocalTheme(outerTheme, localTheme) {
        if (typeof localTheme === "function") {
            const mergedTheme = localTheme(outerTheme);
            return mergedTheme;
        }
        return {
            ...outerTheme,
            ...localTheme
        };
    }
    function ThemeProvider$2(props) {
        const { children, theme: localTheme } = props;
        const outerTheme = useTheme$1();
        const theme = reactExports.useMemo(()=>{
            const output = outerTheme === null ? {
                ...localTheme
            } : mergeOuterLocalTheme(outerTheme, localTheme);
            if (output != null) {
                output[nested] = outerTheme !== null;
            }
            return output;
        }, [
            localTheme,
            outerTheme
        ]);
        return jsxRuntimeExports.jsx(ThemeContext.Provider, {
            value: theme,
            children
        });
    }
    const RtlContext = reactExports.createContext();
    function RtlProvider({ value, ...props }) {
        return jsxRuntimeExports.jsx(RtlContext.Provider, {
            value: value ?? true,
            ...props
        });
    }
    const useRtl = ()=>{
        const value = reactExports.useContext(RtlContext);
        return value ?? false;
    };
    const PropsContext = reactExports.createContext(void 0);
    function DefaultPropsProvider({ value, children }) {
        return jsxRuntimeExports.jsx(PropsContext.Provider, {
            value,
            children
        });
    }
    function getThemeProps(params) {
        const { theme, name, props } = params;
        if (!theme || !theme.components || !theme.components[name]) {
            return props;
        }
        const config = theme.components[name];
        if (config.defaultProps) {
            return resolveProps(config.defaultProps, props, theme.components.mergeClassNameAndStyle);
        }
        if (!config.styleOverrides && !config.variants) {
            return resolveProps(config, props, theme.components.mergeClassNameAndStyle);
        }
        return props;
    }
    function useDefaultProps$1({ props, name }) {
        const ctx = reactExports.useContext(PropsContext);
        return getThemeProps({
            props,
            name,
            theme: {
                components: ctx
            }
        });
    }
    let globalId = 0;
    function useGlobalId(idOverride) {
        const [defaultId, setDefaultId] = reactExports.useState(idOverride);
        const id = idOverride || defaultId;
        reactExports.useEffect(()=>{
            if (defaultId == null) {
                globalId += 1;
                setDefaultId(`mui-${globalId}`);
            }
        }, [
            defaultId
        ]);
        return id;
    }
    const safeReact = {
        ...React$1
    };
    const maybeReactUseId = safeReact.useId;
    function useId(idOverride) {
        if (maybeReactUseId !== undefined) {
            const reactId = maybeReactUseId();
            return idOverride ?? reactId;
        }
        return useGlobalId(idOverride);
    }
    function useLayerOrder(theme) {
        const upperTheme = useTheme$3();
        const id = useId() || '';
        const { modularCssLayers } = theme;
        let layerOrder = 'mui.global, mui.components, mui.theme, mui.custom, mui.sx';
        if (!modularCssLayers || upperTheme !== null) {
            layerOrder = '';
        } else if (typeof modularCssLayers === 'string') {
            layerOrder = modularCssLayers.replace(/mui(?!\.)/g, layerOrder);
        } else {
            layerOrder = `@layer ${layerOrder};`;
        }
        useEnhancedEffect(()=>{
            const head = document.querySelector('head');
            if (!head) {
                return;
            }
            const firstChild = head.firstChild;
            if (layerOrder) {
                if (firstChild && firstChild.hasAttribute?.('data-mui-layer-order') && firstChild.getAttribute('data-mui-layer-order') === id) {
                    return;
                }
                const styleElement = document.createElement('style');
                styleElement.setAttribute('data-mui-layer-order', id);
                styleElement.textContent = layerOrder;
                head.prepend(styleElement);
            } else {
                head.querySelector(`style[data-mui-layer-order="${id}"]`)?.remove();
            }
        }, [
            layerOrder,
            id
        ]);
        if (!layerOrder) {
            return null;
        }
        return jsxRuntimeExports.jsx(GlobalStyles$2, {
            styles: layerOrder
        });
    }
    const EMPTY_THEME = {};
    function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
        return reactExports.useMemo(()=>{
            const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
            if (typeof localTheme === "function") {
                const mergedTheme = localTheme(resolvedTheme);
                const result = themeId ? {
                    ...upperTheme,
                    [themeId]: mergedTheme
                } : mergedTheme;
                if (isPrivate) {
                    return ()=>result;
                }
                return result;
            }
            return themeId ? {
                ...upperTheme,
                [themeId]: localTheme
            } : {
                ...upperTheme,
                ...localTheme
            };
        }, [
            themeId,
            upperTheme,
            localTheme,
            isPrivate
        ]);
    }
    function ThemeProvider$1(props) {
        const { children, theme: localTheme, themeId } = props;
        const upperTheme = useTheme$3(EMPTY_THEME);
        const upperPrivateTheme = useTheme$1() || EMPTY_THEME;
        const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
        const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
        const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
        const layerOrder = useLayerOrder(engineTheme);
        return jsxRuntimeExports.jsx(ThemeProvider$2, {
            theme: privateTheme,
            children: jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
                value: engineTheme,
                children: jsxRuntimeExports.jsx(RtlProvider, {
                    value: rtlValue,
                    children: jsxRuntimeExports.jsxs(DefaultPropsProvider, {
                        value: themeId ? engineTheme[themeId].components : engineTheme.components,
                        children: [
                            layerOrder,
                            children
                        ]
                    })
                })
            })
        });
    }
    const arg = {
        theme: undefined
    };
    function unstable_memoTheme(styleFn) {
        let lastValue;
        let lastTheme;
        return function styleMemoized(props) {
            let value = lastValue;
            if (value === undefined || props.theme !== lastTheme) {
                arg.theme = props.theme;
                value = preprocessStyles(styleFn(arg));
                lastValue = value;
                lastTheme = props.theme;
            }
            return value;
        };
    }
    const DEFAULT_MODE_STORAGE_KEY = 'mode';
    const DEFAULT_COLOR_SCHEME_STORAGE_KEY = 'color-scheme';
    const DEFAULT_ATTRIBUTE = 'data-color-scheme';
    function InitColorSchemeScript(options) {
        const { defaultMode = 'system', defaultLightColorScheme = 'light', defaultDarkColorScheme = 'dark', modeStorageKey = DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY, attribute: initialAttribute = DEFAULT_ATTRIBUTE, colorSchemeNode = 'document.documentElement', nonce } = options || {};
        let setter = '';
        let attribute = initialAttribute;
        if (initialAttribute === 'class') {
            attribute = '.%s';
        }
        if (initialAttribute === 'data') {
            attribute = '[data-%s]';
        }
        if (attribute.startsWith('.')) {
            const selector = attribute.substring(1);
            setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
        }
        const matches = attribute.match(/\[([^\]]+)\]/);
        if (matches) {
            const [attr, value] = matches[1].split('=');
            if (!value) {
                setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
            }
            setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : '""'});`;
        } else {
            setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
        }
        return jsxRuntimeExports.jsx("script", {
            suppressHydrationWarning: true,
            nonce: typeof window === 'undefined' ? nonce : '',
            dangerouslySetInnerHTML: {
                __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`
            }
        }, "mui-color-scheme-init");
    }
    function noop$5() {}
    const localStorageManager = ({ key, storageWindow })=>{
        if (!storageWindow && typeof window !== 'undefined') {
            storageWindow = window;
        }
        return {
            get (defaultValue) {
                if (typeof window === 'undefined') {
                    return undefined;
                }
                if (!storageWindow) {
                    return defaultValue;
                }
                let value;
                try {
                    value = storageWindow.localStorage.getItem(key);
                } catch  {}
                return value || defaultValue;
            },
            set: (value)=>{
                if (storageWindow) {
                    try {
                        storageWindow.localStorage.setItem(key, value);
                    } catch  {}
                }
            },
            subscribe: (handler)=>{
                if (!storageWindow) {
                    return noop$5;
                }
                const listener = (event)=>{
                    const value = event.newValue;
                    if (event.key === key) {
                        handler(value);
                    }
                };
                storageWindow.addEventListener('storage', listener);
                return ()=>{
                    storageWindow.removeEventListener('storage', listener);
                };
            }
        };
    };
    function noop$4() {}
    function getSystemMode(mode) {
        if (typeof window !== 'undefined' && typeof window.matchMedia === 'function' && mode === 'system') {
            const mql = window.matchMedia('(prefers-color-scheme: dark)');
            if (mql.matches) {
                return 'dark';
            }
            return 'light';
        }
        return undefined;
    }
    function processState(state, callback) {
        if (state.mode === 'light' || state.mode === 'system' && state.systemMode === 'light') {
            return callback('light');
        }
        if (state.mode === 'dark' || state.mode === 'system' && state.systemMode === 'dark') {
            return callback('dark');
        }
        return undefined;
    }
    function getColorScheme(state) {
        return processState(state, (mode)=>{
            if (mode === 'light') {
                return state.lightColorScheme;
            }
            if (mode === 'dark') {
                return state.darkColorScheme;
            }
            return undefined;
        });
    }
    function useCurrentColorScheme(options) {
        const { defaultMode = 'light', defaultLightColorScheme, defaultDarkColorScheme, supportedColorSchemes = [], modeStorageKey = DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY, storageWindow = typeof window === 'undefined' ? undefined : window, storageManager = localStorageManager, noSsr = false } = options;
        const joinedColorSchemes = supportedColorSchemes.join(',');
        const isMultiSchemes = supportedColorSchemes.length > 1;
        const modeStorage = reactExports.useMemo(()=>storageManager?.({
                key: modeStorageKey,
                storageWindow
            }), [
            storageManager,
            modeStorageKey,
            storageWindow
        ]);
        const lightStorage = reactExports.useMemo(()=>storageManager?.({
                key: `${colorSchemeStorageKey}-light`,
                storageWindow
            }), [
            storageManager,
            colorSchemeStorageKey,
            storageWindow
        ]);
        const darkStorage = reactExports.useMemo(()=>storageManager?.({
                key: `${colorSchemeStorageKey}-dark`,
                storageWindow
            }), [
            storageManager,
            colorSchemeStorageKey,
            storageWindow
        ]);
        const [state, setState] = reactExports.useState(()=>{
            const initialMode = modeStorage?.get(defaultMode) || defaultMode;
            const lightColorScheme = lightStorage?.get(defaultLightColorScheme) || defaultLightColorScheme;
            const darkColorScheme = darkStorage?.get(defaultDarkColorScheme) || defaultDarkColorScheme;
            return {
                mode: initialMode,
                systemMode: getSystemMode(initialMode),
                lightColorScheme,
                darkColorScheme
            };
        });
        const [isClient, setIsClient] = reactExports.useState(noSsr || !isMultiSchemes);
        reactExports.useEffect(()=>{
            setIsClient(true);
        }, []);
        const colorScheme = getColorScheme(state);
        const setMode = reactExports.useCallback((mode)=>{
            setState((currentState)=>{
                if (mode === currentState.mode) {
                    return currentState;
                }
                const newMode = mode ?? defaultMode;
                modeStorage?.set(newMode);
                return {
                    ...currentState,
                    mode: newMode,
                    systemMode: getSystemMode(newMode)
                };
            });
        }, [
            modeStorage,
            defaultMode
        ]);
        const setColorScheme = reactExports.useCallback((value)=>{
            if (!value) {
                setState((currentState)=>{
                    lightStorage?.set(defaultLightColorScheme);
                    darkStorage?.set(defaultDarkColorScheme);
                    return {
                        ...currentState,
                        lightColorScheme: defaultLightColorScheme,
                        darkColorScheme: defaultDarkColorScheme
                    };
                });
            } else if (typeof value === 'string') {
                if (value && !joinedColorSchemes.includes(value)) {
                    console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
                } else {
                    setState((currentState)=>{
                        const newState = {
                            ...currentState
                        };
                        processState(currentState, (mode)=>{
                            if (mode === 'light') {
                                lightStorage?.set(value);
                                newState.lightColorScheme = value;
                            }
                            if (mode === 'dark') {
                                darkStorage?.set(value);
                                newState.darkColorScheme = value;
                            }
                        });
                        return newState;
                    });
                }
            } else {
                setState((currentState)=>{
                    const newState = {
                        ...currentState
                    };
                    const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
                    const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
                    if (newLightColorScheme) {
                        if (!joinedColorSchemes.includes(newLightColorScheme)) {
                            console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
                        } else {
                            newState.lightColorScheme = newLightColorScheme;
                            lightStorage?.set(newLightColorScheme);
                        }
                    }
                    if (newDarkColorScheme) {
                        if (!joinedColorSchemes.includes(newDarkColorScheme)) {
                            console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
                        } else {
                            newState.darkColorScheme = newDarkColorScheme;
                            darkStorage?.set(newDarkColorScheme);
                        }
                    }
                    return newState;
                });
            }
        }, [
            joinedColorSchemes,
            lightStorage,
            darkStorage,
            defaultLightColorScheme,
            defaultDarkColorScheme
        ]);
        const handleMediaQuery = reactExports.useCallback((event)=>{
            if (state.mode === 'system') {
                setState((currentState)=>{
                    const systemMode = event?.matches ? 'dark' : 'light';
                    if (currentState.systemMode === systemMode) {
                        return currentState;
                    }
                    return {
                        ...currentState,
                        systemMode
                    };
                });
            }
        }, [
            state.mode
        ]);
        const mediaListener = reactExports.useRef(handleMediaQuery);
        mediaListener.current = handleMediaQuery;
        reactExports.useEffect(()=>{
            if (typeof window.matchMedia !== 'function' || !isMultiSchemes) {
                return undefined;
            }
            const handler = (...args)=>mediaListener.current(...args);
            const media = window.matchMedia('(prefers-color-scheme: dark)');
            media.addListener(handler);
            handler(media);
            return ()=>{
                media.removeListener(handler);
            };
        }, [
            isMultiSchemes
        ]);
        reactExports.useEffect(()=>{
            if (isMultiSchemes) {
                const unsubscribeMode = modeStorage?.subscribe((value)=>{
                    if (!value || [
                        'light',
                        'dark',
                        'system'
                    ].includes(value)) {
                        setMode(value || defaultMode);
                    }
                }) || noop$4;
                const unsubscribeLight = lightStorage?.subscribe((value)=>{
                    if (!value || joinedColorSchemes.match(value)) {
                        setColorScheme({
                            light: value
                        });
                    }
                }) || noop$4;
                const unsubscribeDark = darkStorage?.subscribe((value)=>{
                    if (!value || joinedColorSchemes.match(value)) {
                        setColorScheme({
                            dark: value
                        });
                    }
                }) || noop$4;
                return ()=>{
                    unsubscribeMode();
                    unsubscribeLight();
                    unsubscribeDark();
                };
            }
            return undefined;
        }, [
            setColorScheme,
            setMode,
            joinedColorSchemes,
            defaultMode,
            storageWindow,
            isMultiSchemes,
            modeStorage,
            lightStorage,
            darkStorage
        ]);
        return {
            ...state,
            mode: isClient ? state.mode : undefined,
            systemMode: isClient ? state.systemMode : undefined,
            colorScheme: isClient ? colorScheme : undefined,
            setMode,
            setColorScheme
        };
    }
    const DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
    function createCssVarsProvider(options) {
        const { themeId, theme: defaultTheme = {}, modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY, disableTransitionOnChange: designSystemTransitionOnChange = false, defaultColorScheme, resolveTheme } = options;
        const defaultContext = {
            allColorSchemes: [],
            colorScheme: void 0,
            darkColorScheme: void 0,
            lightColorScheme: void 0,
            mode: void 0,
            setColorScheme: ()=>{},
            setMode: ()=>{},
            systemMode: void 0
        };
        const ColorSchemeContext = reactExports.createContext(void 0);
        const useColorScheme = ()=>reactExports.useContext(ColorSchemeContext) || defaultContext;
        const defaultColorSchemes = {};
        const defaultComponents = {};
        function CssVarsProvider(props) {
            const { children, theme: themeProp, modeStorageKey = defaultModeStorageKey, colorSchemeStorageKey = defaultColorSchemeStorageKey, disableTransitionOnChange = designSystemTransitionOnChange, storageManager, storageWindow = typeof window === "undefined" ? void 0 : window, documentNode = typeof document === "undefined" ? void 0 : document, colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement, disableNestedContext = false, disableStyleSheetGeneration = false, defaultMode: initialMode = "system", forceThemeRerender = false, noSsr } = props;
            const hasMounted = reactExports.useRef(false);
            const upperTheme = useTheme$1();
            const ctx = reactExports.useContext(ColorSchemeContext);
            const nested = !!ctx && !disableNestedContext;
            const initialTheme = reactExports.useMemo(()=>{
                if (themeProp) {
                    return themeProp;
                }
                return typeof defaultTheme === "function" ? defaultTheme() : defaultTheme;
            }, [
                themeProp
            ]);
            const scopedTheme = initialTheme[themeId];
            const restThemeProp = scopedTheme || initialTheme;
            const { colorSchemes = defaultColorSchemes, components = defaultComponents, cssVarPrefix } = restThemeProp;
            const joinedColorSchemes = Object.keys(colorSchemes).filter((k)=>!!colorSchemes[k]).join(",");
            const allColorSchemes = reactExports.useMemo(()=>joinedColorSchemes.split(","), [
                joinedColorSchemes
            ]);
            const defaultLightColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
            const defaultDarkColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
            const defaultMode = colorSchemes[defaultLightColorScheme2] && colorSchemes[defaultDarkColorScheme2] ? initialMode : colorSchemes[restThemeProp.defaultColorScheme]?.palette?.mode || restThemeProp.palette?.mode;
            const { mode: stateMode, setMode, systemMode, lightColorScheme, darkColorScheme, colorScheme: stateColorScheme, setColorScheme } = useCurrentColorScheme({
                supportedColorSchemes: allColorSchemes,
                defaultLightColorScheme: defaultLightColorScheme2,
                defaultDarkColorScheme: defaultDarkColorScheme2,
                modeStorageKey,
                colorSchemeStorageKey,
                defaultMode,
                storageManager,
                storageWindow,
                noSsr
            });
            let mode = stateMode;
            let colorScheme = stateColorScheme;
            if (nested) {
                mode = ctx.mode;
                colorScheme = ctx.colorScheme;
            }
            let calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
            if (restThemeProp.vars && !forceThemeRerender) {
                calculatedColorScheme = restThemeProp.defaultColorScheme;
            }
            const memoTheme = reactExports.useMemo(()=>{
                const themeVars = restThemeProp.generateThemeVars?.() || restThemeProp.vars;
                const theme = {
                    ...restThemeProp,
                    components,
                    colorSchemes,
                    cssVarPrefix,
                    vars: themeVars
                };
                if (typeof theme.generateSpacing === "function") {
                    theme.spacing = theme.generateSpacing();
                }
                if (calculatedColorScheme) {
                    const scheme = colorSchemes[calculatedColorScheme];
                    if (scheme && typeof scheme === "object") {
                        Object.keys(scheme).forEach((schemeKey)=>{
                            if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") {
                                theme[schemeKey] = {
                                    ...theme[schemeKey],
                                    ...scheme[schemeKey]
                                };
                            } else {
                                theme[schemeKey] = scheme[schemeKey];
                            }
                        });
                    }
                }
                return resolveTheme ? resolveTheme(theme) : theme;
            }, [
                restThemeProp,
                calculatedColorScheme,
                components,
                colorSchemes,
                cssVarPrefix
            ]);
            const colorSchemeSelector = restThemeProp.colorSchemeSelector;
            useEnhancedEffect(()=>{
                if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
                    const selector = colorSchemeSelector;
                    let rule = colorSchemeSelector;
                    if (selector === "class") {
                        rule = `.%s`;
                    }
                    if (selector === "data") {
                        rule = `[data-%s]`;
                    }
                    if (selector?.startsWith("data-") && !selector.includes("%s")) {
                        rule = `[${selector}="%s"]`;
                    }
                    if (rule.startsWith(".")) {
                        colorSchemeNode.classList.remove(...allColorSchemes.map((scheme)=>rule.substring(1).replace("%s", scheme)));
                        colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
                    } else {
                        const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
                        if (matches) {
                            const [attr, value] = matches[1].split("=");
                            if (!value) {
                                allColorSchemes.forEach((scheme)=>{
                                    colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
                                });
                            }
                            colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
                        } else {
                            colorSchemeNode.setAttribute(rule, colorScheme);
                        }
                    }
                }
            }, [
                colorScheme,
                colorSchemeSelector,
                colorSchemeNode,
                allColorSchemes
            ]);
            reactExports.useEffect(()=>{
                let timer;
                if (disableTransitionOnChange && hasMounted.current && documentNode) {
                    const css = documentNode.createElement("style");
                    css.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
                    documentNode.head.appendChild(css);
                    (()=>window.getComputedStyle(documentNode.body))();
                    timer = setTimeout(()=>{
                        documentNode.head.removeChild(css);
                    }, 1);
                }
                return ()=>{
                    clearTimeout(timer);
                };
            }, [
                colorScheme,
                disableTransitionOnChange,
                documentNode
            ]);
            reactExports.useEffect(()=>{
                hasMounted.current = true;
                return ()=>{
                    hasMounted.current = false;
                };
            }, []);
            const contextValue = reactExports.useMemo(()=>({
                    allColorSchemes,
                    colorScheme,
                    darkColorScheme,
                    lightColorScheme,
                    mode,
                    setColorScheme,
                    setMode: setMode,
                    systemMode
                }), [
                allColorSchemes,
                colorScheme,
                darkColorScheme,
                lightColorScheme,
                mode,
                setColorScheme,
                setMode,
                systemMode,
                memoTheme.colorSchemeSelector
            ]);
            let shouldGenerateStyleSheet = true;
            if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested && upperTheme?.cssVarPrefix === cssVarPrefix) {
                shouldGenerateStyleSheet = false;
            }
            const element = jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [
                    jsxRuntimeExports.jsx(ThemeProvider$1, {
                        themeId: scopedTheme ? themeId : void 0,
                        theme: memoTheme,
                        children
                    }),
                    shouldGenerateStyleSheet && jsxRuntimeExports.jsx(GlobalStyles$3, {
                        styles: memoTheme.generateStyleSheets?.() || []
                    })
                ]
            });
            if (nested) {
                return element;
            }
            return jsxRuntimeExports.jsx(ColorSchemeContext.Provider, {
                value: contextValue,
                children: element
            });
        }
        const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
        const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
        const getInitColorSchemeScript = (params)=>InitColorSchemeScript({
                colorSchemeStorageKey: defaultColorSchemeStorageKey,
                defaultLightColorScheme,
                defaultDarkColorScheme,
                modeStorageKey: defaultModeStorageKey,
                ...params
            });
        return {
            CssVarsProvider,
            useColorScheme,
            getInitColorSchemeScript
        };
    }
    function createGetCssVar$1(prefix = '') {
        function appendVar(...vars) {
            if (!vars.length) {
                return '';
            }
            const value = vars[0];
            if (typeof value === 'string' && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
                return `, var(--${prefix ? `${prefix}-` : ''}${value}${appendVar(...vars.slice(1))})`;
            }
            return `, ${value}`;
        }
        const getCssVar = (field, ...fallbacks)=>{
            return `var(--${prefix ? `${prefix}-` : ''}${field}${appendVar(...fallbacks)})`;
        };
        return getCssVar;
    }
    const assignNestedKeys = (obj, keys, value, arrayKeys = [])=>{
        let temp = obj;
        keys.forEach((k, index)=>{
            if (index === keys.length - 1) {
                if (Array.isArray(temp)) {
                    temp[Number(k)] = value;
                } else if (temp && typeof temp === 'object') {
                    temp[k] = value;
                }
            } else if (temp && typeof temp === 'object') {
                if (!temp[k]) {
                    temp[k] = arrayKeys.includes(k) ? [] : {};
                }
                temp = temp[k];
            }
        });
    };
    const walkObjectDeep = (obj, callback, shouldSkipPaths)=>{
        function recurse(object, parentKeys = [], arrayKeys = []) {
            Object.entries(object).forEach(([key, value])=>{
                if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([
                    ...parentKeys,
                    key
                ])) {
                    if (value !== undefined && value !== null) {
                        if (typeof value === 'object' && Object.keys(value).length > 0) {
                            recurse(value, [
                                ...parentKeys,
                                key
                            ], Array.isArray(value) ? [
                                ...arrayKeys,
                                key
                            ] : arrayKeys);
                        } else {
                            callback([
                                ...parentKeys,
                                key
                            ], value, arrayKeys);
                        }
                    }
                }
            });
        }
        recurse(obj);
    };
    const getCssValue = (keys, value)=>{
        if (typeof value === 'number') {
            if ([
                'lineHeight',
                'fontWeight',
                'opacity',
                'zIndex'
            ].some((prop)=>keys.includes(prop))) {
                return value;
            }
            const lastKey = keys[keys.length - 1];
            if (lastKey.toLowerCase().includes('opacity')) {
                return value;
            }
            return `${value}px`;
        }
        return value;
    };
    function cssVarsParser(theme, options) {
        const { prefix, shouldSkipGeneratingVar } = options || {};
        const css = {};
        const vars = {};
        const varsWithDefaults = {};
        walkObjectDeep(theme, (keys, value, arrayKeys)=>{
            if (typeof value === 'string' || typeof value === 'number') {
                if (!shouldSkipGeneratingVar || !shouldSkipGeneratingVar(keys, value)) {
                    const cssVar = `--${prefix ? `${prefix}-` : ''}${keys.join('-')}`;
                    const resolvedValue = getCssValue(keys, value);
                    Object.assign(css, {
                        [cssVar]: resolvedValue
                    });
                    assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
                    assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
                }
            }
        }, (keys)=>keys[0] === 'vars');
        return {
            css,
            vars,
            varsWithDefaults
        };
    }
    function prepareCssVars(theme, parserConfig = {}) {
        const { getSelector = defaultGetSelector, disableCssColorScheme, colorSchemeSelector: selector, enableContrastVars } = parserConfig;
        const { colorSchemes = {}, components, defaultColorScheme = 'light', ...otherTheme } = theme;
        const { vars: rootVars, css: rootCss, varsWithDefaults: rootVarsWithDefaults } = cssVarsParser(otherTheme, parserConfig);
        let themeVars = rootVarsWithDefaults;
        const colorSchemesMap = {};
        const { [defaultColorScheme]: defaultScheme, ...otherColorSchemes } = colorSchemes;
        Object.entries(otherColorSchemes || {}).forEach(([key, scheme])=>{
            const { vars, css, varsWithDefaults } = cssVarsParser(scheme, parserConfig);
            themeVars = deepmerge(themeVars, varsWithDefaults);
            colorSchemesMap[key] = {
                css,
                vars
            };
        });
        if (defaultScheme) {
            const { css, vars, varsWithDefaults } = cssVarsParser(defaultScheme, parserConfig);
            themeVars = deepmerge(themeVars, varsWithDefaults);
            colorSchemesMap[defaultColorScheme] = {
                css,
                vars
            };
        }
        function defaultGetSelector(colorScheme, cssObject) {
            let rule = selector;
            if (selector === 'class') {
                rule = '.%s';
            }
            if (selector === 'data') {
                rule = '[data-%s]';
            }
            if (selector?.startsWith('data-') && !selector.includes('%s')) {
                rule = `[${selector}="%s"]`;
            }
            if (colorScheme) {
                if (rule === 'media') {
                    if (theme.defaultColorScheme === colorScheme) {
                        return ':root';
                    }
                    const mode = colorSchemes[colorScheme]?.palette?.mode || colorScheme;
                    return {
                        [`@media (prefers-color-scheme: ${mode})`]: {
                            ':root': cssObject
                        }
                    };
                }
                if (rule) {
                    if (theme.defaultColorScheme === colorScheme) {
                        return `:root, ${rule.replace('%s', String(colorScheme))}`;
                    }
                    return rule.replace('%s', String(colorScheme));
                }
            }
            return ':root';
        }
        const generateThemeVars = ()=>{
            let vars = {
                ...rootVars
            };
            Object.entries(colorSchemesMap).forEach(([, { vars: schemeVars }])=>{
                vars = deepmerge(vars, schemeVars);
            });
            return vars;
        };
        const generateStyleSheets = ()=>{
            const stylesheets = [];
            const colorScheme = theme.defaultColorScheme || 'light';
            function insertStyleSheet(key, css) {
                if (Object.keys(css).length) {
                    stylesheets.push(typeof key === 'string' ? {
                        [key]: {
                            ...css
                        }
                    } : key);
                }
            }
            insertStyleSheet(getSelector(undefined, {
                ...rootCss
            }), rootCss);
            const { [colorScheme]: defaultSchemeVal, ...other } = colorSchemesMap;
            if (defaultSchemeVal) {
                const { css } = defaultSchemeVal;
                const cssColorSheme = colorSchemes[colorScheme]?.palette?.mode;
                const finalCss = !disableCssColorScheme && cssColorSheme ? {
                    colorScheme: cssColorSheme,
                    ...css
                } : {
                    ...css
                };
                insertStyleSheet(getSelector(colorScheme, {
                    ...finalCss
                }), finalCss);
            }
            Object.entries(other).forEach(([key, { css }])=>{
                const cssColorSheme = colorSchemes[key]?.palette?.mode;
                const finalCss = !disableCssColorScheme && cssColorSheme ? {
                    colorScheme: cssColorSheme,
                    ...css
                } : {
                    ...css
                };
                insertStyleSheet(getSelector(key, {
                    ...finalCss
                }), finalCss);
            });
            if (enableContrastVars) {
                stylesheets.push({
                    ':root': {
                        '--__l-threshold': '0.7',
                        '--__l': 'clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)',
                        '--__a': 'clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)'
                    }
                });
            }
            return stylesheets;
        };
        return {
            vars: themeVars,
            generateThemeVars,
            generateStyleSheets
        };
    }
    function createGetColorSchemeSelector(selector) {
        return function getColorSchemeSelector(colorScheme) {
            if (selector === "media") {
                return `@media (prefers-color-scheme: ${colorScheme})`;
            }
            if (selector) {
                if (selector.startsWith("data-") && !selector.includes("%s")) {
                    return `[${selector}="${colorScheme}"] &`;
                }
                if (selector === "class") {
                    return `.${colorScheme} &`;
                }
                if (selector === "data") {
                    return `[data-${colorScheme}] &`;
                }
                return `${selector.replace("%s", colorScheme)} &`;
            }
            return "&";
        };
    }
    function composeClasses(slots, getUtilityClass, classes = undefined) {
        const output = {};
        for(const slotName in slots){
            const slot = slots[slotName];
            let buffer = '';
            let start = true;
            for(let i = 0; i < slot.length; i += 1){
                const value = slot[i];
                if (value) {
                    buffer += (start === true ? '' : ' ') + getUtilityClass(value);
                    start = false;
                    if (classes && classes[value]) {
                        buffer += ' ' + classes[value];
                    }
                }
            }
            output[slotName] = buffer;
        }
        return output;
    }
    const defaultTheme$2 = createTheme$1();
    const defaultCreateStyledComponent = styled$1("div", {
        name: "MuiContainer",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[`maxWidth${capitalize(String(ownerState.maxWidth))}`],
                ownerState.fixed && styles.fixed,
                ownerState.disableGutters && styles.disableGutters
            ];
        }
    });
    const useThemePropsDefault = (inProps)=>useThemeProps({
            props: inProps,
            name: "MuiContainer",
            defaultTheme: defaultTheme$2
        });
    const useUtilityClasses$B = (ownerState, componentName)=>{
        const getContainerUtilityClass = (slot)=>{
            return generateUtilityClass(componentName, slot);
        };
        const { classes, fixed, disableGutters, maxWidth } = ownerState;
        const slots = {
            root: [
                "root",
                maxWidth && `maxWidth${capitalize(String(maxWidth))}`,
                fixed && "fixed",
                disableGutters && "disableGutters"
            ]
        };
        return composeClasses(slots, getContainerUtilityClass, classes);
    };
    function createContainer(options = {}) {
        const { createStyledComponent = defaultCreateStyledComponent, useThemeProps = useThemePropsDefault, componentName = "MuiContainer" } = options;
        const ContainerRoot = createStyledComponent(({ theme, ownerState })=>({
                width: "100%",
                marginLeft: "auto",
                boxSizing: "border-box",
                marginRight: "auto",
                ...!ownerState.disableGutters && {
                    paddingLeft: theme.spacing(2),
                    paddingRight: theme.spacing(2),
                    [theme.breakpoints.up("sm")]: {
                        paddingLeft: theme.spacing(3),
                        paddingRight: theme.spacing(3)
                    }
                }
            }), ({ theme, ownerState })=>ownerState.fixed && Object.keys(theme.breakpoints.values).reduce((acc, breakpointValueKey)=>{
                const breakpoint = breakpointValueKey;
                const value = theme.breakpoints.values[breakpoint];
                if (value !== 0) {
                    acc[theme.breakpoints.up(breakpoint)] = {
                        maxWidth: `${value}${theme.breakpoints.unit}`
                    };
                }
                return acc;
            }, {}), ({ theme, ownerState })=>({
                ...ownerState.maxWidth === "xs" && {
                    [theme.breakpoints.up("xs")]: {
                        maxWidth: Math.max(theme.breakpoints.values.xs, 444)
                    }
                },
                ...ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
                    [theme.breakpoints.up(ownerState.maxWidth)]: {
                        maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`
                    }
                }
            }));
        const Container = reactExports.forwardRef(function Container2(inProps, ref) {
            const props = useThemeProps(inProps);
            const { className, component = "div", disableGutters = false, fixed = false, maxWidth = "lg", classes: classesProp, ...other } = props;
            const ownerState = {
                ...props,
                component,
                disableGutters,
                fixed,
                maxWidth
            };
            const classes = useUtilityClasses$B(ownerState, componentName);
            return (jsxRuntimeExports.jsx(ContainerRoot, {
                as: component,
                ownerState,
                className: clsx(classes.root, className),
                ref,
                ...other
            }));
        });
        return Container;
    }
    function isMuiElement(element, muiNames) {
        return reactExports.isValidElement(element) && muiNames.indexOf(element.type.muiName ?? element.type?._payload?.value?.muiName) !== -1;
    }
    function getLight() {
        return {
            text: {
                primary: "rgba(0, 0, 0, 0.87)",
                secondary: "rgba(0, 0, 0, 0.6)",
                disabled: "rgba(0, 0, 0, 0.38)"
            },
            divider: "rgba(0, 0, 0, 0.12)",
            background: {
                paper: common$1.white,
                default: common$1.white
            },
            action: {
                active: "rgba(0, 0, 0, 0.54)",
                hover: "rgba(0, 0, 0, 0.04)",
                hoverOpacity: 0.04,
                selected: "rgba(0, 0, 0, 0.08)",
                selectedOpacity: 0.08,
                disabled: "rgba(0, 0, 0, 0.26)",
                disabledBackground: "rgba(0, 0, 0, 0.12)",
                disabledOpacity: 0.38,
                focus: "rgba(0, 0, 0, 0.12)",
                focusOpacity: 0.12,
                activatedOpacity: 0.12
            }
        };
    }
    const light = getLight();
    function getDark() {
        return {
            text: {
                primary: common$1.white,
                secondary: "rgba(255, 255, 255, 0.7)",
                disabled: "rgba(255, 255, 255, 0.5)",
                icon: "rgba(255, 255, 255, 0.5)"
            },
            divider: "rgba(255, 255, 255, 0.12)",
            background: {
                paper: "#121212",
                default: "#121212"
            },
            action: {
                active: common$1.white,
                hover: "rgba(255, 255, 255, 0.08)",
                hoverOpacity: 0.08,
                selected: "rgba(255, 255, 255, 0.16)",
                selectedOpacity: 0.16,
                disabled: "rgba(255, 255, 255, 0.3)",
                disabledBackground: "rgba(255, 255, 255, 0.12)",
                disabledOpacity: 0.38,
                focus: "rgba(255, 255, 255, 0.12)",
                focusOpacity: 0.12,
                activatedOpacity: 0.24
            }
        };
    }
    const dark = getDark();
    function addLightOrDark(intent, direction, shade, tonalOffset) {
        const tonalOffsetLight = tonalOffset.light || tonalOffset;
        const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
        if (!intent[direction]) {
            if (intent.hasOwnProperty(shade)) {
                intent[direction] = intent[shade];
            } else if (direction === "light") {
                intent.light = lighten(intent.main, tonalOffsetLight);
            } else if (direction === "dark") {
                intent.dark = darken(intent.main, tonalOffsetDark);
            }
        }
    }
    function mixLightOrDark(colorSpace, intent, direction, shade, tonalOffset) {
        const tonalOffsetLight = tonalOffset.light || tonalOffset;
        const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
        if (!intent[direction]) {
            if (intent.hasOwnProperty(shade)) {
                intent[direction] = intent[shade];
            } else if (direction === "light") {
                intent.light = `color-mix(in ${colorSpace}, ${intent.main}, #fff ${(tonalOffsetLight * 100).toFixed(0)}%)`;
            } else if (direction === "dark") {
                intent.dark = `color-mix(in ${colorSpace}, ${intent.main}, #000 ${(tonalOffsetDark * 100).toFixed(0)}%)`;
            }
        }
    }
    function getDefaultPrimary(mode = "light") {
        if (mode === "dark") {
            return {
                main: blue[200],
                light: blue[50],
                dark: blue[400]
            };
        }
        return {
            main: blue[700],
            light: blue[400],
            dark: blue[800]
        };
    }
    function getDefaultSecondary(mode = "light") {
        if (mode === "dark") {
            return {
                main: purple[200],
                light: purple[50],
                dark: purple[400]
            };
        }
        return {
            main: purple[500],
            light: purple[300],
            dark: purple[700]
        };
    }
    function getDefaultError(mode = "light") {
        if (mode === "dark") {
            return {
                main: red[500],
                light: red[300],
                dark: red[700]
            };
        }
        return {
            main: red[700],
            light: red[400],
            dark: red[800]
        };
    }
    function getDefaultInfo(mode = "light") {
        if (mode === "dark") {
            return {
                main: lightBlue[400],
                light: lightBlue[300],
                dark: lightBlue[700]
            };
        }
        return {
            main: lightBlue[700],
            light: lightBlue[500],
            dark: lightBlue[900]
        };
    }
    function getDefaultSuccess(mode = "light") {
        if (mode === "dark") {
            return {
                main: green[400],
                light: green[300],
                dark: green[700]
            };
        }
        return {
            main: green[800],
            light: green[500],
            dark: green[900]
        };
    }
    function getDefaultWarning(mode = "light") {
        if (mode === "dark") {
            return {
                main: orange[400],
                light: orange[300],
                dark: orange[700]
            };
        }
        return {
            main: "#ed6c02",
            light: orange[500],
            dark: orange[900]
        };
    }
    function contrastColor(background) {
        return `oklch(from ${background} var(--__l) 0 h / var(--__a))`;
    }
    function createPalette(palette) {
        const { mode = "light", contrastThreshold = 3, tonalOffset = 0.2, colorSpace, ...other } = palette;
        const primary = palette.primary || getDefaultPrimary(mode);
        const secondary = palette.secondary || getDefaultSecondary(mode);
        const error = palette.error || getDefaultError(mode);
        const info = palette.info || getDefaultInfo(mode);
        const success = palette.success || getDefaultSuccess(mode);
        const warning = palette.warning || getDefaultWarning(mode);
        function getContrastText(background) {
            if (colorSpace) {
                return contrastColor(background);
            }
            const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
            return contrastText;
        }
        const augmentColor = ({ color, name, mainShade = 500, lightShade = 300, darkShade = 700 })=>{
            color = {
                ...color
            };
            if (!color.main && color[mainShade]) {
                color.main = color[mainShade];
            }
            if (!color.hasOwnProperty("main")) {
                throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
            }
            if (typeof color.main !== "string") {
                throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color.main)));
            }
            if (colorSpace) {
                mixLightOrDark(colorSpace, color, "light", lightShade, tonalOffset);
                mixLightOrDark(colorSpace, color, "dark", darkShade, tonalOffset);
            } else {
                addLightOrDark(color, "light", lightShade, tonalOffset);
                addLightOrDark(color, "dark", darkShade, tonalOffset);
            }
            if (!color.contrastText) {
                color.contrastText = getContrastText(color.main);
            }
            return color;
        };
        let modeHydrated;
        if (mode === "light") {
            modeHydrated = getLight();
        } else if (mode === "dark") {
            modeHydrated = getDark();
        }
        const paletteOutput = deepmerge({
            common: {
                ...common$1
            },
            mode,
            primary: augmentColor({
                color: primary,
                name: "primary"
            }),
            secondary: augmentColor({
                color: secondary,
                name: "secondary",
                mainShade: "A400",
                lightShade: "A200",
                darkShade: "A700"
            }),
            error: augmentColor({
                color: error,
                name: "error"
            }),
            warning: augmentColor({
                color: warning,
                name: "warning"
            }),
            info: augmentColor({
                color: info,
                name: "info"
            }),
            success: augmentColor({
                color: success,
                name: "success"
            }),
            grey,
            contrastThreshold,
            getContrastText,
            augmentColor,
            tonalOffset,
            ...modeHydrated
        }, other);
        return paletteOutput;
    }
    function prepareTypographyVars(typography) {
        const vars = {};
        const entries = Object.entries(typography);
        entries.forEach((entry)=>{
            const [key, value] = entry;
            if (typeof value === 'object') {
                vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ''}${value.fontVariant ? `${value.fontVariant} ` : ''}${value.fontWeight ? `${value.fontWeight} ` : ''}${value.fontStretch ? `${value.fontStretch} ` : ''}${value.fontSize || ''}${value.lineHeight ? `/${value.lineHeight} ` : ''}${value.fontFamily || ''}`;
            }
        });
        return vars;
    }
    function createMixins(breakpoints, mixins) {
        return {
            toolbar: {
                minHeight: 56,
                [breakpoints.up('xs')]: {
                    '@media (orientation: landscape)': {
                        minHeight: 48
                    }
                },
                [breakpoints.up('sm')]: {
                    minHeight: 64
                }
            },
            ...mixins
        };
    }
    function round(value) {
        return Math.round(value * 1e5) / 1e5;
    }
    const caseAllCaps = {
        textTransform: "uppercase"
    };
    const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
    function createTypography(palette, typography) {
        const { fontFamily = defaultFontFamily, fontSize = 14, fontWeightLight = 300, fontWeightRegular = 400, fontWeightMedium = 500, fontWeightBold = 700, htmlFontSize = 16, allVariants, pxToRem: pxToRem2, ...other } = typeof typography === "function" ? typography(palette) : typography;
        const coef = fontSize / 14;
        const pxToRem = pxToRem2 || ((size)=>`${size / htmlFontSize * coef}rem`);
        const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing)=>({
                fontFamily,
                fontWeight,
                fontSize: pxToRem(size),
                lineHeight,
                ...fontFamily === defaultFontFamily ? {
                    letterSpacing: `${round(letterSpacing / size)}em`
                } : {},
                ...casing,
                ...allVariants
            });
        const variants = {
            h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
            h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
            h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
            h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
            h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
            h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
            subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
            subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
            body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
            body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
            button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
            caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
            overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
            inherit: {
                fontFamily: "inherit",
                fontWeight: "inherit",
                fontSize: "inherit",
                lineHeight: "inherit",
                letterSpacing: "inherit"
            }
        };
        return deepmerge({
            htmlFontSize,
            pxToRem,
            fontFamily,
            fontSize,
            fontWeightLight,
            fontWeightRegular,
            fontWeightMedium,
            fontWeightBold,
            ...variants
        }, other, {
            clone: false
        });
    }
    const shadowKeyUmbraOpacity = 0.2;
    const shadowKeyPenumbraOpacity = 0.14;
    const shadowAmbientShadowOpacity = 0.12;
    function createShadow(...px) {
        return [
            `${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`,
            `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`,
            `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`
        ].join(',');
    }
    const shadows = [
        'none',
        createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
        createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
        createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
        createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
        createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
        createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
        createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
        createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
        createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
        createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
        createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
        createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
        createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
        createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
        createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
        createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
        createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
        createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
        createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
        createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
        createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
        createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
        createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
        createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)
    ];
    const easing = {
        easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
        easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
        easeIn: "cubic-bezier(0.4, 0, 1, 1)",
        sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    };
    const duration = {
        shortest: 150,
        shorter: 200,
        short: 250,
        standard: 300,
        complex: 375,
        enteringScreen: 225,
        leavingScreen: 195
    };
    function formatMs(milliseconds) {
        return `${Math.round(milliseconds)}ms`;
    }
    function getAutoHeightDuration(height) {
        if (!height) {
            return 0;
        }
        const constant = height / 36;
        return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3e3);
    }
    function createTransitions(inputTransitions) {
        const mergedEasing = {
            ...easing,
            ...inputTransitions.easing
        };
        const mergedDuration = {
            ...duration,
            ...inputTransitions.duration
        };
        const create = (props = [
            "all"
        ], options = {})=>{
            const { duration: durationOption = mergedDuration.standard, easing: easingOption = mergedEasing.easeInOut, delay = 0, ...other } = options;
            return (Array.isArray(props) ? props : [
                props
            ]).map((animatedProp)=>`${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
        };
        return {
            getAutoHeightDuration,
            create,
            ...inputTransitions,
            easing: mergedEasing,
            duration: mergedDuration
        };
    }
    const zIndex = {
        mobileStepper: 1000,
        fab: 1050,
        speedDial: 1050,
        appBar: 1100,
        drawer: 1200,
        modal: 1300,
        snackbar: 1400,
        tooltip: 1500
    };
    function isSerializable(val) {
        return isPlainObject$3(val) || typeof val === 'undefined' || typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number' || Array.isArray(val);
    }
    function stringifyTheme(baseTheme = {}) {
        const serializableTheme = {
            ...baseTheme
        };
        function serializeTheme(object) {
            const array = Object.entries(object);
            for(let index = 0; index < array.length; index++){
                const [key, value] = array[index];
                if (!isSerializable(value) || key.startsWith('unstable_')) {
                    delete object[key];
                } else if (isPlainObject$3(value)) {
                    object[key] = {
                        ...value
                    };
                    serializeTheme(object[key]);
                }
            }
        }
        serializeTheme(serializableTheme);
        return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
    }
    function coefficientToPercentage(coefficient) {
        if (typeof coefficient === "number") {
            return `${(coefficient * 100).toFixed(0)}%`;
        }
        return `calc((${coefficient}) * 100%)`;
    }
    const parseAddition = (str)=>{
        if (!Number.isNaN(+str)) {
            return +str;
        }
        const numbers = str.match(/\d*\.?\d+/g);
        if (!numbers) {
            return 0;
        }
        let sum = 0;
        for(let i = 0; i < numbers.length; i += 1){
            sum += +numbers[i];
        }
        return sum;
    };
    function attachColorManipulators(theme) {
        Object.assign(theme, {
            alpha (color, coefficient) {
                const obj = this || theme;
                if (obj.colorSpace) {
                    return `oklch(from ${color} l c h / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
                }
                if (obj.vars) {
                    return `rgba(${color.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
                }
                return alpha(color, parseAddition(coefficient));
            },
            lighten (color, coefficient) {
                const obj = this || theme;
                if (obj.colorSpace) {
                    return `color-mix(in ${obj.colorSpace}, ${color}, #fff ${coefficientToPercentage(coefficient)})`;
                }
                return lighten(color, coefficient);
            },
            darken (color, coefficient) {
                const obj = this || theme;
                if (obj.colorSpace) {
                    return `color-mix(in ${obj.colorSpace}, ${color}, #000 ${coefficientToPercentage(coefficient)})`;
                }
                return darken(color, coefficient);
            }
        });
    }
    function createThemeNoVars(options = {}, ...args) {
        const { breakpoints: breakpointsInput, mixins: mixinsInput = {}, spacing: spacingInput, palette: paletteInput = {}, transitions: transitionsInput = {}, typography: typographyInput = {}, shape: shapeInput, colorSpace, ...other } = options;
        if (options.vars && options.generateThemeVars === void 0) {
            throw new Error(formatMuiErrorMessage(20));
        }
        const palette = createPalette({
            ...paletteInput,
            colorSpace
        });
        const systemTheme = createTheme$1(options);
        let muiTheme = deepmerge(systemTheme, {
            mixins: createMixins(systemTheme.breakpoints, mixinsInput),
            palette,
            shadows: shadows.slice(),
            typography: createTypography(palette, typographyInput),
            transitions: createTransitions(transitionsInput),
            zIndex: {
                ...zIndex
            }
        });
        muiTheme = deepmerge(muiTheme, other);
        muiTheme = args.reduce((acc, argument)=>deepmerge(acc, argument), muiTheme);
        muiTheme.unstable_sxConfig = {
            ...defaultSxConfig,
            ...other?.unstable_sxConfig
        };
        muiTheme.unstable_sx = function sx(props) {
            return styleFunctionSx({
                sx: props,
                theme: this
            });
        };
        muiTheme.toRuntimeSource = stringifyTheme;
        attachColorManipulators(muiTheme);
        return muiTheme;
    }
    function getOverlayAlpha(elevation) {
        let alphaValue;
        if (elevation < 1) {
            alphaValue = 5.11916 * elevation ** 2;
        } else {
            alphaValue = 4.5 * Math.log(elevation + 1) + 2;
        }
        return Math.round(alphaValue * 10) / 1000;
    }
    const defaultDarkOverlays = [
        ...Array(25)
    ].map((_, index)=>{
        if (index === 0) {
            return 'none';
        }
        const overlay = getOverlayAlpha(index);
        return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
    });
    function getOpacity(mode) {
        return {
            inputPlaceholder: mode === 'dark' ? 0.5 : 0.42,
            inputUnderline: mode === 'dark' ? 0.7 : 0.42,
            switchTrackDisabled: mode === 'dark' ? 0.2 : 0.12,
            switchTrack: mode === 'dark' ? 0.3 : 0.38
        };
    }
    function getOverlays(mode) {
        return mode === 'dark' ? defaultDarkOverlays : [];
    }
    function createColorScheme(options) {
        const { palette: paletteInput = {
            mode: 'light'
        }, opacity, overlays, colorSpace, ...rest } = options;
        const palette = createPalette({
            ...paletteInput,
            colorSpace
        });
        return {
            palette,
            opacity: {
                ...getOpacity(palette.mode),
                ...opacity
            },
            overlays: overlays || getOverlays(palette.mode),
            ...rest
        };
    }
    function shouldSkipGeneratingVar(keys) {
        return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || keys[0] === 'palette' && !!keys[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
    }
    const excludeVariablesFromRoot = (cssVarPrefix)=>[
            ...[
                ...Array(25)
            ].map((_, index)=>`--${cssVarPrefix ? `${cssVarPrefix}-` : ''}overlays-${index}`),
            `--${cssVarPrefix ? `${cssVarPrefix}-` : ''}palette-AppBar-darkBg`,
            `--${cssVarPrefix ? `${cssVarPrefix}-` : ''}palette-AppBar-darkColor`
        ];
    const defaultGetSelector = (theme)=>(colorScheme, css)=>{
            const root = theme.rootSelector || ':root';
            const selector = theme.colorSchemeSelector;
            let rule = selector;
            if (selector === 'class') {
                rule = '.%s';
            }
            if (selector === 'data') {
                rule = '[data-%s]';
            }
            if (selector?.startsWith('data-') && !selector.includes('%s')) {
                rule = `[${selector}="%s"]`;
            }
            if (theme.defaultColorScheme === colorScheme) {
                if (colorScheme === 'dark') {
                    const excludedVariables = {};
                    excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar)=>{
                        excludedVariables[cssVar] = css[cssVar];
                        delete css[cssVar];
                    });
                    if (rule === 'media') {
                        return {
                            [root]: css,
                            [`@media (prefers-color-scheme: dark)`]: {
                                [root]: excludedVariables
                            }
                        };
                    }
                    if (rule) {
                        return {
                            [rule.replace('%s', colorScheme)]: excludedVariables,
                            [`${root}, ${rule.replace('%s', colorScheme)}`]: css
                        };
                    }
                    return {
                        [root]: {
                            ...css,
                            ...excludedVariables
                        }
                    };
                }
                if (rule && rule !== 'media') {
                    return `${root}, ${rule.replace('%s', String(colorScheme))}`;
                }
            } else if (colorScheme) {
                if (rule === 'media') {
                    return {
                        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
                            [root]: css
                        }
                    };
                }
                if (rule) {
                    return rule.replace('%s', String(colorScheme));
                }
            }
            return root;
        };
    function assignNode(obj, keys) {
        keys.forEach((k)=>{
            if (!obj[k]) {
                obj[k] = {};
            }
        });
    }
    function setColor(obj, key, defaultValue) {
        if (!obj[key] && defaultValue) {
            obj[key] = defaultValue;
        }
    }
    function toRgb(color) {
        if (typeof color !== "string" || !color.startsWith("hsl")) {
            return color;
        }
        return hslToRgb(color);
    }
    function setColorChannel(obj, key) {
        if (!(`${key}Channel` in obj)) {
            obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]));
        }
    }
    function getSpacingVal(spacingInput) {
        if (typeof spacingInput === "number") {
            return `${spacingInput}px`;
        }
        if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
            return spacingInput;
        }
        return "8px";
    }
    const silent = (fn)=>{
        try {
            return fn();
        } catch (error) {}
        return void 0;
    };
    const createGetCssVar = (cssVarPrefix = "mui")=>createGetCssVar$1(cssVarPrefix);
    function attachColorScheme$1(colorSpace, colorSchemes, scheme, restTheme, colorScheme) {
        if (!scheme) {
            return void 0;
        }
        scheme = scheme === true ? {} : scheme;
        const mode = colorScheme === "dark" ? "dark" : "light";
        if (!restTheme) {
            colorSchemes[colorScheme] = createColorScheme({
                ...scheme,
                palette: {
                    mode,
                    ...scheme?.palette
                },
                colorSpace
            });
            return void 0;
        }
        const { palette, ...muiTheme } = createThemeNoVars({
            ...restTheme,
            palette: {
                mode,
                ...scheme?.palette
            },
            colorSpace
        });
        colorSchemes[colorScheme] = {
            ...scheme,
            palette,
            opacity: {
                ...getOpacity(mode),
                ...scheme?.opacity
            },
            overlays: scheme?.overlays || getOverlays(mode)
        };
        return muiTheme;
    }
    function createThemeWithVars(options = {}, ...args) {
        const { colorSchemes: colorSchemesInput = {
            light: true
        }, defaultColorScheme: defaultColorSchemeInput, disableCssColorScheme = false, cssVarPrefix = "mui", nativeColor = false, shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar, colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0, rootSelector = ":root", ...input } = options;
        const firstColorScheme = Object.keys(colorSchemesInput)[0];
        const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
        const getCssVar = createGetCssVar(cssVarPrefix);
        const { [defaultColorScheme]: defaultSchemeInput, light: builtInLight, dark: builtInDark, ...customColorSchemes } = colorSchemesInput;
        const colorSchemes = {
            ...customColorSchemes
        };
        let defaultScheme = defaultSchemeInput;
        if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
            defaultScheme = true;
        }
        if (!defaultScheme) {
            throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
        }
        let colorSpace;
        if (nativeColor) {
            colorSpace = "oklch";
        }
        const muiTheme = attachColorScheme$1(colorSpace, colorSchemes, defaultScheme, input, defaultColorScheme);
        if (builtInLight && !colorSchemes.light) {
            attachColorScheme$1(colorSpace, colorSchemes, builtInLight, void 0, "light");
        }
        if (builtInDark && !colorSchemes.dark) {
            attachColorScheme$1(colorSpace, colorSchemes, builtInDark, void 0, "dark");
        }
        let theme = {
            defaultColorScheme,
            ...muiTheme,
            cssVarPrefix,
            colorSchemeSelector: selector,
            rootSelector,
            getCssVar,
            colorSchemes,
            font: {
                ...prepareTypographyVars(muiTheme.typography),
                ...muiTheme.font
            },
            spacing: getSpacingVal(input.spacing)
        };
        Object.keys(theme.colorSchemes).forEach((key)=>{
            const palette = theme.colorSchemes[key].palette;
            const setCssVarColor = (cssVar)=>{
                const tokens = cssVar.split("-");
                const color = tokens[1];
                const colorToken = tokens[2];
                return getCssVar(cssVar, palette[color][colorToken]);
            };
            if (palette.mode === "light") {
                setColor(palette.common, "background", "#fff");
                setColor(palette.common, "onBackground", "#000");
            }
            if (palette.mode === "dark") {
                setColor(palette.common, "background", "#000");
                setColor(palette.common, "onBackground", "#fff");
            }
            function colorMix(method, color, coefficient) {
                if (colorSpace) {
                    let mixer;
                    if (method === private_safeAlpha) {
                        mixer = `transparent ${((1 - coefficient) * 100).toFixed(0)}%`;
                    }
                    if (method === private_safeDarken) {
                        mixer = `#000 ${(coefficient * 100).toFixed(0)}%`;
                    }
                    if (method === private_safeLighten) {
                        mixer = `#fff ${(coefficient * 100).toFixed(0)}%`;
                    }
                    return `color-mix(in ${colorSpace}, ${color}, ${mixer})`;
                }
                return method(color, coefficient);
            }
            assignNode(palette, [
                "Alert",
                "AppBar",
                "Avatar",
                "Button",
                "Chip",
                "FilledInput",
                "LinearProgress",
                "Skeleton",
                "Slider",
                "SnackbarContent",
                "SpeedDialAction",
                "StepConnector",
                "StepContent",
                "Switch",
                "TableCell",
                "Tooltip"
            ]);
            if (palette.mode === "light") {
                setColor(palette.Alert, "errorColor", colorMix(private_safeDarken, palette.error.light, 0.6));
                setColor(palette.Alert, "infoColor", colorMix(private_safeDarken, palette.info.light, 0.6));
                setColor(palette.Alert, "successColor", colorMix(private_safeDarken, palette.success.light, 0.6));
                setColor(palette.Alert, "warningColor", colorMix(private_safeDarken, palette.warning.light, 0.6));
                setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
                setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
                setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
                setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
                setColor(palette.Alert, "errorFilledColor", silent(()=>palette.getContrastText(palette.error.main)));
                setColor(palette.Alert, "infoFilledColor", silent(()=>palette.getContrastText(palette.info.main)));
                setColor(palette.Alert, "successFilledColor", silent(()=>palette.getContrastText(palette.success.main)));
                setColor(palette.Alert, "warningFilledColor", silent(()=>palette.getContrastText(palette.warning.main)));
                setColor(palette.Alert, "errorStandardBg", colorMix(private_safeLighten, palette.error.light, 0.9));
                setColor(palette.Alert, "infoStandardBg", colorMix(private_safeLighten, palette.info.light, 0.9));
                setColor(palette.Alert, "successStandardBg", colorMix(private_safeLighten, palette.success.light, 0.9));
                setColor(palette.Alert, "warningStandardBg", colorMix(private_safeLighten, palette.warning.light, 0.9));
                setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
                setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
                setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
                setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
                setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
                setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
                setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
                setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
                setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
                setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
                setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
                setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
                setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
                setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
                setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeLighten, palette.primary.main, 0.62));
                setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeLighten, palette.secondary.main, 0.62));
                setColor(palette.LinearProgress, "errorBg", colorMix(private_safeLighten, palette.error.main, 0.62));
                setColor(palette.LinearProgress, "infoBg", colorMix(private_safeLighten, palette.info.main, 0.62));
                setColor(palette.LinearProgress, "successBg", colorMix(private_safeLighten, palette.success.main, 0.62));
                setColor(palette.LinearProgress, "warningBg", colorMix(private_safeLighten, palette.warning.main, 0.62));
                setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.11) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
                setColor(palette.Slider, "primaryTrack", colorMix(private_safeLighten, palette.primary.main, 0.62));
                setColor(palette.Slider, "secondaryTrack", colorMix(private_safeLighten, palette.secondary.main, 0.62));
                setColor(palette.Slider, "errorTrack", colorMix(private_safeLighten, palette.error.main, 0.62));
                setColor(palette.Slider, "infoTrack", colorMix(private_safeLighten, palette.info.main, 0.62));
                setColor(palette.Slider, "successTrack", colorMix(private_safeLighten, palette.success.main, 0.62));
                setColor(palette.Slider, "warningTrack", colorMix(private_safeLighten, palette.warning.main, 0.62));
                const snackbarContentBackground = colorSpace ? colorMix(private_safeDarken, palette.background.default, 0.6825) : private_safeEmphasize(palette.background.default, 0.8);
                setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
                setColor(palette.SnackbarContent, "color", silent(()=>colorSpace ? dark.text.primary : palette.getContrastText(snackbarContentBackground)));
                setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
                setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
                setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
                setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
                setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
                setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeLighten, palette.primary.main, 0.62));
                setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeLighten, palette.secondary.main, 0.62));
                setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeLighten, palette.error.main, 0.62));
                setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeLighten, palette.info.main, 0.62));
                setColor(palette.Switch, "successDisabledColor", colorMix(private_safeLighten, palette.success.main, 0.62));
                setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeLighten, palette.warning.main, 0.62));
                setColor(palette.TableCell, "border", colorMix(private_safeLighten, colorMix(private_safeAlpha, palette.divider, 1), 0.88));
                setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
            }
            if (palette.mode === "dark") {
                setColor(palette.Alert, "errorColor", colorMix(private_safeLighten, palette.error.light, 0.6));
                setColor(palette.Alert, "infoColor", colorMix(private_safeLighten, palette.info.light, 0.6));
                setColor(palette.Alert, "successColor", colorMix(private_safeLighten, palette.success.light, 0.6));
                setColor(palette.Alert, "warningColor", colorMix(private_safeLighten, palette.warning.light, 0.6));
                setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
                setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
                setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
                setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
                setColor(palette.Alert, "errorFilledColor", silent(()=>palette.getContrastText(palette.error.dark)));
                setColor(palette.Alert, "infoFilledColor", silent(()=>palette.getContrastText(palette.info.dark)));
                setColor(palette.Alert, "successFilledColor", silent(()=>palette.getContrastText(palette.success.dark)));
                setColor(palette.Alert, "warningFilledColor", silent(()=>palette.getContrastText(palette.warning.dark)));
                setColor(palette.Alert, "errorStandardBg", colorMix(private_safeDarken, palette.error.light, 0.9));
                setColor(palette.Alert, "infoStandardBg", colorMix(private_safeDarken, palette.info.light, 0.9));
                setColor(palette.Alert, "successStandardBg", colorMix(private_safeDarken, palette.success.light, 0.9));
                setColor(palette.Alert, "warningStandardBg", colorMix(private_safeDarken, palette.warning.light, 0.9));
                setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
                setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
                setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
                setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
                setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
                setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
                setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
                setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
                setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
                setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
                setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
                setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
                setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
                setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
                setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
                setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
                setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeDarken, palette.primary.main, 0.5));
                setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeDarken, palette.secondary.main, 0.5));
                setColor(palette.LinearProgress, "errorBg", colorMix(private_safeDarken, palette.error.main, 0.5));
                setColor(palette.LinearProgress, "infoBg", colorMix(private_safeDarken, palette.info.main, 0.5));
                setColor(palette.LinearProgress, "successBg", colorMix(private_safeDarken, palette.success.main, 0.5));
                setColor(palette.LinearProgress, "warningBg", colorMix(private_safeDarken, palette.warning.main, 0.5));
                setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.13) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
                setColor(palette.Slider, "primaryTrack", colorMix(private_safeDarken, palette.primary.main, 0.5));
                setColor(palette.Slider, "secondaryTrack", colorMix(private_safeDarken, palette.secondary.main, 0.5));
                setColor(palette.Slider, "errorTrack", colorMix(private_safeDarken, palette.error.main, 0.5));
                setColor(palette.Slider, "infoTrack", colorMix(private_safeDarken, palette.info.main, 0.5));
                setColor(palette.Slider, "successTrack", colorMix(private_safeDarken, palette.success.main, 0.5));
                setColor(palette.Slider, "warningTrack", colorMix(private_safeDarken, palette.warning.main, 0.5));
                const snackbarContentBackground = colorSpace ? colorMix(private_safeLighten, palette.background.default, 0.985) : private_safeEmphasize(palette.background.default, 0.98);
                setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
                setColor(palette.SnackbarContent, "color", silent(()=>colorSpace ? light.text.primary : palette.getContrastText(snackbarContentBackground)));
                setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
                setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
                setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
                setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
                setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
                setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeDarken, palette.primary.main, 0.55));
                setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeDarken, palette.secondary.main, 0.55));
                setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeDarken, palette.error.main, 0.55));
                setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeDarken, palette.info.main, 0.55));
                setColor(palette.Switch, "successDisabledColor", colorMix(private_safeDarken, palette.success.main, 0.55));
                setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeDarken, palette.warning.main, 0.55));
                setColor(palette.TableCell, "border", colorMix(private_safeDarken, colorMix(private_safeAlpha, palette.divider, 1), 0.68));
                setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
            }
            setColorChannel(palette.background, "default");
            setColorChannel(palette.background, "paper");
            setColorChannel(palette.common, "background");
            setColorChannel(palette.common, "onBackground");
            setColorChannel(palette, "divider");
            Object.keys(palette).forEach((color)=>{
                const colors = palette[color];
                if (color !== "tonalOffset" && colors && typeof colors === "object") {
                    if (colors.main) {
                        setColor(palette[color], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
                    }
                    if (colors.light) {
                        setColor(palette[color], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
                    }
                    if (colors.dark) {
                        setColor(palette[color], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
                    }
                    if (colors.contrastText) {
                        setColor(palette[color], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
                    }
                    if (color === "text") {
                        setColorChannel(palette[color], "primary");
                        setColorChannel(palette[color], "secondary");
                    }
                    if (color === "action") {
                        if (colors.active) {
                            setColorChannel(palette[color], "active");
                        }
                        if (colors.selected) {
                            setColorChannel(palette[color], "selected");
                        }
                    }
                }
            });
        });
        theme = args.reduce((acc, argument)=>deepmerge(acc, argument), theme);
        const parserConfig = {
            prefix: cssVarPrefix,
            disableCssColorScheme,
            shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
            getSelector: defaultGetSelector(theme),
            enableContrastVars: nativeColor
        };
        const { vars, generateThemeVars, generateStyleSheets } = prepareCssVars(theme, parserConfig);
        theme.vars = vars;
        Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value])=>{
            theme[key] = value;
        });
        theme.generateThemeVars = generateThemeVars;
        theme.generateStyleSheets = generateStyleSheets;
        theme.generateSpacing = function generateSpacing() {
            return createSpacing(input.spacing, createUnarySpacing(this));
        };
        theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
        theme.spacing = theme.generateSpacing();
        theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
        theme.unstable_sxConfig = {
            ...defaultSxConfig,
            ...input?.unstable_sxConfig
        };
        theme.unstable_sx = function sx(props) {
            return styleFunctionSx({
                sx: props,
                theme: this
            });
        };
        theme.toRuntimeSource = stringifyTheme;
        return theme;
    }
    function attachColorScheme(theme, scheme, colorScheme) {
        if (!theme.colorSchemes) {
            return undefined;
        }
        if (colorScheme) {
            theme.colorSchemes[scheme] = {
                ...(colorScheme !== true && colorScheme),
                palette: createPalette({
                    ...(colorScheme === true ? {} : colorScheme.palette),
                    mode: scheme
                })
            };
        }
    }
    function createTheme(options = {}, ...args) {
        const { palette, cssVariables = false, colorSchemes: initialColorSchemes = !palette ? {
            light: true
        } : undefined, defaultColorScheme: initialDefaultColorScheme = palette?.mode, ...rest } = options;
        const defaultColorSchemeInput = initialDefaultColorScheme || 'light';
        const defaultScheme = initialColorSchemes?.[defaultColorSchemeInput];
        const colorSchemesInput = {
            ...initialColorSchemes,
            ...(palette ? {
                [defaultColorSchemeInput]: {
                    ...(typeof defaultScheme !== 'boolean' && defaultScheme),
                    palette
                }
            } : undefined)
        };
        if (cssVariables === false) {
            if (!('colorSchemes' in options)) {
                return createThemeNoVars(options, ...args);
            }
            let paletteOptions = palette;
            if (!('palette' in options)) {
                if (colorSchemesInput[defaultColorSchemeInput]) {
                    if (colorSchemesInput[defaultColorSchemeInput] !== true) {
                        paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
                    } else if (defaultColorSchemeInput === 'dark') {
                        paletteOptions = {
                            mode: 'dark'
                        };
                    }
                }
            }
            const theme = createThemeNoVars({
                ...options,
                palette: paletteOptions
            }, ...args);
            theme.defaultColorScheme = defaultColorSchemeInput;
            theme.colorSchemes = colorSchemesInput;
            if (theme.palette.mode === 'light') {
                theme.colorSchemes.light = {
                    ...(colorSchemesInput.light !== true && colorSchemesInput.light),
                    palette: theme.palette
                };
                attachColorScheme(theme, 'dark', colorSchemesInput.dark);
            }
            if (theme.palette.mode === 'dark') {
                theme.colorSchemes.dark = {
                    ...(colorSchemesInput.dark !== true && colorSchemesInput.dark),
                    palette: theme.palette
                };
                attachColorScheme(theme, 'light', colorSchemesInput.light);
            }
            return theme;
        }
        if (!palette && !('light' in colorSchemesInput) && defaultColorSchemeInput === 'light') {
            colorSchemesInput.light = true;
        }
        return createThemeWithVars({
            ...rest,
            colorSchemes: colorSchemesInput,
            defaultColorScheme: defaultColorSchemeInput,
            ...(typeof cssVariables !== 'boolean' && cssVariables)
        }, ...args);
    }
    const defaultTheme$1 = createTheme();
    function useTheme() {
        const theme = useTheme$2(defaultTheme$1);
        return theme[THEME_ID] || theme;
    }
    function slotShouldForwardProp(prop) {
        return prop !== 'ownerState' && prop !== 'theme' && prop !== 'sx' && prop !== 'as';
    }
    const rootShouldForwardProp = (prop)=>slotShouldForwardProp(prop) && prop !== 'classes';
    const styled = createStyled({
        themeId: THEME_ID,
        defaultTheme: defaultTheme$1,
        rootShouldForwardProp
    });
    function ThemeProviderNoVars({ theme: themeInput, ...props }) {
        const scopedTheme = THEME_ID in themeInput ? themeInput[THEME_ID] : undefined;
        return jsxRuntimeExports.jsx(ThemeProvider$1, {
            ...props,
            themeId: scopedTheme ? THEME_ID : undefined,
            theme: scopedTheme || themeInput
        });
    }
    const defaultConfig$1 = {
        colorSchemeStorageKey: "mui-color-scheme",
        defaultLightColorScheme: "light",
        defaultDarkColorScheme: "dark",
        modeStorageKey: "mui-mode"
    };
    const { CssVarsProvider: InternalCssVarsProvider } = createCssVarsProvider({
        themeId: THEME_ID,
        theme: ()=>createTheme({
                cssVariables: true
            }),
        colorSchemeStorageKey: defaultConfig$1.colorSchemeStorageKey,
        modeStorageKey: defaultConfig$1.modeStorageKey,
        defaultColorScheme: {
            light: defaultConfig$1.defaultLightColorScheme,
            dark: defaultConfig$1.defaultDarkColorScheme
        },
        resolveTheme: (theme)=>{
            const newTheme = {
                ...theme,
                typography: createTypography(theme.palette, theme.typography)
            };
            newTheme.unstable_sx = function sx(props) {
                return styleFunctionSx({
                    sx: props,
                    theme: this
                });
            };
            return newTheme;
        }
    });
    const CssVarsProvider = InternalCssVarsProvider;
    function ThemeProvider({ theme, ...props }) {
        const noVarsTheme = reactExports.useMemo(()=>{
            if (typeof theme === 'function') {
                return theme;
            }
            const muiTheme = THEME_ID in theme ? theme[THEME_ID] : theme;
            if (!('colorSchemes' in muiTheme)) {
                if (!('vars' in muiTheme)) {
                    return {
                        ...theme,
                        vars: null
                    };
                }
                return theme;
            }
            return null;
        }, [
            theme
        ]);
        if (noVarsTheme) {
            return jsxRuntimeExports.jsx(ThemeProviderNoVars, {
                theme: noVarsTheme,
                ...props
            });
        }
        return jsxRuntimeExports.jsx(CssVarsProvider, {
            theme: theme,
            ...props
        });
    }
    function createChainedFunction(...funcs) {
        return funcs.reduce((acc, func)=>{
            if (func == null) {
                return acc;
            }
            return function chainedFunction(...args) {
                acc.apply(this, args);
                func.apply(this, args);
            };
        }, ()=>{});
    }
    function GlobalStyles$1(props) {
        return jsxRuntimeExports.jsx(GlobalStyles$2, {
            ...props,
            defaultTheme: defaultTheme$1,
            themeId: THEME_ID
        });
    }
    function globalCss(styles) {
        return function GlobalStylesWrapper(props) {
            return (jsxRuntimeExports.jsx(GlobalStyles$1, {
                styles: typeof styles === 'function' ? (theme)=>styles({
                        theme,
                        ...props
                    }) : styles
            }));
        };
    }
    function internal_createExtendSxProp() {
        return extendSxProp$1;
    }
    const memoTheme = unstable_memoTheme;
    function useDefaultProps(params) {
        return useDefaultProps$1(params);
    }
    function getSvgIconUtilityClass(slot) {
        return generateUtilityClass('MuiSvgIcon', slot);
    }
    generateUtilityClasses('MuiSvgIcon', [
        'root',
        'colorPrimary',
        'colorSecondary',
        'colorAction',
        'colorError',
        'colorDisabled',
        'fontSizeInherit',
        'fontSizeSmall',
        'fontSizeMedium',
        'fontSizeLarge'
    ]);
    const useUtilityClasses$A = (ownerState)=>{
        const { color, fontSize, classes } = ownerState;
        const slots = {
            root: [
                "root",
                color !== "inherit" && `color${capitalize(color)}`,
                `fontSize${capitalize(fontSize)}`
            ]
        };
        return composeClasses(slots, getSvgIconUtilityClass, classes);
    };
    const SvgIconRoot = styled("svg", {
        name: "MuiSvgIcon",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.color !== "inherit" && styles[`color${capitalize(ownerState.color)}`],
                styles[`fontSize${capitalize(ownerState.fontSize)}`]
            ];
        }
    })(memoTheme(({ theme })=>({
            userSelect: "none",
            width: "1em",
            height: "1em",
            display: "inline-block",
            flexShrink: 0,
            transition: theme.transitions?.create?.("fill", {
                duration: (theme.vars ?? theme).transitions?.duration?.shorter
            }),
            variants: [
                {
                    props: (props)=>!props.hasSvgAsChild,
                    style: {
                        fill: "currentColor"
                    }
                },
                {
                    props: {
                        fontSize: "inherit"
                    },
                    style: {
                        fontSize: "inherit"
                    }
                },
                {
                    props: {
                        fontSize: "small"
                    },
                    style: {
                        fontSize: theme.typography?.pxToRem?.(20) || "1.25rem"
                    }
                },
                {
                    props: {
                        fontSize: "medium"
                    },
                    style: {
                        fontSize: theme.typography?.pxToRem?.(24) || "1.5rem"
                    }
                },
                {
                    props: {
                        fontSize: "large"
                    },
                    style: {
                        fontSize: theme.typography?.pxToRem?.(35) || "2.1875rem"
                    }
                },
                ...Object.entries((theme.vars ?? theme).palette).filter(([, value])=>value && value.main).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            color: (theme.vars ?? theme).palette?.[color]?.main
                        }
                    })),
                {
                    props: {
                        color: "action"
                    },
                    style: {
                        color: (theme.vars ?? theme).palette?.action?.active
                    }
                },
                {
                    props: {
                        color: "disabled"
                    },
                    style: {
                        color: (theme.vars ?? theme).palette?.action?.disabled
                    }
                },
                {
                    props: {
                        color: "inherit"
                    },
                    style: {
                        color: void 0
                    }
                }
            ]
        })));
    const SvgIcon = reactExports.forwardRef(function SvgIcon2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiSvgIcon"
        });
        const { children, className, color = "inherit", component = "svg", fontSize = "medium", htmlColor, inheritViewBox = false, titleAccess, viewBox = "0 0 24 24", ...other } = props;
        const hasSvgAsChild = reactExports.isValidElement(children) && children.type === "svg";
        const ownerState = {
            ...props,
            color,
            component,
            fontSize,
            instanceFontSize: inProps.fontSize,
            inheritViewBox,
            viewBox,
            hasSvgAsChild
        };
        const more = {};
        if (!inheritViewBox) {
            more.viewBox = viewBox;
        }
        const classes = useUtilityClasses$A(ownerState);
        return jsxRuntimeExports.jsxs(SvgIconRoot, {
            as: component,
            className: clsx(classes.root, className),
            focusable: "false",
            color: htmlColor,
            "aria-hidden": titleAccess ? void 0 : true,
            role: titleAccess ? "img" : void 0,
            ref,
            ...more,
            ...other,
            ...hasSvgAsChild && children.props,
            ownerState,
            children: [
                hasSvgAsChild ? children.props.children : children,
                titleAccess ? jsxRuntimeExports.jsx("title", {
                    children: titleAccess
                }) : null
            ]
        });
    });
    SvgIcon.muiName = "SvgIcon";
    function createSvgIcon(path, displayName) {
        function Component(props, ref) {
            return jsxRuntimeExports.jsx(SvgIcon, {
                "data-testid": void 0,
                ref,
                ...props,
                children: path
            });
        }
        Component.muiName = SvgIcon.muiName;
        return reactExports.memo(reactExports.forwardRef(Component));
    }
    function debounce(func, wait = 166) {
        let timeout;
        function debounced(...args) {
            const later = ()=>{
                func.apply(this, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        }
        debounced.clear = ()=>{
            clearTimeout(timeout);
        };
        return debounced;
    }
    function ownerDocument(node) {
        return node && node.ownerDocument || document;
    }
    function ownerWindow(node) {
        const doc = ownerDocument(node);
        return doc.defaultView || window;
    }
    function setRef(ref, value) {
        if (typeof ref === 'function') {
            ref(value);
        } else if (ref) {
            ref.current = value;
        }
    }
    function useControlled(props) {
        const { controlled, default: defaultProp, name, state = "value" } = props;
        const { current: isControlled } = reactExports.useRef(controlled !== void 0);
        const [valueState, setValue] = reactExports.useState(defaultProp);
        const value = isControlled ? controlled : valueState;
        const setValueIfUncontrolled = reactExports.useCallback((newValue)=>{
            if (!isControlled) {
                setValue(newValue);
            }
        }, []);
        return [
            value,
            setValueIfUncontrolled
        ];
    }
    function useEventCallback(fn) {
        const ref = reactExports.useRef(fn);
        useEnhancedEffect(()=>{
            ref.current = fn;
        });
        return reactExports.useRef((...args)=>(0, ref.current)(...args)).current;
    }
    function useForkRef(...refs) {
        const cleanupRef = reactExports.useRef(undefined);
        const refEffect = reactExports.useCallback((instance)=>{
            const cleanups = refs.map((ref)=>{
                if (ref == null) {
                    return null;
                }
                if (typeof ref === 'function') {
                    const refCallback = ref;
                    const refCleanup = refCallback(instance);
                    return typeof refCleanup === 'function' ? refCleanup : ()=>{
                        refCallback(null);
                    };
                }
                ref.current = instance;
                return ()=>{
                    ref.current = null;
                };
            });
            return ()=>{
                cleanups.forEach((refCleanup)=>refCleanup?.());
            };
        }, refs);
        return reactExports.useMemo(()=>{
            if (refs.every((ref)=>ref == null)) {
                return null;
            }
            return (value)=>{
                if (cleanupRef.current) {
                    cleanupRef.current();
                    cleanupRef.current = undefined;
                }
                if (value != null) {
                    cleanupRef.current = refEffect(value);
                }
            };
        }, refs);
    }
    function isEventHandler(key, value) {
        const thirdCharCode = key.charCodeAt(2);
        return key[0] === 'o' && key[1] === 'n' && thirdCharCode >= 65 && thirdCharCode <= 90 && typeof value === 'function';
    }
    function mergeSlotProps$1(externalSlotProps, defaultSlotProps) {
        if (!externalSlotProps) {
            return defaultSlotProps;
        }
        function extractHandlers(externalSlotPropsValue, defaultSlotPropsValue) {
            const handlers = {};
            Object.keys(defaultSlotPropsValue).forEach((key)=>{
                if (isEventHandler(key, defaultSlotPropsValue[key]) && typeof externalSlotPropsValue[key] === 'function') {
                    handlers[key] = (...args)=>{
                        externalSlotPropsValue[key](...args);
                        defaultSlotPropsValue[key](...args);
                    };
                }
            });
            return handlers;
        }
        if (typeof externalSlotProps === 'function' || typeof defaultSlotProps === 'function') {
            return (ownerState)=>{
                const defaultSlotPropsValue = typeof defaultSlotProps === 'function' ? defaultSlotProps(ownerState) : defaultSlotProps;
                const externalSlotPropsValue = typeof externalSlotProps === 'function' ? externalSlotProps({
                    ...ownerState,
                    ...defaultSlotPropsValue
                }) : externalSlotProps;
                const className = clsx(ownerState?.className, defaultSlotPropsValue?.className, externalSlotPropsValue?.className);
                const handlers = extractHandlers(externalSlotPropsValue, defaultSlotPropsValue);
                return {
                    ...defaultSlotPropsValue,
                    ...externalSlotPropsValue,
                    ...handlers,
                    ...(!!className && {
                        className
                    }),
                    ...(defaultSlotPropsValue?.style && externalSlotPropsValue?.style && {
                        style: {
                            ...defaultSlotPropsValue.style,
                            ...externalSlotPropsValue.style
                        }
                    }),
                    ...(defaultSlotPropsValue?.sx && externalSlotPropsValue?.sx && {
                        sx: [
                            ...(Array.isArray(defaultSlotPropsValue.sx) ? defaultSlotPropsValue.sx : [
                                defaultSlotPropsValue.sx
                            ]),
                            ...(Array.isArray(externalSlotPropsValue.sx) ? externalSlotPropsValue.sx : [
                                externalSlotPropsValue.sx
                            ])
                        ]
                    })
                };
            };
        }
        const typedDefaultSlotProps = defaultSlotProps;
        const handlers = extractHandlers(externalSlotProps, typedDefaultSlotProps);
        const className = clsx(typedDefaultSlotProps?.className, externalSlotProps?.className);
        return {
            ...defaultSlotProps,
            ...externalSlotProps,
            ...handlers,
            ...(!!className && {
                className
            }),
            ...(typedDefaultSlotProps?.style && externalSlotProps?.style && {
                style: {
                    ...typedDefaultSlotProps.style,
                    ...externalSlotProps.style
                }
            }),
            ...(typedDefaultSlotProps?.sx && externalSlotProps?.sx && {
                sx: [
                    ...(Array.isArray(typedDefaultSlotProps.sx) ? typedDefaultSlotProps.sx : [
                        typedDefaultSlotProps.sx
                    ]),
                    ...(Array.isArray(externalSlotProps.sx) ? externalSlotProps.sx : [
                        externalSlotProps.sx
                    ])
                ]
            })
        };
    }
    function _objectWithoutPropertiesLoose(r, e) {
        if (null == r) return {};
        var t = {};
        for(var n in r)if ({}.hasOwnProperty.call(r, n)) {
            if (-1 !== e.indexOf(n)) continue;
            t[n] = r[n];
        }
        return t;
    }
    function _setPrototypeOf(t, e) {
        return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
            return t.__proto__ = e, t;
        }, _setPrototypeOf(t, e);
    }
    function _inheritsLoose(t, o) {
        t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
    }
    const config$1 = {
        disabled: false
    };
    const TransitionGroupContext = React.createContext(null);
    var forceReflow = function forceReflow(node) {
        return node.scrollTop;
    };
    var UNMOUNTED = "unmounted";
    var EXITED = "exited";
    var ENTERING = "entering";
    var ENTERED = "entered";
    var EXITING = "exiting";
    var Transition = (function(_React$Component) {
        _inheritsLoose(Transition2, _React$Component);
        function Transition2(props, context) {
            var _this;
            _this = _React$Component.call(this, props, context) || this;
            var parentGroup = context;
            var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
            var initialStatus;
            _this.appearStatus = null;
            if (props.in) {
                if (appear) {
                    initialStatus = EXITED;
                    _this.appearStatus = ENTERING;
                } else {
                    initialStatus = ENTERED;
                }
            } else {
                if (props.unmountOnExit || props.mountOnEnter) {
                    initialStatus = UNMOUNTED;
                } else {
                    initialStatus = EXITED;
                }
            }
            _this.state = {
                status: initialStatus
            };
            _this.nextCallback = null;
            return _this;
        }
        Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
            var nextIn = _ref.in;
            if (nextIn && prevState.status === UNMOUNTED) {
                return {
                    status: EXITED
                };
            }
            return null;
        };
        var _proto = Transition2.prototype;
        _proto.componentDidMount = function componentDidMount() {
            this.updateStatus(true, this.appearStatus);
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
            var nextStatus = null;
            if (prevProps !== this.props) {
                var status = this.state.status;
                if (this.props.in) {
                    if (status !== ENTERING && status !== ENTERED) {
                        nextStatus = ENTERING;
                    }
                } else {
                    if (status === ENTERING || status === ENTERED) {
                        nextStatus = EXITING;
                    }
                }
            }
            this.updateStatus(false, nextStatus);
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
            this.cancelNextCallback();
        };
        _proto.getTimeouts = function getTimeouts() {
            var timeout2 = this.props.timeout;
            var exit, enter, appear;
            exit = enter = appear = timeout2;
            if (timeout2 != null && typeof timeout2 !== "number") {
                exit = timeout2.exit;
                enter = timeout2.enter;
                appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
            }
            return {
                exit,
                enter,
                appear
            };
        };
        _proto.updateStatus = function updateStatus(mounting, nextStatus) {
            if (mounting === void 0) {
                mounting = false;
            }
            if (nextStatus !== null) {
                this.cancelNextCallback();
                if (nextStatus === ENTERING) {
                    if (this.props.unmountOnExit || this.props.mountOnEnter) {
                        var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
                        if (node) forceReflow(node);
                    }
                    this.performEnter(mounting);
                } else {
                    this.performExit();
                }
            } else if (this.props.unmountOnExit && this.state.status === EXITED) {
                this.setState({
                    status: UNMOUNTED
                });
            }
        };
        _proto.performEnter = function performEnter(mounting) {
            var _this2 = this;
            var enter = this.props.enter;
            var appearing = this.context ? this.context.isMounting : mounting;
            var _ref2 = this.props.nodeRef ? [
                appearing
            ] : [
                ReactDOM.findDOMNode(this),
                appearing
            ], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
            var timeouts = this.getTimeouts();
            var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
            if (!mounting && !enter || config$1.disabled) {
                this.safeSetState({
                    status: ENTERED
                }, function() {
                    _this2.props.onEntered(maybeNode);
                });
                return;
            }
            this.props.onEnter(maybeNode, maybeAppearing);
            this.safeSetState({
                status: ENTERING
            }, function() {
                _this2.props.onEntering(maybeNode, maybeAppearing);
                _this2.onTransitionEnd(enterTimeout, function() {
                    _this2.safeSetState({
                        status: ENTERED
                    }, function() {
                        _this2.props.onEntered(maybeNode, maybeAppearing);
                    });
                });
            });
        };
        _proto.performExit = function performExit() {
            var _this3 = this;
            var exit = this.props.exit;
            var timeouts = this.getTimeouts();
            var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
            if (!exit || config$1.disabled) {
                this.safeSetState({
                    status: EXITED
                }, function() {
                    _this3.props.onExited(maybeNode);
                });
                return;
            }
            this.props.onExit(maybeNode);
            this.safeSetState({
                status: EXITING
            }, function() {
                _this3.props.onExiting(maybeNode);
                _this3.onTransitionEnd(timeouts.exit, function() {
                    _this3.safeSetState({
                        status: EXITED
                    }, function() {
                        _this3.props.onExited(maybeNode);
                    });
                });
            });
        };
        _proto.cancelNextCallback = function cancelNextCallback() {
            if (this.nextCallback !== null) {
                this.nextCallback.cancel();
                this.nextCallback = null;
            }
        };
        _proto.safeSetState = function safeSetState(nextState, callback) {
            callback = this.setNextCallback(callback);
            this.setState(nextState, callback);
        };
        _proto.setNextCallback = function setNextCallback(callback) {
            var _this4 = this;
            var active = true;
            this.nextCallback = function(event) {
                if (active) {
                    active = false;
                    _this4.nextCallback = null;
                    callback(event);
                }
            };
            this.nextCallback.cancel = function() {
                active = false;
            };
            return this.nextCallback;
        };
        _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
            this.setNextCallback(handler);
            var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
            var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
            if (!node || doesNotHaveTimeoutOrListener) {
                setTimeout(this.nextCallback, 0);
                return;
            }
            if (this.props.addEndListener) {
                var _ref3 = this.props.nodeRef ? [
                    this.nextCallback
                ] : [
                    node,
                    this.nextCallback
                ], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
                this.props.addEndListener(maybeNode, maybeNextCallback);
            }
            if (timeout2 != null) {
                setTimeout(this.nextCallback, timeout2);
            }
        };
        _proto.render = function render() {
            var status = this.state.status;
            if (status === UNMOUNTED) {
                return null;
            }
            var _this$props = this.props, children = _this$props.children;
            _this$props.in;
            _this$props.mountOnEnter;
            _this$props.unmountOnExit;
            _this$props.appear;
            _this$props.enter;
            _this$props.exit;
            _this$props.timeout;
            _this$props.addEndListener;
            _this$props.onEnter;
            _this$props.onEntering;
            _this$props.onEntered;
            _this$props.onExit;
            _this$props.onExiting;
            _this$props.onExited;
            _this$props.nodeRef;
            var childProps = _objectWithoutPropertiesLoose(_this$props, [
                "children",
                "in",
                "mountOnEnter",
                "unmountOnExit",
                "appear",
                "enter",
                "exit",
                "timeout",
                "addEndListener",
                "onEnter",
                "onEntering",
                "onEntered",
                "onExit",
                "onExiting",
                "onExited",
                "nodeRef"
            ]);
            return (React.createElement(TransitionGroupContext.Provider, {
                value: null
            }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps)));
        };
        return Transition2;
    })(React.Component);
    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = {};
    function noop$3() {}
    Transition.defaultProps = {
        in: false,
        mountOnEnter: false,
        unmountOnExit: false,
        appear: false,
        enter: true,
        exit: true,
        onEnter: noop$3,
        onEntering: noop$3,
        onEntered: noop$3,
        onExit: noop$3,
        onExiting: noop$3,
        onExited: noop$3
    };
    Transition.UNMOUNTED = UNMOUNTED;
    Transition.EXITED = EXITED;
    Transition.ENTERING = ENTERING;
    Transition.ENTERED = ENTERED;
    Transition.EXITING = EXITING;
    function _assertThisInitialized(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
    }
    function getChildMapping(children, mapFn) {
        var mapper = function mapper(child) {
            return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
        };
        var result = Object.create(null);
        if (children) reactExports.Children.map(children, function(c) {
            return c;
        }).forEach(function(child) {
            result[child.key] = mapper(child);
        });
        return result;
    }
    function mergeChildMappings(prev, next) {
        prev = prev || {};
        next = next || {};
        function getValueForKey(key) {
            return key in next ? next[key] : prev[key];
        }
        var nextKeysPending = Object.create(null);
        var pendingKeys = [];
        for(var prevKey in prev){
            if (prevKey in next) {
                if (pendingKeys.length) {
                    nextKeysPending[prevKey] = pendingKeys;
                    pendingKeys = [];
                }
            } else {
                pendingKeys.push(prevKey);
            }
        }
        var i;
        var childMapping = {};
        for(var nextKey in next){
            if (nextKeysPending[nextKey]) {
                for(i = 0; i < nextKeysPending[nextKey].length; i++){
                    var pendingNextKey = nextKeysPending[nextKey][i];
                    childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
                }
            }
            childMapping[nextKey] = getValueForKey(nextKey);
        }
        for(i = 0; i < pendingKeys.length; i++){
            childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
        }
        return childMapping;
    }
    function getProp(child, prop, props) {
        return props[prop] != null ? props[prop] : child.props[prop];
    }
    function getInitialChildMapping(props, onExited) {
        return getChildMapping(props.children, function(child) {
            return reactExports.cloneElement(child, {
                onExited: onExited.bind(null, child),
                in: true,
                appear: getProp(child, 'appear', props),
                enter: getProp(child, 'enter', props),
                exit: getProp(child, 'exit', props)
            });
        });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
        var nextChildMapping = getChildMapping(nextProps.children);
        var children = mergeChildMappings(prevChildMapping, nextChildMapping);
        Object.keys(children).forEach(function(key) {
            var child = children[key];
            if (!reactExports.isValidElement(child)) return;
            var hasPrev = (key in prevChildMapping);
            var hasNext = (key in nextChildMapping);
            var prevChild = prevChildMapping[key];
            var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
            if (hasNext && (!hasPrev || isLeaving)) {
                children[key] = reactExports.cloneElement(child, {
                    onExited: onExited.bind(null, child),
                    in: true,
                    exit: getProp(child, 'exit', nextProps),
                    enter: getProp(child, 'enter', nextProps)
                });
            } else if (!hasNext && hasPrev && !isLeaving) {
                children[key] = reactExports.cloneElement(child, {
                    in: false
                });
            } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
                children[key] = reactExports.cloneElement(child, {
                    onExited: onExited.bind(null, child),
                    in: prevChild.props.in,
                    exit: getProp(child, 'exit', nextProps),
                    enter: getProp(child, 'enter', nextProps)
                });
            }
        });
        return children;
    }
    var values = Object.values || function(obj) {
        return Object.keys(obj).map(function(k) {
            return obj[k];
        });
    };
    var defaultProps = {
        component: "div",
        childFactory: function childFactory(child) {
            return child;
        }
    };
    var TransitionGroup = (function(_React$Component) {
        _inheritsLoose(TransitionGroup2, _React$Component);
        function TransitionGroup2(props, context) {
            var _this;
            _this = _React$Component.call(this, props, context) || this;
            var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
            _this.state = {
                contextValue: {
                    isMounting: true
                },
                handleExited,
                firstRender: true
            };
            return _this;
        }
        var _proto = TransitionGroup2.prototype;
        _proto.componentDidMount = function componentDidMount() {
            this.mounted = true;
            this.setState({
                contextValue: {
                    isMounting: false
                }
            });
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
            this.mounted = false;
        };
        TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
            var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
            return {
                children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
                firstRender: false
            };
        };
        _proto.handleExited = function handleExited(child, node) {
            var currentChildMapping = getChildMapping(this.props.children);
            if (child.key in currentChildMapping) return;
            if (child.props.onExited) {
                child.props.onExited(node);
            }
            if (this.mounted) {
                this.setState(function(state) {
                    var children = _extends({}, state.children);
                    delete children[child.key];
                    return {
                        children
                    };
                });
            }
        };
        _proto.render = function render() {
            var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, [
                "component",
                "childFactory"
            ]);
            var contextValue = this.state.contextValue;
            var children = values(this.state.children).map(childFactory2);
            delete props.appear;
            delete props.enter;
            delete props.exit;
            if (Component === null) {
                return React.createElement(TransitionGroupContext.Provider, {
                    value: contextValue
                }, children);
            }
            return React.createElement(TransitionGroupContext.Provider, {
                value: contextValue
            }, React.createElement(Component, props, children));
        };
        return TransitionGroup2;
    })(React.Component);
    TransitionGroup.propTypes = {};
    TransitionGroup.defaultProps = defaultProps;
    const UNINITIALIZED = {};
    function useLazyRef(init, initArg) {
        const ref = reactExports.useRef(UNINITIALIZED);
        if (ref.current === UNINITIALIZED) {
            ref.current = init(initArg);
        }
        return ref;
    }
    const EMPTY$1 = [];
    function useOnMount(fn) {
        reactExports.useEffect(fn, EMPTY$1);
    }
    class Timeout {
        static create() {
            return new Timeout();
        }
        currentId = null;
        start(delay, fn) {
            this.clear();
            this.currentId = setTimeout(()=>{
                this.currentId = null;
                fn();
            }, delay);
        }
        clear = ()=>{
            if (this.currentId !== null) {
                clearTimeout(this.currentId);
                this.currentId = null;
            }
        };
        disposeEffect = ()=>{
            return this.clear;
        };
    }
    function useTimeout() {
        const timeout = useLazyRef(Timeout.create).current;
        useOnMount(timeout.disposeEffect);
        return timeout;
    }
    const reflow = (node)=>node.scrollTop;
    function getTransitionProps(props, options) {
        const { timeout, easing, style = {} } = props;
        return {
            duration: style.transitionDuration ?? (typeof timeout === 'number' ? timeout : timeout[options.mode] || 0),
            easing: style.transitionTimingFunction ?? (typeof easing === 'object' ? easing[options.mode] : easing),
            delay: style.transitionDelay
        };
    }
    function getPaperUtilityClass(slot) {
        return generateUtilityClass('MuiPaper', slot);
    }
    generateUtilityClasses('MuiPaper', [
        'root',
        'rounded',
        'outlined',
        'elevation',
        'elevation0',
        'elevation1',
        'elevation2',
        'elevation3',
        'elevation4',
        'elevation5',
        'elevation6',
        'elevation7',
        'elevation8',
        'elevation9',
        'elevation10',
        'elevation11',
        'elevation12',
        'elevation13',
        'elevation14',
        'elevation15',
        'elevation16',
        'elevation17',
        'elevation18',
        'elevation19',
        'elevation20',
        'elevation21',
        'elevation22',
        'elevation23',
        'elevation24'
    ]);
    const useUtilityClasses$z = (ownerState)=>{
        const { square, elevation, variant, classes } = ownerState;
        const slots = {
            root: [
                "root",
                variant,
                !square && "rounded",
                variant === "elevation" && `elevation${elevation}`
            ]
        };
        return composeClasses(slots, getPaperUtilityClass, classes);
    };
    const PaperRoot = styled("div", {
        name: "MuiPaper",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[ownerState.variant],
                !ownerState.square && styles.rounded,
                ownerState.variant === "elevation" && styles[`elevation${ownerState.elevation}`]
            ];
        }
    })(memoTheme(({ theme })=>({
            backgroundColor: (theme.vars || theme).palette.background.paper,
            color: (theme.vars || theme).palette.text.primary,
            transition: theme.transitions.create("box-shadow"),
            variants: [
                {
                    props: ({ ownerState })=>!ownerState.square,
                    style: {
                        borderRadius: theme.shape.borderRadius
                    }
                },
                {
                    props: {
                        variant: "outlined"
                    },
                    style: {
                        border: `1px solid ${(theme.vars || theme).palette.divider}`
                    }
                },
                {
                    props: {
                        variant: "elevation"
                    },
                    style: {
                        boxShadow: "var(--Paper-shadow)",
                        backgroundImage: "var(--Paper-overlay)"
                    }
                }
            ]
        })));
    const Paper = reactExports.forwardRef(function Paper2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiPaper"
        });
        const theme = useTheme();
        const { className, component = "div", elevation = 1, square = false, variant = "elevation", ...other } = props;
        const ownerState = {
            ...props,
            component,
            elevation,
            square,
            variant
        };
        const classes = useUtilityClasses$z(ownerState);
        return jsxRuntimeExports.jsx(PaperRoot, {
            as: component,
            ownerState,
            className: clsx(classes.root, className),
            ref,
            ...other,
            style: {
                ...variant === "elevation" && {
                    "--Paper-shadow": (theme.vars || theme).shadows[elevation],
                    ...theme.vars && {
                        "--Paper-overlay": theme.vars.overlays?.[elevation]
                    },
                    ...!theme.vars && theme.palette.mode === "dark" && {
                        "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
                    }
                },
                ...other.style
            }
        });
    });
    function isHostComponent$1(element) {
        return typeof element === 'string';
    }
    function appendOwnerState(elementType, otherProps, ownerState) {
        if (elementType === undefined || isHostComponent$1(elementType)) {
            return otherProps;
        }
        return {
            ...otherProps,
            ownerState: {
                ...otherProps.ownerState,
                ...ownerState
            }
        };
    }
    function resolveComponentProps(componentProps, ownerState, slotState) {
        if (typeof componentProps === 'function') {
            return componentProps(ownerState, slotState);
        }
        return componentProps;
    }
    function extractEventHandlers(object, excludeKeys = []) {
        if (object === undefined) {
            return {};
        }
        const result = {};
        Object.keys(object).filter((prop)=>prop.match(/^on[A-Z]/) && typeof object[prop] === 'function' && !excludeKeys.includes(prop)).forEach((prop)=>{
            result[prop] = object[prop];
        });
        return result;
    }
    function omitEventHandlers(object) {
        if (object === undefined) {
            return {};
        }
        const result = {};
        Object.keys(object).filter((prop)=>!(prop.match(/^on[A-Z]/) && typeof object[prop] === 'function')).forEach((prop)=>{
            result[prop] = object[prop];
        });
        return result;
    }
    function mergeSlotProps(parameters) {
        const { getSlotProps, additionalProps, externalSlotProps, externalForwardedProps, className } = parameters;
        if (!getSlotProps) {
            const joinedClasses = clsx(additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
            const mergedStyle = {
                ...additionalProps?.style,
                ...externalForwardedProps?.style,
                ...externalSlotProps?.style
            };
            const props = {
                ...additionalProps,
                ...externalForwardedProps,
                ...externalSlotProps
            };
            if (joinedClasses.length > 0) {
                props.className = joinedClasses;
            }
            if (Object.keys(mergedStyle).length > 0) {
                props.style = mergedStyle;
            }
            return {
                props,
                internalRef: undefined
            };
        }
        const eventHandlers = extractEventHandlers({
            ...externalForwardedProps,
            ...externalSlotProps
        });
        const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
        const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
        const internalSlotProps = getSlotProps(eventHandlers);
        const joinedClasses = clsx(internalSlotProps?.className, additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
        const mergedStyle = {
            ...internalSlotProps?.style,
            ...additionalProps?.style,
            ...externalForwardedProps?.style,
            ...externalSlotProps?.style
        };
        const props = {
            ...internalSlotProps,
            ...additionalProps,
            ...otherPropsWithoutEventHandlers,
            ...componentsPropsWithoutEventHandlers
        };
        if (joinedClasses.length > 0) {
            props.className = joinedClasses;
        }
        if (Object.keys(mergedStyle).length > 0) {
            props.style = mergedStyle;
        }
        return {
            props,
            internalRef: internalSlotProps.ref
        };
    }
    function useSlot(name, parameters) {
        const { className, elementType: initialElementType, ownerState, externalForwardedProps, internalForwardedProps, shouldForwardComponentProp = false, ...useSlotPropsParams } = parameters;
        const { component: rootComponent, slots = {
            [name]: undefined
        }, slotProps = {
            [name]: undefined
        }, ...other } = externalForwardedProps;
        const elementType = slots[name] || initialElementType;
        const resolvedComponentsProps = resolveComponentProps(slotProps[name], ownerState);
        const { props: { component: slotComponent, ...mergedProps }, internalRef } = mergeSlotProps({
            className,
            ...useSlotPropsParams,
            externalForwardedProps: name === 'root' ? other : undefined,
            externalSlotProps: resolvedComponentsProps
        });
        const ref = useForkRef(internalRef, resolvedComponentsProps?.ref, parameters.ref);
        const LeafComponent = name === 'root' ? slotComponent || rootComponent : slotComponent;
        const props = appendOwnerState(elementType, {
            ...(name === 'root' && !rootComponent && !slots[name] && internalForwardedProps),
            ...(name !== 'root' && !slots[name] && internalForwardedProps),
            ...mergedProps,
            ...(LeafComponent && !shouldForwardComponentProp && {
                as: LeafComponent
            }),
            ...(LeafComponent && shouldForwardComponentProp && {
                component: LeafComponent
            }),
            ref
        }, ownerState);
        return [
            elementType,
            props
        ];
    }
    function isFocusVisible(element) {
        try {
            return element.matches(":focus-visible");
        } catch (error) {}
        return false;
    }
    class LazyRipple {
        static create() {
            return new LazyRipple();
        }
        static use() {
            const ripple = useLazyRef(LazyRipple.create).current;
            const [shouldMount, setShouldMount] = reactExports.useState(false);
            ripple.shouldMount = shouldMount;
            ripple.setShouldMount = setShouldMount;
            reactExports.useEffect(ripple.mountEffect, [
                shouldMount
            ]);
            return ripple;
        }
        constructor(){
            this.ref = {
                current: null
            };
            this.mounted = null;
            this.didMount = false;
            this.shouldMount = false;
            this.setShouldMount = null;
        }
        mount() {
            if (!this.mounted) {
                this.mounted = createControlledPromise();
                this.shouldMount = true;
                this.setShouldMount(this.shouldMount);
            }
            return this.mounted;
        }
        mountEffect = ()=>{
            if (this.shouldMount && !this.didMount) {
                if (this.ref.current !== null) {
                    this.didMount = true;
                    this.mounted.resolve();
                }
            }
        };
        start(...args) {
            this.mount().then(()=>this.ref.current?.start(...args));
        }
        stop(...args) {
            this.mount().then(()=>this.ref.current?.stop(...args));
        }
        pulsate(...args) {
            this.mount().then(()=>this.ref.current?.pulsate(...args));
        }
    }
    function useLazyRipple() {
        return LazyRipple.use();
    }
    function createControlledPromise() {
        let resolve;
        let reject;
        const p = new Promise((resolveFn, rejectFn)=>{
            resolve = resolveFn;
            reject = rejectFn;
        });
        p.resolve = resolve;
        p.reject = reject;
        return p;
    }
    function Ripple(props) {
        const { className, classes, pulsate = false, rippleX, rippleY, rippleSize, in: inProp, onExited, timeout } = props;
        const [leaving, setLeaving] = reactExports.useState(false);
        const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
        const rippleStyles = {
            width: rippleSize,
            height: rippleSize,
            top: -(rippleSize / 2) + rippleY,
            left: -(rippleSize / 2) + rippleX
        };
        const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
        if (!inProp && !leaving) {
            setLeaving(true);
        }
        reactExports.useEffect(()=>{
            if (!inProp && onExited != null) {
                const timeoutId = setTimeout(onExited, timeout);
                return ()=>{
                    clearTimeout(timeoutId);
                };
            }
            return void 0;
        }, [
            onExited,
            inProp,
            timeout
        ]);
        return jsxRuntimeExports.jsx("span", {
            className: rippleClassName,
            style: rippleStyles,
            children: jsxRuntimeExports.jsx("span", {
                className: childClassName
            })
        });
    }
    const touchRippleClasses = generateUtilityClasses('MuiTouchRipple', [
        'root',
        'ripple',
        'rippleVisible',
        'ripplePulsate',
        'child',
        'childLeaving',
        'childPulsate'
    ]);
    const DURATION = 550;
    const DELAY_RIPPLE = 80;
    const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
    const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
    const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
    const TouchRippleRoot = styled("span", {
        name: "MuiTouchRipple",
        slot: "Root"
    })({
        overflow: "hidden",
        pointerEvents: "none",
        position: "absolute",
        zIndex: 0,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        borderRadius: "inherit"
    });
    const TouchRippleRipple = styled(Ripple, {
        name: "MuiTouchRipple",
        slot: "Ripple"
    })`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({ theme })=>theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({ theme })=>theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({ theme })=>theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({ theme })=>theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
    const TouchRipple = reactExports.forwardRef(function TouchRipple2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiTouchRipple"
        });
        const { center: centerProp = false, classes = {}, className, ...other } = props;
        const [ripples, setRipples] = reactExports.useState([]);
        const nextKey = reactExports.useRef(0);
        const rippleCallback = reactExports.useRef(null);
        reactExports.useEffect(()=>{
            if (rippleCallback.current) {
                rippleCallback.current();
                rippleCallback.current = null;
            }
        }, [
            ripples
        ]);
        const ignoringMouseDown = reactExports.useRef(false);
        const startTimer = useTimeout();
        const startTimerCommit = reactExports.useRef(null);
        const container = reactExports.useRef(null);
        const startCommit = reactExports.useCallback((params)=>{
            const { pulsate: pulsate2, rippleX, rippleY, rippleSize, cb } = params;
            setRipples((oldRipples)=>[
                    ...oldRipples,
                    jsxRuntimeExports.jsx(TouchRippleRipple, {
                        classes: {
                            ripple: clsx(classes.ripple, touchRippleClasses.ripple),
                            rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
                            ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
                            child: clsx(classes.child, touchRippleClasses.child),
                            childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
                            childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
                        },
                        timeout: DURATION,
                        pulsate: pulsate2,
                        rippleX,
                        rippleY,
                        rippleSize
                    }, nextKey.current)
                ]);
            nextKey.current += 1;
            rippleCallback.current = cb;
        }, [
            classes
        ]);
        const start = reactExports.useCallback((event = {}, options = {}, cb = ()=>{})=>{
            const { pulsate: pulsate2 = false, center = centerProp || options.pulsate, fakeElement = false } = options;
            if (event?.type === "mousedown" && ignoringMouseDown.current) {
                ignoringMouseDown.current = false;
                return;
            }
            if (event?.type === "touchstart") {
                ignoringMouseDown.current = true;
            }
            const element = fakeElement ? null : container.current;
            const rect = element ? element.getBoundingClientRect() : {
                width: 0,
                height: 0,
                left: 0,
                top: 0
            };
            let rippleX;
            let rippleY;
            let rippleSize;
            if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
                rippleX = Math.round(rect.width / 2);
                rippleY = Math.round(rect.height / 2);
            } else {
                const { clientX, clientY } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
                rippleX = Math.round(clientX - rect.left);
                rippleY = Math.round(clientY - rect.top);
            }
            if (center) {
                rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
                if (rippleSize % 2 === 0) {
                    rippleSize += 1;
                }
            } else {
                const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
                const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
                rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
            }
            if (event?.touches) {
                if (startTimerCommit.current === null) {
                    startTimerCommit.current = ()=>{
                        startCommit({
                            pulsate: pulsate2,
                            rippleX,
                            rippleY,
                            rippleSize,
                            cb
                        });
                    };
                    startTimer.start(DELAY_RIPPLE, ()=>{
                        if (startTimerCommit.current) {
                            startTimerCommit.current();
                            startTimerCommit.current = null;
                        }
                    });
                }
            } else {
                startCommit({
                    pulsate: pulsate2,
                    rippleX,
                    rippleY,
                    rippleSize,
                    cb
                });
            }
        }, [
            centerProp,
            startCommit,
            startTimer
        ]);
        const pulsate = reactExports.useCallback(()=>{
            start({}, {
                pulsate: true
            });
        }, [
            start
        ]);
        const stop = reactExports.useCallback((event, cb)=>{
            startTimer.clear();
            if (event?.type === "touchend" && startTimerCommit.current) {
                startTimerCommit.current();
                startTimerCommit.current = null;
                startTimer.start(0, ()=>{
                    stop(event, cb);
                });
                return;
            }
            startTimerCommit.current = null;
            setRipples((oldRipples)=>{
                if (oldRipples.length > 0) {
                    return oldRipples.slice(1);
                }
                return oldRipples;
            });
            rippleCallback.current = cb;
        }, [
            startTimer
        ]);
        reactExports.useImperativeHandle(ref, ()=>({
                pulsate,
                start,
                stop
            }), [
            pulsate,
            start,
            stop
        ]);
        return jsxRuntimeExports.jsx(TouchRippleRoot, {
            className: clsx(touchRippleClasses.root, classes.root, className),
            ref: container,
            ...other,
            children: jsxRuntimeExports.jsx(TransitionGroup, {
                component: null,
                exit: true,
                children: ripples
            })
        });
    });
    function getButtonBaseUtilityClass(slot) {
        return generateUtilityClass('MuiButtonBase', slot);
    }
    const buttonBaseClasses = generateUtilityClasses('MuiButtonBase', [
        'root',
        'disabled',
        'focusVisible'
    ]);
    const useUtilityClasses$y = (ownerState)=>{
        const { disabled, focusVisible, focusVisibleClassName, classes } = ownerState;
        const slots = {
            root: [
                "root",
                disabled && "disabled",
                focusVisible && "focusVisible"
            ]
        };
        const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
        if (focusVisible && focusVisibleClassName) {
            composedClasses.root += ` ${focusVisibleClassName}`;
        }
        return composedClasses;
    };
    const ButtonBaseRoot = styled("button", {
        name: "MuiButtonBase",
        slot: "Root"
    })({
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative",
        boxSizing: "border-box",
        WebkitTapHighlightColor: "transparent",
        backgroundColor: "transparent",
        outline: 0,
        border: 0,
        margin: 0,
        borderRadius: 0,
        padding: 0,
        cursor: "pointer",
        userSelect: "none",
        verticalAlign: "middle",
        MozAppearance: "none",
        WebkitAppearance: "none",
        textDecoration: "none",
        color: "inherit",
        "&::-moz-focus-inner": {
            borderStyle: "none"
        },
        [`&.${buttonBaseClasses.disabled}`]: {
            pointerEvents: "none",
            cursor: "default"
        },
        "@media print": {
            colorAdjust: "exact"
        }
    });
    const ButtonBase = reactExports.forwardRef(function ButtonBase2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiButtonBase"
        });
        const { action, centerRipple = false, children, className, component = "button", disabled = false, disableRipple = false, disableTouchRipple = false, focusRipple = false, focusVisibleClassName, LinkComponent = "a", onBlur, onClick, onContextMenu, onDragLeave, onFocus, onFocusVisible, onKeyDown, onKeyUp, onMouseDown, onMouseLeave, onMouseUp, onTouchEnd, onTouchMove, onTouchStart, tabIndex = 0, TouchRippleProps, touchRippleRef, type, ...other } = props;
        const buttonRef = reactExports.useRef(null);
        const ripple = useLazyRipple();
        const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
        const [focusVisible, setFocusVisible] = reactExports.useState(false);
        if (disabled && focusVisible) {
            setFocusVisible(false);
        }
        reactExports.useImperativeHandle(action, ()=>({
                focusVisible: ()=>{
                    setFocusVisible(true);
                    buttonRef.current.focus();
                }
            }), []);
        const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
        reactExports.useEffect(()=>{
            if (focusVisible && focusRipple && !disableRipple) {
                ripple.pulsate();
            }
        }, [
            disableRipple,
            focusRipple,
            focusVisible,
            ripple
        ]);
        const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
        const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
        const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
        const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
        const handleMouseLeave = useRippleHandler(ripple, "stop", (event)=>{
            if (focusVisible) {
                event.preventDefault();
            }
            if (onMouseLeave) {
                onMouseLeave(event);
            }
        }, disableTouchRipple);
        const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
        const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
        const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
        const handleBlur = useRippleHandler(ripple, "stop", (event)=>{
            if (!isFocusVisible(event.target)) {
                setFocusVisible(false);
            }
            if (onBlur) {
                onBlur(event);
            }
        }, false);
        const handleFocus = useEventCallback((event)=>{
            if (!buttonRef.current) {
                buttonRef.current = event.currentTarget;
            }
            if (isFocusVisible(event.target)) {
                setFocusVisible(true);
                if (onFocusVisible) {
                    onFocusVisible(event);
                }
            }
            if (onFocus) {
                onFocus(event);
            }
        });
        const isNonNativeButton = ()=>{
            const button = buttonRef.current;
            return component && component !== "button" && !(button.tagName === "A" && button.href);
        };
        const handleKeyDown = useEventCallback((event)=>{
            if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
                ripple.stop(event, ()=>{
                    ripple.start(event);
                });
            }
            if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
                event.preventDefault();
            }
            if (onKeyDown) {
                onKeyDown(event);
            }
            if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
                event.preventDefault();
                if (onClick) {
                    onClick(event);
                }
            }
        });
        const handleKeyUp = useEventCallback((event)=>{
            if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
                ripple.stop(event, ()=>{
                    ripple.pulsate(event);
                });
            }
            if (onKeyUp) {
                onKeyUp(event);
            }
            if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
                onClick(event);
            }
        });
        let ComponentProp = component;
        if (ComponentProp === "button" && (other.href || other.to)) {
            ComponentProp = LinkComponent;
        }
        const buttonProps = {};
        if (ComponentProp === "button") {
            buttonProps.type = type === void 0 ? "button" : type;
            buttonProps.disabled = disabled;
        } else {
            if (!other.href && !other.to) {
                buttonProps.role = "button";
            }
            if (disabled) {
                buttonProps["aria-disabled"] = disabled;
            }
        }
        const handleRef = useForkRef(ref, buttonRef);
        const ownerState = {
            ...props,
            centerRipple,
            component,
            disabled,
            disableRipple,
            disableTouchRipple,
            focusRipple,
            tabIndex,
            focusVisible
        };
        const classes = useUtilityClasses$y(ownerState);
        return jsxRuntimeExports.jsxs(ButtonBaseRoot, {
            as: ComponentProp,
            className: clsx(classes.root, className),
            ownerState,
            onBlur: handleBlur,
            onClick,
            onContextMenu: handleContextMenu,
            onFocus: handleFocus,
            onKeyDown: handleKeyDown,
            onKeyUp: handleKeyUp,
            onMouseDown: handleMouseDown,
            onMouseLeave: handleMouseLeave,
            onMouseUp: handleMouseUp,
            onDragLeave: handleDragLeave,
            onTouchEnd: handleTouchEnd,
            onTouchMove: handleTouchMove,
            onTouchStart: handleTouchStart,
            ref: handleRef,
            tabIndex: disabled ? -1 : tabIndex,
            type,
            ...buttonProps,
            ...other,
            children: [
                children,
                enableTouchRipple ? jsxRuntimeExports.jsx(TouchRipple, {
                    ref: handleRippleRef,
                    center: centerRipple,
                    ...TouchRippleProps
                }) : null
            ]
        });
    });
    function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
        return useEventCallback((event)=>{
            if (eventCallback) {
                eventCallback(event);
            }
            if (!skipRippleAction) {
                ripple[rippleAction](event);
            }
            return true;
        });
    }
    function hasCorrectMainProperty(obj) {
        return typeof obj.main === 'string';
    }
    function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
        if (!hasCorrectMainProperty(obj)) {
            return false;
        }
        for (const value of additionalPropertiesToCheck){
            if (!obj.hasOwnProperty(value) || typeof obj[value] !== 'string') {
                return false;
            }
        }
        return true;
    }
    function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
        return ([, value])=>value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
    }
    function getAlertUtilityClass(slot) {
        return generateUtilityClass('MuiAlert', slot);
    }
    const alertClasses = generateUtilityClasses('MuiAlert', [
        'root',
        'action',
        'icon',
        'message',
        'filled',
        'colorSuccess',
        'colorInfo',
        'colorWarning',
        'colorError',
        'filledSuccess',
        'filledInfo',
        'filledWarning',
        'filledError',
        'outlined',
        'outlinedSuccess',
        'outlinedInfo',
        'outlinedWarning',
        'outlinedError',
        'standard',
        'standardSuccess',
        'standardInfo',
        'standardWarning',
        'standardError'
    ]);
    function getCircularProgressUtilityClass(slot) {
        return generateUtilityClass('MuiCircularProgress', slot);
    }
    generateUtilityClasses('MuiCircularProgress', [
        'root',
        'determinate',
        'indeterminate',
        'colorPrimary',
        'colorSecondary',
        'svg',
        'circle',
        'circleDeterminate',
        'circleIndeterminate',
        'circleDisableShrink'
    ]);
    const SIZE = 44;
    const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
    const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
    const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
    const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
    const useUtilityClasses$x = (ownerState)=>{
        const { classes, variant, color, disableShrink } = ownerState;
        const slots = {
            root: [
                "root",
                variant,
                `color${capitalize(color)}`
            ],
            svg: [
                "svg"
            ],
            circle: [
                "circle",
                `circle${capitalize(variant)}`,
                disableShrink && "circleDisableShrink"
            ]
        };
        return composeClasses(slots, getCircularProgressUtilityClass, classes);
    };
    const CircularProgressRoot = styled("span", {
        name: "MuiCircularProgress",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[ownerState.variant],
                styles[`color${capitalize(ownerState.color)}`]
            ];
        }
    })(memoTheme(({ theme })=>({
            display: "inline-block",
            variants: [
                {
                    props: {
                        variant: "determinate"
                    },
                    style: {
                        transition: theme.transitions.create("transform")
                    }
                },
                {
                    props: {
                        variant: "indeterminate"
                    },
                    style: rotateAnimation || {
                        animation: `${circularRotateKeyframe} 1.4s linear infinite`
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            color: (theme.vars || theme).palette[color].main
                        }
                    }))
            ]
        })));
    const CircularProgressSVG = styled("svg", {
        name: "MuiCircularProgress",
        slot: "Svg"
    })({
        display: "block"
    });
    const CircularProgressCircle = styled("circle", {
        name: "MuiCircularProgress",
        slot: "Circle",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.circle,
                styles[`circle${capitalize(ownerState.variant)}`],
                ownerState.disableShrink && styles.circleDisableShrink
            ];
        }
    })(memoTheme(({ theme })=>({
            stroke: "currentColor",
            variants: [
                {
                    props: {
                        variant: "determinate"
                    },
                    style: {
                        transition: theme.transitions.create("stroke-dashoffset")
                    }
                },
                {
                    props: {
                        variant: "indeterminate"
                    },
                    style: {
                        strokeDasharray: "80px, 200px",
                        strokeDashoffset: 0
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.variant === "indeterminate" && !ownerState.disableShrink,
                    style: dashAnimation || {
                        animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
                    }
                }
            ]
        })));
    const CircularProgress = reactExports.forwardRef(function CircularProgress2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiCircularProgress"
        });
        const { className, color = "primary", disableShrink = false, size = 40, style, thickness = 3.6, value = 0, variant = "indeterminate", ...other } = props;
        const ownerState = {
            ...props,
            color,
            disableShrink,
            size,
            thickness,
            value,
            variant
        };
        const classes = useUtilityClasses$x(ownerState);
        const circleStyle = {};
        const rootStyle = {};
        const rootProps = {};
        if (variant === "determinate") {
            const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
            circleStyle.strokeDasharray = circumference.toFixed(3);
            rootProps["aria-valuenow"] = Math.round(value);
            circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
            rootStyle.transform = "rotate(-90deg)";
        }
        return jsxRuntimeExports.jsx(CircularProgressRoot, {
            className: clsx(classes.root, className),
            style: {
                width: size,
                height: size,
                ...rootStyle,
                ...style
            },
            ownerState,
            ref,
            role: "progressbar",
            ...rootProps,
            ...other,
            children: jsxRuntimeExports.jsx(CircularProgressSVG, {
                className: classes.svg,
                ownerState,
                viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
                children: jsxRuntimeExports.jsx(CircularProgressCircle, {
                    className: classes.circle,
                    style: circleStyle,
                    ownerState,
                    cx: SIZE,
                    cy: SIZE,
                    r: (SIZE - thickness) / 2,
                    fill: "none",
                    strokeWidth: thickness
                })
            })
        });
    });
    function getIconButtonUtilityClass(slot) {
        return generateUtilityClass('MuiIconButton', slot);
    }
    const iconButtonClasses = generateUtilityClasses('MuiIconButton', [
        'root',
        'disabled',
        'colorInherit',
        'colorPrimary',
        'colorSecondary',
        'colorError',
        'colorInfo',
        'colorSuccess',
        'colorWarning',
        'edgeStart',
        'edgeEnd',
        'sizeSmall',
        'sizeMedium',
        'sizeLarge',
        'loading',
        'loadingIndicator',
        'loadingWrapper'
    ]);
    const useUtilityClasses$w = (ownerState)=>{
        const { classes, disabled, color, edge, size, loading } = ownerState;
        const slots = {
            root: [
                "root",
                loading && "loading",
                disabled && "disabled",
                color !== "default" && `color${capitalize(color)}`,
                edge && `edge${capitalize(edge)}`,
                `size${capitalize(size)}`
            ],
            loadingIndicator: [
                "loadingIndicator"
            ],
            loadingWrapper: [
                "loadingWrapper"
            ]
        };
        return composeClasses(slots, getIconButtonUtilityClass, classes);
    };
    const IconButtonRoot = styled(ButtonBase, {
        name: "MuiIconButton",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.loading && styles.loading,
                ownerState.color !== "default" && styles[`color${capitalize(ownerState.color)}`],
                ownerState.edge && styles[`edge${capitalize(ownerState.edge)}`],
                styles[`size${capitalize(ownerState.size)}`]
            ];
        }
    })(memoTheme(({ theme })=>({
            textAlign: "center",
            flex: "0 0 auto",
            fontSize: theme.typography.pxToRem(24),
            padding: 8,
            borderRadius: "50%",
            color: (theme.vars || theme).palette.action.active,
            transition: theme.transitions.create("background-color", {
                duration: theme.transitions.duration.shortest
            }),
            variants: [
                {
                    props: (props)=>!props.disableRipple,
                    style: {
                        "--IconButton-hoverBg": theme.alpha((theme.vars || theme).palette.action.active, (theme.vars || theme).palette.action.hoverOpacity),
                        "&:hover": {
                            backgroundColor: "var(--IconButton-hoverBg)",
                            "@media (hover: none)": {
                                backgroundColor: "transparent"
                            }
                        }
                    }
                },
                {
                    props: {
                        edge: "start"
                    },
                    style: {
                        marginLeft: -12
                    }
                },
                {
                    props: {
                        edge: "start",
                        size: "small"
                    },
                    style: {
                        marginLeft: -3
                    }
                },
                {
                    props: {
                        edge: "end"
                    },
                    style: {
                        marginRight: -12
                    }
                },
                {
                    props: {
                        edge: "end",
                        size: "small"
                    },
                    style: {
                        marginRight: -3
                    }
                }
            ]
        })), memoTheme(({ theme })=>({
            variants: [
                {
                    props: {
                        color: "inherit"
                    },
                    style: {
                        color: "inherit"
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            color: (theme.vars || theme).palette[color].main
                        }
                    })),
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            "--IconButton-hoverBg": theme.alpha((theme.vars || theme).palette[color].main, (theme.vars || theme).palette.action.hoverOpacity)
                        }
                    })),
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        padding: 5,
                        fontSize: theme.typography.pxToRem(18)
                    }
                },
                {
                    props: {
                        size: "large"
                    },
                    style: {
                        padding: 12,
                        fontSize: theme.typography.pxToRem(28)
                    }
                }
            ],
            [`&.${iconButtonClasses.disabled}`]: {
                backgroundColor: "transparent",
                color: (theme.vars || theme).palette.action.disabled
            },
            [`&.${iconButtonClasses.loading}`]: {
                color: "transparent"
            }
        })));
    const IconButtonLoadingIndicator = styled("span", {
        name: "MuiIconButton",
        slot: "LoadingIndicator"
    })(({ theme })=>({
            display: "none",
            position: "absolute",
            visibility: "visible",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            color: (theme.vars || theme).palette.action.disabled,
            variants: [
                {
                    props: {
                        loading: true
                    },
                    style: {
                        display: "flex"
                    }
                }
            ]
        }));
    const IconButton = reactExports.forwardRef(function IconButton2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiIconButton"
        });
        const { edge = false, children, className, color = "default", disabled = false, disableFocusRipple = false, size = "medium", id: idProp, loading = null, loadingIndicator: loadingIndicatorProp, ...other } = props;
        const loadingId = useId(idProp);
        const loadingIndicator = loadingIndicatorProp ?? jsxRuntimeExports.jsx(CircularProgress, {
            "aria-labelledby": loadingId,
            color: "inherit",
            size: 16
        });
        const ownerState = {
            ...props,
            edge,
            color,
            disabled,
            disableFocusRipple,
            loading,
            loadingIndicator,
            size
        };
        const classes = useUtilityClasses$w(ownerState);
        return jsxRuntimeExports.jsxs(IconButtonRoot, {
            id: loading ? loadingId : idProp,
            className: clsx(classes.root, className),
            centerRipple: true,
            focusRipple: !disableFocusRipple,
            disabled: disabled || loading,
            ref,
            ...other,
            ownerState,
            children: [
                typeof loading === "boolean" && jsxRuntimeExports.jsx("span", {
                    className: classes.loadingWrapper,
                    style: {
                        display: "contents"
                    },
                    children: jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
                        className: classes.loadingIndicator,
                        ownerState,
                        children: loading && loadingIndicator
                    })
                }),
                children
            ]
        });
    });
    const SuccessOutlinedIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
    }));
    const ReportProblemOutlinedIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
    }));
    const ErrorOutlineIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
    }));
    const InfoOutlinedIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
    }));
    const ClearIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
    }));
    const useUtilityClasses$v = (ownerState)=>{
        const { variant, color, severity, classes } = ownerState;
        const slots = {
            root: [
                "root",
                `color${capitalize(color || severity)}`,
                `${variant}${capitalize(color || severity)}`,
                `${variant}`
            ],
            icon: [
                "icon"
            ],
            message: [
                "message"
            ],
            action: [
                "action"
            ]
        };
        return composeClasses(slots, getAlertUtilityClass, classes);
    };
    const AlertRoot = styled(Paper, {
        name: "MuiAlert",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[ownerState.variant],
                styles[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]
            ];
        }
    })(memoTheme(({ theme })=>{
        const getColor = theme.palette.mode === "light" ? theme.darken : theme.lighten;
        const getBackgroundColor = theme.palette.mode === "light" ? theme.lighten : theme.darken;
        return {
            ...theme.typography.body2,
            backgroundColor: "transparent",
            display: "flex",
            padding: "6px 16px",
            variants: [
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "light"
                ])).map(([color])=>({
                        props: {
                            colorSeverity: color,
                            variant: "standard"
                        },
                        style: {
                            color: theme.vars ? theme.vars.palette.Alert[`${color}Color`] : getColor(theme.palette[color].light, 0.6),
                            backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color}StandardBg`] : getBackgroundColor(theme.palette[color].light, 0.9),
                            [`& .${alertClasses.icon}`]: theme.vars ? {
                                color: theme.vars.palette.Alert[`${color}IconColor`]
                            } : {
                                color: theme.palette[color].main
                            }
                        }
                    })),
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "light"
                ])).map(([color])=>({
                        props: {
                            colorSeverity: color,
                            variant: "outlined"
                        },
                        style: {
                            color: theme.vars ? theme.vars.palette.Alert[`${color}Color`] : getColor(theme.palette[color].light, 0.6),
                            border: `1px solid ${(theme.vars || theme).palette[color].light}`,
                            [`& .${alertClasses.icon}`]: theme.vars ? {
                                color: theme.vars.palette.Alert[`${color}IconColor`]
                            } : {
                                color: theme.palette[color].main
                            }
                        }
                    })),
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "dark"
                ])).map(([color])=>({
                        props: {
                            colorSeverity: color,
                            variant: "filled"
                        },
                        style: {
                            fontWeight: theme.typography.fontWeightMedium,
                            ...theme.vars ? {
                                color: theme.vars.palette.Alert[`${color}FilledColor`],
                                backgroundColor: theme.vars.palette.Alert[`${color}FilledBg`]
                            } : {
                                backgroundColor: theme.palette.mode === "dark" ? theme.palette[color].dark : theme.palette[color].main,
                                color: theme.palette.getContrastText(theme.palette[color].main)
                            }
                        }
                    }))
            ]
        };
    }));
    const AlertIcon = styled("div", {
        name: "MuiAlert",
        slot: "Icon"
    })({
        marginRight: 12,
        padding: "7px 0",
        display: "flex",
        fontSize: 22,
        opacity: 0.9
    });
    const AlertMessage = styled("div", {
        name: "MuiAlert",
        slot: "Message"
    })({
        padding: "8px 0",
        minWidth: 0,
        overflow: "auto"
    });
    const AlertAction = styled("div", {
        name: "MuiAlert",
        slot: "Action"
    })({
        display: "flex",
        alignItems: "flex-start",
        padding: "4px 0 0 16px",
        marginLeft: "auto",
        marginRight: -8
    });
    const defaultIconMapping = {
        success: jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
            fontSize: "inherit"
        }),
        warning: jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
            fontSize: "inherit"
        }),
        error: jsxRuntimeExports.jsx(ErrorOutlineIcon, {
            fontSize: "inherit"
        }),
        info: jsxRuntimeExports.jsx(InfoOutlinedIcon, {
            fontSize: "inherit"
        })
    };
    const Alert = reactExports.forwardRef(function Alert2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiAlert"
        });
        const { action, children, className, closeText = "Close", color, components = {}, componentsProps = {}, icon, iconMapping = defaultIconMapping, onClose, role = "alert", severity = "success", slotProps = {}, slots = {}, variant = "standard", ...other } = props;
        const ownerState = {
            ...props,
            color,
            severity,
            variant,
            colorSeverity: color || severity
        };
        const classes = useUtilityClasses$v(ownerState);
        const externalForwardedProps = {
            slots: {
                closeButton: components.CloseButton,
                closeIcon: components.CloseIcon,
                ...slots
            },
            slotProps: {
                ...componentsProps,
                ...slotProps
            }
        };
        const [RootSlot, rootSlotProps] = useSlot("root", {
            ref,
            shouldForwardComponentProp: true,
            className: clsx(classes.root, className),
            elementType: AlertRoot,
            externalForwardedProps: {
                ...externalForwardedProps,
                ...other
            },
            ownerState,
            additionalProps: {
                role,
                elevation: 0
            }
        });
        const [IconSlot, iconSlotProps] = useSlot("icon", {
            className: classes.icon,
            elementType: AlertIcon,
            externalForwardedProps,
            ownerState
        });
        const [MessageSlot, messageSlotProps] = useSlot("message", {
            className: classes.message,
            elementType: AlertMessage,
            externalForwardedProps,
            ownerState
        });
        const [ActionSlot, actionSlotProps] = useSlot("action", {
            className: classes.action,
            elementType: AlertAction,
            externalForwardedProps,
            ownerState
        });
        const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
            elementType: IconButton,
            externalForwardedProps,
            ownerState
        });
        const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
            elementType: ClearIcon,
            externalForwardedProps,
            ownerState
        });
        return jsxRuntimeExports.jsxs(RootSlot, {
            ...rootSlotProps,
            children: [
                icon !== false ? jsxRuntimeExports.jsx(IconSlot, {
                    ...iconSlotProps,
                    children: icon || iconMapping[severity] || defaultIconMapping[severity]
                }) : null,
                jsxRuntimeExports.jsx(MessageSlot, {
                    ...messageSlotProps,
                    children
                }),
                action != null ? jsxRuntimeExports.jsx(ActionSlot, {
                    ...actionSlotProps,
                    children: action
                }) : null,
                action == null && onClose ? jsxRuntimeExports.jsx(ActionSlot, {
                    ...actionSlotProps,
                    children: jsxRuntimeExports.jsx(CloseButtonSlot, {
                        size: "small",
                        "aria-label": closeText,
                        title: closeText,
                        color: "inherit",
                        onClick: onClose,
                        ...closeButtonProps,
                        children: jsxRuntimeExports.jsx(CloseIconSlot, {
                            fontSize: "small",
                            ...closeIconProps
                        })
                    })
                }) : null
            ]
        });
    });
    function getTypographyUtilityClass(slot) {
        return generateUtilityClass('MuiTypography', slot);
    }
    generateUtilityClasses('MuiTypography', [
        'root',
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6',
        'subtitle1',
        'subtitle2',
        'body1',
        'body2',
        'inherit',
        'button',
        'caption',
        'overline',
        'alignLeft',
        'alignRight',
        'alignCenter',
        'alignJustify',
        'noWrap',
        'gutterBottom',
        'paragraph'
    ]);
    const v6Colors = {
        primary: true,
        secondary: true,
        error: true,
        info: true,
        success: true,
        warning: true,
        textPrimary: true,
        textSecondary: true,
        textDisabled: true
    };
    const extendSxProp = internal_createExtendSxProp();
    const useUtilityClasses$u = (ownerState)=>{
        const { align, gutterBottom, noWrap, paragraph, variant, classes } = ownerState;
        const slots = {
            root: [
                "root",
                variant,
                ownerState.align !== "inherit" && `align${capitalize(align)}`,
                gutterBottom && "gutterBottom",
                noWrap && "noWrap",
                paragraph && "paragraph"
            ]
        };
        return composeClasses(slots, getTypographyUtilityClass, classes);
    };
    const TypographyRoot = styled("span", {
        name: "MuiTypography",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.variant && styles[ownerState.variant],
                ownerState.align !== "inherit" && styles[`align${capitalize(ownerState.align)}`],
                ownerState.noWrap && styles.noWrap,
                ownerState.gutterBottom && styles.gutterBottom,
                ownerState.paragraph && styles.paragraph
            ];
        }
    })(memoTheme(({ theme })=>({
            margin: 0,
            variants: [
                {
                    props: {
                        variant: "inherit"
                    },
                    style: {
                        font: "inherit",
                        lineHeight: "inherit",
                        letterSpacing: "inherit"
                    }
                },
                ...Object.entries(theme.typography).filter(([variant, value])=>variant !== "inherit" && value && typeof value === "object").map(([variant, value])=>({
                        props: {
                            variant
                        },
                        style: value
                    })),
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            color: (theme.vars || theme).palette[color].main
                        }
                    })),
                ...Object.entries(theme.palette?.text || {}).filter(([, value])=>typeof value === "string").map(([color])=>({
                        props: {
                            color: `text${capitalize(color)}`
                        },
                        style: {
                            color: (theme.vars || theme).palette.text[color]
                        }
                    })),
                {
                    props: ({ ownerState })=>ownerState.align !== "inherit",
                    style: {
                        textAlign: "var(--Typography-textAlign)"
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.noWrap,
                    style: {
                        overflow: "hidden",
                        textOverflow: "ellipsis",
                        whiteSpace: "nowrap"
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.gutterBottom,
                    style: {
                        marginBottom: "0.35em"
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.paragraph,
                    style: {
                        marginBottom: 16
                    }
                }
            ]
        })));
    const defaultVariantMapping = {
        h1: "h1",
        h2: "h2",
        h3: "h3",
        h4: "h4",
        h5: "h5",
        h6: "h6",
        subtitle1: "h6",
        subtitle2: "h6",
        body1: "p",
        body2: "p",
        inherit: "p"
    };
    const Typography = reactExports.forwardRef(function Typography2(inProps, ref) {
        const { color, ...themeProps } = useDefaultProps({
            props: inProps,
            name: "MuiTypography"
        });
        const isSxColor = !v6Colors[color];
        const props = extendSxProp({
            ...themeProps,
            ...isSxColor && {
                color
            }
        });
        const { align = "inherit", className, component, gutterBottom = false, noWrap = false, paragraph = false, variant = "body1", variantMapping = defaultVariantMapping, ...other } = props;
        const ownerState = {
            ...props,
            align,
            color,
            className,
            component,
            gutterBottom,
            noWrap,
            paragraph,
            variant,
            variantMapping
        };
        const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
        const classes = useUtilityClasses$u(ownerState);
        return jsxRuntimeExports.jsx(TypographyRoot, {
            as: Component,
            ref,
            className: clsx(classes.root, className),
            ...other,
            ownerState,
            style: {
                ...align !== "inherit" && {
                    "--Typography-textAlign": align
                },
                ...other.style
            }
        });
    });
    function getAppBarUtilityClass(slot) {
        return generateUtilityClass('MuiAppBar', slot);
    }
    generateUtilityClasses('MuiAppBar', [
        'root',
        'positionFixed',
        'positionAbsolute',
        'positionSticky',
        'positionStatic',
        'positionRelative',
        'colorDefault',
        'colorPrimary',
        'colorSecondary',
        'colorInherit',
        'colorTransparent',
        'colorError',
        'colorInfo',
        'colorSuccess',
        'colorWarning'
    ]);
    const useUtilityClasses$t = (ownerState)=>{
        const { color, position, classes } = ownerState;
        const slots = {
            root: [
                "root",
                `color${capitalize(color)}`,
                `position${capitalize(position)}`
            ]
        };
        return composeClasses(slots, getAppBarUtilityClass, classes);
    };
    const joinVars = (var1, var2)=>var1 ? `${var1?.replace(")", "")}, ${var2})` : var2;
    const AppBarRoot = styled(Paper, {
        name: "MuiAppBar",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[`position${capitalize(ownerState.position)}`],
                styles[`color${capitalize(ownerState.color)}`]
            ];
        }
    })(memoTheme(({ theme })=>({
            display: "flex",
            flexDirection: "column",
            width: "100%",
            boxSizing: "border-box",
            flexShrink: 0,
            variants: [
                {
                    props: {
                        position: "fixed"
                    },
                    style: {
                        position: "fixed",
                        zIndex: (theme.vars || theme).zIndex.appBar,
                        top: 0,
                        left: "auto",
                        right: 0,
                        "@media print": {
                            position: "absolute"
                        }
                    }
                },
                {
                    props: {
                        position: "absolute"
                    },
                    style: {
                        position: "absolute",
                        zIndex: (theme.vars || theme).zIndex.appBar,
                        top: 0,
                        left: "auto",
                        right: 0
                    }
                },
                {
                    props: {
                        position: "sticky"
                    },
                    style: {
                        position: "sticky",
                        zIndex: (theme.vars || theme).zIndex.appBar,
                        top: 0,
                        left: "auto",
                        right: 0
                    }
                },
                {
                    props: {
                        position: "static"
                    },
                    style: {
                        position: "static"
                    }
                },
                {
                    props: {
                        position: "relative"
                    },
                    style: {
                        position: "relative"
                    }
                },
                {
                    props: {
                        color: "inherit"
                    },
                    style: {
                        "--AppBar-color": "inherit"
                    }
                },
                {
                    props: {
                        color: "default"
                    },
                    style: {
                        "--AppBar-background": theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[100],
                        "--AppBar-color": theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[100]),
                        ...theme.applyStyles("dark", {
                            "--AppBar-background": theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[900],
                            "--AppBar-color": theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[900])
                        })
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "contrastText"
                ])).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            "--AppBar-background": (theme.vars ?? theme).palette[color].main,
                            "--AppBar-color": (theme.vars ?? theme).palette[color].contrastText
                        }
                    })),
                {
                    props: (props)=>props.enableColorOnDark === true && ![
                            "inherit",
                            "transparent"
                        ].includes(props.color),
                    style: {
                        backgroundColor: "var(--AppBar-background)",
                        color: "var(--AppBar-color)"
                    }
                },
                {
                    props: (props)=>props.enableColorOnDark === false && ![
                            "inherit",
                            "transparent"
                        ].includes(props.color),
                    style: {
                        backgroundColor: "var(--AppBar-background)",
                        color: "var(--AppBar-color)",
                        ...theme.applyStyles("dark", {
                            backgroundColor: theme.vars ? joinVars(theme.vars.palette.AppBar.darkBg, "var(--AppBar-background)") : null,
                            color: theme.vars ? joinVars(theme.vars.palette.AppBar.darkColor, "var(--AppBar-color)") : null
                        })
                    }
                },
                {
                    props: {
                        color: "transparent"
                    },
                    style: {
                        "--AppBar-background": "transparent",
                        "--AppBar-color": "inherit",
                        backgroundColor: "var(--AppBar-background)",
                        color: "var(--AppBar-color)",
                        ...theme.applyStyles("dark", {
                            backgroundImage: "none"
                        })
                    }
                }
            ]
        })));
    const AppBar = reactExports.forwardRef(function AppBar2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiAppBar"
        });
        const { className, color = "primary", enableColorOnDark = false, position = "fixed", ...other } = props;
        const ownerState = {
            ...props,
            color,
            position,
            enableColorOnDark
        };
        const classes = useUtilityClasses$t(ownerState);
        return jsxRuntimeExports.jsx(AppBarRoot, {
            square: true,
            component: "header",
            ownerState,
            elevation: 4,
            className: clsx(classes.root, className, position === "fixed" && "mui-fixed"),
            ref,
            ...other
        });
    });
    function useSlotProps(parameters) {
        const { elementType, externalSlotProps, ownerState, skipResolvingSlotProps = false, ...other } = parameters;
        const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
        const { props: mergedProps, internalRef } = mergeSlotProps({
            ...other,
            externalSlotProps: resolvedComponentsProps
        });
        const ref = useForkRef(internalRef, resolvedComponentsProps?.ref, parameters.additionalProps?.ref);
        const props = appendOwnerState(elementType, {
            ...mergedProps,
            ref
        }, ownerState);
        return props;
    }
    function getReactElementRef(element) {
        if (parseInt(reactExports.version, 10) >= 19) {
            return element?.props?.ref || null;
        }
        return element?.ref || null;
    }
    function getContainer$1(container) {
        return typeof container === "function" ? container() : container;
    }
    const Portal = reactExports.forwardRef(function Portal2(props, forwardedRef) {
        const { children, container, disablePortal = false } = props;
        const [mountNode, setMountNode] = reactExports.useState(null);
        const handleRef = useForkRef(reactExports.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
        useEnhancedEffect(()=>{
            if (!disablePortal) {
                setMountNode(getContainer$1(container) || document.body);
            }
        }, [
            container,
            disablePortal
        ]);
        useEnhancedEffect(()=>{
            if (mountNode && !disablePortal) {
                setRef(forwardedRef, mountNode);
                return ()=>{
                    setRef(forwardedRef, null);
                };
            }
            return void 0;
        }, [
            forwardedRef,
            mountNode,
            disablePortal
        ]);
        if (disablePortal) {
            if (reactExports.isValidElement(children)) {
                const newProps = {
                    ref: handleRef
                };
                return reactExports.cloneElement(children, newProps);
            }
            return children;
        }
        return mountNode ? reactDomExports.createPortal(children, mountNode) : mountNode;
    });
    const CancelIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
    }));
    function getChipUtilityClass(slot) {
        return generateUtilityClass('MuiChip', slot);
    }
    const chipClasses = generateUtilityClasses('MuiChip', [
        'root',
        'sizeSmall',
        'sizeMedium',
        'colorDefault',
        'colorError',
        'colorInfo',
        'colorPrimary',
        'colorSecondary',
        'colorSuccess',
        'colorWarning',
        'disabled',
        'clickable',
        'clickableColorPrimary',
        'clickableColorSecondary',
        'deletable',
        'deletableColorPrimary',
        'deletableColorSecondary',
        'outlined',
        'filled',
        'outlinedPrimary',
        'outlinedSecondary',
        'filledPrimary',
        'filledSecondary',
        'avatar',
        'avatarSmall',
        'avatarMedium',
        'avatarColorPrimary',
        'avatarColorSecondary',
        'icon',
        'iconSmall',
        'iconMedium',
        'iconColorPrimary',
        'iconColorSecondary',
        'label',
        'labelSmall',
        'labelMedium',
        'deleteIcon',
        'deleteIconSmall',
        'deleteIconMedium',
        'deleteIconColorPrimary',
        'deleteIconColorSecondary',
        'deleteIconOutlinedColorPrimary',
        'deleteIconOutlinedColorSecondary',
        'deleteIconFilledColorPrimary',
        'deleteIconFilledColorSecondary',
        'focusVisible'
    ]);
    const useUtilityClasses$s = (ownerState)=>{
        const { classes, disabled, size, color, iconColor, onDelete, clickable, variant } = ownerState;
        const slots = {
            root: [
                "root",
                variant,
                disabled && "disabled",
                `size${capitalize(size)}`,
                `color${capitalize(color)}`,
                clickable && "clickable",
                clickable && `clickableColor${capitalize(color)}`,
                onDelete && "deletable",
                onDelete && `deletableColor${capitalize(color)}`,
                `${variant}${capitalize(color)}`
            ],
            label: [
                "label",
                `label${capitalize(size)}`
            ],
            avatar: [
                "avatar",
                `avatar${capitalize(size)}`,
                `avatarColor${capitalize(color)}`
            ],
            icon: [
                "icon",
                `icon${capitalize(size)}`,
                `iconColor${capitalize(iconColor)}`
            ],
            deleteIcon: [
                "deleteIcon",
                `deleteIcon${capitalize(size)}`,
                `deleteIconColor${capitalize(color)}`,
                `deleteIcon${capitalize(variant)}Color${capitalize(color)}`
            ]
        };
        return composeClasses(slots, getChipUtilityClass, classes);
    };
    const ChipRoot = styled("div", {
        name: "MuiChip",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            const { color, iconColor, clickable, onDelete, size, variant } = ownerState;
            return [
                {
                    [`& .${chipClasses.avatar}`]: styles.avatar
                },
                {
                    [`& .${chipClasses.avatar}`]: styles[`avatar${capitalize(size)}`]
                },
                {
                    [`& .${chipClasses.avatar}`]: styles[`avatarColor${capitalize(color)}`]
                },
                {
                    [`& .${chipClasses.icon}`]: styles.icon
                },
                {
                    [`& .${chipClasses.icon}`]: styles[`icon${capitalize(size)}`]
                },
                {
                    [`& .${chipClasses.icon}`]: styles[`iconColor${capitalize(iconColor)}`]
                },
                {
                    [`& .${chipClasses.deleteIcon}`]: styles.deleteIcon
                },
                {
                    [`& .${chipClasses.deleteIcon}`]: styles[`deleteIcon${capitalize(size)}`]
                },
                {
                    [`& .${chipClasses.deleteIcon}`]: styles[`deleteIconColor${capitalize(color)}`]
                },
                {
                    [`& .${chipClasses.deleteIcon}`]: styles[`deleteIcon${capitalize(variant)}Color${capitalize(color)}`]
                },
                styles.root,
                styles[`size${capitalize(size)}`],
                styles[`color${capitalize(color)}`],
                clickable && styles.clickable,
                clickable && color !== "default" && styles[`clickableColor${capitalize(color)})`],
                onDelete && styles.deletable,
                onDelete && color !== "default" && styles[`deletableColor${capitalize(color)}`],
                styles[variant],
                styles[`${variant}${capitalize(color)}`]
            ];
        }
    })(memoTheme(({ theme })=>{
        const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
        return {
            maxWidth: "100%",
            fontFamily: theme.typography.fontFamily,
            fontSize: theme.typography.pxToRem(13),
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            height: 32,
            lineHeight: 1.5,
            color: (theme.vars || theme).palette.text.primary,
            backgroundColor: (theme.vars || theme).palette.action.selected,
            borderRadius: 32 / 2,
            whiteSpace: "nowrap",
            transition: theme.transitions.create([
                "background-color",
                "box-shadow"
            ]),
            cursor: "unset",
            outline: 0,
            textDecoration: "none",
            border: 0,
            padding: 0,
            verticalAlign: "middle",
            boxSizing: "border-box",
            [`&.${chipClasses.disabled}`]: {
                opacity: (theme.vars || theme).palette.action.disabledOpacity,
                pointerEvents: "none"
            },
            [`& .${chipClasses.avatar}`]: {
                marginLeft: 5,
                marginRight: -6,
                width: 24,
                height: 24,
                color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
                fontSize: theme.typography.pxToRem(12)
            },
            [`& .${chipClasses.avatarColorPrimary}`]: {
                color: (theme.vars || theme).palette.primary.contrastText,
                backgroundColor: (theme.vars || theme).palette.primary.dark
            },
            [`& .${chipClasses.avatarColorSecondary}`]: {
                color: (theme.vars || theme).palette.secondary.contrastText,
                backgroundColor: (theme.vars || theme).palette.secondary.dark
            },
            [`& .${chipClasses.avatarSmall}`]: {
                marginLeft: 4,
                marginRight: -4,
                width: 18,
                height: 18,
                fontSize: theme.typography.pxToRem(10)
            },
            [`& .${chipClasses.icon}`]: {
                marginLeft: 5,
                marginRight: -6
            },
            [`& .${chipClasses.deleteIcon}`]: {
                WebkitTapHighlightColor: "transparent",
                color: theme.alpha((theme.vars || theme).palette.text.primary, 0.26),
                fontSize: 22,
                cursor: "pointer",
                margin: "0 5px 0 -6px",
                "&:hover": {
                    color: theme.alpha((theme.vars || theme).palette.text.primary, 0.4)
                }
            },
            variants: [
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        height: 24,
                        [`& .${chipClasses.icon}`]: {
                            fontSize: 18,
                            marginLeft: 4,
                            marginRight: -4
                        },
                        [`& .${chipClasses.deleteIcon}`]: {
                            fontSize: 16,
                            marginRight: 4,
                            marginLeft: -4
                        }
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "contrastText"
                ])).map(([color])=>{
                    return {
                        props: {
                            color
                        },
                        style: {
                            backgroundColor: (theme.vars || theme).palette[color].main,
                            color: (theme.vars || theme).palette[color].contrastText,
                            [`& .${chipClasses.deleteIcon}`]: {
                                color: theme.alpha((theme.vars || theme).palette[color].contrastText, 0.7),
                                "&:hover, &:active": {
                                    color: (theme.vars || theme).palette[color].contrastText
                                }
                            }
                        }
                    };
                }),
                {
                    props: (props)=>props.iconColor === props.color,
                    style: {
                        [`& .${chipClasses.icon}`]: {
                            color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
                        }
                    }
                },
                {
                    props: (props)=>props.iconColor === props.color && props.color !== "default",
                    style: {
                        [`& .${chipClasses.icon}`]: {
                            color: "inherit"
                        }
                    }
                },
                {
                    props: {
                        onDelete: true
                    },
                    style: {
                        [`&.${chipClasses.focusVisible}`]: {
                            backgroundColor: theme.alpha((theme.vars || theme).palette.action.selected, `${(theme.vars || theme).palette.action.selectedOpacity} + ${(theme.vars || theme).palette.action.focusOpacity}`)
                        }
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "dark"
                ])).map(([color])=>{
                    return {
                        props: {
                            color,
                            onDelete: true
                        },
                        style: {
                            [`&.${chipClasses.focusVisible}`]: {
                                background: (theme.vars || theme).palette[color].dark
                            }
                        }
                    };
                }),
                {
                    props: {
                        clickable: true
                    },
                    style: {
                        userSelect: "none",
                        WebkitTapHighlightColor: "transparent",
                        cursor: "pointer",
                        "&:hover": {
                            backgroundColor: theme.alpha((theme.vars || theme).palette.action.selected, `${(theme.vars || theme).palette.action.selectedOpacity} + ${(theme.vars || theme).palette.action.hoverOpacity}`)
                        },
                        [`&.${chipClasses.focusVisible}`]: {
                            backgroundColor: theme.alpha((theme.vars || theme).palette.action.selected, `${(theme.vars || theme).palette.action.selectedOpacity} + ${(theme.vars || theme).palette.action.focusOpacity}`)
                        },
                        "&:active": {
                            boxShadow: (theme.vars || theme).shadows[1]
                        }
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "dark"
                ])).map(([color])=>({
                        props: {
                            color,
                            clickable: true
                        },
                        style: {
                            [`&:hover, &.${chipClasses.focusVisible}`]: {
                                backgroundColor: (theme.vars || theme).palette[color].dark
                            }
                        }
                    })),
                {
                    props: {
                        variant: "outlined"
                    },
                    style: {
                        backgroundColor: "transparent",
                        border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
                        [`&.${chipClasses.clickable}:hover`]: {
                            backgroundColor: (theme.vars || theme).palette.action.hover
                        },
                        [`&.${chipClasses.focusVisible}`]: {
                            backgroundColor: (theme.vars || theme).palette.action.focus
                        },
                        [`& .${chipClasses.avatar}`]: {
                            marginLeft: 4
                        },
                        [`& .${chipClasses.avatarSmall}`]: {
                            marginLeft: 2
                        },
                        [`& .${chipClasses.icon}`]: {
                            marginLeft: 4
                        },
                        [`& .${chipClasses.iconSmall}`]: {
                            marginLeft: 2
                        },
                        [`& .${chipClasses.deleteIcon}`]: {
                            marginRight: 5
                        },
                        [`& .${chipClasses.deleteIconSmall}`]: {
                            marginRight: 3
                        }
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            variant: "outlined",
                            color
                        },
                        style: {
                            color: (theme.vars || theme).palette[color].main,
                            border: `1px solid ${theme.alpha((theme.vars || theme).palette[color].main, 0.7)}`,
                            [`&.${chipClasses.clickable}:hover`]: {
                                backgroundColor: theme.alpha((theme.vars || theme).palette[color].main, (theme.vars || theme).palette.action.hoverOpacity)
                            },
                            [`&.${chipClasses.focusVisible}`]: {
                                backgroundColor: theme.alpha((theme.vars || theme).palette[color].main, (theme.vars || theme).palette.action.focusOpacity)
                            },
                            [`& .${chipClasses.deleteIcon}`]: {
                                color: theme.alpha((theme.vars || theme).palette[color].main, 0.7),
                                "&:hover, &:active": {
                                    color: (theme.vars || theme).palette[color].main
                                }
                            }
                        }
                    }))
            ]
        };
    }));
    const ChipLabel = styled("span", {
        name: "MuiChip",
        slot: "Label",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            const { size } = ownerState;
            return [
                styles.label,
                styles[`label${capitalize(size)}`]
            ];
        }
    })({
        overflow: "hidden",
        textOverflow: "ellipsis",
        paddingLeft: 12,
        paddingRight: 12,
        whiteSpace: "nowrap",
        variants: [
            {
                props: {
                    variant: "outlined"
                },
                style: {
                    paddingLeft: 11,
                    paddingRight: 11
                }
            },
            {
                props: {
                    size: "small"
                },
                style: {
                    paddingLeft: 8,
                    paddingRight: 8
                }
            },
            {
                props: {
                    size: "small",
                    variant: "outlined"
                },
                style: {
                    paddingLeft: 7,
                    paddingRight: 7
                }
            }
        ]
    });
    function isDeleteKeyboardEvent(keyboardEvent) {
        return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
    }
    const Chip = reactExports.forwardRef(function Chip2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiChip"
        });
        const { avatar: avatarProp, className, clickable: clickableProp, color = "default", component: ComponentProp, deleteIcon: deleteIconProp, disabled = false, icon: iconProp, label, onClick, onDelete, onKeyDown, onKeyUp, size = "medium", variant = "filled", tabIndex, skipFocusWhenDisabled = false, slots = {}, slotProps = {}, ...other } = props;
        const chipRef = reactExports.useRef(null);
        const handleRef = useForkRef(chipRef, ref);
        const handleDeleteIconClick = (event)=>{
            event.stopPropagation();
            if (onDelete) {
                onDelete(event);
            }
        };
        const handleKeyDown = (event)=>{
            if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
                event.preventDefault();
            }
            if (onKeyDown) {
                onKeyDown(event);
            }
        };
        const handleKeyUp = (event)=>{
            if (event.currentTarget === event.target) {
                if (onDelete && isDeleteKeyboardEvent(event)) {
                    onDelete(event);
                }
            }
            if (onKeyUp) {
                onKeyUp(event);
            }
        };
        const clickable = clickableProp !== false && onClick ? true : clickableProp;
        const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
        const ownerState = {
            ...props,
            component,
            disabled,
            size,
            color,
            iconColor: reactExports.isValidElement(iconProp) ? iconProp.props.color || color : color,
            onDelete: !!onDelete,
            clickable,
            variant
        };
        const classes = useUtilityClasses$s(ownerState);
        const moreProps = component === ButtonBase ? {
            component: ComponentProp || "div",
            focusVisibleClassName: classes.focusVisible,
            ...onDelete && {
                disableRipple: true
            }
        } : {};
        let deleteIcon = null;
        if (onDelete) {
            deleteIcon = deleteIconProp && reactExports.isValidElement(deleteIconProp) ? reactExports.cloneElement(deleteIconProp, {
                className: clsx(deleteIconProp.props.className, classes.deleteIcon),
                onClick: handleDeleteIconClick
            }) : jsxRuntimeExports.jsx(CancelIcon, {
                className: classes.deleteIcon,
                onClick: handleDeleteIconClick
            });
        }
        let avatar = null;
        if (avatarProp && reactExports.isValidElement(avatarProp)) {
            avatar = reactExports.cloneElement(avatarProp, {
                className: clsx(classes.avatar, avatarProp.props.className)
            });
        }
        let icon = null;
        if (iconProp && reactExports.isValidElement(iconProp)) {
            icon = reactExports.cloneElement(iconProp, {
                className: clsx(classes.icon, iconProp.props.className)
            });
        }
        const externalForwardedProps = {
            slots,
            slotProps
        };
        const [RootSlot, rootProps] = useSlot("root", {
            elementType: ChipRoot,
            externalForwardedProps: {
                ...externalForwardedProps,
                ...other
            },
            ownerState,
            shouldForwardComponentProp: true,
            ref: handleRef,
            className: clsx(classes.root, className),
            additionalProps: {
                disabled: clickable && disabled ? true : void 0,
                tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
                ...moreProps
            },
            getSlotProps: (handlers)=>({
                    ...handlers,
                    onClick: (event)=>{
                        handlers.onClick?.(event);
                        onClick?.(event);
                    },
                    onKeyDown: (event)=>{
                        handlers.onKeyDown?.(event);
                        handleKeyDown?.(event);
                    },
                    onKeyUp: (event)=>{
                        handlers.onKeyUp?.(event);
                        handleKeyUp?.(event);
                    }
                })
        });
        const [LabelSlot, labelProps] = useSlot("label", {
            elementType: ChipLabel,
            externalForwardedProps,
            ownerState,
            className: classes.label
        });
        return jsxRuntimeExports.jsxs(RootSlot, {
            as: component,
            ...rootProps,
            children: [
                avatar || icon,
                jsxRuntimeExports.jsx(LabelSlot, {
                    ...labelProps,
                    children: label
                }),
                deleteIcon
            ]
        });
    });
    function getStyleValue(value) {
        return parseInt(value, 10) || 0;
    }
    const styles$3 = {
        shadow: {
            visibility: "hidden",
            position: "absolute",
            overflow: "hidden",
            height: 0,
            top: 0,
            left: 0,
            transform: "translateZ(0)"
        }
    };
    function isObjectEmpty(object) {
        for(const _ in object){
            return false;
        }
        return true;
    }
    function isEmpty$2(obj) {
        return isObjectEmpty(obj) || obj.outerHeightStyle === 0 && !obj.overflowing;
    }
    const TextareaAutosize = reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
        const { onChange, maxRows, minRows = 1, style, value, ...other } = props;
        const { current: isControlled } = reactExports.useRef(value != null);
        const textareaRef = reactExports.useRef(null);
        const handleRef = useForkRef(forwardedRef, textareaRef);
        const heightRef = reactExports.useRef(null);
        const hiddenTextareaRef = reactExports.useRef(null);
        const calculateTextareaStyles = reactExports.useCallback(()=>{
            const textarea = textareaRef.current;
            const hiddenTextarea = hiddenTextareaRef.current;
            if (!textarea || !hiddenTextarea) {
                return void 0;
            }
            const containerWindow = ownerWindow(textarea);
            const computedStyle = containerWindow.getComputedStyle(textarea);
            if (computedStyle.width === "0px") {
                return {
                    outerHeightStyle: 0,
                    overflowing: false
                };
            }
            hiddenTextarea.style.width = computedStyle.width;
            hiddenTextarea.value = textarea.value || props.placeholder || "x";
            if (hiddenTextarea.value.slice(-1) === "\n") {
                hiddenTextarea.value += " ";
            }
            const boxSizing = computedStyle.boxSizing;
            const padding = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
            const border = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
            const innerHeight = hiddenTextarea.scrollHeight;
            hiddenTextarea.value = "x";
            const singleRowHeight = hiddenTextarea.scrollHeight;
            let outerHeight = innerHeight;
            if (minRows) {
                outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
            }
            if (maxRows) {
                outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
            }
            outerHeight = Math.max(outerHeight, singleRowHeight);
            const outerHeightStyle = outerHeight + (boxSizing === "border-box" ? padding + border : 0);
            const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
            return {
                outerHeightStyle,
                overflowing
            };
        }, [
            maxRows,
            minRows,
            props.placeholder
        ]);
        const didHeightChange = useEventCallback(()=>{
            const textarea = textareaRef.current;
            const textareaStyles = calculateTextareaStyles();
            if (!textarea || !textareaStyles || isEmpty$2(textareaStyles)) {
                return false;
            }
            const outerHeightStyle = textareaStyles.outerHeightStyle;
            return heightRef.current != null && heightRef.current !== outerHeightStyle;
        });
        const syncHeight = reactExports.useCallback(()=>{
            const textarea = textareaRef.current;
            const textareaStyles = calculateTextareaStyles();
            if (!textarea || !textareaStyles || isEmpty$2(textareaStyles)) {
                return;
            }
            const outerHeightStyle = textareaStyles.outerHeightStyle;
            if (heightRef.current !== outerHeightStyle) {
                heightRef.current = outerHeightStyle;
                textarea.style.height = `${outerHeightStyle}px`;
            }
            textarea.style.overflow = textareaStyles.overflowing ? "hidden" : "";
        }, [
            calculateTextareaStyles
        ]);
        const frameRef = reactExports.useRef(-1);
        useEnhancedEffect(()=>{
            const debouncedHandleResize = debounce(syncHeight);
            const textarea = textareaRef?.current;
            if (!textarea) {
                return void 0;
            }
            const containerWindow = ownerWindow(textarea);
            containerWindow.addEventListener("resize", debouncedHandleResize);
            let resizeObserver;
            if (typeof ResizeObserver !== "undefined") {
                resizeObserver = new ResizeObserver(()=>{
                    if (didHeightChange()) {
                        resizeObserver.unobserve(textarea);
                        cancelAnimationFrame(frameRef.current);
                        syncHeight();
                        frameRef.current = requestAnimationFrame(()=>{
                            resizeObserver.observe(textarea);
                        });
                    }
                });
                resizeObserver.observe(textarea);
            }
            return ()=>{
                debouncedHandleResize.clear();
                cancelAnimationFrame(frameRef.current);
                containerWindow.removeEventListener("resize", debouncedHandleResize);
                if (resizeObserver) {
                    resizeObserver.disconnect();
                }
            };
        }, [
            calculateTextareaStyles,
            syncHeight,
            didHeightChange
        ]);
        useEnhancedEffect(()=>{
            syncHeight();
        });
        const handleChange = (event)=>{
            if (!isControlled) {
                syncHeight();
            }
            const textarea = event.target;
            const countOfCharacters = textarea.value.length;
            const isLastCharacterNewLine = textarea.value.endsWith("\n");
            const isEndOfTheLine = textarea.selectionStart === countOfCharacters;
            if (isLastCharacterNewLine && isEndOfTheLine) {
                textarea.setSelectionRange(countOfCharacters, countOfCharacters);
            }
            if (onChange) {
                onChange(event);
            }
        };
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx("textarea", {
                    value,
                    onChange: handleChange,
                    ref: handleRef,
                    rows: minRows,
                    style,
                    ...other
                }),
                jsxRuntimeExports.jsx("textarea", {
                    "aria-hidden": true,
                    className: props.className,
                    readOnly: true,
                    ref: hiddenTextareaRef,
                    tabIndex: -1,
                    style: {
                        ...styles$3.shadow,
                        ...style,
                        paddingTop: 0,
                        paddingBottom: 0
                    }
                })
            ]
        });
    });
    function isHostComponent(element) {
        return typeof element === 'string';
    }
    function formControlState({ props, states, muiFormControl }) {
        return states.reduce((acc, state)=>{
            acc[state] = props[state];
            if (muiFormControl) {
                if (typeof props[state] === 'undefined') {
                    acc[state] = muiFormControl[state];
                }
            }
            return acc;
        }, {});
    }
    const FormControlContext = reactExports.createContext(void 0);
    function useFormControl() {
        return reactExports.useContext(FormControlContext);
    }
    function hasValue(value) {
        return value != null && !(Array.isArray(value) && value.length === 0);
    }
    function isFilled(obj, SSR = false) {
        return obj && (hasValue(obj.value) && obj.value !== '' || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== '');
    }
    function isAdornedStart(obj) {
        return obj.startAdornment;
    }
    function getInputBaseUtilityClass(slot) {
        return generateUtilityClass('MuiInputBase', slot);
    }
    const inputBaseClasses = generateUtilityClasses('MuiInputBase', [
        'root',
        'formControl',
        'focused',
        'disabled',
        'adornedStart',
        'adornedEnd',
        'error',
        'sizeSmall',
        'multiline',
        'colorSecondary',
        'fullWidth',
        'hiddenLabel',
        'readOnly',
        'input',
        'inputSizeSmall',
        'inputMultiline',
        'inputTypeSearch',
        'inputAdornedStart',
        'inputAdornedEnd',
        'inputHiddenLabel'
    ]);
    var _InputGlobalStyles;
    const rootOverridesResolver = (props, styles)=>{
        const { ownerState } = props;
        return [
            styles.root,
            ownerState.formControl && styles.formControl,
            ownerState.startAdornment && styles.adornedStart,
            ownerState.endAdornment && styles.adornedEnd,
            ownerState.error && styles.error,
            ownerState.size === "small" && styles.sizeSmall,
            ownerState.multiline && styles.multiline,
            ownerState.color && styles[`color${capitalize(ownerState.color)}`],
            ownerState.fullWidth && styles.fullWidth,
            ownerState.hiddenLabel && styles.hiddenLabel
        ];
    };
    const inputOverridesResolver = (props, styles)=>{
        const { ownerState } = props;
        return [
            styles.input,
            ownerState.size === "small" && styles.inputSizeSmall,
            ownerState.multiline && styles.inputMultiline,
            ownerState.type === "search" && styles.inputTypeSearch,
            ownerState.startAdornment && styles.inputAdornedStart,
            ownerState.endAdornment && styles.inputAdornedEnd,
            ownerState.hiddenLabel && styles.inputHiddenLabel
        ];
    };
    const useUtilityClasses$r = (ownerState)=>{
        const { classes, color, disabled, error, endAdornment, focused, formControl, fullWidth, hiddenLabel, multiline, readOnly, size, startAdornment, type } = ownerState;
        const slots = {
            root: [
                "root",
                `color${capitalize(color)}`,
                disabled && "disabled",
                error && "error",
                fullWidth && "fullWidth",
                focused && "focused",
                formControl && "formControl",
                size && size !== "medium" && `size${capitalize(size)}`,
                multiline && "multiline",
                startAdornment && "adornedStart",
                endAdornment && "adornedEnd",
                hiddenLabel && "hiddenLabel",
                readOnly && "readOnly"
            ],
            input: [
                "input",
                disabled && "disabled",
                type === "search" && "inputTypeSearch",
                multiline && "inputMultiline",
                size === "small" && "inputSizeSmall",
                hiddenLabel && "inputHiddenLabel",
                startAdornment && "inputAdornedStart",
                endAdornment && "inputAdornedEnd",
                readOnly && "readOnly"
            ]
        };
        return composeClasses(slots, getInputBaseUtilityClass, classes);
    };
    const InputBaseRoot = styled("div", {
        name: "MuiInputBase",
        slot: "Root",
        overridesResolver: rootOverridesResolver
    })(memoTheme(({ theme })=>({
            ...theme.typography.body1,
            color: (theme.vars || theme).palette.text.primary,
            lineHeight: "1.4375em",
            boxSizing: "border-box",
            position: "relative",
            cursor: "text",
            display: "inline-flex",
            alignItems: "center",
            [`&.${inputBaseClasses.disabled}`]: {
                color: (theme.vars || theme).palette.text.disabled,
                cursor: "default"
            },
            variants: [
                {
                    props: ({ ownerState })=>ownerState.multiline,
                    style: {
                        padding: "4px 0 5px"
                    }
                },
                {
                    props: ({ ownerState, size })=>ownerState.multiline && size === "small",
                    style: {
                        paddingTop: 1
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.fullWidth,
                    style: {
                        width: "100%"
                    }
                }
            ]
        })));
    const InputBaseInput = styled("input", {
        name: "MuiInputBase",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })(memoTheme(({ theme })=>{
        const light = theme.palette.mode === "light";
        const placeholder = {
            color: "currentColor",
            ...theme.vars ? {
                opacity: theme.vars.opacity.inputPlaceholder
            } : {
                opacity: light ? 0.42 : 0.5
            },
            transition: theme.transitions.create("opacity", {
                duration: theme.transitions.duration.shorter
            })
        };
        const placeholderHidden = {
            opacity: "0 !important"
        };
        const placeholderVisible = theme.vars ? {
            opacity: theme.vars.opacity.inputPlaceholder
        } : {
            opacity: light ? 0.42 : 0.5
        };
        return {
            font: "inherit",
            letterSpacing: "inherit",
            color: "currentColor",
            padding: "4px 0 5px",
            border: 0,
            boxSizing: "content-box",
            background: "none",
            height: "1.4375em",
            margin: 0,
            WebkitTapHighlightColor: "transparent",
            display: "block",
            minWidth: 0,
            width: "100%",
            "&::-webkit-input-placeholder": placeholder,
            "&::-moz-placeholder": placeholder,
            "&::-ms-input-placeholder": placeholder,
            "&:focus": {
                outline: 0
            },
            "&:invalid": {
                boxShadow: "none"
            },
            "&::-webkit-search-decoration": {
                WebkitAppearance: "none"
            },
            [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
                "&::-webkit-input-placeholder": placeholderHidden,
                "&::-moz-placeholder": placeholderHidden,
                "&::-ms-input-placeholder": placeholderHidden,
                "&:focus::-webkit-input-placeholder": placeholderVisible,
                "&:focus::-moz-placeholder": placeholderVisible,
                "&:focus::-ms-input-placeholder": placeholderVisible
            },
            [`&.${inputBaseClasses.disabled}`]: {
                opacity: 1,
                WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
            },
            variants: [
                {
                    props: ({ ownerState })=>!ownerState.disableInjectingGlobalStyles,
                    style: {
                        animationName: "mui-auto-fill-cancel",
                        animationDuration: "10ms",
                        "&:-webkit-autofill": {
                            animationDuration: "5000s",
                            animationName: "mui-auto-fill"
                        }
                    }
                },
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        paddingTop: 1
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.multiline,
                    style: {
                        height: "auto",
                        resize: "none",
                        padding: 0,
                        paddingTop: 0
                    }
                },
                {
                    props: {
                        type: "search"
                    },
                    style: {
                        MozAppearance: "textfield"
                    }
                }
            ]
        };
    }));
    const InputGlobalStyles = globalCss({
        "@keyframes mui-auto-fill": {
            from: {
                display: "block"
            }
        },
        "@keyframes mui-auto-fill-cancel": {
            from: {
                display: "block"
            }
        }
    });
    const InputBase = reactExports.forwardRef(function InputBase2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiInputBase"
        });
        const { "aria-describedby": ariaDescribedby, autoComplete, autoFocus, className, color, components = {}, componentsProps = {}, defaultValue, disabled, disableInjectingGlobalStyles, endAdornment, error, fullWidth = false, id, inputComponent = "input", inputProps: inputPropsProp = {}, inputRef: inputRefProp, margin, maxRows, minRows, multiline = false, name, onBlur, onChange, onClick, onFocus, onKeyDown, onKeyUp, placeholder, readOnly, renderSuffix, rows, size, slotProps = {}, slots = {}, startAdornment, type = "text", value: valueProp, ...other } = props;
        const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
        const { current: isControlled } = reactExports.useRef(value != null);
        const inputRef = reactExports.useRef();
        const handleInputRefWarning = reactExports.useCallback((instance)=>{}, []);
        const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
        const [focused, setFocused] = reactExports.useState(false);
        const muiFormControl = useFormControl();
        const fcs = formControlState({
            props,
            muiFormControl,
            states: [
                "color",
                "disabled",
                "error",
                "hiddenLabel",
                "size",
                "required",
                "filled"
            ]
        });
        fcs.focused = muiFormControl ? muiFormControl.focused : focused;
        reactExports.useEffect(()=>{
            if (!muiFormControl && disabled && focused) {
                setFocused(false);
                if (onBlur) {
                    onBlur();
                }
            }
        }, [
            muiFormControl,
            disabled,
            focused,
            onBlur
        ]);
        const onFilled = muiFormControl && muiFormControl.onFilled;
        const onEmpty = muiFormControl && muiFormControl.onEmpty;
        const checkDirty = reactExports.useCallback((obj)=>{
            if (isFilled(obj)) {
                if (onFilled) {
                    onFilled();
                }
            } else if (onEmpty) {
                onEmpty();
            }
        }, [
            onFilled,
            onEmpty
        ]);
        useEnhancedEffect(()=>{
            if (isControlled) {
                checkDirty({
                    value
                });
            }
        }, [
            value,
            checkDirty,
            isControlled
        ]);
        const handleFocus = (event)=>{
            if (onFocus) {
                onFocus(event);
            }
            if (inputPropsProp.onFocus) {
                inputPropsProp.onFocus(event);
            }
            if (muiFormControl && muiFormControl.onFocus) {
                muiFormControl.onFocus(event);
            } else {
                setFocused(true);
            }
        };
        const handleBlur = (event)=>{
            if (onBlur) {
                onBlur(event);
            }
            if (inputPropsProp.onBlur) {
                inputPropsProp.onBlur(event);
            }
            if (muiFormControl && muiFormControl.onBlur) {
                muiFormControl.onBlur(event);
            } else {
                setFocused(false);
            }
        };
        const handleChange = (event, ...args)=>{
            if (!isControlled) {
                const element = event.target || inputRef.current;
                if (element == null) {
                    throw new Error(formatMuiErrorMessage(1));
                }
                checkDirty({
                    value: element.value
                });
            }
            if (inputPropsProp.onChange) {
                inputPropsProp.onChange(event, ...args);
            }
            if (onChange) {
                onChange(event, ...args);
            }
        };
        reactExports.useEffect(()=>{
            checkDirty(inputRef.current);
        }, []);
        const handleClick = (event)=>{
            if (inputRef.current && event.currentTarget === event.target) {
                inputRef.current.focus();
            }
            if (onClick) {
                onClick(event);
            }
        };
        let InputComponent = inputComponent;
        let inputProps = inputPropsProp;
        if (multiline && InputComponent === "input") {
            if (rows) {
                inputProps = {
                    type: void 0,
                    minRows: rows,
                    maxRows: rows,
                    ...inputProps
                };
            } else {
                inputProps = {
                    type: void 0,
                    maxRows,
                    minRows,
                    ...inputProps
                };
            }
            InputComponent = TextareaAutosize;
        }
        const handleAutoFill = (event)=>{
            checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
                value: "x"
            });
        };
        reactExports.useEffect(()=>{
            if (muiFormControl) {
                muiFormControl.setAdornedStart(Boolean(startAdornment));
            }
        }, [
            muiFormControl,
            startAdornment
        ]);
        const ownerState = {
            ...props,
            color: fcs.color || "primary",
            disabled: fcs.disabled,
            endAdornment,
            error: fcs.error,
            focused: fcs.focused,
            formControl: muiFormControl,
            fullWidth,
            hiddenLabel: fcs.hiddenLabel,
            multiline,
            size: fcs.size,
            startAdornment,
            type
        };
        const classes = useUtilityClasses$r(ownerState);
        const Root = slots.root || components.Root || InputBaseRoot;
        const rootProps = slotProps.root || componentsProps.root || {};
        const Input = slots.input || components.Input || InputBaseInput;
        inputProps = {
            ...inputProps,
            ...slotProps.input ?? componentsProps.input
        };
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                !disableInjectingGlobalStyles && typeof InputGlobalStyles === "function" && (_InputGlobalStyles || (_InputGlobalStyles = jsxRuntimeExports.jsx(InputGlobalStyles, {}))),
                jsxRuntimeExports.jsxs(Root, {
                    ...rootProps,
                    ref,
                    onClick: handleClick,
                    ...other,
                    ...!isHostComponent(Root) && {
                        ownerState: {
                            ...ownerState,
                            ...rootProps.ownerState
                        }
                    },
                    className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
                    children: [
                        startAdornment,
                        jsxRuntimeExports.jsx(FormControlContext.Provider, {
                            value: null,
                            children: jsxRuntimeExports.jsx(Input, {
                                "aria-invalid": fcs.error,
                                "aria-describedby": ariaDescribedby,
                                autoComplete,
                                autoFocus,
                                defaultValue,
                                disabled: fcs.disabled,
                                id,
                                onAnimationStart: handleAutoFill,
                                name,
                                placeholder,
                                readOnly,
                                required: fcs.required,
                                rows,
                                value,
                                onKeyDown,
                                onKeyUp,
                                type,
                                ...inputProps,
                                ...!isHostComponent(Input) && {
                                    as: InputComponent,
                                    ownerState: {
                                        ...ownerState,
                                        ...inputProps.ownerState
                                    }
                                },
                                ref: handleInputRef,
                                className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
                                onBlur: handleBlur,
                                onChange: handleChange,
                                onFocus: handleFocus
                            })
                        }),
                        endAdornment,
                        renderSuffix ? renderSuffix({
                            ...fcs,
                            startAdornment
                        }) : null
                    ]
                })
            ]
        });
    });
    function getInputUtilityClass(slot) {
        return generateUtilityClass('MuiInput', slot);
    }
    const inputClasses = {
        ...inputBaseClasses,
        ...generateUtilityClasses('MuiInput', [
            'root',
            'underline',
            'input'
        ])
    };
    function getOutlinedInputUtilityClass(slot) {
        return generateUtilityClass('MuiOutlinedInput', slot);
    }
    const outlinedInputClasses = {
        ...inputBaseClasses,
        ...generateUtilityClasses('MuiOutlinedInput', [
            'root',
            'notchedOutline',
            'input'
        ])
    };
    function getFilledInputUtilityClass(slot) {
        return generateUtilityClass('MuiFilledInput', slot);
    }
    const filledInputClasses = {
        ...inputBaseClasses,
        ...generateUtilityClasses('MuiFilledInput', [
            'root',
            'underline',
            'input',
            'adornedStart',
            'adornedEnd',
            'sizeSmall',
            'multiline',
            'hiddenLabel'
        ])
    };
    const ArrowDropDownIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M7 10l5 5 5-5z"
    }));
    const styles$2 = {
        entering: {
            opacity: 1
        },
        entered: {
            opacity: 1
        }
    };
    const Fade = reactExports.forwardRef(function Fade2(props, ref) {
        const theme = useTheme();
        const defaultTimeout = {
            enter: theme.transitions.duration.enteringScreen,
            exit: theme.transitions.duration.leavingScreen
        };
        const { addEndListener, appear = true, children, easing, in: inProp, onEnter, onEntered, onEntering, onExit, onExited, onExiting, style, timeout = defaultTimeout, TransitionComponent = Transition, ...other } = props;
        const nodeRef = reactExports.useRef(null);
        const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
        const normalizedTransitionCallback = (callback)=>(maybeIsAppearing)=>{
                if (callback) {
                    const node = nodeRef.current;
                    if (maybeIsAppearing === void 0) {
                        callback(node);
                    } else {
                        callback(node, maybeIsAppearing);
                    }
                }
            };
        const handleEntering = normalizedTransitionCallback(onEntering);
        const handleEnter = normalizedTransitionCallback((node, isAppearing)=>{
            reflow(node);
            const transitionProps = getTransitionProps({
                style,
                timeout,
                easing
            }, {
                mode: "enter"
            });
            node.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
            node.style.transition = theme.transitions.create("opacity", transitionProps);
            if (onEnter) {
                onEnter(node, isAppearing);
            }
        });
        const handleEntered = normalizedTransitionCallback(onEntered);
        const handleExiting = normalizedTransitionCallback(onExiting);
        const handleExit = normalizedTransitionCallback((node)=>{
            const transitionProps = getTransitionProps({
                style,
                timeout,
                easing
            }, {
                mode: "exit"
            });
            node.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
            node.style.transition = theme.transitions.create("opacity", transitionProps);
            if (onExit) {
                onExit(node);
            }
        });
        const handleExited = normalizedTransitionCallback(onExited);
        const handleAddEndListener = (next)=>{
            if (addEndListener) {
                addEndListener(nodeRef.current, next);
            }
        };
        return jsxRuntimeExports.jsx(TransitionComponent, {
            appear,
            in: inProp,
            nodeRef: nodeRef,
            onEnter: handleEnter,
            onEntered: handleEntered,
            onEntering: handleEntering,
            onExit: handleExit,
            onExited: handleExited,
            onExiting: handleExiting,
            addEndListener: handleAddEndListener,
            timeout,
            ...other,
            children: (state, { ownerState, ...restChildProps })=>{
                return reactExports.cloneElement(children, {
                    style: {
                        opacity: 0,
                        visibility: state === "exited" && !inProp ? "hidden" : void 0,
                        ...styles$2[state],
                        ...style,
                        ...children.props.style
                    },
                    ref: handleRef,
                    ...restChildProps
                });
            }
        });
    });
    function getBackdropUtilityClass(slot) {
        return generateUtilityClass('MuiBackdrop', slot);
    }
    generateUtilityClasses('MuiBackdrop', [
        'root',
        'invisible'
    ]);
    const useUtilityClasses$q = (ownerState)=>{
        const { classes, invisible } = ownerState;
        const slots = {
            root: [
                "root",
                invisible && "invisible"
            ]
        };
        return composeClasses(slots, getBackdropUtilityClass, classes);
    };
    const BackdropRoot = styled("div", {
        name: "MuiBackdrop",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.invisible && styles.invisible
            ];
        }
    })({
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        WebkitTapHighlightColor: "transparent",
        variants: [
            {
                props: {
                    invisible: true
                },
                style: {
                    backgroundColor: "transparent"
                }
            }
        ]
    });
    const Backdrop = reactExports.forwardRef(function Backdrop2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiBackdrop"
        });
        const { children, className, component = "div", invisible = false, open, components = {}, componentsProps = {}, slotProps = {}, slots = {}, TransitionComponent: TransitionComponentProp, transitionDuration, ...other } = props;
        const ownerState = {
            ...props,
            component,
            invisible
        };
        const classes = useUtilityClasses$q(ownerState);
        const backwardCompatibleSlots = {
            transition: TransitionComponentProp,
            root: components.Root,
            ...slots
        };
        const backwardCompatibleSlotProps = {
            ...componentsProps,
            ...slotProps
        };
        const externalForwardedProps = {
            component,
            slots: backwardCompatibleSlots,
            slotProps: backwardCompatibleSlotProps
        };
        const [RootSlot, rootProps] = useSlot("root", {
            elementType: BackdropRoot,
            externalForwardedProps,
            className: clsx(classes.root, className),
            ownerState
        });
        const [TransitionSlot, transitionProps] = useSlot("transition", {
            elementType: Fade,
            externalForwardedProps,
            ownerState
        });
        return jsxRuntimeExports.jsx(TransitionSlot, {
            in: open,
            timeout: transitionDuration,
            ...other,
            ...transitionProps,
            children: jsxRuntimeExports.jsx(RootSlot, {
                "aria-hidden": true,
                ...rootProps,
                classes,
                ref,
                children
            })
        });
    });
    const boxClasses = generateUtilityClasses('MuiBox', [
        'root'
    ]);
    const defaultTheme = createTheme();
    const Box = createBox({
        themeId: THEME_ID,
        defaultTheme,
        defaultClassName: boxClasses.root,
        generateClassName: ClassNameGenerator.generate
    });
    function getButtonUtilityClass(slot) {
        return generateUtilityClass('MuiButton', slot);
    }
    const buttonClasses = generateUtilityClasses('MuiButton', [
        'root',
        'text',
        'textInherit',
        'textPrimary',
        'textSecondary',
        'textSuccess',
        'textError',
        'textInfo',
        'textWarning',
        'outlined',
        'outlinedInherit',
        'outlinedPrimary',
        'outlinedSecondary',
        'outlinedSuccess',
        'outlinedError',
        'outlinedInfo',
        'outlinedWarning',
        'contained',
        'containedInherit',
        'containedPrimary',
        'containedSecondary',
        'containedSuccess',
        'containedError',
        'containedInfo',
        'containedWarning',
        'disableElevation',
        'focusVisible',
        'disabled',
        'colorInherit',
        'colorPrimary',
        'colorSecondary',
        'colorSuccess',
        'colorError',
        'colorInfo',
        'colorWarning',
        'textSizeSmall',
        'textSizeMedium',
        'textSizeLarge',
        'outlinedSizeSmall',
        'outlinedSizeMedium',
        'outlinedSizeLarge',
        'containedSizeSmall',
        'containedSizeMedium',
        'containedSizeLarge',
        'sizeMedium',
        'sizeSmall',
        'sizeLarge',
        'fullWidth',
        'startIcon',
        'endIcon',
        'icon',
        'iconSizeSmall',
        'iconSizeMedium',
        'iconSizeLarge',
        'loading',
        'loadingWrapper',
        'loadingIconPlaceholder',
        'loadingIndicator',
        'loadingPositionCenter',
        'loadingPositionStart',
        'loadingPositionEnd'
    ]);
    const ButtonGroupContext = reactExports.createContext({});
    const ButtonGroupButtonContext = reactExports.createContext(void 0);
    const useUtilityClasses$p = (ownerState)=>{
        const { color, disableElevation, fullWidth, size, variant, loading, loadingPosition, classes } = ownerState;
        const slots = {
            root: [
                "root",
                loading && "loading",
                variant,
                `${variant}${capitalize(color)}`,
                `size${capitalize(size)}`,
                `${variant}Size${capitalize(size)}`,
                `color${capitalize(color)}`,
                disableElevation && "disableElevation",
                fullWidth && "fullWidth",
                loading && `loadingPosition${capitalize(loadingPosition)}`
            ],
            startIcon: [
                "icon",
                "startIcon",
                `iconSize${capitalize(size)}`
            ],
            endIcon: [
                "icon",
                "endIcon",
                `iconSize${capitalize(size)}`
            ],
            loadingIndicator: [
                "loadingIndicator"
            ],
            loadingWrapper: [
                "loadingWrapper"
            ]
        };
        const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
        return {
            ...classes,
            ...composedClasses
        };
    };
    const commonIconStyles = [
        {
            props: {
                size: "small"
            },
            style: {
                "& > *:nth-of-type(1)": {
                    fontSize: 18
                }
            }
        },
        {
            props: {
                size: "medium"
            },
            style: {
                "& > *:nth-of-type(1)": {
                    fontSize: 20
                }
            }
        },
        {
            props: {
                size: "large"
            },
            style: {
                "& > *:nth-of-type(1)": {
                    fontSize: 22
                }
            }
        }
    ];
    const ButtonRoot = styled(ButtonBase, {
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) || prop === "classes",
        name: "MuiButton",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[ownerState.variant],
                styles[`${ownerState.variant}${capitalize(ownerState.color)}`],
                styles[`size${capitalize(ownerState.size)}`],
                styles[`${ownerState.variant}Size${capitalize(ownerState.size)}`],
                ownerState.color === "inherit" && styles.colorInherit,
                ownerState.disableElevation && styles.disableElevation,
                ownerState.fullWidth && styles.fullWidth,
                ownerState.loading && styles.loading
            ];
        }
    })(memoTheme(({ theme })=>{
        const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
        const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
        return {
            ...theme.typography.button,
            minWidth: 64,
            padding: "6px 16px",
            border: 0,
            borderRadius: (theme.vars || theme).shape.borderRadius,
            transition: theme.transitions.create([
                "background-color",
                "box-shadow",
                "border-color",
                "color"
            ], {
                duration: theme.transitions.duration.short
            }),
            "&:hover": {
                textDecoration: "none"
            },
            [`&.${buttonClasses.disabled}`]: {
                color: (theme.vars || theme).palette.action.disabled
            },
            variants: [
                {
                    props: {
                        variant: "contained"
                    },
                    style: {
                        color: `var(--variant-containedColor)`,
                        backgroundColor: `var(--variant-containedBg)`,
                        boxShadow: (theme.vars || theme).shadows[2],
                        "&:hover": {
                            boxShadow: (theme.vars || theme).shadows[4],
                            "@media (hover: none)": {
                                boxShadow: (theme.vars || theme).shadows[2]
                            }
                        },
                        "&:active": {
                            boxShadow: (theme.vars || theme).shadows[8]
                        },
                        [`&.${buttonClasses.focusVisible}`]: {
                            boxShadow: (theme.vars || theme).shadows[6]
                        },
                        [`&.${buttonClasses.disabled}`]: {
                            color: (theme.vars || theme).palette.action.disabled,
                            boxShadow: (theme.vars || theme).shadows[0],
                            backgroundColor: (theme.vars || theme).palette.action.disabledBackground
                        }
                    }
                },
                {
                    props: {
                        variant: "outlined"
                    },
                    style: {
                        padding: "5px 15px",
                        border: "1px solid currentColor",
                        borderColor: `var(--variant-outlinedBorder, currentColor)`,
                        backgroundColor: `var(--variant-outlinedBg)`,
                        color: `var(--variant-outlinedColor)`,
                        [`&.${buttonClasses.disabled}`]: {
                            border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
                        }
                    }
                },
                {
                    props: {
                        variant: "text"
                    },
                    style: {
                        padding: "6px 8px",
                        color: `var(--variant-textColor)`,
                        backgroundColor: `var(--variant-textBg)`
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            "--variant-textColor": (theme.vars || theme).palette[color].main,
                            "--variant-outlinedColor": (theme.vars || theme).palette[color].main,
                            "--variant-outlinedBorder": theme.alpha((theme.vars || theme).palette[color].main, 0.5),
                            "--variant-containedColor": (theme.vars || theme).palette[color].contrastText,
                            "--variant-containedBg": (theme.vars || theme).palette[color].main,
                            "@media (hover: hover)": {
                                "&:hover": {
                                    "--variant-containedBg": (theme.vars || theme).palette[color].dark,
                                    "--variant-textBg": theme.alpha((theme.vars || theme).palette[color].main, (theme.vars || theme).palette.action.hoverOpacity),
                                    "--variant-outlinedBorder": (theme.vars || theme).palette[color].main,
                                    "--variant-outlinedBg": theme.alpha((theme.vars || theme).palette[color].main, (theme.vars || theme).palette.action.hoverOpacity)
                                }
                            }
                        }
                    })),
                {
                    props: {
                        color: "inherit"
                    },
                    style: {
                        color: "inherit",
                        borderColor: "currentColor",
                        "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
                        "@media (hover: hover)": {
                            "&:hover": {
                                "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
                                "--variant-textBg": theme.alpha((theme.vars || theme).palette.text.primary, (theme.vars || theme).palette.action.hoverOpacity),
                                "--variant-outlinedBg": theme.alpha((theme.vars || theme).palette.text.primary, (theme.vars || theme).palette.action.hoverOpacity)
                            }
                        }
                    }
                },
                {
                    props: {
                        size: "small",
                        variant: "text"
                    },
                    style: {
                        padding: "4px 5px",
                        fontSize: theme.typography.pxToRem(13)
                    }
                },
                {
                    props: {
                        size: "large",
                        variant: "text"
                    },
                    style: {
                        padding: "8px 11px",
                        fontSize: theme.typography.pxToRem(15)
                    }
                },
                {
                    props: {
                        size: "small",
                        variant: "outlined"
                    },
                    style: {
                        padding: "3px 9px",
                        fontSize: theme.typography.pxToRem(13)
                    }
                },
                {
                    props: {
                        size: "large",
                        variant: "outlined"
                    },
                    style: {
                        padding: "7px 21px",
                        fontSize: theme.typography.pxToRem(15)
                    }
                },
                {
                    props: {
                        size: "small",
                        variant: "contained"
                    },
                    style: {
                        padding: "4px 10px",
                        fontSize: theme.typography.pxToRem(13)
                    }
                },
                {
                    props: {
                        size: "large",
                        variant: "contained"
                    },
                    style: {
                        padding: "8px 22px",
                        fontSize: theme.typography.pxToRem(15)
                    }
                },
                {
                    props: {
                        disableElevation: true
                    },
                    style: {
                        boxShadow: "none",
                        "&:hover": {
                            boxShadow: "none"
                        },
                        [`&.${buttonClasses.focusVisible}`]: {
                            boxShadow: "none"
                        },
                        "&:active": {
                            boxShadow: "none"
                        },
                        [`&.${buttonClasses.disabled}`]: {
                            boxShadow: "none"
                        }
                    }
                },
                {
                    props: {
                        fullWidth: true
                    },
                    style: {
                        width: "100%"
                    }
                },
                {
                    props: {
                        loadingPosition: "center"
                    },
                    style: {
                        transition: theme.transitions.create([
                            "background-color",
                            "box-shadow",
                            "border-color"
                        ], {
                            duration: theme.transitions.duration.short
                        }),
                        [`&.${buttonClasses.loading}`]: {
                            color: "transparent"
                        }
                    }
                }
            ]
        };
    }));
    const ButtonStartIcon = styled("span", {
        name: "MuiButton",
        slot: "StartIcon",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.startIcon,
                ownerState.loading && styles.startIconLoadingStart,
                styles[`iconSize${capitalize(ownerState.size)}`]
            ];
        }
    })(({ theme })=>({
            display: "inherit",
            marginRight: 8,
            marginLeft: -4,
            variants: [
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        marginLeft: -2
                    }
                },
                {
                    props: {
                        loadingPosition: "start",
                        loading: true
                    },
                    style: {
                        transition: theme.transitions.create([
                            "opacity"
                        ], {
                            duration: theme.transitions.duration.short
                        }),
                        opacity: 0
                    }
                },
                {
                    props: {
                        loadingPosition: "start",
                        loading: true,
                        fullWidth: true
                    },
                    style: {
                        marginRight: -8
                    }
                },
                ...commonIconStyles
            ]
        }));
    const ButtonEndIcon = styled("span", {
        name: "MuiButton",
        slot: "EndIcon",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.endIcon,
                ownerState.loading && styles.endIconLoadingEnd,
                styles[`iconSize${capitalize(ownerState.size)}`]
            ];
        }
    })(({ theme })=>({
            display: "inherit",
            marginRight: -4,
            marginLeft: 8,
            variants: [
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        marginRight: -2
                    }
                },
                {
                    props: {
                        loadingPosition: "end",
                        loading: true
                    },
                    style: {
                        transition: theme.transitions.create([
                            "opacity"
                        ], {
                            duration: theme.transitions.duration.short
                        }),
                        opacity: 0
                    }
                },
                {
                    props: {
                        loadingPosition: "end",
                        loading: true,
                        fullWidth: true
                    },
                    style: {
                        marginLeft: -8
                    }
                },
                ...commonIconStyles
            ]
        }));
    const ButtonLoadingIndicator = styled("span", {
        name: "MuiButton",
        slot: "LoadingIndicator"
    })(({ theme })=>({
            display: "none",
            position: "absolute",
            visibility: "visible",
            variants: [
                {
                    props: {
                        loading: true
                    },
                    style: {
                        display: "flex"
                    }
                },
                {
                    props: {
                        loadingPosition: "start"
                    },
                    style: {
                        left: 14
                    }
                },
                {
                    props: {
                        loadingPosition: "start",
                        size: "small"
                    },
                    style: {
                        left: 10
                    }
                },
                {
                    props: {
                        variant: "text",
                        loadingPosition: "start"
                    },
                    style: {
                        left: 6
                    }
                },
                {
                    props: {
                        loadingPosition: "center"
                    },
                    style: {
                        left: "50%",
                        transform: "translate(-50%)",
                        color: (theme.vars || theme).palette.action.disabled
                    }
                },
                {
                    props: {
                        loadingPosition: "end"
                    },
                    style: {
                        right: 14
                    }
                },
                {
                    props: {
                        loadingPosition: "end",
                        size: "small"
                    },
                    style: {
                        right: 10
                    }
                },
                {
                    props: {
                        variant: "text",
                        loadingPosition: "end"
                    },
                    style: {
                        right: 6
                    }
                },
                {
                    props: {
                        loadingPosition: "start",
                        fullWidth: true
                    },
                    style: {
                        position: "relative",
                        left: -10
                    }
                },
                {
                    props: {
                        loadingPosition: "end",
                        fullWidth: true
                    },
                    style: {
                        position: "relative",
                        right: -10
                    }
                }
            ]
        }));
    const ButtonLoadingIconPlaceholder = styled("span", {
        name: "MuiButton",
        slot: "LoadingIconPlaceholder"
    })({
        display: "inline-block",
        width: "1em",
        height: "1em"
    });
    const Button = reactExports.forwardRef(function Button2(inProps, ref) {
        const contextProps = reactExports.useContext(ButtonGroupContext);
        const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
        const resolvedProps = resolveProps(contextProps, inProps);
        const props = useDefaultProps({
            props: resolvedProps,
            name: "MuiButton"
        });
        const { children, color = "primary", component = "button", className, disabled = false, disableElevation = false, disableFocusRipple = false, endIcon: endIconProp, focusVisibleClassName, fullWidth = false, id: idProp, loading = null, loadingIndicator: loadingIndicatorProp, loadingPosition = "center", size = "medium", startIcon: startIconProp, type, variant = "text", ...other } = props;
        const loadingId = useId(idProp);
        const loadingIndicator = loadingIndicatorProp ?? jsxRuntimeExports.jsx(CircularProgress, {
            "aria-labelledby": loadingId,
            color: "inherit",
            size: 16
        });
        const ownerState = {
            ...props,
            color,
            component,
            disabled,
            disableElevation,
            disableFocusRipple,
            fullWidth,
            loading,
            loadingIndicator,
            loadingPosition,
            size,
            type,
            variant
        };
        const classes = useUtilityClasses$p(ownerState);
        const startIcon = (startIconProp || loading && loadingPosition === "start") && jsxRuntimeExports.jsx(ButtonStartIcon, {
            className: classes.startIcon,
            ownerState,
            children: startIconProp || jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
                className: classes.loadingIconPlaceholder,
                ownerState
            })
        });
        const endIcon = (endIconProp || loading && loadingPosition === "end") && jsxRuntimeExports.jsx(ButtonEndIcon, {
            className: classes.endIcon,
            ownerState,
            children: endIconProp || jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
                className: classes.loadingIconPlaceholder,
                ownerState
            })
        });
        const positionClassName = buttonGroupButtonContextPositionClassName || "";
        const loader = typeof loading === "boolean" ? (jsxRuntimeExports.jsx("span", {
            className: classes.loadingWrapper,
            style: {
                display: "contents"
            },
            children: loading && jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
                className: classes.loadingIndicator,
                ownerState,
                children: loadingIndicator
            })
        })) : null;
        return jsxRuntimeExports.jsxs(ButtonRoot, {
            ownerState,
            className: clsx(contextProps.className, classes.root, className, positionClassName),
            component,
            disabled: disabled || loading,
            focusRipple: !disableFocusRipple,
            focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
            ref,
            type,
            id: loading ? loadingId : idProp,
            ...other,
            classes,
            children: [
                startIcon,
                loadingPosition !== "end" && loader,
                children,
                loadingPosition === "end" && loader,
                endIcon
            ]
        });
    });
    function getCardUtilityClass(slot) {
        return generateUtilityClass('MuiCard', slot);
    }
    generateUtilityClasses('MuiCard', [
        'root'
    ]);
    const useUtilityClasses$o = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ]
        };
        return composeClasses(slots, getCardUtilityClass, classes);
    };
    const CardRoot = styled(Paper, {
        name: "MuiCard",
        slot: "Root"
    })({
        overflow: "hidden"
    });
    const Card = reactExports.forwardRef(function Card2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiCard"
        });
        const { className, raised = false, ...other } = props;
        const ownerState = {
            ...props,
            raised
        };
        const classes = useUtilityClasses$o(ownerState);
        return jsxRuntimeExports.jsx(CardRoot, {
            className: clsx(classes.root, className),
            elevation: raised ? 8 : void 0,
            ref,
            ownerState,
            ...other
        });
    });
    function getCardContentUtilityClass(slot) {
        return generateUtilityClass('MuiCardContent', slot);
    }
    generateUtilityClasses('MuiCardContent', [
        'root'
    ]);
    const useUtilityClasses$n = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ]
        };
        return composeClasses(slots, getCardContentUtilityClass, classes);
    };
    const CardContentRoot = styled("div", {
        name: "MuiCardContent",
        slot: "Root"
    })({
        padding: 16,
        "&:last-child": {
            paddingBottom: 24
        }
    });
    const CardContent = reactExports.forwardRef(function CardContent2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiCardContent"
        });
        const { className, component = "div", ...other } = props;
        const ownerState = {
            ...props,
            component
        };
        const classes = useUtilityClasses$n(ownerState);
        return jsxRuntimeExports.jsx(CardContentRoot, {
            as: component,
            className: clsx(classes.root, className),
            ownerState,
            ref,
            ...other
        });
    });
    const Container = createContainer({
        createStyledComponent: styled("div", {
            name: "MuiContainer",
            slot: "Root",
            overridesResolver: (props, styles)=>{
                const { ownerState } = props;
                return [
                    styles.root,
                    styles[`maxWidth${capitalize(String(ownerState.maxWidth))}`],
                    ownerState.fixed && styles.fixed,
                    ownerState.disableGutters && styles.disableGutters
                ];
            }
        }),
        useThemeProps: (inProps)=>useDefaultProps({
                props: inProps,
                name: "MuiContainer"
            })
    });
    const isDynamicSupport = typeof globalCss({}) === "function";
    const html = (theme, enableColorScheme)=>({
            WebkitFontSmoothing: "antialiased",
            MozOsxFontSmoothing: "grayscale",
            boxSizing: "border-box",
            WebkitTextSizeAdjust: "100%",
            ...enableColorScheme && !theme.vars && {
                colorScheme: theme.palette.mode
            }
        });
    const body = (theme)=>({
            color: (theme.vars || theme).palette.text.primary,
            ...theme.typography.body1,
            backgroundColor: (theme.vars || theme).palette.background.default,
            "@media print": {
                backgroundColor: (theme.vars || theme).palette.common.white
            }
        });
    const styles$1 = (theme, enableColorScheme = false)=>{
        const colorSchemeStyles = {};
        if (enableColorScheme && theme.colorSchemes && typeof theme.getColorSchemeSelector === "function") {
            Object.entries(theme.colorSchemes).forEach(([key, scheme])=>{
                const selector = theme.getColorSchemeSelector(key);
                if (selector.startsWith("@")) {
                    colorSchemeStyles[selector] = {
                        ":root": {
                            colorScheme: scheme.palette?.mode
                        }
                    };
                } else {
                    colorSchemeStyles[selector.replace(/\s*&/, "")] = {
                        colorScheme: scheme.palette?.mode
                    };
                }
            });
        }
        let defaultStyles = {
            html: html(theme, enableColorScheme),
            "*, *::before, *::after": {
                boxSizing: "inherit"
            },
            "strong, b": {
                fontWeight: theme.typography.fontWeightBold
            },
            body: {
                margin: 0,
                ...body(theme),
                "&::backdrop": {
                    backgroundColor: (theme.vars || theme).palette.background.default
                }
            },
            ...colorSchemeStyles
        };
        const themeOverrides = theme.components?.MuiCssBaseline?.styleOverrides;
        if (themeOverrides) {
            defaultStyles = [
                defaultStyles,
                themeOverrides
            ];
        }
        return defaultStyles;
    };
    const SELECTOR = "mui-ecs";
    const staticStyles = (theme)=>{
        const result = styles$1(theme, false);
        const baseStyles = Array.isArray(result) ? result[0] : result;
        if (!theme.vars && baseStyles) {
            baseStyles.html[`:root:has(${SELECTOR})`] = {
                colorScheme: theme.palette.mode
            };
        }
        if (theme.colorSchemes) {
            Object.entries(theme.colorSchemes).forEach(([key, scheme])=>{
                const selector = theme.getColorSchemeSelector(key);
                if (selector.startsWith("@")) {
                    baseStyles[selector] = {
                        [`:root:not(:has(.${SELECTOR}))`]: {
                            colorScheme: scheme.palette?.mode
                        }
                    };
                } else {
                    baseStyles[selector.replace(/\s*&/, "")] = {
                        [`&:not(:has(.${SELECTOR}))`]: {
                            colorScheme: scheme.palette?.mode
                        }
                    };
                }
            });
        }
        return result;
    };
    const GlobalStyles = globalCss(isDynamicSupport ? ({ theme, enableColorScheme })=>styles$1(theme, enableColorScheme) : ({ theme })=>staticStyles(theme));
    function CssBaseline(inProps) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiCssBaseline"
        });
        const { children, enableColorScheme = false } = props;
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                isDynamicSupport && jsxRuntimeExports.jsx(GlobalStyles, {
                    enableColorScheme
                }),
                !isDynamicSupport && !enableColorScheme && jsxRuntimeExports.jsx("span", {
                    className: SELECTOR,
                    style: {
                        display: "none"
                    }
                }),
                children
            ]
        });
    }
    function getScrollbarSize(win = window) {
        const documentWidth = win.document.documentElement.clientWidth;
        return win.innerWidth - documentWidth;
    }
    function isOverflowing(container) {
        const doc = ownerDocument(container);
        if (doc.body === container) {
            return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
        }
        return container.scrollHeight > container.clientHeight;
    }
    function ariaHidden(element, hide) {
        if (hide) {
            element.setAttribute('aria-hidden', 'true');
        } else {
            element.removeAttribute('aria-hidden');
        }
    }
    function getPaddingRight(element) {
        return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
    }
    function isAriaHiddenForbiddenOnElement(element) {
        const forbiddenTagNames = [
            'TEMPLATE',
            'SCRIPT',
            'STYLE',
            'LINK',
            'MAP',
            'META',
            'NOSCRIPT',
            'PICTURE',
            'COL',
            'COLGROUP',
            'PARAM',
            'SLOT',
            'SOURCE',
            'TRACK'
        ];
        const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
        const isInputHidden = element.tagName === 'INPUT' && element.getAttribute('type') === 'hidden';
        return isForbiddenTagName || isInputHidden;
    }
    function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide) {
        const blacklist = [
            mountElement,
            currentElement,
            ...elementsToExclude
        ];
        [].forEach.call(container.children, (element)=>{
            const isNotExcludedElement = !blacklist.includes(element);
            const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
            if (isNotExcludedElement && isNotForbiddenElement) {
                ariaHidden(element, hide);
            }
        });
    }
    function findIndexOf(items, callback) {
        let idx = -1;
        items.some((item, index)=>{
            if (callback(item)) {
                idx = index;
                return true;
            }
            return false;
        });
        return idx;
    }
    function handleContainer(containerInfo, props) {
        const restoreStyle = [];
        const container = containerInfo.container;
        if (!props.disableScrollLock) {
            if (isOverflowing(container)) {
                const scrollbarSize = getScrollbarSize(ownerWindow(container));
                restoreStyle.push({
                    value: container.style.paddingRight,
                    property: 'padding-right',
                    el: container
                });
                container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
                const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
                [].forEach.call(fixedElements, (element)=>{
                    restoreStyle.push({
                        value: element.style.paddingRight,
                        property: 'padding-right',
                        el: element
                    });
                    element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
                });
            }
            let scrollContainer;
            if (container.parentNode instanceof DocumentFragment) {
                scrollContainer = ownerDocument(container).body;
            } else {
                const parent = container.parentElement;
                const containerWindow = ownerWindow(container);
                scrollContainer = parent?.nodeName === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container;
            }
            restoreStyle.push({
                value: scrollContainer.style.overflow,
                property: 'overflow',
                el: scrollContainer
            }, {
                value: scrollContainer.style.overflowX,
                property: 'overflow-x',
                el: scrollContainer
            }, {
                value: scrollContainer.style.overflowY,
                property: 'overflow-y',
                el: scrollContainer
            });
            scrollContainer.style.overflow = 'hidden';
        }
        const restore = ()=>{
            restoreStyle.forEach(({ value, el, property })=>{
                if (value) {
                    el.style.setProperty(property, value);
                } else {
                    el.style.removeProperty(property);
                }
            });
        };
        return restore;
    }
    function getHiddenSiblings(container) {
        const hiddenSiblings = [];
        [].forEach.call(container.children, (element)=>{
            if (element.getAttribute('aria-hidden') === 'true') {
                hiddenSiblings.push(element);
            }
        });
        return hiddenSiblings;
    }
    class ModalManager {
        constructor(){
            this.modals = [];
            this.containers = [];
        }
        add(modal, container) {
            let modalIndex = this.modals.indexOf(modal);
            if (modalIndex !== -1) {
                return modalIndex;
            }
            modalIndex = this.modals.length;
            this.modals.push(modal);
            if (modal.modalRef) {
                ariaHidden(modal.modalRef, false);
            }
            const hiddenSiblings = getHiddenSiblings(container);
            ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
            const containerIndex = findIndexOf(this.containers, (item)=>item.container === container);
            if (containerIndex !== -1) {
                this.containers[containerIndex].modals.push(modal);
                return modalIndex;
            }
            this.containers.push({
                modals: [
                    modal
                ],
                container,
                restore: null,
                hiddenSiblings
            });
            return modalIndex;
        }
        mount(modal, props) {
            const containerIndex = findIndexOf(this.containers, (item)=>item.modals.includes(modal));
            const containerInfo = this.containers[containerIndex];
            if (!containerInfo.restore) {
                containerInfo.restore = handleContainer(containerInfo, props);
            }
        }
        remove(modal, ariaHiddenState = true) {
            const modalIndex = this.modals.indexOf(modal);
            if (modalIndex === -1) {
                return modalIndex;
            }
            const containerIndex = findIndexOf(this.containers, (item)=>item.modals.includes(modal));
            const containerInfo = this.containers[containerIndex];
            containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
            this.modals.splice(modalIndex, 1);
            if (containerInfo.modals.length === 0) {
                if (containerInfo.restore) {
                    containerInfo.restore();
                }
                if (modal.modalRef) {
                    ariaHidden(modal.modalRef, ariaHiddenState);
                }
                ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
                this.containers.splice(containerIndex, 1);
            } else {
                const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
                if (nextTop.modalRef) {
                    ariaHidden(nextTop.modalRef, false);
                }
            }
            return modalIndex;
        }
        isTopModal(modal) {
            return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
        }
    }
    const candidatesSelector = [
        "input",
        "select",
        "textarea",
        "a[href]",
        "button",
        "[tabindex]",
        "audio[controls]",
        "video[controls]",
        '[contenteditable]:not([contenteditable="false"])'
    ].join(",");
    function getTabIndex(node) {
        const tabindexAttr = parseInt(node.getAttribute("tabindex") || "", 10);
        if (!Number.isNaN(tabindexAttr)) {
            return tabindexAttr;
        }
        if (node.contentEditable === "true" || (node.nodeName === "AUDIO" || node.nodeName === "VIDEO" || node.nodeName === "DETAILS") && node.getAttribute("tabindex") === null) {
            return 0;
        }
        return node.tabIndex;
    }
    function isNonTabbableRadio(node) {
        if (node.tagName !== "INPUT" || node.type !== "radio") {
            return false;
        }
        if (!node.name) {
            return false;
        }
        const getRadio = (selector)=>node.ownerDocument.querySelector(`input[type="radio"]${selector}`);
        let roving = getRadio(`[name="${node.name}"]:checked`);
        if (!roving) {
            roving = getRadio(`[name="${node.name}"]`);
        }
        return roving !== node;
    }
    function isNodeMatchingSelectorFocusable(node) {
        if (node.disabled || node.tagName === "INPUT" && node.type === "hidden" || isNonTabbableRadio(node)) {
            return false;
        }
        return true;
    }
    function defaultGetTabbable(root) {
        const regularTabNodes = [];
        const orderedTabNodes = [];
        Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i)=>{
            const nodeTabIndex = getTabIndex(node);
            if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
                return;
            }
            if (nodeTabIndex === 0) {
                regularTabNodes.push(node);
            } else {
                orderedTabNodes.push({
                    documentOrder: i,
                    tabIndex: nodeTabIndex,
                    node
                });
            }
        });
        return orderedTabNodes.sort((a, b)=>a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a)=>a.node).concat(regularTabNodes);
    }
    function defaultIsEnabled() {
        return true;
    }
    function FocusTrap(props) {
        const { children, disableAutoFocus = false, disableEnforceFocus = false, disableRestoreFocus = false, getTabbable = defaultGetTabbable, isEnabled = defaultIsEnabled, open } = props;
        const ignoreNextEnforceFocus = reactExports.useRef(false);
        const sentinelStart = reactExports.useRef(null);
        const sentinelEnd = reactExports.useRef(null);
        const nodeToRestore = reactExports.useRef(null);
        const reactFocusEventTarget = reactExports.useRef(null);
        const activated = reactExports.useRef(false);
        const rootRef = reactExports.useRef(null);
        const handleRef = useForkRef(getReactElementRef(children), rootRef);
        const lastKeydown = reactExports.useRef(null);
        reactExports.useEffect(()=>{
            if (!open || !rootRef.current) {
                return;
            }
            activated.current = !disableAutoFocus;
        }, [
            disableAutoFocus,
            open
        ]);
        reactExports.useEffect(()=>{
            if (!open || !rootRef.current) {
                return;
            }
            const doc = ownerDocument(rootRef.current);
            if (!rootRef.current.contains(doc.activeElement)) {
                if (!rootRef.current.hasAttribute("tabIndex")) {
                    rootRef.current.setAttribute("tabIndex", "-1");
                }
                if (activated.current) {
                    rootRef.current.focus();
                }
            }
            return ()=>{
                if (!disableRestoreFocus) {
                    if (nodeToRestore.current && nodeToRestore.current.focus) {
                        ignoreNextEnforceFocus.current = true;
                        nodeToRestore.current.focus();
                    }
                    nodeToRestore.current = null;
                }
            };
        }, [
            open
        ]);
        reactExports.useEffect(()=>{
            if (!open || !rootRef.current) {
                return;
            }
            const doc = ownerDocument(rootRef.current);
            const loopFocus = (nativeEvent)=>{
                lastKeydown.current = nativeEvent;
                if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
                    return;
                }
                if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
                    ignoreNextEnforceFocus.current = true;
                    if (sentinelEnd.current) {
                        sentinelEnd.current.focus();
                    }
                }
            };
            const contain = ()=>{
                const rootElement = rootRef.current;
                if (rootElement === null) {
                    return;
                }
                if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
                    ignoreNextEnforceFocus.current = false;
                    return;
                }
                if (rootElement.contains(doc.activeElement)) {
                    return;
                }
                if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
                    return;
                }
                if (doc.activeElement !== reactFocusEventTarget.current) {
                    reactFocusEventTarget.current = null;
                } else if (reactFocusEventTarget.current !== null) {
                    return;
                }
                if (!activated.current) {
                    return;
                }
                let tabbable = [];
                if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
                    tabbable = getTabbable(rootRef.current);
                }
                if (tabbable.length > 0) {
                    const isShiftTab = Boolean(lastKeydown.current?.shiftKey && lastKeydown.current?.key === "Tab");
                    const focusNext = tabbable[0];
                    const focusPrevious = tabbable[tabbable.length - 1];
                    if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
                        if (isShiftTab) {
                            focusPrevious.focus();
                        } else {
                            focusNext.focus();
                        }
                    }
                } else {
                    rootElement.focus();
                }
            };
            doc.addEventListener("focusin", contain);
            doc.addEventListener("keydown", loopFocus, true);
            const interval = setInterval(()=>{
                if (doc.activeElement && doc.activeElement.tagName === "BODY") {
                    contain();
                }
            }, 50);
            return ()=>{
                clearInterval(interval);
                doc.removeEventListener("focusin", contain);
                doc.removeEventListener("keydown", loopFocus, true);
            };
        }, [
            disableAutoFocus,
            disableEnforceFocus,
            disableRestoreFocus,
            isEnabled,
            open,
            getTabbable
        ]);
        const onFocus = (event)=>{
            if (nodeToRestore.current === null) {
                nodeToRestore.current = event.relatedTarget;
            }
            activated.current = true;
            reactFocusEventTarget.current = event.target;
            const childrenPropsHandler = children.props.onFocus;
            if (childrenPropsHandler) {
                childrenPropsHandler(event);
            }
        };
        const handleFocusSentinel = (event)=>{
            if (nodeToRestore.current === null) {
                nodeToRestore.current = event.relatedTarget;
            }
            activated.current = true;
        };
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx("div", {
                    tabIndex: open ? 0 : -1,
                    onFocus: handleFocusSentinel,
                    ref: sentinelStart,
                    "data-testid": "sentinelStart"
                }),
                reactExports.cloneElement(children, {
                    ref: handleRef,
                    onFocus
                }),
                jsxRuntimeExports.jsx("div", {
                    tabIndex: open ? 0 : -1,
                    onFocus: handleFocusSentinel,
                    ref: sentinelEnd,
                    "data-testid": "sentinelEnd"
                })
            ]
        });
    }
    function getContainer(container) {
        return typeof container === 'function' ? container() : container;
    }
    function getHasTransition(children) {
        return children ? children.props.hasOwnProperty('in') : false;
    }
    const noop$2 = ()=>{};
    const manager = new ModalManager();
    function useModal(parameters) {
        const { container, disableEscapeKeyDown = false, disableScrollLock = false, closeAfterTransition = false, onTransitionEnter, onTransitionExited, children, onClose, open, rootRef } = parameters;
        const modal = reactExports.useRef({});
        const mountNodeRef = reactExports.useRef(null);
        const modalRef = reactExports.useRef(null);
        const handleRef = useForkRef(modalRef, rootRef);
        const [exited, setExited] = reactExports.useState(!open);
        const hasTransition = getHasTransition(children);
        let ariaHiddenProp = true;
        if (parameters['aria-hidden'] === 'false' || parameters['aria-hidden'] === false) {
            ariaHiddenProp = false;
        }
        const getDoc = ()=>ownerDocument(mountNodeRef.current);
        const getModal = ()=>{
            modal.current.modalRef = modalRef.current;
            modal.current.mount = mountNodeRef.current;
            return modal.current;
        };
        const handleMounted = ()=>{
            manager.mount(getModal(), {
                disableScrollLock
            });
            if (modalRef.current) {
                modalRef.current.scrollTop = 0;
            }
        };
        const handleOpen = useEventCallback(()=>{
            const resolvedContainer = getContainer(container) || getDoc().body;
            manager.add(getModal(), resolvedContainer);
            if (modalRef.current) {
                handleMounted();
            }
        });
        const isTopModal = ()=>manager.isTopModal(getModal());
        const handlePortalRef = useEventCallback((node)=>{
            mountNodeRef.current = node;
            if (!node) {
                return;
            }
            if (open && isTopModal()) {
                handleMounted();
            } else if (modalRef.current) {
                ariaHidden(modalRef.current, ariaHiddenProp);
            }
        });
        const handleClose = reactExports.useCallback(()=>{
            manager.remove(getModal(), ariaHiddenProp);
        }, [
            ariaHiddenProp
        ]);
        reactExports.useEffect(()=>{
            return ()=>{
                handleClose();
            };
        }, [
            handleClose
        ]);
        reactExports.useEffect(()=>{
            if (open) {
                handleOpen();
            } else if (!hasTransition || !closeAfterTransition) {
                handleClose();
            }
        }, [
            open,
            handleClose,
            hasTransition,
            closeAfterTransition,
            handleOpen
        ]);
        const createHandleKeyDown = (otherHandlers)=>(event)=>{
                otherHandlers.onKeyDown?.(event);
                if (event.key !== 'Escape' || event.which === 229 || !isTopModal()) {
                    return;
                }
                if (!disableEscapeKeyDown) {
                    event.stopPropagation();
                    if (onClose) {
                        onClose(event, 'escapeKeyDown');
                    }
                }
            };
        const createHandleBackdropClick = (otherHandlers)=>(event)=>{
                otherHandlers.onClick?.(event);
                if (event.target !== event.currentTarget) {
                    return;
                }
                if (onClose) {
                    onClose(event, 'backdropClick');
                }
            };
        const getRootProps = (otherHandlers = {})=>{
            const propsEventHandlers = extractEventHandlers(parameters);
            delete propsEventHandlers.onTransitionEnter;
            delete propsEventHandlers.onTransitionExited;
            const externalEventHandlers = {
                ...propsEventHandlers,
                ...otherHandlers
            };
            return {
                role: 'presentation',
                ...externalEventHandlers,
                onKeyDown: createHandleKeyDown(externalEventHandlers),
                ref: handleRef
            };
        };
        const getBackdropProps = (otherHandlers = {})=>{
            const externalEventHandlers = otherHandlers;
            return {
                'aria-hidden': true,
                ...externalEventHandlers,
                onClick: createHandleBackdropClick(externalEventHandlers),
                open
            };
        };
        const getTransitionProps = ()=>{
            const handleEnter = ()=>{
                setExited(false);
                if (onTransitionEnter) {
                    onTransitionEnter();
                }
            };
            const handleExited = ()=>{
                setExited(true);
                if (onTransitionExited) {
                    onTransitionExited();
                }
                if (closeAfterTransition) {
                    handleClose();
                }
            };
            return {
                onEnter: createChainedFunction(handleEnter, children?.props.onEnter ?? noop$2),
                onExited: createChainedFunction(handleExited, children?.props.onExited ?? noop$2)
            };
        };
        return {
            getRootProps,
            getBackdropProps,
            getTransitionProps,
            rootRef: handleRef,
            portalRef: handlePortalRef,
            isTopModal,
            exited,
            hasTransition
        };
    }
    function getModalUtilityClass(slot) {
        return generateUtilityClass('MuiModal', slot);
    }
    generateUtilityClasses('MuiModal', [
        'root',
        'hidden',
        'backdrop'
    ]);
    const useUtilityClasses$m = (ownerState)=>{
        const { open, exited, classes } = ownerState;
        const slots = {
            root: [
                "root",
                !open && exited && "hidden"
            ],
            backdrop: [
                "backdrop"
            ]
        };
        return composeClasses(slots, getModalUtilityClass, classes);
    };
    const ModalRoot = styled("div", {
        name: "MuiModal",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                !ownerState.open && ownerState.exited && styles.hidden
            ];
        }
    })(memoTheme(({ theme })=>({
            position: "fixed",
            zIndex: (theme.vars || theme).zIndex.modal,
            right: 0,
            bottom: 0,
            top: 0,
            left: 0,
            variants: [
                {
                    props: ({ ownerState })=>!ownerState.open && ownerState.exited,
                    style: {
                        visibility: "hidden"
                    }
                }
            ]
        })));
    const ModalBackdrop = styled(Backdrop, {
        name: "MuiModal",
        slot: "Backdrop"
    })({
        zIndex: -1
    });
    const Modal = reactExports.forwardRef(function Modal2(inProps, ref) {
        const props = useDefaultProps({
            name: "MuiModal",
            props: inProps
        });
        const { BackdropComponent = ModalBackdrop, BackdropProps, classes: classesProp, className, closeAfterTransition = false, children, container, component, components = {}, componentsProps = {}, disableAutoFocus = false, disableEnforceFocus = false, disableEscapeKeyDown = false, disablePortal = false, disableRestoreFocus = false, disableScrollLock = false, hideBackdrop = false, keepMounted = false, onClose, onTransitionEnter, onTransitionExited, open, slotProps = {}, slots = {}, theme, ...other } = props;
        const propsWithDefaults = {
            ...props,
            closeAfterTransition,
            disableAutoFocus,
            disableEnforceFocus,
            disableEscapeKeyDown,
            disablePortal,
            disableRestoreFocus,
            disableScrollLock,
            hideBackdrop,
            keepMounted
        };
        const { getRootProps, getBackdropProps, getTransitionProps, portalRef, isTopModal, exited, hasTransition } = useModal({
            ...propsWithDefaults,
            rootRef: ref
        });
        const ownerState = {
            ...propsWithDefaults,
            exited
        };
        const classes = useUtilityClasses$m(ownerState);
        const childProps = {};
        if (children.props.tabIndex === void 0) {
            childProps.tabIndex = "-1";
        }
        if (hasTransition) {
            const { onEnter, onExited } = getTransitionProps();
            childProps.onEnter = onEnter;
            childProps.onExited = onExited;
        }
        const externalForwardedProps = {
            slots: {
                root: components.Root,
                backdrop: components.Backdrop,
                ...slots
            },
            slotProps: {
                ...componentsProps,
                ...slotProps
            }
        };
        const [RootSlot, rootProps] = useSlot("root", {
            ref,
            elementType: ModalRoot,
            externalForwardedProps: {
                ...externalForwardedProps,
                ...other,
                component
            },
            getSlotProps: getRootProps,
            ownerState,
            className: clsx(className, classes?.root, !ownerState.open && ownerState.exited && classes?.hidden)
        });
        const [BackdropSlot, backdropProps] = useSlot("backdrop", {
            ref: BackdropProps?.ref,
            elementType: BackdropComponent,
            externalForwardedProps,
            shouldForwardComponentProp: true,
            additionalProps: BackdropProps,
            getSlotProps: (otherHandlers)=>{
                return getBackdropProps({
                    ...otherHandlers,
                    onClick: (event)=>{
                        if (otherHandlers?.onClick) {
                            otherHandlers.onClick(event);
                        }
                    }
                });
            },
            className: clsx(BackdropProps?.className, classes?.backdrop),
            ownerState
        });
        if (!keepMounted && !open && (!hasTransition || exited)) {
            return null;
        }
        return jsxRuntimeExports.jsx(Portal, {
            ref: portalRef,
            container,
            disablePortal,
            children: jsxRuntimeExports.jsxs(RootSlot, {
                ...rootProps,
                children: [
                    !hideBackdrop && BackdropComponent ? jsxRuntimeExports.jsx(BackdropSlot, {
                        ...backdropProps
                    }) : null,
                    jsxRuntimeExports.jsx(FocusTrap, {
                        disableEnforceFocus,
                        disableAutoFocus,
                        disableRestoreFocus,
                        isEnabled: isTopModal,
                        open,
                        children: reactExports.cloneElement(children, childProps)
                    })
                ]
            })
        });
    });
    function getDialogUtilityClass(slot) {
        return generateUtilityClass('MuiDialog', slot);
    }
    const dialogClasses = generateUtilityClasses('MuiDialog', [
        'root',
        'scrollPaper',
        'scrollBody',
        'container',
        'paper',
        'paperScrollPaper',
        'paperScrollBody',
        'paperWidthFalse',
        'paperWidthXs',
        'paperWidthSm',
        'paperWidthMd',
        'paperWidthLg',
        'paperWidthXl',
        'paperFullWidth',
        'paperFullScreen'
    ]);
    const DialogContext = reactExports.createContext({});
    const DialogBackdrop = styled(Backdrop, {
        name: "MuiDialog",
        slot: "Backdrop",
        overrides: (props, styles)=>styles.backdrop
    })({
        zIndex: -1
    });
    const useUtilityClasses$l = (ownerState)=>{
        const { classes, scroll, maxWidth, fullWidth, fullScreen } = ownerState;
        const slots = {
            root: [
                "root"
            ],
            container: [
                "container",
                `scroll${capitalize(scroll)}`
            ],
            paper: [
                "paper",
                `paperScroll${capitalize(scroll)}`,
                `paperWidth${capitalize(String(maxWidth))}`,
                fullWidth && "paperFullWidth",
                fullScreen && "paperFullScreen"
            ]
        };
        return composeClasses(slots, getDialogUtilityClass, classes);
    };
    const DialogRoot = styled(Modal, {
        name: "MuiDialog",
        slot: "Root"
    })({
        "@media print": {
            position: "absolute !important"
        }
    });
    const DialogContainer = styled("div", {
        name: "MuiDialog",
        slot: "Container",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.container,
                styles[`scroll${capitalize(ownerState.scroll)}`]
            ];
        }
    })({
        height: "100%",
        "@media print": {
            height: "auto"
        },
        outline: 0,
        variants: [
            {
                props: {
                    scroll: "paper"
                },
                style: {
                    display: "flex",
                    justifyContent: "center",
                    alignItems: "center"
                }
            },
            {
                props: {
                    scroll: "body"
                },
                style: {
                    overflowY: "auto",
                    overflowX: "hidden",
                    textAlign: "center",
                    "&::after": {
                        content: '""',
                        display: "inline-block",
                        verticalAlign: "middle",
                        height: "100%",
                        width: "0"
                    }
                }
            }
        ]
    });
    const DialogPaper = styled(Paper, {
        name: "MuiDialog",
        slot: "Paper",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.paper,
                styles[`scrollPaper${capitalize(ownerState.scroll)}`],
                styles[`paperWidth${capitalize(String(ownerState.maxWidth))}`],
                ownerState.fullWidth && styles.paperFullWidth,
                ownerState.fullScreen && styles.paperFullScreen
            ];
        }
    })(memoTheme(({ theme })=>({
            margin: 32,
            position: "relative",
            overflowY: "auto",
            "@media print": {
                overflowY: "visible",
                boxShadow: "none"
            },
            variants: [
                {
                    props: {
                        scroll: "paper"
                    },
                    style: {
                        display: "flex",
                        flexDirection: "column",
                        maxHeight: "calc(100% - 64px)"
                    }
                },
                {
                    props: {
                        scroll: "body"
                    },
                    style: {
                        display: "inline-block",
                        verticalAlign: "middle",
                        textAlign: "initial"
                    }
                },
                {
                    props: ({ ownerState })=>!ownerState.maxWidth,
                    style: {
                        maxWidth: "calc(100% - 64px)"
                    }
                },
                {
                    props: {
                        maxWidth: "xs"
                    },
                    style: {
                        maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
                        [`&.${dialogClasses.paperScrollBody}`]: {
                            [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
                                maxWidth: "calc(100% - 64px)"
                            }
                        }
                    }
                },
                ...Object.keys(theme.breakpoints.values).filter((maxWidth)=>maxWidth !== "xs").map((maxWidth)=>({
                        props: {
                            maxWidth
                        },
                        style: {
                            maxWidth: `${theme.breakpoints.values[maxWidth]}${theme.breakpoints.unit}`,
                            [`&.${dialogClasses.paperScrollBody}`]: {
                                [theme.breakpoints.down(theme.breakpoints.values[maxWidth] + 32 * 2)]: {
                                    maxWidth: "calc(100% - 64px)"
                                }
                            }
                        }
                    })),
                {
                    props: ({ ownerState })=>ownerState.fullWidth,
                    style: {
                        width: "calc(100% - 64px)"
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.fullScreen,
                    style: {
                        margin: 0,
                        width: "100%",
                        maxWidth: "100%",
                        height: "100%",
                        maxHeight: "none",
                        borderRadius: 0,
                        [`&.${dialogClasses.paperScrollBody}`]: {
                            margin: 0,
                            maxWidth: "100%"
                        }
                    }
                }
            ]
        })));
    const Dialog = reactExports.forwardRef(function Dialog2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiDialog"
        });
        const theme = useTheme();
        const defaultTransitionDuration = {
            enter: theme.transitions.duration.enteringScreen,
            exit: theme.transitions.duration.leavingScreen
        };
        const { "aria-describedby": ariaDescribedby, "aria-labelledby": ariaLabelledbyProp, "aria-modal": ariaModal = true, BackdropComponent, BackdropProps, children, className, disableEscapeKeyDown = false, fullScreen = false, fullWidth = false, maxWidth = "sm", onClick, onClose, open, PaperComponent = Paper, PaperProps = {}, scroll = "paper", slots = {}, slotProps = {}, TransitionComponent = Fade, transitionDuration = defaultTransitionDuration, TransitionProps, ...other } = props;
        const ownerState = {
            ...props,
            disableEscapeKeyDown,
            fullScreen,
            fullWidth,
            maxWidth,
            scroll
        };
        const classes = useUtilityClasses$l(ownerState);
        const backdropClick = reactExports.useRef();
        const handleMouseDown = (event)=>{
            backdropClick.current = event.target === event.currentTarget;
        };
        const handleBackdropClick = (event)=>{
            if (onClick) {
                onClick(event);
            }
            if (!backdropClick.current) {
                return;
            }
            backdropClick.current = null;
            if (onClose) {
                onClose(event, "backdropClick");
            }
        };
        const ariaLabelledby = useId(ariaLabelledbyProp);
        const dialogContextValue = reactExports.useMemo(()=>{
            return {
                titleId: ariaLabelledby
            };
        }, [
            ariaLabelledby
        ]);
        const backwardCompatibleSlots = {
            transition: TransitionComponent,
            ...slots
        };
        const backwardCompatibleSlotProps = {
            transition: TransitionProps,
            paper: PaperProps,
            backdrop: BackdropProps,
            ...slotProps
        };
        const externalForwardedProps = {
            slots: backwardCompatibleSlots,
            slotProps: backwardCompatibleSlotProps
        };
        const [RootSlot, rootSlotProps] = useSlot("root", {
            elementType: DialogRoot,
            shouldForwardComponentProp: true,
            externalForwardedProps,
            ownerState,
            className: clsx(classes.root, className),
            ref
        });
        const [BackdropSlot, backdropSlotProps] = useSlot("backdrop", {
            elementType: DialogBackdrop,
            shouldForwardComponentProp: true,
            externalForwardedProps,
            ownerState
        });
        const [PaperSlot, paperSlotProps] = useSlot("paper", {
            elementType: DialogPaper,
            shouldForwardComponentProp: true,
            externalForwardedProps,
            ownerState,
            className: clsx(classes.paper, PaperProps.className)
        });
        const [ContainerSlot, containerSlotProps] = useSlot("container", {
            elementType: DialogContainer,
            externalForwardedProps,
            ownerState,
            className: classes.container
        });
        const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
            elementType: Fade,
            externalForwardedProps,
            ownerState,
            additionalProps: {
                appear: true,
                in: open,
                timeout: transitionDuration,
                role: "presentation"
            }
        });
        return jsxRuntimeExports.jsx(RootSlot, {
            closeAfterTransition: true,
            slots: {
                backdrop: BackdropSlot
            },
            slotProps: {
                backdrop: {
                    transitionDuration,
                    as: BackdropComponent,
                    ...backdropSlotProps
                }
            },
            disableEscapeKeyDown,
            onClose,
            open,
            onClick: handleBackdropClick,
            ...rootSlotProps,
            ...other,
            children: jsxRuntimeExports.jsx(TransitionSlot, {
                ...transitionSlotProps,
                children: jsxRuntimeExports.jsx(ContainerSlot, {
                    onMouseDown: handleMouseDown,
                    ...containerSlotProps,
                    children: jsxRuntimeExports.jsx(PaperSlot, {
                        as: PaperComponent,
                        elevation: 24,
                        role: "dialog",
                        "aria-describedby": ariaDescribedby,
                        "aria-labelledby": ariaLabelledby,
                        "aria-modal": ariaModal,
                        ...paperSlotProps,
                        children: jsxRuntimeExports.jsx(DialogContext.Provider, {
                            value: dialogContextValue,
                            children
                        })
                    })
                })
            })
        });
    });
    function getDialogActionsUtilityClass(slot) {
        return generateUtilityClass('MuiDialogActions', slot);
    }
    generateUtilityClasses('MuiDialogActions', [
        'root',
        'spacing'
    ]);
    const useUtilityClasses$k = (ownerState)=>{
        const { classes, disableSpacing } = ownerState;
        const slots = {
            root: [
                "root",
                !disableSpacing && "spacing"
            ]
        };
        return composeClasses(slots, getDialogActionsUtilityClass, classes);
    };
    const DialogActionsRoot = styled("div", {
        name: "MuiDialogActions",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                !ownerState.disableSpacing && styles.spacing
            ];
        }
    })({
        display: "flex",
        alignItems: "center",
        padding: 8,
        justifyContent: "flex-end",
        flex: "0 0 auto",
        variants: [
            {
                props: ({ ownerState })=>!ownerState.disableSpacing,
                style: {
                    "& > :not(style) ~ :not(style)": {
                        marginLeft: 8
                    }
                }
            }
        ]
    });
    const DialogActions = reactExports.forwardRef(function DialogActions2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiDialogActions"
        });
        const { className, disableSpacing = false, ...other } = props;
        const ownerState = {
            ...props,
            disableSpacing
        };
        const classes = useUtilityClasses$k(ownerState);
        return jsxRuntimeExports.jsx(DialogActionsRoot, {
            className: clsx(classes.root, className),
            ownerState,
            ref,
            ...other
        });
    });
    function getDialogContentUtilityClass(slot) {
        return generateUtilityClass('MuiDialogContent', slot);
    }
    generateUtilityClasses('MuiDialogContent', [
        'root',
        'dividers'
    ]);
    function getDialogTitleUtilityClass(slot) {
        return generateUtilityClass('MuiDialogTitle', slot);
    }
    const dialogTitleClasses = generateUtilityClasses('MuiDialogTitle', [
        'root'
    ]);
    const useUtilityClasses$j = (ownerState)=>{
        const { classes, dividers } = ownerState;
        const slots = {
            root: [
                "root",
                dividers && "dividers"
            ]
        };
        return composeClasses(slots, getDialogContentUtilityClass, classes);
    };
    const DialogContentRoot = styled("div", {
        name: "MuiDialogContent",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.dividers && styles.dividers
            ];
        }
    })(memoTheme(({ theme })=>({
            flex: "1 1 auto",
            WebkitOverflowScrolling: "touch",
            overflowY: "auto",
            padding: "20px 24px",
            variants: [
                {
                    props: ({ ownerState })=>ownerState.dividers,
                    style: {
                        padding: "16px 24px",
                        borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
                        borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
                    }
                },
                {
                    props: ({ ownerState })=>!ownerState.dividers,
                    style: {
                        [`.${dialogTitleClasses.root} + &`]: {
                            paddingTop: 0
                        }
                    }
                }
            ]
        })));
    const DialogContent = reactExports.forwardRef(function DialogContent2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiDialogContent"
        });
        const { className, dividers = false, ...other } = props;
        const ownerState = {
            ...props,
            dividers
        };
        const classes = useUtilityClasses$j(ownerState);
        return jsxRuntimeExports.jsx(DialogContentRoot, {
            className: clsx(classes.root, className),
            ownerState,
            ref,
            ...other
        });
    });
    const useUtilityClasses$i = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ]
        };
        return composeClasses(slots, getDialogTitleUtilityClass, classes);
    };
    const DialogTitleRoot = styled(Typography, {
        name: "MuiDialogTitle",
        slot: "Root"
    })({
        padding: "16px 24px",
        flex: "0 0 auto"
    });
    const DialogTitle = reactExports.forwardRef(function DialogTitle2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiDialogTitle"
        });
        const { className, id: idProp, ...other } = props;
        const ownerState = props;
        const classes = useUtilityClasses$i(ownerState);
        const { titleId = idProp } = reactExports.useContext(DialogContext);
        return jsxRuntimeExports.jsx(DialogTitleRoot, {
            component: "h2",
            className: clsx(classes.root, className),
            ownerState,
            ref,
            variant: "h6",
            id: idProp ?? titleId,
            ...other
        });
    });
    function getDividerUtilityClass(slot) {
        return generateUtilityClass('MuiDivider', slot);
    }
    generateUtilityClasses('MuiDivider', [
        'root',
        'absolute',
        'fullWidth',
        'inset',
        'middle',
        'flexItem',
        'light',
        'vertical',
        'withChildren',
        'withChildrenVertical',
        'textAlignRight',
        'textAlignLeft',
        'wrapper',
        'wrapperVertical'
    ]);
    const useUtilityClasses$h = (ownerState)=>{
        const { absolute, children, classes, flexItem, light, orientation, textAlign, variant } = ownerState;
        const slots = {
            root: [
                "root",
                absolute && "absolute",
                variant,
                light && "light",
                orientation === "vertical" && "vertical",
                flexItem && "flexItem",
                children && "withChildren",
                children && orientation === "vertical" && "withChildrenVertical",
                textAlign === "right" && orientation !== "vertical" && "textAlignRight",
                textAlign === "left" && orientation !== "vertical" && "textAlignLeft"
            ],
            wrapper: [
                "wrapper",
                orientation === "vertical" && "wrapperVertical"
            ]
        };
        return composeClasses(slots, getDividerUtilityClass, classes);
    };
    const DividerRoot = styled("div", {
        name: "MuiDivider",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.absolute && styles.absolute,
                styles[ownerState.variant],
                ownerState.light && styles.light,
                ownerState.orientation === "vertical" && styles.vertical,
                ownerState.flexItem && styles.flexItem,
                ownerState.children && styles.withChildren,
                ownerState.children && ownerState.orientation === "vertical" && styles.withChildrenVertical,
                ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles.textAlignRight,
                ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles.textAlignLeft
            ];
        }
    })(memoTheme(({ theme })=>({
            margin: 0,
            flexShrink: 0,
            borderWidth: 0,
            borderStyle: "solid",
            borderColor: (theme.vars || theme).palette.divider,
            borderBottomWidth: "thin",
            variants: [
                {
                    props: {
                        absolute: true
                    },
                    style: {
                        position: "absolute",
                        bottom: 0,
                        left: 0,
                        width: "100%"
                    }
                },
                {
                    props: {
                        light: true
                    },
                    style: {
                        borderColor: theme.alpha((theme.vars || theme).palette.divider, 0.08)
                    }
                },
                {
                    props: {
                        variant: "inset"
                    },
                    style: {
                        marginLeft: 72
                    }
                },
                {
                    props: {
                        variant: "middle",
                        orientation: "horizontal"
                    },
                    style: {
                        marginLeft: theme.spacing(2),
                        marginRight: theme.spacing(2)
                    }
                },
                {
                    props: {
                        variant: "middle",
                        orientation: "vertical"
                    },
                    style: {
                        marginTop: theme.spacing(1),
                        marginBottom: theme.spacing(1)
                    }
                },
                {
                    props: {
                        orientation: "vertical"
                    },
                    style: {
                        height: "100%",
                        borderBottomWidth: 0,
                        borderRightWidth: "thin"
                    }
                },
                {
                    props: {
                        flexItem: true
                    },
                    style: {
                        alignSelf: "stretch",
                        height: "auto"
                    }
                },
                {
                    props: ({ ownerState })=>!!ownerState.children,
                    style: {
                        display: "flex",
                        textAlign: "center",
                        border: 0,
                        borderTopStyle: "solid",
                        borderLeftStyle: "solid",
                        "&::before, &::after": {
                            content: '""',
                            alignSelf: "center"
                        }
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.children && ownerState.orientation !== "vertical",
                    style: {
                        "&::before, &::after": {
                            width: "100%",
                            borderTop: `thin solid ${(theme.vars || theme).palette.divider}`,
                            borderTopStyle: "inherit"
                        }
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.orientation === "vertical" && ownerState.children,
                    style: {
                        flexDirection: "column",
                        "&::before, &::after": {
                            height: "100%",
                            borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`,
                            borderLeftStyle: "inherit"
                        }
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.textAlign === "right" && ownerState.orientation !== "vertical",
                    style: {
                        "&::before": {
                            width: "90%"
                        },
                        "&::after": {
                            width: "10%"
                        }
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.textAlign === "left" && ownerState.orientation !== "vertical",
                    style: {
                        "&::before": {
                            width: "10%"
                        },
                        "&::after": {
                            width: "90%"
                        }
                    }
                }
            ]
        })));
    const DividerWrapper = styled("span", {
        name: "MuiDivider",
        slot: "Wrapper",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.wrapper,
                ownerState.orientation === "vertical" && styles.wrapperVertical
            ];
        }
    })(memoTheme(({ theme })=>({
            display: "inline-block",
            paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,
            paddingRight: `calc(${theme.spacing(1)} * 1.2)`,
            whiteSpace: "nowrap",
            variants: [
                {
                    props: {
                        orientation: "vertical"
                    },
                    style: {
                        paddingTop: `calc(${theme.spacing(1)} * 1.2)`,
                        paddingBottom: `calc(${theme.spacing(1)} * 1.2)`
                    }
                }
            ]
        })));
    const Divider = reactExports.forwardRef(function Divider2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiDivider"
        });
        const { absolute = false, children, className, orientation = "horizontal", component = children || orientation === "vertical" ? "div" : "hr", flexItem = false, light = false, role = component !== "hr" ? "separator" : void 0, textAlign = "center", variant = "fullWidth", ...other } = props;
        const ownerState = {
            ...props,
            absolute,
            component,
            flexItem,
            light,
            orientation,
            role,
            textAlign,
            variant
        };
        const classes = useUtilityClasses$h(ownerState);
        return jsxRuntimeExports.jsx(DividerRoot, {
            as: component,
            className: clsx(classes.root, className),
            role,
            ref,
            ownerState,
            "aria-orientation": role === "separator" && (component !== "hr" || orientation === "vertical") ? orientation : void 0,
            ...other,
            children: children ? jsxRuntimeExports.jsx(DividerWrapper, {
                className: classes.wrapper,
                ownerState,
                children
            }) : null
        });
    });
    if (Divider) {
        Divider.muiSkipListHighlight = true;
    }
    function getFabUtilityClass(slot) {
        return generateUtilityClass('MuiFab', slot);
    }
    const fabClasses = generateUtilityClasses('MuiFab', [
        'root',
        'primary',
        'secondary',
        'extended',
        'circular',
        'focusVisible',
        'disabled',
        'colorInherit',
        'sizeSmall',
        'sizeMedium',
        'sizeLarge',
        'info',
        'error',
        'warning',
        'success'
    ]);
    const useUtilityClasses$g = (ownerState)=>{
        const { color, variant, classes, size } = ownerState;
        const slots = {
            root: [
                "root",
                variant,
                `size${capitalize(size)}`,
                color === "inherit" ? "colorInherit" : color
            ]
        };
        const composedClasses = composeClasses(slots, getFabUtilityClass, classes);
        return {
            ...classes,
            ...composedClasses
        };
    };
    const FabRoot = styled(ButtonBase, {
        name: "MuiFab",
        slot: "Root",
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) || prop === "classes",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[ownerState.variant],
                styles[`size${capitalize(ownerState.size)}`],
                ownerState.color === "inherit" && styles.colorInherit,
                styles[capitalize(ownerState.size)],
                styles[ownerState.color]
            ];
        }
    })(memoTheme(({ theme })=>({
            ...theme.typography.button,
            minHeight: 36,
            transition: theme.transitions.create([
                "background-color",
                "box-shadow",
                "border-color"
            ], {
                duration: theme.transitions.duration.short
            }),
            borderRadius: "50%",
            padding: 0,
            minWidth: 0,
            width: 56,
            height: 56,
            zIndex: (theme.vars || theme).zIndex.fab,
            boxShadow: (theme.vars || theme).shadows[6],
            "&:active": {
                boxShadow: (theme.vars || theme).shadows[12]
            },
            color: theme.vars ? theme.vars.palette.grey[900] : theme.palette.getContrastText?.(theme.palette.grey[300]),
            backgroundColor: (theme.vars || theme).palette.grey[300],
            "&:hover": {
                backgroundColor: (theme.vars || theme).palette.grey.A100,
                "@media (hover: none)": {
                    backgroundColor: (theme.vars || theme).palette.grey[300]
                },
                textDecoration: "none"
            },
            [`&.${fabClasses.focusVisible}`]: {
                boxShadow: (theme.vars || theme).shadows[6]
            },
            variants: [
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        width: 40,
                        height: 40
                    }
                },
                {
                    props: {
                        size: "medium"
                    },
                    style: {
                        width: 48,
                        height: 48
                    }
                },
                {
                    props: {
                        variant: "extended"
                    },
                    style: {
                        borderRadius: 48 / 2,
                        padding: "0 16px",
                        width: "auto",
                        minHeight: "auto",
                        minWidth: 48,
                        height: 48
                    }
                },
                {
                    props: {
                        variant: "extended",
                        size: "small"
                    },
                    style: {
                        width: "auto",
                        padding: "0 8px",
                        borderRadius: 34 / 2,
                        minWidth: 34,
                        height: 34
                    }
                },
                {
                    props: {
                        variant: "extended",
                        size: "medium"
                    },
                    style: {
                        width: "auto",
                        padding: "0 16px",
                        borderRadius: 40 / 2,
                        minWidth: 40,
                        height: 40
                    }
                },
                {
                    props: {
                        color: "inherit"
                    },
                    style: {
                        color: "inherit"
                    }
                }
            ]
        })), memoTheme(({ theme })=>({
            variants: [
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter([
                    "dark",
                    "contrastText"
                ])).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            color: (theme.vars || theme).palette[color].contrastText,
                            backgroundColor: (theme.vars || theme).palette[color].main,
                            "&:hover": {
                                backgroundColor: (theme.vars || theme).palette[color].dark,
                                "@media (hover: none)": {
                                    backgroundColor: (theme.vars || theme).palette[color].main
                                }
                            }
                        }
                    }))
            ]
        })), memoTheme(({ theme })=>({
            [`&.${fabClasses.disabled}`]: {
                color: (theme.vars || theme).palette.action.disabled,
                boxShadow: (theme.vars || theme).shadows[0],
                backgroundColor: (theme.vars || theme).palette.action.disabledBackground
            }
        })));
    const Fab = reactExports.forwardRef(function Fab2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiFab"
        });
        const { children, className, color = "default", component = "button", disabled = false, disableFocusRipple = false, focusVisibleClassName, size = "large", variant = "circular", ...other } = props;
        const ownerState = {
            ...props,
            color,
            component,
            disabled,
            disableFocusRipple,
            size,
            variant
        };
        const classes = useUtilityClasses$g(ownerState);
        return jsxRuntimeExports.jsx(FabRoot, {
            className: clsx(classes.root, className),
            component,
            disabled,
            focusRipple: !disableFocusRipple,
            focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
            ownerState,
            ref,
            ...other,
            classes,
            children
        });
    });
    const useUtilityClasses$f = (ownerState)=>{
        const { classes, disableUnderline, startAdornment, endAdornment, size, hiddenLabel, multiline } = ownerState;
        const slots = {
            root: [
                "root",
                !disableUnderline && "underline",
                startAdornment && "adornedStart",
                endAdornment && "adornedEnd",
                size === "small" && `size${capitalize(size)}`,
                hiddenLabel && "hiddenLabel",
                multiline && "multiline"
            ],
            input: [
                "input"
            ]
        };
        const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
        return {
            ...classes,
            ...composedClasses
        };
    };
    const FilledInputRoot = styled(InputBaseRoot, {
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) || prop === "classes",
        name: "MuiFilledInput",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                ...rootOverridesResolver(props, styles),
                !ownerState.disableUnderline && styles.underline
            ];
        }
    })(memoTheme(({ theme })=>{
        const light = theme.palette.mode === "light";
        const bottomLineColor = light ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
        const backgroundColor = light ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
        const hoverBackground = light ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
        const disabledBackground = light ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
        return {
            position: "relative",
            backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor,
            borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
            borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
            transition: theme.transitions.create("background-color", {
                duration: theme.transitions.duration.shorter,
                easing: theme.transitions.easing.easeOut
            }),
            "&:hover": {
                backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
                "@media (hover: none)": {
                    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor
                }
            },
            [`&.${filledInputClasses.focused}`]: {
                backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor
            },
            [`&.${filledInputClasses.disabled}`]: {
                backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
            },
            variants: [
                {
                    props: ({ ownerState })=>!ownerState.disableUnderline,
                    style: {
                        "&::after": {
                            left: 0,
                            bottom: 0,
                            content: '""',
                            position: "absolute",
                            right: 0,
                            transform: "scaleX(0)",
                            transition: theme.transitions.create("transform", {
                                duration: theme.transitions.duration.shorter,
                                easing: theme.transitions.easing.easeOut
                            }),
                            pointerEvents: "none"
                        },
                        [`&.${filledInputClasses.focused}:after`]: {
                            transform: "scaleX(1) translateX(0)"
                        },
                        [`&.${filledInputClasses.error}`]: {
                            "&::before, &::after": {
                                borderBottomColor: (theme.vars || theme).palette.error.main
                            }
                        },
                        "&::before": {
                            borderBottom: `1px solid ${theme.vars ? theme.alpha(theme.vars.palette.common.onBackground, theme.vars.opacity.inputUnderline) : bottomLineColor}`,
                            left: 0,
                            bottom: 0,
                            content: '"\\00a0"',
                            position: "absolute",
                            right: 0,
                            transition: theme.transitions.create("border-bottom-color", {
                                duration: theme.transitions.duration.shorter
                            }),
                            pointerEvents: "none"
                        },
                        [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
                            borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
                        },
                        [`&.${filledInputClasses.disabled}:before`]: {
                            borderBottomStyle: "dotted"
                        }
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            disableUnderline: false,
                            color
                        },
                        style: {
                            "&::after": {
                                borderBottom: `2px solid ${(theme.vars || theme).palette[color]?.main}`
                            }
                        }
                    })),
                {
                    props: ({ ownerState })=>ownerState.startAdornment,
                    style: {
                        paddingLeft: 12
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.endAdornment,
                    style: {
                        paddingRight: 12
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.multiline,
                    style: {
                        padding: "25px 12px 8px"
                    }
                },
                {
                    props: ({ ownerState, size })=>ownerState.multiline && size === "small",
                    style: {
                        paddingTop: 21,
                        paddingBottom: 4
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.multiline && ownerState.hiddenLabel,
                    style: {
                        paddingTop: 16,
                        paddingBottom: 17
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.multiline && ownerState.hiddenLabel && ownerState.size === "small",
                    style: {
                        paddingTop: 8,
                        paddingBottom: 9
                    }
                }
            ]
        };
    }));
    const FilledInputInput = styled(InputBaseInput, {
        name: "MuiFilledInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })(memoTheme(({ theme })=>({
            paddingTop: 25,
            paddingRight: 12,
            paddingBottom: 8,
            paddingLeft: 12,
            ...!theme.vars && {
                "&:-webkit-autofill": {
                    WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
                    WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
                    caretColor: theme.palette.mode === "light" ? null : "#fff",
                    borderTopLeftRadius: "inherit",
                    borderTopRightRadius: "inherit"
                }
            },
            ...theme.vars && {
                "&:-webkit-autofill": {
                    borderTopLeftRadius: "inherit",
                    borderTopRightRadius: "inherit"
                },
                [theme.getColorSchemeSelector("dark")]: {
                    "&:-webkit-autofill": {
                        WebkitBoxShadow: "0 0 0 100px #266798 inset",
                        WebkitTextFillColor: "#fff",
                        caretColor: "#fff"
                    }
                }
            },
            variants: [
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        paddingTop: 21,
                        paddingBottom: 4
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.hiddenLabel,
                    style: {
                        paddingTop: 16,
                        paddingBottom: 17
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.startAdornment,
                    style: {
                        paddingLeft: 0
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.endAdornment,
                    style: {
                        paddingRight: 0
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.hiddenLabel && ownerState.size === "small",
                    style: {
                        paddingTop: 8,
                        paddingBottom: 9
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.multiline,
                    style: {
                        paddingTop: 0,
                        paddingBottom: 0,
                        paddingLeft: 0,
                        paddingRight: 0
                    }
                }
            ]
        })));
    const FilledInput = reactExports.forwardRef(function FilledInput2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiFilledInput"
        });
        const { disableUnderline = false, components = {}, componentsProps: componentsPropsProp, fullWidth = false, hiddenLabel, inputComponent = "input", multiline = false, slotProps, slots = {}, type = "text", ...other } = props;
        const ownerState = {
            ...props,
            disableUnderline,
            fullWidth,
            inputComponent,
            multiline,
            type
        };
        const classes = useUtilityClasses$f(props);
        const filledInputComponentsProps = {
            root: {
                ownerState
            },
            input: {
                ownerState
            }
        };
        const componentsProps = slotProps ?? componentsPropsProp ? deepmerge(filledInputComponentsProps, slotProps ?? componentsPropsProp) : filledInputComponentsProps;
        const RootSlot = slots.root ?? components.Root ?? FilledInputRoot;
        const InputSlot = slots.input ?? components.Input ?? FilledInputInput;
        return jsxRuntimeExports.jsx(InputBase, {
            slots: {
                root: RootSlot,
                input: InputSlot
            },
            slotProps: componentsProps,
            fullWidth,
            inputComponent,
            multiline,
            ref,
            type,
            ...other,
            classes
        });
    });
    FilledInput.muiName = "Input";
    function getFormControlUtilityClasses(slot) {
        return generateUtilityClass('MuiFormControl', slot);
    }
    generateUtilityClasses('MuiFormControl', [
        'root',
        'marginNone',
        'marginNormal',
        'marginDense',
        'fullWidth',
        'disabled'
    ]);
    const useUtilityClasses$e = (ownerState)=>{
        const { classes, margin, fullWidth } = ownerState;
        const slots = {
            root: [
                "root",
                margin !== "none" && `margin${capitalize(margin)}`,
                fullWidth && "fullWidth"
            ]
        };
        return composeClasses(slots, getFormControlUtilityClasses, classes);
    };
    const FormControlRoot = styled("div", {
        name: "MuiFormControl",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                styles[`margin${capitalize(ownerState.margin)}`],
                ownerState.fullWidth && styles.fullWidth
            ];
        }
    })({
        display: "inline-flex",
        flexDirection: "column",
        position: "relative",
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: "top",
        variants: [
            {
                props: {
                    margin: "normal"
                },
                style: {
                    marginTop: 16,
                    marginBottom: 8
                }
            },
            {
                props: {
                    margin: "dense"
                },
                style: {
                    marginTop: 8,
                    marginBottom: 4
                }
            },
            {
                props: {
                    fullWidth: true
                },
                style: {
                    width: "100%"
                }
            }
        ]
    });
    const FormControl = reactExports.forwardRef(function FormControl2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiFormControl"
        });
        const { children, className, color = "primary", component = "div", disabled = false, error = false, focused: visuallyFocused, fullWidth = false, hiddenLabel = false, margin = "none", required = false, size = "medium", variant = "outlined", ...other } = props;
        const ownerState = {
            ...props,
            color,
            component,
            disabled,
            error,
            fullWidth,
            hiddenLabel,
            margin,
            required,
            size,
            variant
        };
        const classes = useUtilityClasses$e(ownerState);
        const [adornedStart, setAdornedStart] = reactExports.useState(()=>{
            let initialAdornedStart = false;
            if (children) {
                reactExports.Children.forEach(children, (child)=>{
                    if (!isMuiElement(child, [
                        "Input",
                        "Select"
                    ])) {
                        return;
                    }
                    const input = isMuiElement(child, [
                        "Select"
                    ]) ? child.props.input : child;
                    if (input && isAdornedStart(input.props)) {
                        initialAdornedStart = true;
                    }
                });
            }
            return initialAdornedStart;
        });
        const [filled, setFilled] = reactExports.useState(()=>{
            let initialFilled = false;
            if (children) {
                reactExports.Children.forEach(children, (child)=>{
                    if (!isMuiElement(child, [
                        "Input",
                        "Select"
                    ])) {
                        return;
                    }
                    if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
                        initialFilled = true;
                    }
                });
            }
            return initialFilled;
        });
        const [focusedState, setFocused] = reactExports.useState(false);
        if (disabled && focusedState) {
            setFocused(false);
        }
        const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
        let registerEffect;
        reactExports.useRef(false);
        const onFilled = reactExports.useCallback(()=>{
            setFilled(true);
        }, []);
        const onEmpty = reactExports.useCallback(()=>{
            setFilled(false);
        }, []);
        const childContext = reactExports.useMemo(()=>{
            return {
                adornedStart,
                setAdornedStart,
                color,
                disabled,
                error,
                filled,
                focused,
                fullWidth,
                hiddenLabel,
                size,
                onBlur: ()=>{
                    setFocused(false);
                },
                onFocus: ()=>{
                    setFocused(true);
                },
                onEmpty,
                onFilled,
                registerEffect,
                required,
                variant
            };
        }, [
            adornedStart,
            color,
            disabled,
            error,
            filled,
            focused,
            fullWidth,
            hiddenLabel,
            registerEffect,
            onEmpty,
            onFilled,
            required,
            size,
            variant
        ]);
        return jsxRuntimeExports.jsx(FormControlContext.Provider, {
            value: childContext,
            children: jsxRuntimeExports.jsx(FormControlRoot, {
                as: component,
                ownerState,
                className: clsx(classes.root, className),
                ref,
                ...other,
                children
            })
        });
    });
    function getFormHelperTextUtilityClasses(slot) {
        return generateUtilityClass('MuiFormHelperText', slot);
    }
    const formHelperTextClasses = generateUtilityClasses('MuiFormHelperText', [
        'root',
        'error',
        'disabled',
        'sizeSmall',
        'sizeMedium',
        'contained',
        'focused',
        'filled',
        'required'
    ]);
    var _span$3;
    const useUtilityClasses$d = (ownerState)=>{
        const { classes, contained, size, disabled, error, filled, focused, required } = ownerState;
        const slots = {
            root: [
                "root",
                disabled && "disabled",
                error && "error",
                size && `size${capitalize(size)}`,
                contained && "contained",
                focused && "focused",
                filled && "filled",
                required && "required"
            ]
        };
        return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
    };
    const FormHelperTextRoot = styled("p", {
        name: "MuiFormHelperText",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.size && styles[`size${capitalize(ownerState.size)}`],
                ownerState.contained && styles.contained,
                ownerState.filled && styles.filled
            ];
        }
    })(memoTheme(({ theme })=>({
            color: (theme.vars || theme).palette.text.secondary,
            ...theme.typography.caption,
            textAlign: "left",
            marginTop: 3,
            marginRight: 0,
            marginBottom: 0,
            marginLeft: 0,
            [`&.${formHelperTextClasses.disabled}`]: {
                color: (theme.vars || theme).palette.text.disabled
            },
            [`&.${formHelperTextClasses.error}`]: {
                color: (theme.vars || theme).palette.error.main
            },
            variants: [
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        marginTop: 4
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.contained,
                    style: {
                        marginLeft: 14,
                        marginRight: 14
                    }
                }
            ]
        })));
    const FormHelperText = reactExports.forwardRef(function FormHelperText2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiFormHelperText"
        });
        const { children, className, component = "p", disabled, error, filled, focused, margin, required, variant, ...other } = props;
        const muiFormControl = useFormControl();
        const fcs = formControlState({
            props,
            muiFormControl,
            states: [
                "variant",
                "size",
                "disabled",
                "error",
                "filled",
                "focused",
                "required"
            ]
        });
        const ownerState = {
            ...props,
            component,
            contained: fcs.variant === "filled" || fcs.variant === "outlined",
            variant: fcs.variant,
            size: fcs.size,
            disabled: fcs.disabled,
            error: fcs.error,
            filled: fcs.filled,
            focused: fcs.focused,
            required: fcs.required
        };
        delete ownerState.ownerState;
        const classes = useUtilityClasses$d(ownerState);
        return jsxRuntimeExports.jsx(FormHelperTextRoot, {
            as: component,
            className: clsx(classes.root, className),
            ref,
            ...other,
            ownerState,
            children: children === " " ? (_span$3 || (_span$3 = jsxRuntimeExports.jsx("span", {
                className: "notranslate",
                "aria-hidden": true,
                children: "​"
            }))) : children
        });
    });
    function getFormLabelUtilityClasses(slot) {
        return generateUtilityClass('MuiFormLabel', slot);
    }
    const formLabelClasses = generateUtilityClasses('MuiFormLabel', [
        'root',
        'colorSecondary',
        'focused',
        'disabled',
        'error',
        'filled',
        'required',
        'asterisk'
    ]);
    const useUtilityClasses$c = (ownerState)=>{
        const { classes, color, focused, disabled, error, filled, required } = ownerState;
        const slots = {
            root: [
                "root",
                `color${capitalize(color)}`,
                disabled && "disabled",
                error && "error",
                filled && "filled",
                focused && "focused",
                required && "required"
            ],
            asterisk: [
                "asterisk",
                error && "error"
            ]
        };
        return composeClasses(slots, getFormLabelUtilityClasses, classes);
    };
    const FormLabelRoot = styled("label", {
        name: "MuiFormLabel",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                ownerState.color === "secondary" && styles.colorSecondary,
                ownerState.filled && styles.filled
            ];
        }
    })(memoTheme(({ theme })=>({
            color: (theme.vars || theme).palette.text.secondary,
            ...theme.typography.body1,
            lineHeight: "1.4375em",
            padding: 0,
            position: "relative",
            variants: [
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            [`&.${formLabelClasses.focused}`]: {
                                color: (theme.vars || theme).palette[color].main
                            }
                        }
                    })),
                {
                    props: {},
                    style: {
                        [`&.${formLabelClasses.disabled}`]: {
                            color: (theme.vars || theme).palette.text.disabled
                        },
                        [`&.${formLabelClasses.error}`]: {
                            color: (theme.vars || theme).palette.error.main
                        }
                    }
                }
            ]
        })));
    const AsteriskComponent = styled("span", {
        name: "MuiFormLabel",
        slot: "Asterisk"
    })(memoTheme(({ theme })=>({
            [`&.${formLabelClasses.error}`]: {
                color: (theme.vars || theme).palette.error.main
            }
        })));
    const FormLabel = reactExports.forwardRef(function FormLabel2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiFormLabel"
        });
        const { children, className, color, component = "label", disabled, error, filled, focused, required, ...other } = props;
        const muiFormControl = useFormControl();
        const fcs = formControlState({
            props,
            muiFormControl,
            states: [
                "color",
                "required",
                "focused",
                "disabled",
                "error",
                "filled"
            ]
        });
        const ownerState = {
            ...props,
            color: fcs.color || "primary",
            component,
            disabled: fcs.disabled,
            error: fcs.error,
            filled: fcs.filled,
            focused: fcs.focused,
            required: fcs.required
        };
        const classes = useUtilityClasses$c(ownerState);
        return jsxRuntimeExports.jsxs(FormLabelRoot, {
            as: component,
            ownerState,
            className: clsx(classes.root, className),
            ref,
            ...other,
            children: [
                children,
                fcs.required && jsxRuntimeExports.jsxs(AsteriskComponent, {
                    ownerState,
                    "aria-hidden": true,
                    className: classes.asterisk,
                    children: [
                        " ",
                        "*"
                    ]
                })
            ]
        });
    });
    function getScale(value) {
        return `scale(${value}, ${value ** 2})`;
    }
    const styles = {
        entering: {
            opacity: 1,
            transform: getScale(1)
        },
        entered: {
            opacity: 1,
            transform: "none"
        }
    };
    const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
    const Grow = reactExports.forwardRef(function Grow2(props, ref) {
        const { addEndListener, appear = true, children, easing, in: inProp, onEnter, onEntered, onEntering, onExit, onExited, onExiting, style, timeout = "auto", TransitionComponent = Transition, ...other } = props;
        const timer = useTimeout();
        const autoTimeout = reactExports.useRef();
        const theme = useTheme();
        const nodeRef = reactExports.useRef(null);
        const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref);
        const normalizedTransitionCallback = (callback)=>(maybeIsAppearing)=>{
                if (callback) {
                    const node = nodeRef.current;
                    if (maybeIsAppearing === void 0) {
                        callback(node);
                    } else {
                        callback(node, maybeIsAppearing);
                    }
                }
            };
        const handleEntering = normalizedTransitionCallback(onEntering);
        const handleEnter = normalizedTransitionCallback((node, isAppearing)=>{
            reflow(node);
            const { duration: transitionDuration, delay, easing: transitionTimingFunction } = getTransitionProps({
                style,
                timeout,
                easing
            }, {
                mode: "enter"
            });
            let duration;
            if (timeout === "auto") {
                duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
                autoTimeout.current = duration;
            } else {
                duration = transitionDuration;
            }
            node.style.transition = [
                theme.transitions.create("opacity", {
                    duration,
                    delay
                }),
                theme.transitions.create("transform", {
                    duration: isWebKit154 ? duration : duration * 0.666,
                    delay,
                    easing: transitionTimingFunction
                })
            ].join(",");
            if (onEnter) {
                onEnter(node, isAppearing);
            }
        });
        const handleEntered = normalizedTransitionCallback(onEntered);
        const handleExiting = normalizedTransitionCallback(onExiting);
        const handleExit = normalizedTransitionCallback((node)=>{
            const { duration: transitionDuration, delay, easing: transitionTimingFunction } = getTransitionProps({
                style,
                timeout,
                easing
            }, {
                mode: "exit"
            });
            let duration;
            if (timeout === "auto") {
                duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
                autoTimeout.current = duration;
            } else {
                duration = transitionDuration;
            }
            node.style.transition = [
                theme.transitions.create("opacity", {
                    duration,
                    delay
                }),
                theme.transitions.create("transform", {
                    duration: isWebKit154 ? duration : duration * 0.666,
                    delay: isWebKit154 ? delay : delay || duration * 0.333,
                    easing: transitionTimingFunction
                })
            ].join(",");
            node.style.opacity = 0;
            node.style.transform = getScale(0.75);
            if (onExit) {
                onExit(node);
            }
        });
        const handleExited = normalizedTransitionCallback(onExited);
        const handleAddEndListener = (next)=>{
            if (timeout === "auto") {
                timer.start(autoTimeout.current || 0, next);
            }
            if (addEndListener) {
                addEndListener(nodeRef.current, next);
            }
        };
        return jsxRuntimeExports.jsx(TransitionComponent, {
            appear,
            in: inProp,
            nodeRef,
            onEnter: handleEnter,
            onEntered: handleEntered,
            onEntering: handleEntering,
            onExit: handleExit,
            onExited: handleExited,
            onExiting: handleExiting,
            addEndListener: handleAddEndListener,
            timeout: timeout === "auto" ? null : timeout,
            ...other,
            children: (state, { ownerState, ...restChildProps })=>{
                return reactExports.cloneElement(children, {
                    style: {
                        opacity: 0,
                        transform: getScale(0.75),
                        visibility: state === "exited" && !inProp ? "hidden" : void 0,
                        ...styles[state],
                        ...style,
                        ...children.props.style
                    },
                    ref: handleRef,
                    ...restChildProps
                });
            }
        });
    });
    if (Grow) {
        Grow.muiSupportAuto = true;
    }
    const useUtilityClasses$b = (ownerState)=>{
        const { classes, disableUnderline } = ownerState;
        const slots = {
            root: [
                "root",
                !disableUnderline && "underline"
            ],
            input: [
                "input"
            ]
        };
        const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
        return {
            ...classes,
            ...composedClasses
        };
    };
    const InputRoot = styled(InputBaseRoot, {
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) || prop === "classes",
        name: "MuiInput",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                ...rootOverridesResolver(props, styles),
                !ownerState.disableUnderline && styles.underline
            ];
        }
    })(memoTheme(({ theme })=>{
        const light = theme.palette.mode === "light";
        let bottomLineColor = light ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
        if (theme.vars) {
            bottomLineColor = theme.alpha(theme.vars.palette.common.onBackground, theme.vars.opacity.inputUnderline);
        }
        return {
            position: "relative",
            variants: [
                {
                    props: ({ ownerState })=>ownerState.formControl,
                    style: {
                        "label + &": {
                            marginTop: 16
                        }
                    }
                },
                {
                    props: ({ ownerState })=>!ownerState.disableUnderline,
                    style: {
                        "&::after": {
                            left: 0,
                            bottom: 0,
                            content: '""',
                            position: "absolute",
                            right: 0,
                            transform: "scaleX(0)",
                            transition: theme.transitions.create("transform", {
                                duration: theme.transitions.duration.shorter,
                                easing: theme.transitions.easing.easeOut
                            }),
                            pointerEvents: "none"
                        },
                        [`&.${inputClasses.focused}:after`]: {
                            transform: "scaleX(1) translateX(0)"
                        },
                        [`&.${inputClasses.error}`]: {
                            "&::before, &::after": {
                                borderBottomColor: (theme.vars || theme).palette.error.main
                            }
                        },
                        "&::before": {
                            borderBottom: `1px solid ${bottomLineColor}`,
                            left: 0,
                            bottom: 0,
                            content: '"\\00a0"',
                            position: "absolute",
                            right: 0,
                            transition: theme.transitions.create("border-bottom-color", {
                                duration: theme.transitions.duration.shorter
                            }),
                            pointerEvents: "none"
                        },
                        [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
                            borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
                            "@media (hover: none)": {
                                borderBottom: `1px solid ${bottomLineColor}`
                            }
                        },
                        [`&.${inputClasses.disabled}:before`]: {
                            borderBottomStyle: "dotted"
                        }
                    }
                },
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color,
                            disableUnderline: false
                        },
                        style: {
                            "&::after": {
                                borderBottom: `2px solid ${(theme.vars || theme).palette[color].main}`
                            }
                        }
                    }))
            ]
        };
    }));
    const InputInput = styled(InputBaseInput, {
        name: "MuiInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })({});
    const Input$3 = reactExports.forwardRef(function Input2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiInput"
        });
        const { disableUnderline = false, components = {}, componentsProps: componentsPropsProp, fullWidth = false, inputComponent = "input", multiline = false, slotProps, slots = {}, type = "text", ...other } = props;
        const classes = useUtilityClasses$b(props);
        const ownerState = {
            disableUnderline
        };
        const inputComponentsProps = {
            root: {
                ownerState
            }
        };
        const componentsProps = slotProps ?? componentsPropsProp ? deepmerge(slotProps ?? componentsPropsProp, inputComponentsProps) : inputComponentsProps;
        const RootSlot = slots.root ?? components.Root ?? InputRoot;
        const InputSlot = slots.input ?? components.Input ?? InputInput;
        return jsxRuntimeExports.jsx(InputBase, {
            slots: {
                root: RootSlot,
                input: InputSlot
            },
            slotProps: componentsProps,
            fullWidth,
            inputComponent,
            multiline,
            ref,
            type,
            ...other,
            classes
        });
    });
    Input$3.muiName = "Input";
    function getInputAdornmentUtilityClass(slot) {
        return generateUtilityClass('MuiInputAdornment', slot);
    }
    const inputAdornmentClasses = generateUtilityClasses('MuiInputAdornment', [
        'root',
        'filled',
        'standard',
        'outlined',
        'positionStart',
        'positionEnd',
        'disablePointerEvents',
        'hiddenLabel',
        'sizeSmall'
    ]);
    var _span$2;
    const overridesResolver = (props, styles)=>{
        const { ownerState } = props;
        return [
            styles.root,
            styles[`position${capitalize(ownerState.position)}`],
            ownerState.disablePointerEvents === true && styles.disablePointerEvents,
            styles[ownerState.variant]
        ];
    };
    const useUtilityClasses$a = (ownerState)=>{
        const { classes, disablePointerEvents, hiddenLabel, position, size, variant } = ownerState;
        const slots = {
            root: [
                "root",
                disablePointerEvents && "disablePointerEvents",
                position && `position${capitalize(position)}`,
                variant,
                hiddenLabel && "hiddenLabel",
                size && `size${capitalize(size)}`
            ]
        };
        return composeClasses(slots, getInputAdornmentUtilityClass, classes);
    };
    const InputAdornmentRoot = styled("div", {
        name: "MuiInputAdornment",
        slot: "Root",
        overridesResolver
    })(memoTheme(({ theme })=>({
            display: "flex",
            maxHeight: "2em",
            alignItems: "center",
            whiteSpace: "nowrap",
            color: (theme.vars || theme).palette.action.active,
            variants: [
                {
                    props: {
                        variant: "filled"
                    },
                    style: {
                        [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
                            marginTop: 16
                        }
                    }
                },
                {
                    props: {
                        position: "start"
                    },
                    style: {
                        marginRight: 8
                    }
                },
                {
                    props: {
                        position: "end"
                    },
                    style: {
                        marginLeft: 8
                    }
                },
                {
                    props: {
                        disablePointerEvents: true
                    },
                    style: {
                        pointerEvents: "none"
                    }
                }
            ]
        })));
    const InputAdornment = reactExports.forwardRef(function InputAdornment2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiInputAdornment"
        });
        const { children, className, component = "div", disablePointerEvents = false, disableTypography = false, position, variant: variantProp, ...other } = props;
        const muiFormControl = useFormControl() || {};
        let variant = variantProp;
        if (variantProp && muiFormControl.variant) ;
        if (muiFormControl && !variant) {
            variant = muiFormControl.variant;
        }
        const ownerState = {
            ...props,
            hiddenLabel: muiFormControl.hiddenLabel,
            size: muiFormControl.size,
            disablePointerEvents,
            position,
            variant
        };
        const classes = useUtilityClasses$a(ownerState);
        return jsxRuntimeExports.jsx(FormControlContext.Provider, {
            value: null,
            children: jsxRuntimeExports.jsx(InputAdornmentRoot, {
                as: component,
                ownerState,
                className: clsx(classes.root, className),
                ref,
                ...other,
                children: typeof children === "string" && !disableTypography ? jsxRuntimeExports.jsx(Typography, {
                    color: "textSecondary",
                    children
                }) : jsxRuntimeExports.jsxs(reactExports.Fragment, {
                    children: [
                        position === "start" ? (_span$2 || (_span$2 = jsxRuntimeExports.jsx("span", {
                            className: "notranslate",
                            "aria-hidden": true,
                            children: "​"
                        }))) : null,
                        children
                    ]
                })
            })
        });
    });
    function getInputLabelUtilityClasses(slot) {
        return generateUtilityClass('MuiInputLabel', slot);
    }
    generateUtilityClasses('MuiInputLabel', [
        'root',
        'focused',
        'disabled',
        'error',
        'required',
        'asterisk',
        'formControl',
        'sizeSmall',
        'shrink',
        'animated',
        'standard',
        'filled',
        'outlined'
    ]);
    const useUtilityClasses$9 = (ownerState)=>{
        const { classes, formControl, size, shrink, disableAnimation, variant, required } = ownerState;
        const slots = {
            root: [
                "root",
                formControl && "formControl",
                !disableAnimation && "animated",
                shrink && "shrink",
                size && size !== "medium" && `size${capitalize(size)}`,
                variant
            ],
            asterisk: [
                required && "asterisk"
            ]
        };
        const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
        return {
            ...classes,
            ...composedClasses
        };
    };
    const InputLabelRoot = styled(FormLabel, {
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) || prop === "classes",
        name: "MuiInputLabel",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                {
                    [`& .${formLabelClasses.asterisk}`]: styles.asterisk
                },
                styles.root,
                ownerState.formControl && styles.formControl,
                ownerState.size === "small" && styles.sizeSmall,
                ownerState.shrink && styles.shrink,
                !ownerState.disableAnimation && styles.animated,
                ownerState.focused && styles.focused,
                styles[ownerState.variant]
            ];
        }
    })(memoTheme(({ theme })=>({
            display: "block",
            transformOrigin: "top left",
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            maxWidth: "100%",
            variants: [
                {
                    props: ({ ownerState })=>ownerState.formControl,
                    style: {
                        position: "absolute",
                        left: 0,
                        top: 0,
                        transform: "translate(0, 20px) scale(1)"
                    }
                },
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        transform: "translate(0, 17px) scale(1)"
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.shrink,
                    style: {
                        transform: "translate(0, -1.5px) scale(0.75)",
                        transformOrigin: "top left",
                        maxWidth: "133%"
                    }
                },
                {
                    props: ({ ownerState })=>!ownerState.disableAnimation,
                    style: {
                        transition: theme.transitions.create([
                            "color",
                            "transform",
                            "max-width"
                        ], {
                            duration: theme.transitions.duration.shorter,
                            easing: theme.transitions.easing.easeOut
                        })
                    }
                },
                {
                    props: {
                        variant: "filled"
                    },
                    style: {
                        zIndex: 1,
                        pointerEvents: "none",
                        transform: "translate(12px, 16px) scale(1)",
                        maxWidth: "calc(100% - 24px)"
                    }
                },
                {
                    props: {
                        variant: "filled",
                        size: "small"
                    },
                    style: {
                        transform: "translate(12px, 13px) scale(1)"
                    }
                },
                {
                    props: ({ variant, ownerState })=>variant === "filled" && ownerState.shrink,
                    style: {
                        userSelect: "none",
                        pointerEvents: "auto",
                        transform: "translate(12px, 7px) scale(0.75)",
                        maxWidth: "calc(133% - 24px)"
                    }
                },
                {
                    props: ({ variant, ownerState, size })=>variant === "filled" && ownerState.shrink && size === "small",
                    style: {
                        transform: "translate(12px, 4px) scale(0.75)"
                    }
                },
                {
                    props: {
                        variant: "outlined"
                    },
                    style: {
                        zIndex: 1,
                        pointerEvents: "none",
                        transform: "translate(14px, 16px) scale(1)",
                        maxWidth: "calc(100% - 24px)"
                    }
                },
                {
                    props: {
                        variant: "outlined",
                        size: "small"
                    },
                    style: {
                        transform: "translate(14px, 9px) scale(1)"
                    }
                },
                {
                    props: ({ variant, ownerState })=>variant === "outlined" && ownerState.shrink,
                    style: {
                        userSelect: "none",
                        pointerEvents: "auto",
                        maxWidth: "calc(133% - 32px)",
                        transform: "translate(14px, -9px) scale(0.75)"
                    }
                }
            ]
        })));
    const InputLabel = reactExports.forwardRef(function InputLabel2(inProps, ref) {
        const props = useDefaultProps({
            name: "MuiInputLabel",
            props: inProps
        });
        const { disableAnimation = false, margin, shrink: shrinkProp, variant, className, ...other } = props;
        const muiFormControl = useFormControl();
        let shrink = shrinkProp;
        if (typeof shrink === "undefined" && muiFormControl) {
            shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
        }
        const fcs = formControlState({
            props,
            muiFormControl,
            states: [
                "size",
                "variant",
                "required",
                "focused"
            ]
        });
        const ownerState = {
            ...props,
            disableAnimation,
            formControl: muiFormControl,
            shrink,
            size: fcs.size,
            variant: fcs.variant,
            required: fcs.required,
            focused: fcs.focused
        };
        const classes = useUtilityClasses$9(ownerState);
        return jsxRuntimeExports.jsx(InputLabelRoot, {
            "data-shrink": shrink,
            ref,
            className: clsx(classes.root, className),
            ...other,
            ownerState,
            classes
        });
    });
    const ListContext = reactExports.createContext({});
    function getListUtilityClass(slot) {
        return generateUtilityClass('MuiList', slot);
    }
    generateUtilityClasses('MuiList', [
        'root',
        'padding',
        'dense',
        'subheader'
    ]);
    const useUtilityClasses$8 = (ownerState)=>{
        const { classes, disablePadding, dense, subheader } = ownerState;
        const slots = {
            root: [
                "root",
                !disablePadding && "padding",
                dense && "dense",
                subheader && "subheader"
            ]
        };
        return composeClasses(slots, getListUtilityClass, classes);
    };
    const ListRoot = styled("ul", {
        name: "MuiList",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                !ownerState.disablePadding && styles.padding,
                ownerState.dense && styles.dense,
                ownerState.subheader && styles.subheader
            ];
        }
    })({
        listStyle: "none",
        margin: 0,
        padding: 0,
        position: "relative",
        variants: [
            {
                props: ({ ownerState })=>!ownerState.disablePadding,
                style: {
                    paddingTop: 8,
                    paddingBottom: 8
                }
            },
            {
                props: ({ ownerState })=>ownerState.subheader,
                style: {
                    paddingTop: 0
                }
            }
        ]
    });
    const List = reactExports.forwardRef(function List2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiList"
        });
        const { children, className, component = "ul", dense = false, disablePadding = false, subheader, ...other } = props;
        const context = reactExports.useMemo(()=>({
                dense
            }), [
            dense
        ]);
        const ownerState = {
            ...props,
            component,
            dense,
            disablePadding
        };
        const classes = useUtilityClasses$8(ownerState);
        return jsxRuntimeExports.jsx(ListContext.Provider, {
            value: context,
            children: jsxRuntimeExports.jsxs(ListRoot, {
                as: component,
                className: clsx(classes.root, className),
                ref,
                ownerState,
                ...other,
                children: [
                    subheader,
                    children
                ]
            })
        });
    });
    function nextItem(list, item, disableListWrap) {
        if (list === item) {
            return list.firstChild;
        }
        if (item && item.nextElementSibling) {
            return item.nextElementSibling;
        }
        return disableListWrap ? null : list.firstChild;
    }
    function previousItem(list, item, disableListWrap) {
        if (list === item) {
            return disableListWrap ? list.firstChild : list.lastChild;
        }
        if (item && item.previousElementSibling) {
            return item.previousElementSibling;
        }
        return disableListWrap ? null : list.lastChild;
    }
    function textCriteriaMatches(nextFocus, textCriteria) {
        if (textCriteria === void 0) {
            return true;
        }
        let text = nextFocus.innerText;
        if (text === void 0) {
            text = nextFocus.textContent;
        }
        text = text.trim().toLowerCase();
        if (text.length === 0) {
            return false;
        }
        if (textCriteria.repeating) {
            return text[0] === textCriteria.keys[0];
        }
        return text.startsWith(textCriteria.keys.join(""));
    }
    function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
        let wrappedOnce = false;
        let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
        while(nextFocus){
            if (nextFocus === list.firstChild) {
                if (wrappedOnce) {
                    return false;
                }
                wrappedOnce = true;
            }
            const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
            if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
                nextFocus = traversalFunction(list, nextFocus, disableListWrap);
            } else {
                nextFocus.focus();
                return true;
            }
        }
        return false;
    }
    const MenuList = reactExports.forwardRef(function MenuList2(props, ref) {
        const { actions, autoFocus = false, autoFocusItem = false, children, className, disabledItemsFocusable = false, disableListWrap = false, onKeyDown, variant = "selectedMenu", ...other } = props;
        const listRef = reactExports.useRef(null);
        const textCriteriaRef = reactExports.useRef({
            keys: [],
            repeating: true,
            previousKeyMatched: true,
            lastTime: null
        });
        useEnhancedEffect(()=>{
            if (autoFocus) {
                listRef.current.focus();
            }
        }, [
            autoFocus
        ]);
        reactExports.useImperativeHandle(actions, ()=>({
                adjustStyleForScrollbar: (containerElement, { direction })=>{
                    const noExplicitWidth = !listRef.current.style.width;
                    if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
                        const scrollbarSize = `${getScrollbarSize(ownerWindow(containerElement))}px`;
                        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
                        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
                    }
                    return listRef.current;
                }
            }), []);
        const handleKeyDown = (event)=>{
            const list = listRef.current;
            const key = event.key;
            const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
            if (isModifierKeyPressed) {
                if (onKeyDown) {
                    onKeyDown(event);
                }
                return;
            }
            const currentFocus = ownerDocument(list).activeElement;
            if (key === "ArrowDown") {
                event.preventDefault();
                moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
            } else if (key === "ArrowUp") {
                event.preventDefault();
                moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
            } else if (key === "Home") {
                event.preventDefault();
                moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
            } else if (key === "End") {
                event.preventDefault();
                moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
            } else if (key.length === 1) {
                const criteria = textCriteriaRef.current;
                const lowerKey = key.toLowerCase();
                const currTime = performance.now();
                if (criteria.keys.length > 0) {
                    if (currTime - criteria.lastTime > 500) {
                        criteria.keys = [];
                        criteria.repeating = true;
                        criteria.previousKeyMatched = true;
                    } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
                        criteria.repeating = false;
                    }
                }
                criteria.lastTime = currTime;
                criteria.keys.push(lowerKey);
                const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
                if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
                    event.preventDefault();
                } else {
                    criteria.previousKeyMatched = false;
                }
            }
            if (onKeyDown) {
                onKeyDown(event);
            }
        };
        const handleRef = useForkRef(listRef, ref);
        let activeItemIndex = -1;
        reactExports.Children.forEach(children, (child, index)=>{
            if (!reactExports.isValidElement(child)) {
                if (activeItemIndex === index) {
                    activeItemIndex += 1;
                    if (activeItemIndex >= children.length) {
                        activeItemIndex = -1;
                    }
                }
                return;
            }
            if (!child.props.disabled) {
                if (variant === "selectedMenu" && child.props.selected) {
                    activeItemIndex = index;
                } else if (activeItemIndex === -1) {
                    activeItemIndex = index;
                }
            }
            if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
                activeItemIndex += 1;
                if (activeItemIndex >= children.length) {
                    activeItemIndex = -1;
                }
            }
        });
        const items = reactExports.Children.map(children, (child, index)=>{
            if (index === activeItemIndex) {
                const newChildProps = {};
                if (autoFocusItem) {
                    newChildProps.autoFocus = true;
                }
                if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
                    newChildProps.tabIndex = 0;
                }
                return reactExports.cloneElement(child, newChildProps);
            }
            return child;
        });
        return jsxRuntimeExports.jsx(List, {
            role: "menu",
            ref: handleRef,
            className,
            onKeyDown: handleKeyDown,
            tabIndex: autoFocus ? 0 : -1,
            ...other,
            children: items
        });
    });
    function getPopoverUtilityClass(slot) {
        return generateUtilityClass('MuiPopover', slot);
    }
    generateUtilityClasses('MuiPopover', [
        'root',
        'paper'
    ]);
    function getOffsetTop(rect, vertical) {
        let offset = 0;
        if (typeof vertical === "number") {
            offset = vertical;
        } else if (vertical === "center") {
            offset = rect.height / 2;
        } else if (vertical === "bottom") {
            offset = rect.height;
        }
        return offset;
    }
    function getOffsetLeft(rect, horizontal) {
        let offset = 0;
        if (typeof horizontal === "number") {
            offset = horizontal;
        } else if (horizontal === "center") {
            offset = rect.width / 2;
        } else if (horizontal === "right") {
            offset = rect.width;
        }
        return offset;
    }
    function getTransformOriginValue(transformOrigin) {
        return [
            transformOrigin.horizontal,
            transformOrigin.vertical
        ].map((n)=>typeof n === "number" ? `${n}px` : n).join(" ");
    }
    function resolveAnchorEl(anchorEl) {
        return typeof anchorEl === "function" ? anchorEl() : anchorEl;
    }
    const useUtilityClasses$7 = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ],
            paper: [
                "paper"
            ]
        };
        return composeClasses(slots, getPopoverUtilityClass, classes);
    };
    const PopoverRoot = styled(Modal, {
        name: "MuiPopover",
        slot: "Root"
    })({});
    const PopoverPaper = styled(Paper, {
        name: "MuiPopover",
        slot: "Paper"
    })({
        position: "absolute",
        overflowY: "auto",
        overflowX: "hidden",
        minWidth: 16,
        minHeight: 16,
        maxWidth: "calc(100% - 32px)",
        maxHeight: "calc(100% - 32px)",
        outline: 0
    });
    const Popover = reactExports.forwardRef(function Popover2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiPopover"
        });
        const { action, anchorEl, anchorOrigin = {
            vertical: "top",
            horizontal: "left"
        }, anchorPosition, anchorReference = "anchorEl", children, className, container: containerProp, elevation = 8, marginThreshold = 16, open, PaperProps: PaperPropsProp = {}, slots = {}, slotProps = {}, transformOrigin = {
            vertical: "top",
            horizontal: "left"
        }, TransitionComponent, transitionDuration: transitionDurationProp = "auto", TransitionProps = {}, disableScrollLock = false, ...other } = props;
        const paperRef = reactExports.useRef();
        const ownerState = {
            ...props,
            anchorOrigin,
            anchorReference,
            elevation,
            marginThreshold,
            transformOrigin,
            TransitionComponent,
            transitionDuration: transitionDurationProp,
            TransitionProps
        };
        const classes = useUtilityClasses$7(ownerState);
        const getAnchorOffset = reactExports.useCallback(()=>{
            if (anchorReference === "anchorPosition") {
                return anchorPosition;
            }
            const resolvedAnchorEl = resolveAnchorEl(anchorEl);
            const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
            const anchorRect = anchorElement.getBoundingClientRect();
            return {
                top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
                left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
            };
        }, [
            anchorEl,
            anchorOrigin.horizontal,
            anchorOrigin.vertical,
            anchorPosition,
            anchorReference
        ]);
        const getTransformOrigin = reactExports.useCallback((elemRect)=>{
            return {
                vertical: getOffsetTop(elemRect, transformOrigin.vertical),
                horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
            };
        }, [
            transformOrigin.horizontal,
            transformOrigin.vertical
        ]);
        const getPositioningStyle = reactExports.useCallback((element)=>{
            const elemRect = {
                width: element.offsetWidth,
                height: element.offsetHeight
            };
            const elemTransformOrigin = getTransformOrigin(elemRect);
            if (anchorReference === "none") {
                return {
                    top: null,
                    left: null,
                    transformOrigin: getTransformOriginValue(elemTransformOrigin)
                };
            }
            const anchorOffset = getAnchorOffset();
            let top = anchorOffset.top - elemTransformOrigin.vertical;
            let left = anchorOffset.left - elemTransformOrigin.horizontal;
            const bottom = top + elemRect.height;
            const right = left + elemRect.width;
            const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
            const heightThreshold = containerWindow.innerHeight - marginThreshold;
            const widthThreshold = containerWindow.innerWidth - marginThreshold;
            if (marginThreshold !== null && top < marginThreshold) {
                const diff = top - marginThreshold;
                top -= diff;
                elemTransformOrigin.vertical += diff;
            } else if (marginThreshold !== null && bottom > heightThreshold) {
                const diff = bottom - heightThreshold;
                top -= diff;
                elemTransformOrigin.vertical += diff;
            }
            if (marginThreshold !== null && left < marginThreshold) {
                const diff = left - marginThreshold;
                left -= diff;
                elemTransformOrigin.horizontal += diff;
            } else if (right > widthThreshold) {
                const diff = right - widthThreshold;
                left -= diff;
                elemTransformOrigin.horizontal += diff;
            }
            return {
                top: `${Math.round(top)}px`,
                left: `${Math.round(left)}px`,
                transformOrigin: getTransformOriginValue(elemTransformOrigin)
            };
        }, [
            anchorEl,
            anchorReference,
            getAnchorOffset,
            getTransformOrigin,
            marginThreshold
        ]);
        const [isPositioned, setIsPositioned] = reactExports.useState(open);
        const setPositioningStyles = reactExports.useCallback(()=>{
            const element = paperRef.current;
            if (!element) {
                return;
            }
            const positioning = getPositioningStyle(element);
            if (positioning.top !== null) {
                element.style.setProperty("top", positioning.top);
            }
            if (positioning.left !== null) {
                element.style.left = positioning.left;
            }
            element.style.transformOrigin = positioning.transformOrigin;
            setIsPositioned(true);
        }, [
            getPositioningStyle
        ]);
        reactExports.useEffect(()=>{
            if (disableScrollLock) {
                window.addEventListener("scroll", setPositioningStyles);
            }
            return ()=>window.removeEventListener("scroll", setPositioningStyles);
        }, [
            anchorEl,
            disableScrollLock,
            setPositioningStyles
        ]);
        const handleEntering = ()=>{
            setPositioningStyles();
        };
        const handleExited = ()=>{
            setIsPositioned(false);
        };
        reactExports.useEffect(()=>{
            if (open) {
                setPositioningStyles();
            }
        });
        reactExports.useImperativeHandle(action, ()=>open ? {
                updatePosition: ()=>{
                    setPositioningStyles();
                }
            } : null, [
            open,
            setPositioningStyles
        ]);
        reactExports.useEffect(()=>{
            if (!open) {
                return void 0;
            }
            const handleResize = debounce(()=>{
                setPositioningStyles();
            });
            const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
            containerWindow.addEventListener("resize", handleResize);
            return ()=>{
                handleResize.clear();
                containerWindow.removeEventListener("resize", handleResize);
            };
        }, [
            anchorEl,
            open,
            setPositioningStyles
        ]);
        let transitionDuration = transitionDurationProp;
        const externalForwardedProps = {
            slots: {
                transition: TransitionComponent,
                ...slots
            },
            slotProps: {
                transition: TransitionProps,
                paper: PaperPropsProp,
                ...slotProps
            }
        };
        const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
            elementType: Grow,
            externalForwardedProps,
            ownerState,
            getSlotProps: (handlers)=>({
                    ...handlers,
                    onEntering: (element, isAppearing)=>{
                        handlers.onEntering?.(element, isAppearing);
                        handleEntering();
                    },
                    onExited: (element)=>{
                        handlers.onExited?.(element);
                        handleExited();
                    }
                }),
            additionalProps: {
                appear: true,
                in: open
            }
        });
        if (transitionDurationProp === "auto" && !TransitionSlot.muiSupportAuto) {
            transitionDuration = void 0;
        }
        const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
        const [RootSlot, { slots: rootSlotsProp, slotProps: rootSlotPropsProp, ...rootProps }] = useSlot("root", {
            ref,
            elementType: PopoverRoot,
            externalForwardedProps: {
                ...externalForwardedProps,
                ...other
            },
            shouldForwardComponentProp: true,
            additionalProps: {
                slots: {
                    backdrop: slots.backdrop
                },
                slotProps: {
                    backdrop: mergeSlotProps$1(typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop, {
                        invisible: true
                    })
                },
                container,
                open
            },
            ownerState,
            className: clsx(classes.root, className)
        });
        const [PaperSlot, paperProps] = useSlot("paper", {
            ref: paperRef,
            className: classes.paper,
            elementType: PopoverPaper,
            externalForwardedProps,
            shouldForwardComponentProp: true,
            additionalProps: {
                elevation,
                style: isPositioned ? void 0 : {
                    opacity: 0
                }
            },
            ownerState
        });
        return jsxRuntimeExports.jsx(RootSlot, {
            ...rootProps,
            ...!isHostComponent(RootSlot) && {
                slots: rootSlotsProp,
                slotProps: rootSlotPropsProp,
                disableScrollLock
            },
            children: jsxRuntimeExports.jsx(TransitionSlot, {
                ...transitionSlotProps,
                timeout: transitionDuration,
                children: jsxRuntimeExports.jsx(PaperSlot, {
                    ...paperProps,
                    children
                })
            })
        });
    });
    function getMenuUtilityClass(slot) {
        return generateUtilityClass('MuiMenu', slot);
    }
    generateUtilityClasses('MuiMenu', [
        'root',
        'paper',
        'list'
    ]);
    const RTL_ORIGIN = {
        vertical: "top",
        horizontal: "right"
    };
    const LTR_ORIGIN = {
        vertical: "top",
        horizontal: "left"
    };
    const useUtilityClasses$6 = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ],
            paper: [
                "paper"
            ],
            list: [
                "list"
            ]
        };
        return composeClasses(slots, getMenuUtilityClass, classes);
    };
    const MenuRoot = styled(Popover, {
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) || prop === "classes",
        name: "MuiMenu",
        slot: "Root"
    })({});
    const MenuPaper = styled(PopoverPaper, {
        name: "MuiMenu",
        slot: "Paper"
    })({
        maxHeight: "calc(100% - 96px)",
        WebkitOverflowScrolling: "touch"
    });
    const MenuMenuList = styled(MenuList, {
        name: "MuiMenu",
        slot: "List"
    })({
        outline: 0
    });
    const Menu = reactExports.forwardRef(function Menu2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiMenu"
        });
        const { autoFocus = true, children, className, disableAutoFocusItem = false, MenuListProps = {}, onClose, open, PaperProps = {}, PopoverClasses, transitionDuration = "auto", TransitionProps: { onEntering, ...TransitionProps } = {}, variant = "selectedMenu", slots = {}, slotProps = {}, ...other } = props;
        const isRtl = useRtl();
        const ownerState = {
            ...props,
            autoFocus,
            disableAutoFocusItem,
            MenuListProps,
            onEntering,
            PaperProps,
            transitionDuration,
            TransitionProps,
            variant
        };
        const classes = useUtilityClasses$6(ownerState);
        const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
        const menuListActionsRef = reactExports.useRef(null);
        const handleEntering = (element, isAppearing)=>{
            if (menuListActionsRef.current) {
                menuListActionsRef.current.adjustStyleForScrollbar(element, {
                    direction: isRtl ? "rtl" : "ltr"
                });
            }
            if (onEntering) {
                onEntering(element, isAppearing);
            }
        };
        const handleListKeyDown = (event)=>{
            if (event.key === "Tab") {
                event.preventDefault();
                if (onClose) {
                    onClose(event, "tabKeyDown");
                }
            }
        };
        let activeItemIndex = -1;
        reactExports.Children.map(children, (child, index)=>{
            if (!reactExports.isValidElement(child)) {
                return;
            }
            if (!child.props.disabled) {
                if (variant === "selectedMenu" && child.props.selected) {
                    activeItemIndex = index;
                } else if (activeItemIndex === -1) {
                    activeItemIndex = index;
                }
            }
        });
        const externalForwardedProps = {
            slots,
            slotProps: {
                list: MenuListProps,
                transition: TransitionProps,
                paper: PaperProps,
                ...slotProps
            }
        };
        const rootSlotProps = useSlotProps({
            elementType: slots.root,
            externalSlotProps: slotProps.root,
            ownerState,
            className: [
                classes.root,
                className
            ]
        });
        const [PaperSlot, paperSlotProps] = useSlot("paper", {
            className: classes.paper,
            elementType: MenuPaper,
            externalForwardedProps,
            shouldForwardComponentProp: true,
            ownerState
        });
        const [ListSlot, listSlotProps] = useSlot("list", {
            className: clsx(classes.list, MenuListProps.className),
            elementType: MenuMenuList,
            shouldForwardComponentProp: true,
            externalForwardedProps,
            getSlotProps: (handlers)=>({
                    ...handlers,
                    onKeyDown: (event)=>{
                        handleListKeyDown(event);
                        handlers.onKeyDown?.(event);
                    }
                }),
            ownerState
        });
        const resolvedTransitionProps = typeof externalForwardedProps.slotProps.transition === "function" ? externalForwardedProps.slotProps.transition(ownerState) : externalForwardedProps.slotProps.transition;
        return jsxRuntimeExports.jsx(MenuRoot, {
            onClose,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: isRtl ? "right" : "left"
            },
            transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
            slots: {
                root: slots.root,
                paper: PaperSlot,
                backdrop: slots.backdrop,
                ...slots.transition && {
                    transition: slots.transition
                }
            },
            slotProps: {
                root: rootSlotProps,
                paper: paperSlotProps,
                backdrop: typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop,
                transition: {
                    ...resolvedTransitionProps,
                    onEntering: (...args)=>{
                        handleEntering(...args);
                        resolvedTransitionProps?.onEntering?.(...args);
                    }
                }
            },
            open,
            ref,
            transitionDuration,
            ownerState,
            ...other,
            classes: PopoverClasses,
            children: jsxRuntimeExports.jsx(ListSlot, {
                actions: menuListActionsRef,
                autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
                autoFocusItem,
                variant,
                ...listSlotProps,
                children
            })
        });
    });
    function getNativeSelectUtilityClasses(slot) {
        return generateUtilityClass('MuiNativeSelect', slot);
    }
    const nativeSelectClasses = generateUtilityClasses('MuiNativeSelect', [
        'root',
        'select',
        'multiple',
        'filled',
        'outlined',
        'standard',
        'disabled',
        'icon',
        'iconOpen',
        'iconFilled',
        'iconOutlined',
        'iconStandard',
        'nativeInput',
        'error'
    ]);
    const useUtilityClasses$5 = (ownerState)=>{
        const { classes, variant, disabled, multiple, open, error } = ownerState;
        const slots = {
            select: [
                "select",
                variant,
                disabled && "disabled",
                multiple && "multiple",
                error && "error"
            ],
            icon: [
                "icon",
                `icon${capitalize(variant)}`,
                open && "iconOpen",
                disabled && "disabled"
            ]
        };
        return composeClasses(slots, getNativeSelectUtilityClasses, classes);
    };
    const StyledSelectSelect = styled("select", {
        name: "MuiNativeSelect"
    })(({ theme })=>({
            MozAppearance: "none",
            WebkitAppearance: "none",
            userSelect: "none",
            borderRadius: 0,
            cursor: "pointer",
            "&:focus": {
                borderRadius: 0
            },
            [`&.${nativeSelectClasses.disabled}`]: {
                cursor: "default"
            },
            "&[multiple]": {
                height: "auto"
            },
            "&:not([multiple]) option, &:not([multiple]) optgroup": {
                backgroundColor: (theme.vars || theme).palette.background.paper
            },
            variants: [
                {
                    props: ({ ownerState })=>ownerState.variant !== "filled" && ownerState.variant !== "outlined",
                    style: {
                        "&&&": {
                            paddingRight: 24,
                            minWidth: 16
                        }
                    }
                },
                {
                    props: {
                        variant: "filled"
                    },
                    style: {
                        "&&&": {
                            paddingRight: 32
                        }
                    }
                },
                {
                    props: {
                        variant: "outlined"
                    },
                    style: {
                        borderRadius: (theme.vars || theme).shape.borderRadius,
                        "&:focus": {
                            borderRadius: (theme.vars || theme).shape.borderRadius
                        },
                        "&&&": {
                            paddingRight: 32
                        }
                    }
                }
            ]
        }));
    const NativeSelectSelect = styled(StyledSelectSelect, {
        name: "MuiNativeSelect",
        slot: "Select",
        shouldForwardProp: rootShouldForwardProp,
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.select,
                styles[ownerState.variant],
                ownerState.error && styles.error,
                {
                    [`&.${nativeSelectClasses.multiple}`]: styles.multiple
                }
            ];
        }
    })({});
    const StyledSelectIcon = styled("svg", {
        name: "MuiNativeSelect"
    })(({ theme })=>({
            position: "absolute",
            right: 0,
            top: "calc(50% - .5em)",
            pointerEvents: "none",
            color: (theme.vars || theme).palette.action.active,
            [`&.${nativeSelectClasses.disabled}`]: {
                color: (theme.vars || theme).palette.action.disabled
            },
            variants: [
                {
                    props: ({ ownerState })=>ownerState.open,
                    style: {
                        transform: "rotate(180deg)"
                    }
                },
                {
                    props: {
                        variant: "filled"
                    },
                    style: {
                        right: 7
                    }
                },
                {
                    props: {
                        variant: "outlined"
                    },
                    style: {
                        right: 7
                    }
                }
            ]
        }));
    const NativeSelectIcon = styled(StyledSelectIcon, {
        name: "MuiNativeSelect",
        slot: "Icon",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.icon,
                ownerState.variant && styles[`icon${capitalize(ownerState.variant)}`],
                ownerState.open && styles.iconOpen
            ];
        }
    })({});
    const NativeSelectInput = reactExports.forwardRef(function NativeSelectInput2(props, ref) {
        const { className, disabled, error, IconComponent, inputRef, variant = "standard", ...other } = props;
        const ownerState = {
            ...props,
            disabled,
            variant,
            error
        };
        const classes = useUtilityClasses$5(ownerState);
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx(NativeSelectSelect, {
                    ownerState,
                    className: clsx(classes.select, className),
                    disabled,
                    ref: inputRef || ref,
                    ...other
                }),
                props.multiple ? null : jsxRuntimeExports.jsx(NativeSelectIcon, {
                    as: IconComponent,
                    ownerState,
                    className: classes.icon
                })
            ]
        });
    });
    var _span$1;
    const NotchedOutlineRoot$1 = styled("fieldset", {
        name: "MuiNotchedOutlined",
        shouldForwardProp: rootShouldForwardProp
    })({
        textAlign: "left",
        position: "absolute",
        bottom: 0,
        right: 0,
        top: -5,
        left: 0,
        margin: 0,
        padding: "0 8px",
        pointerEvents: "none",
        borderRadius: "inherit",
        borderStyle: "solid",
        borderWidth: 1,
        overflow: "hidden",
        minWidth: "0%"
    });
    const NotchedOutlineLegend = styled("legend", {
        name: "MuiNotchedOutlined",
        shouldForwardProp: rootShouldForwardProp
    })(memoTheme(({ theme })=>({
            float: "unset",
            width: "auto",
            overflow: "hidden",
            variants: [
                {
                    props: ({ ownerState })=>!ownerState.withLabel,
                    style: {
                        padding: 0,
                        lineHeight: "11px",
                        transition: theme.transitions.create("width", {
                            duration: 150,
                            easing: theme.transitions.easing.easeOut
                        })
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.withLabel,
                    style: {
                        display: "block",
                        padding: 0,
                        height: 11,
                        fontSize: "0.75em",
                        visibility: "hidden",
                        maxWidth: 0.01,
                        transition: theme.transitions.create("max-width", {
                            duration: 50,
                            easing: theme.transitions.easing.easeOut
                        }),
                        whiteSpace: "nowrap",
                        "& > span": {
                            paddingLeft: 5,
                            paddingRight: 5,
                            display: "inline-block",
                            opacity: 0,
                            visibility: "visible"
                        }
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.withLabel && ownerState.notched,
                    style: {
                        maxWidth: "100%",
                        transition: theme.transitions.create("max-width", {
                            duration: 100,
                            easing: theme.transitions.easing.easeOut,
                            delay: 50
                        })
                    }
                }
            ]
        })));
    function NotchedOutline(props) {
        const { children, classes, className, label, notched, ...other } = props;
        const withLabel = label != null && label !== "";
        const ownerState = {
            ...props,
            notched,
            withLabel
        };
        return jsxRuntimeExports.jsx(NotchedOutlineRoot$1, {
            "aria-hidden": true,
            className,
            ownerState,
            ...other,
            children: jsxRuntimeExports.jsx(NotchedOutlineLegend, {
                ownerState,
                children: withLabel ? jsxRuntimeExports.jsx("span", {
                    children: label
                }) : (_span$1 || (_span$1 = jsxRuntimeExports.jsx("span", {
                    className: "notranslate",
                    "aria-hidden": true,
                    children: "​"
                })))
            })
        });
    }
    const useUtilityClasses$4 = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ],
            notchedOutline: [
                "notchedOutline"
            ],
            input: [
                "input"
            ]
        };
        const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
        return {
            ...classes,
            ...composedClasses
        };
    };
    const OutlinedInputRoot = styled(InputBaseRoot, {
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) || prop === "classes",
        name: "MuiOutlinedInput",
        slot: "Root",
        overridesResolver: rootOverridesResolver
    })(memoTheme(({ theme })=>{
        const borderColor = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
        return {
            position: "relative",
            borderRadius: (theme.vars || theme).shape.borderRadius,
            [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                borderColor: (theme.vars || theme).palette.text.primary
            },
            "@media (hover: none)": {
                [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                    borderColor: theme.vars ? theme.alpha(theme.vars.palette.common.onBackground, 0.23) : borderColor
                }
            },
            [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
                borderWidth: 2
            },
            variants: [
                ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color])=>({
                        props: {
                            color
                        },
                        style: {
                            [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
                                borderColor: (theme.vars || theme).palette[color].main
                            }
                        }
                    })),
                {
                    props: {},
                    style: {
                        [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
                            borderColor: (theme.vars || theme).palette.error.main
                        },
                        [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
                            borderColor: (theme.vars || theme).palette.action.disabled
                        }
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.startAdornment,
                    style: {
                        paddingLeft: 14
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.endAdornment,
                    style: {
                        paddingRight: 14
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.multiline,
                    style: {
                        padding: "16.5px 14px"
                    }
                },
                {
                    props: ({ ownerState, size })=>ownerState.multiline && size === "small",
                    style: {
                        padding: "8.5px 14px"
                    }
                }
            ]
        };
    }));
    const NotchedOutlineRoot = styled(NotchedOutline, {
        name: "MuiOutlinedInput",
        slot: "NotchedOutline"
    })(memoTheme(({ theme })=>{
        const borderColor = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
        return {
            borderColor: theme.vars ? theme.alpha(theme.vars.palette.common.onBackground, 0.23) : borderColor
        };
    }));
    const OutlinedInputInput = styled(InputBaseInput, {
        name: "MuiOutlinedInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver
    })(memoTheme(({ theme })=>({
            padding: "16.5px 14px",
            ...!theme.vars && {
                "&:-webkit-autofill": {
                    WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
                    WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
                    caretColor: theme.palette.mode === "light" ? null : "#fff",
                    borderRadius: "inherit"
                }
            },
            ...theme.vars && {
                "&:-webkit-autofill": {
                    borderRadius: "inherit"
                },
                [theme.getColorSchemeSelector("dark")]: {
                    "&:-webkit-autofill": {
                        WebkitBoxShadow: "0 0 0 100px #266798 inset",
                        WebkitTextFillColor: "#fff",
                        caretColor: "#fff"
                    }
                }
            },
            variants: [
                {
                    props: {
                        size: "small"
                    },
                    style: {
                        padding: "8.5px 14px"
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.multiline,
                    style: {
                        padding: 0
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.startAdornment,
                    style: {
                        paddingLeft: 0
                    }
                },
                {
                    props: ({ ownerState })=>ownerState.endAdornment,
                    style: {
                        paddingRight: 0
                    }
                }
            ]
        })));
    const OutlinedInput = reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiOutlinedInput"
        });
        const { components = {}, fullWidth = false, inputComponent = "input", label, multiline = false, notched, slots = {}, slotProps = {}, type = "text", ...other } = props;
        const classes = useUtilityClasses$4(props);
        const muiFormControl = useFormControl();
        const fcs = formControlState({
            props,
            muiFormControl,
            states: [
                "color",
                "disabled",
                "error",
                "focused",
                "hiddenLabel",
                "size",
                "required"
            ]
        });
        const ownerState = {
            ...props,
            color: fcs.color || "primary",
            disabled: fcs.disabled,
            error: fcs.error,
            focused: fcs.focused,
            formControl: muiFormControl,
            fullWidth,
            hiddenLabel: fcs.hiddenLabel,
            multiline,
            size: fcs.size,
            type
        };
        const RootSlot = slots.root ?? components.Root ?? OutlinedInputRoot;
        const InputSlot = slots.input ?? components.Input ?? OutlinedInputInput;
        const [NotchedSlot, notchedProps] = useSlot("notchedOutline", {
            elementType: NotchedOutlineRoot,
            className: classes.notchedOutline,
            shouldForwardComponentProp: true,
            ownerState,
            externalForwardedProps: {
                slots,
                slotProps
            },
            additionalProps: {
                label: label != null && label !== "" && fcs.required ? jsxRuntimeExports.jsxs(reactExports.Fragment, {
                    children: [
                        label,
                        " ",
                        "*"
                    ]
                }) : label
            }
        });
        return jsxRuntimeExports.jsx(InputBase, {
            slots: {
                root: RootSlot,
                input: InputSlot
            },
            slotProps,
            renderSuffix: (state)=>jsxRuntimeExports.jsx(NotchedSlot, {
                    ...notchedProps,
                    notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
                }),
            fullWidth,
            inputComponent,
            multiline,
            ref,
            type,
            ...other,
            classes: {
                ...classes,
                notchedOutline: null
            }
        });
    });
    OutlinedInput.muiName = "Input";
    function getSelectUtilityClasses(slot) {
        return generateUtilityClass('MuiSelect', slot);
    }
    const selectClasses = generateUtilityClasses('MuiSelect', [
        'root',
        'select',
        'multiple',
        'filled',
        'outlined',
        'standard',
        'disabled',
        'focused',
        'icon',
        'iconOpen',
        'iconFilled',
        'iconOutlined',
        'iconStandard',
        'nativeInput',
        'error'
    ]);
    var _span;
    const SelectSelect = styled(StyledSelectSelect, {
        name: "MuiSelect",
        slot: "Select",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                {
                    [`&.${selectClasses.select}`]: styles.select
                },
                {
                    [`&.${selectClasses.select}`]: styles[ownerState.variant]
                },
                {
                    [`&.${selectClasses.error}`]: styles.error
                },
                {
                    [`&.${selectClasses.multiple}`]: styles.multiple
                }
            ];
        }
    })({
        [`&.${selectClasses.select}`]: {
            height: "auto",
            minHeight: "1.4375em",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            overflow: "hidden"
        }
    });
    const SelectIcon = styled(StyledSelectIcon, {
        name: "MuiSelect",
        slot: "Icon",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.icon,
                ownerState.variant && styles[`icon${capitalize(ownerState.variant)}`],
                ownerState.open && styles.iconOpen
            ];
        }
    })({});
    const SelectNativeInput = styled("input", {
        shouldForwardProp: (prop)=>slotShouldForwardProp(prop) && prop !== "classes",
        name: "MuiSelect",
        slot: "NativeInput"
    })({
        bottom: 0,
        left: 0,
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        width: "100%",
        boxSizing: "border-box"
    });
    function areEqualValues(a, b) {
        if (typeof b === "object" && b !== null) {
            return a === b;
        }
        return String(a) === String(b);
    }
    function isEmpty$1(display) {
        return display == null || typeof display === "string" && !display.trim();
    }
    const useUtilityClasses$3 = (ownerState)=>{
        const { classes, variant, disabled, multiple, open, error } = ownerState;
        const slots = {
            select: [
                "select",
                variant,
                disabled && "disabled",
                multiple && "multiple",
                error && "error"
            ],
            icon: [
                "icon",
                `icon${capitalize(variant)}`,
                open && "iconOpen",
                disabled && "disabled"
            ],
            nativeInput: [
                "nativeInput"
            ]
        };
        return composeClasses(slots, getSelectUtilityClasses, classes);
    };
    const SelectInput = reactExports.forwardRef(function SelectInput2(props, ref) {
        const { "aria-describedby": ariaDescribedby, "aria-label": ariaLabel, autoFocus, autoWidth, children, className, defaultOpen, defaultValue, disabled, displayEmpty, error = false, IconComponent, inputRef: inputRefProp, labelId, MenuProps = {}, multiple, name, onBlur, onChange, onClose, onFocus, onOpen, open: openProp, readOnly, renderValue, required, SelectDisplayProps = {}, tabIndex: tabIndexProp, type, value: valueProp, variant = "standard", ...other } = props;
        const [value, setValueState] = useControlled({
            controlled: valueProp,
            default: defaultValue,
            name: "Select"
        });
        const [openState, setOpenState] = useControlled({
            controlled: openProp,
            default: defaultOpen,
            name: "Select"
        });
        const inputRef = reactExports.useRef(null);
        const displayRef = reactExports.useRef(null);
        const [displayNode, setDisplayNode] = reactExports.useState(null);
        const { current: isOpenControlled } = reactExports.useRef(openProp != null);
        const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
        const handleRef = useForkRef(ref, inputRefProp);
        const handleDisplayRef = reactExports.useCallback((node)=>{
            displayRef.current = node;
            if (node) {
                setDisplayNode(node);
            }
        }, []);
        const anchorElement = displayNode?.parentNode;
        reactExports.useImperativeHandle(handleRef, ()=>({
                focus: ()=>{
                    displayRef.current.focus();
                },
                node: inputRef.current,
                value
            }), [
            value
        ]);
        reactExports.useEffect(()=>{
            if (defaultOpen && openState && displayNode && !isOpenControlled) {
                setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
                displayRef.current.focus();
            }
        }, [
            displayNode,
            autoWidth
        ]);
        reactExports.useEffect(()=>{
            if (autoFocus) {
                displayRef.current.focus();
            }
        }, [
            autoFocus
        ]);
        reactExports.useEffect(()=>{
            if (!labelId) {
                return void 0;
            }
            const label = ownerDocument(displayRef.current).getElementById(labelId);
            if (label) {
                const handler = ()=>{
                    if (getSelection().isCollapsed) {
                        displayRef.current.focus();
                    }
                };
                label.addEventListener("click", handler);
                return ()=>{
                    label.removeEventListener("click", handler);
                };
            }
            return void 0;
        }, [
            labelId
        ]);
        const update = (open2, event)=>{
            if (open2) {
                if (onOpen) {
                    onOpen(event);
                }
            } else if (onClose) {
                onClose(event);
            }
            if (!isOpenControlled) {
                setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
                setOpenState(open2);
            }
        };
        const handleMouseDown = (event)=>{
            if (event.button !== 0) {
                return;
            }
            event.preventDefault();
            displayRef.current.focus();
            update(true, event);
        };
        const handleClose = (event)=>{
            update(false, event);
        };
        const childrenArray = reactExports.Children.toArray(children);
        const handleChange = (event)=>{
            const child = childrenArray.find((childItem)=>childItem.props.value === event.target.value);
            if (child === void 0) {
                return;
            }
            setValueState(child.props.value);
            if (onChange) {
                onChange(event, child);
            }
        };
        const handleItemClick = (child)=>(event)=>{
                let newValue;
                if (!event.currentTarget.hasAttribute("tabindex")) {
                    return;
                }
                if (multiple) {
                    newValue = Array.isArray(value) ? value.slice() : [];
                    const itemIndex = value.indexOf(child.props.value);
                    if (itemIndex === -1) {
                        newValue.push(child.props.value);
                    } else {
                        newValue.splice(itemIndex, 1);
                    }
                } else {
                    newValue = child.props.value;
                }
                if (child.props.onClick) {
                    child.props.onClick(event);
                }
                if (value !== newValue) {
                    setValueState(newValue);
                    if (onChange) {
                        const nativeEvent = event.nativeEvent || event;
                        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                        Object.defineProperty(clonedEvent, "target", {
                            writable: true,
                            value: {
                                value: newValue,
                                name
                            }
                        });
                        onChange(clonedEvent, child);
                    }
                }
                if (!multiple) {
                    update(false, event);
                }
            };
        const handleKeyDown = (event)=>{
            if (!readOnly) {
                const validKeys = [
                    " ",
                    "ArrowUp",
                    "ArrowDown",
                    "Enter"
                ];
                if (validKeys.includes(event.key)) {
                    event.preventDefault();
                    update(true, event);
                }
            }
        };
        const open = displayNode !== null && openState;
        const handleBlur = (event)=>{
            if (!open && onBlur) {
                Object.defineProperty(event, "target", {
                    writable: true,
                    value: {
                        value,
                        name
                    }
                });
                onBlur(event);
            }
        };
        delete other["aria-invalid"];
        let display;
        let displaySingle;
        const displayMultiple = [];
        let computeDisplay = false;
        if (isFilled({
            value
        }) || displayEmpty) {
            if (renderValue) {
                display = renderValue(value);
            } else {
                computeDisplay = true;
            }
        }
        const items = childrenArray.map((child)=>{
            if (!reactExports.isValidElement(child)) {
                return null;
            }
            let selected;
            if (multiple) {
                if (!Array.isArray(value)) {
                    throw new Error(formatMuiErrorMessage(2));
                }
                selected = value.some((v)=>areEqualValues(v, child.props.value));
                if (selected && computeDisplay) {
                    displayMultiple.push(child.props.children);
                }
            } else {
                selected = areEqualValues(value, child.props.value);
                if (selected && computeDisplay) {
                    displaySingle = child.props.children;
                }
            }
            return reactExports.cloneElement(child, {
                "aria-selected": selected ? "true" : "false",
                onClick: handleItemClick(child),
                onKeyUp: (event)=>{
                    if (event.key === " ") {
                        event.preventDefault();
                    }
                    if (child.props.onKeyUp) {
                        child.props.onKeyUp(event);
                    }
                },
                role: "option",
                selected,
                value: void 0,
                "data-value": child.props.value
            });
        });
        if (computeDisplay) {
            if (multiple) {
                if (displayMultiple.length === 0) {
                    display = null;
                } else {
                    display = displayMultiple.reduce((output, child, index)=>{
                        output.push(child);
                        if (index < displayMultiple.length - 1) {
                            output.push(", ");
                        }
                        return output;
                    }, []);
                }
            } else {
                display = displaySingle;
            }
        }
        let menuMinWidth = menuMinWidthState;
        if (!autoWidth && isOpenControlled && displayNode) {
            menuMinWidth = anchorElement.clientWidth;
        }
        let tabIndex;
        if (typeof tabIndexProp !== "undefined") {
            tabIndex = tabIndexProp;
        } else {
            tabIndex = disabled ? null : 0;
        }
        const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
        const ownerState = {
            ...props,
            variant,
            value,
            open,
            error
        };
        const classes = useUtilityClasses$3(ownerState);
        const paperProps = {
            ...MenuProps.PaperProps,
            ...typeof MenuProps.slotProps?.paper === "function" ? MenuProps.slotProps.paper(ownerState) : MenuProps.slotProps?.paper
        };
        const listProps = {
            ...MenuProps.MenuListProps,
            ...typeof MenuProps.slotProps?.list === "function" ? MenuProps.slotProps.list(ownerState) : MenuProps.slotProps?.list
        };
        const listboxId = useId();
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx(SelectSelect, {
                    as: "div",
                    ref: handleDisplayRef,
                    tabIndex,
                    role: "combobox",
                    "aria-controls": open ? listboxId : void 0,
                    "aria-disabled": disabled ? "true" : void 0,
                    "aria-expanded": open ? "true" : "false",
                    "aria-haspopup": "listbox",
                    "aria-label": ariaLabel,
                    "aria-labelledby": [
                        labelId,
                        buttonId
                    ].filter(Boolean).join(" ") || void 0,
                    "aria-describedby": ariaDescribedby,
                    "aria-required": required ? "true" : void 0,
                    "aria-invalid": error ? "true" : void 0,
                    onKeyDown: handleKeyDown,
                    onMouseDown: disabled || readOnly ? null : handleMouseDown,
                    onBlur: handleBlur,
                    onFocus,
                    ...SelectDisplayProps,
                    ownerState,
                    className: clsx(SelectDisplayProps.className, classes.select, className),
                    id: buttonId,
                    children: isEmpty$1(display) ? (_span || (_span = jsxRuntimeExports.jsx("span", {
                        className: "notranslate",
                        "aria-hidden": true,
                        children: "​"
                    }))) : display
                }),
                jsxRuntimeExports.jsx(SelectNativeInput, {
                    "aria-invalid": error,
                    value: Array.isArray(value) ? value.join(",") : value,
                    name,
                    ref: inputRef,
                    "aria-hidden": true,
                    onChange: handleChange,
                    tabIndex: -1,
                    disabled,
                    className: classes.nativeInput,
                    autoFocus,
                    required,
                    ...other,
                    ownerState
                }),
                jsxRuntimeExports.jsx(SelectIcon, {
                    as: IconComponent,
                    className: classes.icon,
                    ownerState
                }),
                jsxRuntimeExports.jsx(Menu, {
                    id: `menu-${name || ""}`,
                    anchorEl: anchorElement,
                    open,
                    onClose: handleClose,
                    anchorOrigin: {
                        vertical: "bottom",
                        horizontal: "center"
                    },
                    transformOrigin: {
                        vertical: "top",
                        horizontal: "center"
                    },
                    ...MenuProps,
                    slotProps: {
                        ...MenuProps.slotProps,
                        list: {
                            "aria-labelledby": labelId,
                            role: "listbox",
                            "aria-multiselectable": multiple ? "true" : void 0,
                            disableListWrap: true,
                            id: listboxId,
                            ...listProps
                        },
                        paper: {
                            ...paperProps,
                            style: {
                                minWidth: menuMinWidth,
                                ...paperProps != null ? paperProps.style : null
                            }
                        }
                    },
                    children: items
                })
            ]
        });
    });
    const useUtilityClasses$2 = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ]
        };
        const composedClasses = composeClasses(slots, getSelectUtilityClasses, classes);
        return {
            ...classes,
            ...composedClasses
        };
    };
    const styledRootConfig = {
        name: "MuiSelect",
        slot: "Root",
        shouldForwardProp: (prop)=>rootShouldForwardProp(prop) && prop !== "variant"
    };
    const StyledInput = styled(Input$3, styledRootConfig)("");
    const StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)("");
    const StyledFilledInput = styled(FilledInput, styledRootConfig)("");
    const Select = reactExports.forwardRef(function Select2(inProps, ref) {
        const props = useDefaultProps({
            name: "MuiSelect",
            props: inProps
        });
        const { autoWidth = false, children, classes: classesProp = {}, className, defaultOpen = false, displayEmpty = false, IconComponent = ArrowDropDownIcon, id, input, inputProps, label, labelId, MenuProps, multiple = false, native = false, onClose, onOpen, open, renderValue, SelectDisplayProps, variant: variantProp = "outlined", ...other } = props;
        const inputComponent = native ? NativeSelectInput : SelectInput;
        const muiFormControl = useFormControl();
        const fcs = formControlState({
            props,
            muiFormControl,
            states: [
                "variant",
                "error"
            ]
        });
        const variant = fcs.variant || variantProp;
        const ownerState = {
            ...props,
            variant,
            classes: classesProp
        };
        const classes = useUtilityClasses$2(ownerState);
        const { root, ...restOfClasses } = classes;
        const InputComponent = input || {
            standard: jsxRuntimeExports.jsx(StyledInput, {
                ownerState
            }),
            outlined: jsxRuntimeExports.jsx(StyledOutlinedInput, {
                label,
                ownerState
            }),
            filled: jsxRuntimeExports.jsx(StyledFilledInput, {
                ownerState
            })
        }[variant];
        const inputComponentRef = useForkRef(ref, getReactElementRef(InputComponent));
        return jsxRuntimeExports.jsx(reactExports.Fragment, {
            children: reactExports.cloneElement(InputComponent, {
                inputComponent,
                inputProps: {
                    children,
                    error: fcs.error,
                    IconComponent,
                    variant,
                    type: void 0,
                    multiple,
                    ...native ? {
                        id
                    } : {
                        autoWidth,
                        defaultOpen,
                        displayEmpty,
                        labelId,
                        MenuProps,
                        onClose,
                        onOpen,
                        open,
                        renderValue,
                        SelectDisplayProps: {
                            id,
                            ...SelectDisplayProps
                        }
                    },
                    ...inputProps,
                    classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses,
                    ...input ? input.props.inputProps : {}
                },
                ...(multiple && native || displayEmpty) && variant === "outlined" ? {
                    notched: true
                } : {},
                ref: inputComponentRef,
                className: clsx(InputComponent.props.className, className, classes.root),
                ...!input && {
                    variant
                },
                ...other
            })
        });
    });
    Select.muiName = "Select";
    function getToolbarUtilityClass(slot) {
        return generateUtilityClass('MuiToolbar', slot);
    }
    generateUtilityClasses('MuiToolbar', [
        'root',
        'gutters',
        'regular',
        'dense'
    ]);
    const useUtilityClasses$1 = (ownerState)=>{
        const { classes, disableGutters, variant } = ownerState;
        const slots = {
            root: [
                "root",
                !disableGutters && "gutters",
                variant
            ]
        };
        return composeClasses(slots, getToolbarUtilityClass, classes);
    };
    const ToolbarRoot = styled("div", {
        name: "MuiToolbar",
        slot: "Root",
        overridesResolver: (props, styles)=>{
            const { ownerState } = props;
            return [
                styles.root,
                !ownerState.disableGutters && styles.gutters,
                styles[ownerState.variant]
            ];
        }
    })(memoTheme(({ theme })=>({
            position: "relative",
            display: "flex",
            alignItems: "center",
            variants: [
                {
                    props: ({ ownerState })=>!ownerState.disableGutters,
                    style: {
                        paddingLeft: theme.spacing(2),
                        paddingRight: theme.spacing(2),
                        [theme.breakpoints.up("sm")]: {
                            paddingLeft: theme.spacing(3),
                            paddingRight: theme.spacing(3)
                        }
                    }
                },
                {
                    props: {
                        variant: "dense"
                    },
                    style: {
                        minHeight: 48
                    }
                },
                {
                    props: {
                        variant: "regular"
                    },
                    style: theme.mixins.toolbar
                }
            ]
        })));
    const Toolbar = reactExports.forwardRef(function Toolbar2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiToolbar"
        });
        const { className, component = "div", disableGutters = false, variant = "regular", ...other } = props;
        const ownerState = {
            ...props,
            component,
            disableGutters,
            variant
        };
        const classes = useUtilityClasses$1(ownerState);
        return jsxRuntimeExports.jsx(ToolbarRoot, {
            as: component,
            className: clsx(classes.root, className),
            ref,
            ownerState,
            ...other
        });
    });
    function getTextFieldUtilityClass(slot) {
        return generateUtilityClass('MuiTextField', slot);
    }
    generateUtilityClasses('MuiTextField', [
        'root'
    ]);
    const variantComponent = {
        standard: Input$3,
        filled: FilledInput,
        outlined: OutlinedInput
    };
    const useUtilityClasses = (ownerState)=>{
        const { classes } = ownerState;
        const slots = {
            root: [
                "root"
            ]
        };
        return composeClasses(slots, getTextFieldUtilityClass, classes);
    };
    const TextFieldRoot = styled(FormControl, {
        name: "MuiTextField",
        slot: "Root"
    })({});
    const TextField = reactExports.forwardRef(function TextField2(inProps, ref) {
        const props = useDefaultProps({
            props: inProps,
            name: "MuiTextField"
        });
        const { autoComplete, autoFocus = false, children, className, color = "primary", defaultValue, disabled = false, error = false, FormHelperTextProps: FormHelperTextPropsProp, fullWidth = false, helperText, id: idOverride, InputLabelProps: InputLabelPropsProp, inputProps: inputPropsProp, InputProps: InputPropsProp, inputRef, label, maxRows, minRows, multiline = false, name, onBlur, onChange, onFocus, placeholder, required = false, rows, select = false, SelectProps: SelectPropsProp, slots = {}, slotProps = {}, type, value, variant = "outlined", ...other } = props;
        const ownerState = {
            ...props,
            autoFocus,
            color,
            disabled,
            error,
            fullWidth,
            multiline,
            required,
            select,
            variant
        };
        const classes = useUtilityClasses(ownerState);
        const id = useId(idOverride);
        const helperTextId = helperText && id ? `${id}-helper-text` : void 0;
        const inputLabelId = label && id ? `${id}-label` : void 0;
        const InputComponent = variantComponent[variant];
        const externalForwardedProps = {
            slots,
            slotProps: {
                input: InputPropsProp,
                inputLabel: InputLabelPropsProp,
                htmlInput: inputPropsProp,
                formHelperText: FormHelperTextPropsProp,
                select: SelectPropsProp,
                ...slotProps
            }
        };
        const inputAdditionalProps = {};
        const inputLabelSlotProps = externalForwardedProps.slotProps.inputLabel;
        if (variant === "outlined") {
            if (inputLabelSlotProps && typeof inputLabelSlotProps.shrink !== "undefined") {
                inputAdditionalProps.notched = inputLabelSlotProps.shrink;
            }
            inputAdditionalProps.label = label;
        }
        if (select) {
            if (!SelectPropsProp || !SelectPropsProp.native) {
                inputAdditionalProps.id = void 0;
            }
            inputAdditionalProps["aria-describedby"] = void 0;
        }
        const [RootSlot, rootProps] = useSlot("root", {
            elementType: TextFieldRoot,
            shouldForwardComponentProp: true,
            externalForwardedProps: {
                ...externalForwardedProps,
                ...other
            },
            ownerState,
            className: clsx(classes.root, className),
            ref,
            additionalProps: {
                disabled,
                error,
                fullWidth,
                required,
                color,
                variant
            }
        });
        const [InputSlot, inputProps] = useSlot("input", {
            elementType: InputComponent,
            externalForwardedProps,
            additionalProps: inputAdditionalProps,
            ownerState
        });
        const [InputLabelSlot, inputLabelProps] = useSlot("inputLabel", {
            elementType: InputLabel,
            externalForwardedProps,
            ownerState
        });
        const [HtmlInputSlot, htmlInputProps] = useSlot("htmlInput", {
            elementType: "input",
            externalForwardedProps,
            ownerState
        });
        const [FormHelperTextSlot, formHelperTextProps] = useSlot("formHelperText", {
            elementType: FormHelperText,
            externalForwardedProps,
            ownerState
        });
        const [SelectSlot, selectProps] = useSlot("select", {
            elementType: Select,
            externalForwardedProps,
            ownerState
        });
        const InputElement = jsxRuntimeExports.jsx(InputSlot, {
            "aria-describedby": helperTextId,
            autoComplete,
            autoFocus,
            defaultValue,
            fullWidth,
            multiline,
            name,
            rows,
            maxRows,
            minRows,
            type,
            value,
            id,
            inputRef,
            onBlur,
            onChange,
            onFocus,
            placeholder,
            inputProps: htmlInputProps,
            slots: {
                input: slots.htmlInput ? HtmlInputSlot : void 0
            },
            ...inputProps
        });
        return jsxRuntimeExports.jsxs(RootSlot, {
            ...rootProps,
            children: [
                label != null && label !== "" && jsxRuntimeExports.jsx(InputLabelSlot, {
                    htmlFor: id,
                    id: inputLabelId,
                    ...inputLabelProps,
                    children: label
                }),
                select ? jsxRuntimeExports.jsx(SelectSlot, {
                    "aria-describedby": helperTextId,
                    id,
                    labelId: inputLabelId,
                    value,
                    input: InputElement,
                    ...selectProps,
                    children
                }) : InputElement,
                helperText && jsxRuntimeExports.jsx(FormHelperTextSlot, {
                    id: helperTextId,
                    ...formHelperTextProps,
                    children: helperText
                })
            ]
        });
    });
    const theme = createTheme({
        palette: {
            mode: "dark",
            primary: {
                main: "#1976d2",
                light: "#42a5f5",
                dark: "#1565c0"
            },
            secondary: {
                main: "#dc004e",
                light: "#ff6b93",
                dark: "#9a0036"
            },
            background: {
                default: "#121212",
                paper: "#1e1e1e"
            },
            text: {
                primary: "#ffffff",
                secondary: "#b3b3b3"
            }
        },
        typography: {
            fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
            h1: {
                fontSize: "2.5rem",
                fontWeight: 600
            },
            h2: {
                fontSize: "2rem",
                fontWeight: 500
            },
            h3: {
                fontSize: "1.5rem",
                fontWeight: 500
            }
        },
        components: {
            MuiCard: {
                styleOverrides: {
                    root: {
                        backgroundColor: "#1e1e1e",
                        borderRadius: 12,
                        boxShadow: "0 4px 20px rgba(0, 0, 0, 0.3)"
                    }
                }
            },
            MuiButton: {
                styleOverrides: {
                    root: {
                        borderRadius: 8,
                        textTransform: "none",
                        fontWeight: 500
                    }
                }
            }
        }
    });
    var AuctionRound = ((AuctionRound2)=>{
        AuctionRound2["BIDDING"] = "bidding";
        AuctionRound2["REVEALING"] = "revealing";
        AuctionRound2["FINISHED"] = "finished";
        return AuctionRound2;
    })(AuctionRound || {});
    const APIPhase = {
        BIDDING: "bidding",
        REVEALING: "revealing",
        FINISHED: "finished"
    };
    function apiPhaseToUIRound(apiPhase) {
        switch(apiPhase){
            case APIPhase.BIDDING:
                return AuctionRound.BIDDING;
            case APIPhase.REVEALING:
                return AuctionRound.REVEALING;
            case APIPhase.FINISHED:
                return AuctionRound.FINISHED;
            default:
                return AuctionRound.BIDDING;
        }
    }
    function apiRevealedBidToUI(apiBid) {
        return {
            participantId: apiBid.participantId,
            bidAmount: Number(apiBid.bidAmount),
            timestamp: Number(apiBid.timestamp)
        };
    }
    function apiPublicStateToUIData(apiState) {
        return {
            productName: apiState.productName,
            productDescription: apiState.productDescription,
            minimumBidValue: Number(apiState.minimumBidValue),
            auctioneerPublicKey: Array.from(apiState.auctioneerPublicKey).map((b)=>b.toString(16).padStart(2, "0")).join(""),
            currentRound: apiPhaseToUIRound(apiState.currentPhase),
            totalBids: Number(apiState.totalBids),
            revealedBids: apiState.revealedBids.map(apiRevealedBidToUI)
        };
    }
    function apiStateToUIState(apiState) {
        const uiAuctionData = apiPublicStateToUIData(apiState.publicState);
        let currentUserBid;
        if (apiState.myCurrentBid) {
            currentUserBid = {
                bidAmount: Number(apiState.myCurrentBid.bidAmount),
                nonce: Array.from(apiState.myCurrentBid.commitment || new Uint8Array()).map((b)=>b.toString(16).padStart(2, "0")).join(""),
                commitment: Array.from(apiState.myCurrentBid.commitment || new Uint8Array()).map((b)=>b.toString(16).padStart(2, "0")).join("")
            };
        }
        return {
            auction: uiAuctionData,
            currentUserBid,
            isParticipant: apiState.hasSubmittedBid,
            canSubmitBid: apiState.canSubmitBid,
            canRevealBid: apiState.canRevealBid
        };
    }
    function dollarsToCents(dollars) {
        return BigInt(Math.round(dollars * 100));
    }
    class MockAuctionAPI {
        static async deploy(_providers, _logger) {
            return new MockAuctionAPI();
        }
        static async join(_providers, _contractAddress, _logger) {
            return new MockAuctionAPI();
        }
        state$ = {
            subscribe: (_observer)=>({
                    unsubscribe: ()=>{}
                })
        };
        async createAuction(productName, productDescription, minimumBid) {
            console.log("Mock: Creating auction:", {
                productName,
                productDescription,
                minimumBid
            });
        }
        async submitBid(bidAmount) {
            console.log("Mock: Submitting bid:", bidAmount);
        }
        async revealBid(bidAmount, nonce) {
            console.log("Mock: Revealing bid:", {
                bidAmount,
                nonce
            });
        }
        async closeBidding() {
            console.log("Mock: Closing bidding");
        }
        async startRevealing() {
            console.log("Mock: Starting revealing");
        }
        async finishAuction() {
            console.log("Mock: Finishing auction");
        }
        async refreshState() {
            console.log("Mock: Refreshing state");
        }
    }
    const AuctionAPI$1 = MockAuctionAPI;
    const AuctionContext = reactExports.createContext(void 0);
    function AuctionProvider({ children, providers }) {
        const [auctionAPI, setAuctionAPI] = reactExports.useState(null);
        const [isConnected, setIsConnected] = reactExports.useState(false);
        const [auctionState, _setAuctionState] = reactExports.useState(apiStateToUIState(auctionAPI?.state$ || {}));
        const [loading, setLoading] = reactExports.useState(false);
        const [error, setError] = reactExports.useState(null);
        reactExports.useEffect(()=>{
            if (!auctionAPI) return;
            const subscription = auctionAPI.state$.subscribe({
                next: (apiState)=>{
                    console.log("API state update:", apiState);
                },
                error: (err)=>{
                    console.error("API error:", err);
                }
            });
            return ()=>subscription.unsubscribe();
        }, [
            auctionAPI
        ]);
        const deployNewAuction = async (productName, productDescription, minimumBid)=>{
            setLoading(true);
            setError(null);
            try {
                const api = await AuctionAPI$1.deploy(providers || {});
                await api.createAuction(productName, productDescription, dollarsToCents(minimumBid));
                setAuctionAPI(api);
                setIsConnected(true);
            } catch (err) {
                setError(`Error deploying auction: ${err instanceof Error ? err.message : "Unknown error"}`);
                throw err;
            } finally{
                setLoading(false);
            }
        };
        const joinExistingAuction = async (contractAddress)=>{
            setLoading(true);
            setError(null);
            try {
                const api = await AuctionAPI$1.join(providers || {}, contractAddress);
                setAuctionAPI(api);
                setIsConnected(true);
            } catch (err) {
                setError(`Error joining auction: ${err instanceof Error ? err.message : "Unknown error"}`);
                throw err;
            } finally{
                setLoading(false);
            }
        };
        const joinAuction = async ()=>{
            setError("Please use the join buttons on the home page to connect to an auction");
        };
        const submitBid = async (bidAmount)=>{
            if (!auctionAPI) {
                throw new Error("Not connected to an auction. Please join an auction first.");
            }
            if (bidAmount < auctionState.auction.minimumBidValue) {
                throw new Error(`The bid must be greater than $${auctionState.auction.minimumBidValue}`);
            }
            if (auctionState.auction.currentRound !== AuctionRound.BIDDING) {
                throw new Error("Bids can only be submitted during the bidding phase");
            }
            setLoading(true);
            setError(null);
            try {
                await auctionAPI.submitBid(dollarsToCents(bidAmount));
            } catch (err) {
                setError(`Error submitting bid: ${err instanceof Error ? err.message : "Unknown error"}`);
                throw err;
            } finally{
                setLoading(false);
            }
        };
        const revealBid = async ()=>{
            throw new Error("Users cannot reveal their own bids. The auctioneer reveals them automatically.");
        };
        const refreshAuctionData = async ()=>{
            if (!auctionAPI) {
                setError("Not connected to an auction");
                return;
            }
            setLoading(true);
            setError(null);
            try {
                await auctionAPI.refreshState();
            } catch (err) {
                setError(`Error refreshing auction data: ${err instanceof Error ? err.message : "Unknown error"}`);
            } finally{
                setLoading(false);
            }
        };
        const startBiddingPhase = async ()=>{
            if (!auctionAPI) {
                throw new Error("Not connected to an auction");
            }
            setLoading(true);
            setError(null);
            try {
                await auctionAPI.refreshState();
            } catch (err) {
                setError(`Error starting bidding phase: ${err instanceof Error ? err.message : "Unknown error"}`);
                throw err;
            } finally{
                setLoading(false);
            }
        };
        const closeBidding = async ()=>{
            if (!auctionAPI) {
                throw new Error("Not connected to an auction");
            }
            setLoading(true);
            setError(null);
            try {
                await auctionAPI.closeBidding();
            } catch (err) {
                setError(`Error closing bidding: ${err instanceof Error ? err.message : "Unknown error"}`);
                throw err;
            } finally{
                setLoading(false);
            }
        };
        const startRevealingPhase = async ()=>{
            if (!auctionAPI) {
                throw new Error("Not connected to an auction");
            }
            setLoading(true);
            setError(null);
            try {
                await auctionAPI.startRevealing();
            } catch (err) {
                setError(`Error starting revealing phase: ${err instanceof Error ? err.message : "Unknown error"}`);
                throw err;
            } finally{
                setLoading(false);
            }
        };
        const finishAuction = async ()=>{
            if (!auctionAPI) {
                throw new Error("Not connected to an auction");
            }
            setLoading(true);
            setError(null);
            try {
                await auctionAPI.finishAuction();
            } catch (err) {
                setError(`Error finishing auction: ${err instanceof Error ? err.message : "Unknown error"}`);
                throw err;
            } finally{
                setLoading(false);
            }
        };
        const revealSpecificBid = async (participantId, bidAmount)=>{
            console.log(`Revealing bid for participant ${participantId} with amount ${bidAmount}`);
        };
        const value = {
            auctionState,
            submitBid,
            revealBid,
            joinAuction,
            refreshAuctionData,
            startBiddingPhase,
            closeBidding,
            startRevealingPhase,
            finishAuction,
            revealSpecificBid,
            deployNewAuction,
            joinExistingAuction,
            loading,
            error,
            isConnected
        };
        return jsxRuntimeExports.jsx(AuctionContext.Provider, {
            value,
            children
        });
    }
    function useAuction() {
        const context = reactExports.useContext(AuctionContext);
        if (context === void 0) {
            throw new Error("useAuction debe ser usado dentro de un AuctionProvider");
        }
        return context;
    }
    function Header({ isParticipant, userRole }) {
        return jsxRuntimeExports.jsx(AppBar, {
            position: "static",
            children: jsxRuntimeExports.jsxs(Toolbar, {
                children: [
                    jsxRuntimeExports.jsx(Typography, {
                        variant: "h6",
                        component: "div",
                        sx: {
                            flexGrow: 1
                        },
                        children: "Midnauction"
                    }),
                    jsxRuntimeExports.jsxs(Box, {
                        sx: {
                            display: "flex",
                            alignItems: "center",
                            gap: 2
                        },
                        children: [
                            jsxRuntimeExports.jsx(Typography, {
                                variant: "subtitle2",
                                sx: {
                                    opacity: 0.8
                                },
                                children: isParticipant ? "Participant" : "Auctioneer"
                            }),
                            userRole && jsxRuntimeExports.jsxs(Typography, {
                                variant: "subtitle2",
                                sx: {
                                    opacity: 0.6
                                },
                                children: [
                                    "(",
                                    userRole,
                                    ")"
                                ]
                            })
                        ]
                    })
                ]
            })
        });
    }
    function MainLayout({ children, isParticipant, userRole }) {
        return jsxRuntimeExports.jsxs(Box, {
            sx: {
                display: "flex",
                flexDirection: "column",
                minHeight: "100vh"
            },
            children: [
                jsxRuntimeExports.jsx(Header, {
                    isParticipant,
                    userRole
                }),
                jsxRuntimeExports.jsx(Container, {
                    maxWidth: "lg",
                    sx: {
                        mt: 4,
                        mb: 4,
                        flexGrow: 1
                    },
                    children
                })
            ]
        });
    }
    const Add = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
    }));
    const ArrowBack = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"
    }));
    const AttachMoney = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4"
    }));
    const Flag = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M14.4 6 14 4H5v17h2v-7h5.6l.4 2h7V6z"
    }));
    const Gavel = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "m5.2494 8.0688 2.83-2.8269 14.1343 14.15-2.83 2.8269zm4.2363-4.2415 2.828-2.8289 5.6577 5.656-2.828 2.8289zM.9989 12.3147l2.8284-2.8285 5.6569 5.6569-2.8285 2.8284zM1 21h12v2H1z"
    }));
    const Lock = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2m3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1z"
    }));
    const PersonAdd = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M15 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4m-9-2V7H4v3H1v2h3v3h2v-3h3v-2zm9 4c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4"
    }));
    const Refresh = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4z"
    }));
    const Search = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
    }));
    const Timer = createSvgIcon(jsxRuntimeExports.jsx("path", {
        d: "M9 1h6v2H9zm10.03 6.39 1.42-1.42c-.43-.51-.9-.99-1.41-1.41l-1.42 1.42C16.07 4.74 14.12 4 12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9 9-4.03 9-9c0-2.12-.74-4.07-1.97-5.61M13 14h-2V8h2z"
    }));
    function HomePage() {
        const navigate = useNavigate();
        return jsxRuntimeExports.jsxs(Box, {
            sx: {
                p: 3
            },
            children: [
                jsxRuntimeExports.jsxs(Box, {
                    textAlign: "center",
                    mb: 6,
                    children: [
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h3",
                            component: "h1",
                            gutterBottom: true,
                            children: "Welcome to Midnauction"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h6",
                            color: "text.secondary",
                            paragraph: true,
                            children: "A private, secure auction system built on Midnight Network"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "body1",
                            color: "text.secondary",
                            children: "Participate in auctions with private bids or create your own auction"
                        })
                    ]
                }),
                jsxRuntimeExports.jsxs(Box, {
                    sx: {
                        display: "grid",
                        gridTemplateColumns: {
                            xs: "1fr",
                            md: "repeat(3, 1fr)"
                        },
                        gap: 3
                    },
                    children: [
                        jsxRuntimeExports.jsx(Box, {
                            sx: {
                                minWidth: 320,
                                maxWidth: 400
                            },
                            children: jsxRuntimeExports.jsx(Card, {
                                children: jsxRuntimeExports.jsxs(CardContent, {
                                    children: [
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "h5",
                                            component: "h2",
                                            gutterBottom: true,
                                            children: "Join as Participant"
                                        }),
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "text.secondary",
                                            paragraph: true,
                                            children: "Participate in existing auctions by submitting private bids and revealing them when the time comes."
                                        }),
                                        jsxRuntimeExports.jsx(Button, {
                                            variant: "contained",
                                            color: "primary",
                                            onClick: ()=>navigate("/join-participant"),
                                            fullWidth: true,
                                            startIcon: jsxRuntimeExports.jsx(PersonAdd, {}),
                                            children: "Join Auction"
                                        })
                                    ]
                                })
                            })
                        }),
                        jsxRuntimeExports.jsx(Box, {
                            sx: {
                                minWidth: 320,
                                maxWidth: 400
                            },
                            children: jsxRuntimeExports.jsx(Card, {
                                children: jsxRuntimeExports.jsxs(CardContent, {
                                    children: [
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "h5",
                                            component: "h2",
                                            gutterBottom: true,
                                            children: "Join as Auctioneer"
                                        }),
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "text.secondary",
                                            paragraph: true,
                                            children: "Manage existing auctions, control phases, and determine winners."
                                        }),
                                        jsxRuntimeExports.jsx(Button, {
                                            variant: "contained",
                                            color: "secondary",
                                            onClick: ()=>navigate("/join-auctioneer"),
                                            fullWidth: true,
                                            startIcon: jsxRuntimeExports.jsx(Gavel, {}),
                                            children: "Join as Auctioneer"
                                        })
                                    ]
                                })
                            })
                        }),
                        jsxRuntimeExports.jsx(Box, {
                            sx: {
                                minWidth: 320,
                                maxWidth: 400
                            },
                            children: jsxRuntimeExports.jsx(Card, {
                                children: jsxRuntimeExports.jsxs(CardContent, {
                                    children: [
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "h5",
                                            component: "h2",
                                            gutterBottom: true,
                                            children: "Create New Auction"
                                        }),
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "text.secondary",
                                            paragraph: true,
                                            children: "Start a new auction by setting up product details and minimum bid requirements."
                                        }),
                                        jsxRuntimeExports.jsx(Button, {
                                            variant: "contained",
                                            color: "success",
                                            onClick: ()=>navigate("/create-auction"),
                                            fullWidth: true,
                                            startIcon: jsxRuntimeExports.jsx(Add, {}),
                                            children: "Create Auction"
                                        })
                                    ]
                                })
                            })
                        })
                    ]
                })
            ]
        });
    }
    function CreateAuctionPage() {
        const navigate = useNavigate();
        const { deployNewAuction, loading, error } = useAuction();
        const [localError, setLocalError] = reactExports.useState(null);
        const [formData, setFormData] = reactExports.useState({
            productName: "",
            productDescription: "",
            minimumBidValue: ""
        });
        const handleInputChange = (field)=>(event)=>{
                setFormData((prev)=>({
                        ...prev,
                        [field]: event.target.value
                    }));
            };
        const handleCreateAuction = async ()=>{
            if (!formData.productName || !formData.productDescription || !formData.minimumBidValue) {
                setLocalError("Please complete all fields");
                return;
            }
            const minBid = parseFloat(formData.minimumBidValue);
            if (isNaN(minBid) || minBid <= 0) {
                setLocalError("The minimum value must be a number greater than 0");
                return;
            }
            setLocalError(null);
            try {
                await deployNewAuction(formData.productName, formData.productDescription, minBid);
                const contractAddress = `0x${Math.random().toString(16).substring(2, 42)}`;
                navigate(`/auction/${contractAddress}?role=auctioneer`);
            } catch (err) {
                setLocalError(err instanceof Error ? err.message : "Error creating auction");
            }
        };
        const handleBack = ()=>{
            navigate("/");
        };
        const isFormValid = formData.productName && formData.productDescription && formData.minimumBidValue;
        return jsxRuntimeExports.jsxs(Box, {
            sx: {
                mt: 4,
                mb: 4
            },
            children: [
                jsxRuntimeExports.jsxs(Box, {
                    mb: 4,
                    children: [
                        jsxRuntimeExports.jsx(Button, {
                            startIcon: jsxRuntimeExports.jsx(ArrowBack, {}),
                            onClick: handleBack,
                            sx: {
                                mb: 2
                            },
                            children: "Back to Home"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h4",
                            component: "h1",
                            gutterBottom: true,
                            children: "Create New Auction"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "body1",
                            color: "text.secondary",
                            children: "Complete the information of the product you want to auction"
                        })
                    ]
                }),
                jsxRuntimeExports.jsx(Card, {
                    children: jsxRuntimeExports.jsxs(CardContent, {
                        sx: {
                            p: 4
                        },
                        children: [
                            (error || localError) && jsxRuntimeExports.jsx(Alert, {
                                severity: "error",
                                sx: {
                                    mb: 3
                                },
                                children: error || localError
                            }),
                            jsxRuntimeExports.jsxs(Box, {
                                sx: {
                                    display: "grid",
                                    gridTemplateColumns: "1fr",
                                    gap: 3
                                },
                                children: [
                                    jsxRuntimeExports.jsxs(Box, {
                                        children: [
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "h6",
                                                gutterBottom: true,
                                                children: "Product Information"
                                            }),
                                            jsxRuntimeExports.jsx(TextField, {
                                                fullWidth: true,
                                                label: "Product Name",
                                                value: formData.productName,
                                                onChange: handleInputChange("productName"),
                                                required: true,
                                                sx: {
                                                    mb: 2
                                                }
                                            }),
                                            jsxRuntimeExports.jsx(TextField, {
                                                fullWidth: true,
                                                label: "Product Description",
                                                value: formData.productDescription,
                                                onChange: handleInputChange("productDescription"),
                                                multiline: true,
                                                rows: 3,
                                                required: true
                                            })
                                        ]
                                    }),
                                    jsxRuntimeExports.jsxs(Box, {
                                        children: [
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "h6",
                                                gutterBottom: true,
                                                children: "Auction Settings"
                                            }),
                                            jsxRuntimeExports.jsx(TextField, {
                                                fullWidth: true,
                                                label: "Minimum Bid (USD)",
                                                type: "number",
                                                value: formData.minimumBidValue,
                                                onChange: handleInputChange("minimumBidValue"),
                                                required: true,
                                                inputProps: {
                                                    min: 0,
                                                    step: 0.01
                                                }
                                            })
                                        ]
                                    }),
                                    jsxRuntimeExports.jsxs(Box, {
                                        sx: {
                                            display: "grid",
                                            gridTemplateColumns: {
                                                xs: "1fr",
                                                md: "1fr 1fr"
                                            },
                                            gap: 2
                                        },
                                        children: [
                                            jsxRuntimeExports.jsx(Button, {
                                                variant: "outlined",
                                                onClick: handleBack,
                                                fullWidth: true,
                                                children: "Cancel"
                                            }),
                                            jsxRuntimeExports.jsx(Button, {
                                                variant: "contained",
                                                onClick: handleCreateAuction,
                                                disabled: !isFormValid || loading,
                                                fullWidth: true,
                                                children: loading ? "Creating Auction..." : "Create Auction"
                                            })
                                        ]
                                    })
                                ]
                            })
                        ]
                    })
                }),
                jsxRuntimeExports.jsx(Box, {
                    mt: 4,
                    children: jsxRuntimeExports.jsx(Alert, {
                        severity: "info",
                        children: jsxRuntimeExports.jsxs(Typography, {
                            variant: "body2",
                            children: [
                                jsxRuntimeExports.jsx("strong", {
                                    children: "How does it work?"
                                }),
                                jsxRuntimeExports.jsx("br", {}),
                                "1. Complete the product information",
                                jsxRuntimeExports.jsx("br", {}),
                                "2. A smart contract will be deployed on the blockchain",
                                jsxRuntimeExports.jsx("br", {}),
                                "3. Participants can join using the contract address",
                                jsxRuntimeExports.jsx("br", {}),
                                "4. As an auctioneer, you'll have total control over the auction phases"
                            ]
                        })
                    })
                })
            ]
        });
    }
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        } instanceof Array && function(d, b) {
            d.__proto__ = b;
        }) || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for(var s, i = 1, n = arguments.length; i < n; i++){
                s = arguments[i];
                for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function(target, key) {
            decorator(target, key, paramIndex);
        };
    }
    function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
            if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
            return f;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for(var i = decorators.length - 1; i >= 0; i--){
            var context = {};
            for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
            for(var p in contextIn.access)context.access[p] = contextIn.access[p];
            context.addInitializer = function(f) {
                if (done) throw new TypeError("Cannot add initializers after decoration has completed");
                extraInitializers.push(accept(f || null));
            };
            var result = (0, decorators[i])(kind === "accessor" ? {
                get: descriptor.get,
                set: descriptor.set
            } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.unshift(_);
            } else if (_ = accept(result)) {
                if (kind === "field") initializers.unshift(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    }
    function __runInitializers(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for(var i = 0; i < initializers.length; i++){
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    }
    function __propKey(x) {
        return typeof x === "symbol" ? x : "".concat(x);
    }
    function __setFunctionName(f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", {
            configurable: true,
            value: prefix ? "".concat(prefix, " ", name) : name
        });
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
            });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
            },
            trys: [],
            ops: []
        }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
        return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
        }), g;
        function verb(n) {
            return function(v) {
                return step([
                    n,
                    v
                ]);
            };
        }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while(g && (g = 0, op[0] && (_ = 0)), _)try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [
                    op[0] & 2,
                    t.value
                ];
                switch(op[0]){
                    case 0:
                    case 1:
                        t = op;
                        break;
                    case 4:
                        _.label++;
                        return {
                            value: op[1],
                            done: false
                        };
                    case 5:
                        _.label++;
                        y = op[1];
                        op = [
                            0
                        ];
                        continue;
                    case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                        }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                            _.label = op[1];
                            break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                }
                op = body.call(thisArg, _);
            } catch (e) {
                op = [
                    6,
                    e
                ];
                y = 0;
            } finally{
                f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return {
                value: op[0] ? op[1] : void 0,
                done: true
            };
        }
    }
    var __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function() {
                if (o && i >= o.length) o = void 0;
                return {
                    value: o && o[i++],
                    done: !o
                };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
        } catch (error) {
            e = {
                error: error
            };
        } finally{
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            } finally{
                if (e) throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
        for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
            return this;
        }, i;
        function awaitReturn(f) {
            return function(v) {
                return Promise.resolve(v).then(f, reject);
            };
        }
        function verb(n, f) {
            if (g[n]) {
                i[n] = function(v) {
                    return new Promise(function(a, b) {
                        q.push([
                            n,
                            v,
                            a,
                            b
                        ]) > 1 || resume(n, v);
                    });
                };
                if (f) i[n] = f(i[n]);
            }
        }
        function resume(n, v) {
            try {
                step(g[n](v));
            } catch (e) {
                settle(q[0][3], e);
            }
        }
        function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
            resume("next", value);
        }
        function reject(value) {
            resume("throw", value);
        }
        function settle(f, v) {
            if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
            return this;
        }, i;
        function verb(n, f) {
            i[n] = o[n] ? function(v) {
                return (p = !p) ? {
                    value: __await(o[n](v)),
                    done: false
                } : f ? f(v) : v;
            } : f;
        }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
        }, i);
        function verb(n) {
            i[n] = o[n] && function(v) {
                return new Promise(function(resolve, reject) {
                    v = o[n](v), settle(resolve, reject, v.done, v.value);
                });
            };
        }
        function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v) {
                resolve({
                    value: v,
                    done: d
                });
            }, reject);
        }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", {
                value: raw
            });
        } else {
            cooked.raw = raw;
        }
        return cooked;
    }
    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", {
            enumerable: true,
            value: v
        });
    }) : function(o, v) {
        o["default"] = v;
    };
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : {
            default: mod
        };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }
    function __classPrivateFieldIn(state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    }
    function __addDisposableResource(env, value, async) {
        if (value !== null && value !== void 0) {
            if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
            var dispose, inner;
            if (async) {
                if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                dispose = value[Symbol.asyncDispose];
            }
            if (dispose === void 0) {
                if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                dispose = value[Symbol.dispose];
                if (async) inner = dispose;
            }
            if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
            if (inner) dispose = function() {
                try {
                    inner.call(this);
                } catch (e) {
                    return Promise.reject(e);
                }
            };
            env.stack.push({
                value: value,
                dispose: dispose,
                async: async
            });
        } else if (async) {
            env.stack.push({
                async: true
            });
        }
        return value;
    }
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    function __disposeResources(env) {
        function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        var r, s = 0;
        function next() {
            while(r = env.stack.pop()){
                try {
                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
                    if (r.dispose) {
                        var result = r.dispose.call(r.value);
                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                        });
                    } else s |= 1;
                } catch (e) {
                    fail(e);
                }
            }
            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
            if (env.hasError) throw env.error;
        }
        return next();
    }
    function __rewriteRelativeImportExtension(path, preserveJsx) {
        if (typeof path === "string" && /^\.\.?\//.test(path)) {
            return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
                return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
            });
        }
        return path;
    }
    const tslib_es6 = {
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __esDecorate,
        __runInitializers,
        __propKey,
        __setFunctionName,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn,
        __addDisposableResource,
        __disposeResources,
        __rewriteRelativeImportExtension
    };
    const tslib_es6$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        __addDisposableResource,
        get __assign () {
            return __assign;
        },
        __asyncDelegator,
        __asyncGenerator,
        __asyncValues,
        __await,
        __awaiter,
        __classPrivateFieldGet,
        __classPrivateFieldIn,
        __classPrivateFieldSet,
        __createBinding,
        __decorate,
        __disposeResources,
        __esDecorate,
        __exportStar,
        __extends,
        __generator,
        __importDefault,
        __importStar,
        __makeTemplateObject,
        __metadata,
        __param,
        __propKey,
        __read,
        __rest,
        __rewriteRelativeImportExtension,
        __runInitializers,
        __setFunctionName,
        __spread,
        __spreadArray,
        __spreadArrays,
        __values,
        default: tslib_es6
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    function isFunction(value) {
        return typeof value === 'function';
    }
    function createErrorClass(createImpl) {
        var _super = function(instance) {
            Error.call(instance);
            instance.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
    }
    var UnsubscriptionError = createErrorClass(function(_super) {
        return function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
                return i + 1 + ") " + err.toString();
            }).join('\n  ') : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
        };
    });
    function arrRemove(arr, item) {
        if (arr) {
            var index = arr.indexOf(item);
            0 <= index && arr.splice(index, 1);
        }
    }
    var Subscription$1 = (function() {
        function Subscription(initialTeardown) {
            this.initialTeardown = initialTeardown;
            this.closed = false;
            this._parentage = null;
            this._finalizers = null;
        }
        Subscription.prototype.unsubscribe = function() {
            var e_1, _a, e_2, _b;
            var errors;
            if (!this.closed) {
                this.closed = true;
                var _parentage = this._parentage;
                if (_parentage) {
                    this._parentage = null;
                    if (Array.isArray(_parentage)) {
                        try {
                            for(var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()){
                                var parent_1 = _parentage_1_1.value;
                                parent_1.remove(this);
                            }
                        } catch (e_1_1) {
                            e_1 = {
                                error: e_1_1
                            };
                        } finally{
                            try {
                                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                            } finally{
                                if (e_1) throw e_1.error;
                            }
                        }
                    } else {
                        _parentage.remove(this);
                    }
                }
                var initialFinalizer = this.initialTeardown;
                if (isFunction(initialFinalizer)) {
                    try {
                        initialFinalizer();
                    } catch (e) {
                        errors = e instanceof UnsubscriptionError ? e.errors : [
                            e
                        ];
                    }
                }
                var _finalizers = this._finalizers;
                if (_finalizers) {
                    this._finalizers = null;
                    try {
                        for(var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()){
                            var finalizer = _finalizers_1_1.value;
                            try {
                                execFinalizer(finalizer);
                            } catch (err) {
                                errors = errors !== null && errors !== void 0 ? errors : [];
                                if (err instanceof UnsubscriptionError) {
                                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                                } else {
                                    errors.push(err);
                                }
                            }
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                }
                if (errors) {
                    throw new UnsubscriptionError(errors);
                }
            }
        };
        Subscription.prototype.add = function(teardown) {
            var _a;
            if (teardown && teardown !== this) {
                if (this.closed) {
                    execFinalizer(teardown);
                } else {
                    if (teardown instanceof Subscription) {
                        if (teardown.closed || teardown._hasParent(this)) {
                            return;
                        }
                        teardown._addParent(this);
                    }
                    (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
                }
            }
        };
        Subscription.prototype._hasParent = function(parent) {
            var _parentage = this._parentage;
            return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
        };
        Subscription.prototype._addParent = function(parent) {
            var _parentage = this._parentage;
            this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [
                _parentage,
                parent
            ] : parent;
        };
        Subscription.prototype._removeParent = function(parent) {
            var _parentage = this._parentage;
            if (_parentage === parent) {
                this._parentage = null;
            } else if (Array.isArray(_parentage)) {
                arrRemove(_parentage, parent);
            }
        };
        Subscription.prototype.remove = function(teardown) {
            var _finalizers = this._finalizers;
            _finalizers && arrRemove(_finalizers, teardown);
            if (teardown instanceof Subscription) {
                teardown._removeParent(this);
            }
        };
        Subscription.EMPTY = (function() {
            var empty = new Subscription();
            empty.closed = true;
            return empty;
        })();
        return Subscription;
    }());
    var EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
    function isSubscription(value) {
        return (value instanceof Subscription$1 || (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
    }
    function execFinalizer(finalizer) {
        if (isFunction(finalizer)) {
            finalizer();
        } else {
            finalizer.unsubscribe();
        }
    }
    var config = {
        Promise: undefined
    };
    var timeoutProvider = {
        setTimeout: function(handler, timeout) {
            var args = [];
            for(var _i = 2; _i < arguments.length; _i++){
                args[_i - 2] = arguments[_i];
            }
            return setTimeout.apply(void 0, __spreadArray([
                handler,
                timeout
            ], __read(args)));
        },
        clearTimeout: function(handle) {
            return (clearTimeout)(handle);
        },
        delegate: undefined
    };
    function reportUnhandledError(err) {
        timeoutProvider.setTimeout(function() {
            {
                throw err;
            }
        });
    }
    function noop$1() {}
    function errorContext(cb) {
        {
            cb();
        }
    }
    var Subscriber = (function(_super) {
        __extends(Subscriber, _super);
        function Subscriber(destination) {
            var _this = _super.call(this) || this;
            _this.isStopped = false;
            if (destination) {
                _this.destination = destination;
                if (isSubscription(destination)) {
                    destination.add(_this);
                }
            } else {
                _this.destination = EMPTY_OBSERVER;
            }
            return _this;
        }
        Subscriber.create = function(next, error, complete) {
            return new SafeSubscriber(next, error, complete);
        };
        Subscriber.prototype.next = function(value) {
            if (this.isStopped) ;
            else {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function(err) {
            if (this.isStopped) ;
            else {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function() {
            if (this.isStopped) ;
            else {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function() {
            if (!this.closed) {
                this.isStopped = true;
                _super.prototype.unsubscribe.call(this);
                this.destination = null;
            }
        };
        Subscriber.prototype._next = function(value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function(err) {
            try {
                this.destination.error(err);
            } finally{
                this.unsubscribe();
            }
        };
        Subscriber.prototype._complete = function() {
            try {
                this.destination.complete();
            } finally{
                this.unsubscribe();
            }
        };
        return Subscriber;
    }(Subscription$1));
    var ConsumerObserver = (function() {
        function ConsumerObserver(partialObserver) {
            this.partialObserver = partialObserver;
        }
        ConsumerObserver.prototype.next = function(value) {
            var partialObserver = this.partialObserver;
            if (partialObserver.next) {
                try {
                    partialObserver.next(value);
                } catch (error) {
                    handleUnhandledError(error);
                }
            }
        };
        ConsumerObserver.prototype.error = function(err) {
            var partialObserver = this.partialObserver;
            if (partialObserver.error) {
                try {
                    partialObserver.error(err);
                } catch (error) {
                    handleUnhandledError(error);
                }
            } else {
                handleUnhandledError(err);
            }
        };
        ConsumerObserver.prototype.complete = function() {
            var partialObserver = this.partialObserver;
            if (partialObserver.complete) {
                try {
                    partialObserver.complete();
                } catch (error) {
                    handleUnhandledError(error);
                }
            }
        };
        return ConsumerObserver;
    }());
    var SafeSubscriber = (function(_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            var partialObserver;
            if (isFunction(observerOrNext) || !observerOrNext) {
                partialObserver = {
                    next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                    error: error !== null && error !== void 0 ? error : undefined,
                    complete: complete !== null && complete !== void 0 ? complete : undefined
                };
            } else {
                {
                    partialObserver = observerOrNext;
                }
            }
            _this.destination = new ConsumerObserver(partialObserver);
            return _this;
        }
        return SafeSubscriber;
    }(Subscriber));
    function handleUnhandledError(error) {
        {
            reportUnhandledError(error);
        }
    }
    function defaultErrorHandler(err) {
        throw err;
    }
    var EMPTY_OBSERVER = {
        closed: true,
        next: noop$1,
        error: defaultErrorHandler,
        complete: noop$1
    };
    var observable = (function() {
        return (typeof Symbol === 'function' && Symbol.observable) || '@@observable';
    })();
    function identity$1(x) {
        return x;
    }
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity$1;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function(prev, fn) {
                return fn(prev);
            }, input);
        };
    }
    var Observable$1 = (function() {
        function Observable(subscribe) {
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function(operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function(observerOrNext, error, complete) {
            var _this = this;
            var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
            errorContext(function() {
                var _a = _this, operator = _a.operator, source = _a.source;
                subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
            });
            return subscriber;
        };
        Observable.prototype._trySubscribe = function(sink) {
            try {
                return this._subscribe(sink);
            } catch (err) {
                sink.error(err);
            }
        };
        Observable.prototype.forEach = function(next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function(resolve, reject) {
                var subscriber = new SafeSubscriber({
                    next: function(value) {
                        try {
                            next(value);
                        } catch (err) {
                            reject(err);
                            subscriber.unsubscribe();
                        }
                    },
                    error: reject,
                    complete: resolve
                });
                _this.subscribe(subscriber);
            });
        };
        Observable.prototype._subscribe = function(subscriber) {
            var _a;
            return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable.prototype[observable] = function() {
            return this;
        };
        Observable.prototype.pipe = function() {
            var operations = [];
            for(var _i = 0; _i < arguments.length; _i++){
                operations[_i] = arguments[_i];
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function(promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function(resolve, reject) {
                var value;
                _this.subscribe(function(x) {
                    return (value = x);
                }, function(err) {
                    return reject(err);
                }, function() {
                    return resolve(value);
                });
            });
        };
        Observable.create = function(subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
        return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
    }
    function isSubscriber(value) {
        return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
    }
    function hasLift(source) {
        return isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    function operate(init) {
        return function(source) {
            if (hasLift(source)) {
                return source.lift(function(liftedSource) {
                    try {
                        return init(liftedSource, this);
                    } catch (err) {
                        this.error(err);
                    }
                });
            }
            throw new TypeError('Unable to lift unknown Observable type');
        };
    }
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
        return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    var OperatorSubscriber = (function(_super) {
        __extends(OperatorSubscriber, _super);
        function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
            var _this = _super.call(this, destination) || this;
            _this.onFinalize = onFinalize;
            _this.shouldUnsubscribe = shouldUnsubscribe;
            _this._next = onNext ? function(value) {
                try {
                    onNext(value);
                } catch (err) {
                    destination.error(err);
                }
            } : _super.prototype._next;
            _this._error = onError ? function(err) {
                try {
                    onError(err);
                } catch (err) {
                    destination.error(err);
                } finally{
                    this.unsubscribe();
                }
            } : _super.prototype._error;
            _this._complete = onComplete ? function() {
                try {
                    onComplete();
                } catch (err) {
                    destination.error(err);
                } finally{
                    this.unsubscribe();
                }
            } : _super.prototype._complete;
            return _this;
        }
        OperatorSubscriber.prototype.unsubscribe = function() {
            var _a;
            if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                var closed_1 = this.closed;
                _super.prototype.unsubscribe.call(this);
                !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
            }
        };
        return OperatorSubscriber;
    }(Subscriber));
    var ObjectUnsubscribedError = createErrorClass(function(_super) {
        return function ObjectUnsubscribedErrorImpl() {
            _super(this);
            this.name = 'ObjectUnsubscribedError';
            this.message = 'object unsubscribed';
        };
    });
    var Subject = (function(_super) {
        __extends(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.closed = false;
            _this.currentObservers = null;
            _this.observers = [];
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype.lift = function(operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype._throwIfClosed = function() {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
        };
        Subject.prototype.next = function(value) {
            var _this = this;
            errorContext(function() {
                var e_1, _a;
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    if (!_this.currentObservers) {
                        _this.currentObservers = Array.from(_this.observers);
                    }
                    try {
                        for(var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()){
                            var observer = _c.value;
                            observer.next(value);
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                }
            });
        };
        Subject.prototype.error = function(err) {
            var _this = this;
            errorContext(function() {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.hasError = _this.isStopped = true;
                    _this.thrownError = err;
                    var observers = _this.observers;
                    while(observers.length){
                        observers.shift().error(err);
                    }
                }
            });
        };
        Subject.prototype.complete = function() {
            var _this = this;
            errorContext(function() {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.isStopped = true;
                    var observers = _this.observers;
                    while(observers.length){
                        observers.shift().complete();
                    }
                }
            });
        };
        Subject.prototype.unsubscribe = function() {
            this.isStopped = this.closed = true;
            this.observers = this.currentObservers = null;
        };
        Object.defineProperty(Subject.prototype, "observed", {
            get: function() {
                var _a;
                return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
            },
            enumerable: false,
            configurable: true
        });
        Subject.prototype._trySubscribe = function(subscriber) {
            this._throwIfClosed();
            return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject.prototype._subscribe = function(subscriber) {
            this._throwIfClosed();
            this._checkFinalizedStatuses(subscriber);
            return this._innerSubscribe(subscriber);
        };
        Subject.prototype._innerSubscribe = function(subscriber) {
            var _this = this;
            var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
            if (hasError || isStopped) {
                return EMPTY_SUBSCRIPTION;
            }
            this.currentObservers = null;
            observers.push(subscriber);
            return new Subscription$1(function() {
                _this.currentObservers = null;
                arrRemove(observers, subscriber);
            });
        };
        Subject.prototype._checkFinalizedStatuses = function(subscriber) {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
            if (hasError) {
                subscriber.error(thrownError);
            } else if (isStopped) {
                subscriber.complete();
            }
        };
        Subject.prototype.asObservable = function() {
            var observable = new Observable$1();
            observable.source = this;
            return observable;
        };
        Subject.create = function(destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable$1));
    var AnonymousSubject = (function(_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function(value) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject.prototype.error = function(err) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject.prototype.complete = function() {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject.prototype._subscribe = function(subscriber) {
            var _a, _b;
            return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject;
    }(Subject));
    var BehaviorSubject = (function(_super) {
        __extends(BehaviorSubject, _super);
        function BehaviorSubject(_value) {
            var _this = _super.call(this) || this;
            _this._value = _value;
            return _this;
        }
        Object.defineProperty(BehaviorSubject.prototype, "value", {
            get: function() {
                return this.getValue();
            },
            enumerable: false,
            configurable: true
        });
        BehaviorSubject.prototype._subscribe = function(subscriber) {
            var subscription = _super.prototype._subscribe.call(this, subscriber);
            !subscription.closed && subscriber.next(this._value);
            return subscription;
        };
        BehaviorSubject.prototype.getValue = function() {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
            if (hasError) {
                throw thrownError;
            }
            this._throwIfClosed();
            return _value;
        };
        BehaviorSubject.prototype.next = function(value) {
            _super.prototype.next.call(this, (this._value = value));
        };
        return BehaviorSubject;
    }(Subject));
    var dateTimestampProvider = {
        now: function() {
            return (Date).now();
        }
    };
    var Action = (function(_super) {
        __extends(Action, _super);
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function(state, delay) {
            return this;
        };
        return Action;
    }(Subscription$1));
    var intervalProvider = {
        setInterval: function(handler, timeout) {
            var args = [];
            for(var _i = 2; _i < arguments.length; _i++){
                args[_i - 2] = arguments[_i];
            }
            return setInterval.apply(void 0, __spreadArray([
                handler,
                timeout
            ], __read(args)));
        },
        clearInterval: function(handle) {
            return (clearInterval)(handle);
        },
        delegate: undefined
    };
    var AsyncAction = (function(_super) {
        __extends(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function(state, delay) {
            var _a;
            if (delay === void 0) {
                delay = 0;
            }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function(scheduler, _id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function(_scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay != null && this.delay === delay && this.pending === false) {
                return id;
            }
            if (id != null) {
                intervalProvider.clearInterval(id);
            }
            return undefined;
        };
        AsyncAction.prototype.execute = function(state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            } else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function(state, _delay) {
            var errored = false;
            var errorValue;
            try {
                this.work(state);
            } catch (e) {
                errored = true;
                errorValue = e ? e : new Error('Scheduled action threw falsy error');
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype.unsubscribe = function() {
            if (!this.closed) {
                var _a = this, id = _a.id, scheduler = _a.scheduler;
                var actions = scheduler.actions;
                this.work = this.state = this.scheduler = null;
                this.pending = false;
                arrRemove(actions, this);
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
                _super.prototype.unsubscribe.call(this);
            }
        };
        return AsyncAction;
    }(Action));
    var Scheduler = (function() {
        function Scheduler(schedulerActionCtor, now) {
            if (now === void 0) {
                now = Scheduler.now;
            }
            this.schedulerActionCtor = schedulerActionCtor;
            this.now = now;
        }
        Scheduler.prototype.schedule = function(work, delay, state) {
            if (delay === void 0) {
                delay = 0;
            }
            return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler.now = dateTimestampProvider.now;
        return Scheduler;
    }());
    var AsyncScheduler = (function(_super) {
        __extends(AsyncScheduler, _super);
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) {
                now = Scheduler.now;
            }
            var _this = _super.call(this, SchedulerAction, now) || this;
            _this.actions = [];
            _this._active = false;
            return _this;
        }
        AsyncScheduler.prototype.flush = function(action) {
            var actions = this.actions;
            if (this._active) {
                actions.push(action);
                return;
            }
            var error;
            this._active = true;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            }while ((action = actions.shift()));
            this._active = false;
            if (error) {
                while((action = actions.shift())){
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));
    var asyncScheduler = new AsyncScheduler(AsyncAction);
    var async = asyncScheduler;
    var EMPTY = new Observable$1(function(subscriber) {
        return subscriber.complete();
    });
    function isScheduler(value) {
        return value && isFunction(value.schedule);
    }
    function last(arr) {
        return arr[arr.length - 1];
    }
    function popResultSelector(args) {
        return isFunction(last(args)) ? args.pop() : undefined;
    }
    function popScheduler(args) {
        return isScheduler(last(args)) ? args.pop() : undefined;
    }
    var isArrayLike = (function(x) {
        return x && typeof x.length === 'number' && typeof x !== 'function';
    });
    function isPromise$1(value) {
        return isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    function isInteropObservable(input) {
        return isFunction(input[observable]);
    }
    function isAsyncIterable$1(obj) {
        return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    function createInvalidObservableTypeError(input) {
        return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator$1 = getSymbolIterator();
    function isIterable(input) {
        return isFunction(input === null || input === void 0 ? void 0 : input[iterator$1]);
    }
    function readableStreamLikeToAsyncGenerator(readableStream) {
        return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
            var reader, _a, value, done;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        reader = readableStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([
                            1,
                            ,
                            9,
                            10
                        ]);
                        _b.label = 2;
                    case 2:
                        return [
                            4,
                            __await(reader.read())
                        ];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        if (!done) return [
                            3,
                            5
                        ];
                        return [
                            4,
                            __await(void 0)
                        ];
                    case 4:
                        return [
                            2,
                            _b.sent()
                        ];
                    case 5:
                        return [
                            4,
                            __await(value)
                        ];
                    case 6:
                        return [
                            4,
                            _b.sent()
                        ];
                    case 7:
                        _b.sent();
                        return [
                            3,
                            2
                        ];
                    case 8:
                        return [
                            3,
                            10
                        ];
                    case 9:
                        reader.releaseLock();
                        return [
                            7
                        ];
                    case 10:
                        return [
                            2
                        ];
                }
            });
        });
    }
    function isReadableStreamLike(obj) {
        return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    function innerFrom(input) {
        if (input instanceof Observable$1) {
            return input;
        }
        if (input != null) {
            if (isInteropObservable(input)) {
                return fromInteropObservable(input);
            }
            if (isArrayLike(input)) {
                return fromArrayLike(input);
            }
            if (isPromise$1(input)) {
                return fromPromise$1(input);
            }
            if (isAsyncIterable$1(input)) {
                return fromAsyncIterable(input);
            }
            if (isIterable(input)) {
                return fromIterable(input);
            }
            if (isReadableStreamLike(input)) {
                return fromReadableStreamLike(input);
            }
        }
        throw createInvalidObservableTypeError(input);
    }
    function fromInteropObservable(obj) {
        return new Observable$1(function(subscriber) {
            var obs = obj[observable]();
            if (isFunction(obs.subscribe)) {
                return obs.subscribe(subscriber);
            }
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        });
    }
    function fromArrayLike(array) {
        return new Observable$1(function(subscriber) {
            for(var i = 0; i < array.length && !subscriber.closed; i++){
                subscriber.next(array[i]);
            }
            subscriber.complete();
        });
    }
    function fromPromise$1(promise) {
        return new Observable$1(function(subscriber) {
            promise.then(function(value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function(err) {
                return subscriber.error(err);
            }).then(null, reportUnhandledError);
        });
    }
    function fromIterable(iterable) {
        return new Observable$1(function(subscriber) {
            var e_1, _a;
            try {
                for(var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()){
                    var value = iterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return;
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            subscriber.complete();
        });
    }
    function fromAsyncIterable(asyncIterable) {
        return new Observable$1(function(subscriber) {
            process$1(asyncIterable, subscriber).catch(function(err) {
                return subscriber.error(err);
            });
        });
    }
    function fromReadableStreamLike(readableStream) {
        return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
    }
    function process$1(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function() {
            var value, e_2_1;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        _b.trys.push([
                            0,
                            5,
                            6,
                            11
                        ]);
                        asyncIterable_1 = __asyncValues(asyncIterable);
                        _b.label = 1;
                    case 1:
                        return [
                            4,
                            asyncIterable_1.next()
                        ];
                    case 2:
                        if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [
                            3,
                            4
                        ];
                        value = asyncIterable_1_1.value;
                        subscriber.next(value);
                        if (subscriber.closed) {
                            return [
                                2
                            ];
                        }
                        _b.label = 3;
                    case 3:
                        return [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            3,
                            11
                        ];
                    case 5:
                        e_2_1 = _b.sent();
                        e_2 = {
                            error: e_2_1
                        };
                        return [
                            3,
                            11
                        ];
                    case 6:
                        _b.trys.push([
                            6,
                            ,
                            9,
                            10
                        ]);
                        if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [
                            3,
                            8
                        ];
                        return [
                            4,
                            _a.call(asyncIterable_1)
                        ];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8:
                        return [
                            3,
                            10
                        ];
                    case 9:
                        if (e_2) throw e_2.error;
                        return [
                            7
                        ];
                    case 10:
                        return [
                            7
                        ];
                    case 11:
                        subscriber.complete();
                        return [
                            2
                        ];
                }
            });
        });
    }
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
        if (delay === void 0) {
            delay = 0;
        }
        if (repeat === void 0) {
            repeat = false;
        }
        var scheduleSubscription = scheduler.schedule(function() {
            work();
            if (repeat) {
                parentSubscription.add(this.schedule(null, delay));
            } else {
                this.unsubscribe();
            }
        }, delay);
        parentSubscription.add(scheduleSubscription);
        if (!repeat) {
            return scheduleSubscription;
        }
    }
    function observeOn(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return operate(function(source, subscriber) {
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
                return executeSchedule(subscriber, scheduler, function() {
                    return subscriber.next(value);
                }, delay);
            }, function() {
                return executeSchedule(subscriber, scheduler, function() {
                    return subscriber.complete();
                }, delay);
            }, function(err) {
                return executeSchedule(subscriber, scheduler, function() {
                    return subscriber.error(err);
                }, delay);
            }));
        });
    }
    function subscribeOn(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return operate(function(source, subscriber) {
            subscriber.add(scheduler.schedule(function() {
                return source.subscribe(subscriber);
            }, delay));
        });
    }
    function scheduleObservable(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }
    function schedulePromise(input, scheduler) {
        return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
    }
    function scheduleArray(input, scheduler) {
        return new Observable$1(function(subscriber) {
            var i = 0;
            return scheduler.schedule(function() {
                if (i === input.length) {
                    subscriber.complete();
                } else {
                    subscriber.next(input[i++]);
                    if (!subscriber.closed) {
                        this.schedule();
                    }
                }
            });
        });
    }
    function scheduleIterable(input, scheduler) {
        return new Observable$1(function(subscriber) {
            var iterator;
            executeSchedule(subscriber, scheduler, function() {
                iterator = input[iterator$1]();
                executeSchedule(subscriber, scheduler, function() {
                    var _a;
                    var value;
                    var done;
                    try {
                        (_a = iterator.next(), value = _a.value, done = _a.done);
                    } catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    } else {
                        subscriber.next(value);
                    }
                }, 0, true);
            });
            return function() {
                return isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
            };
        });
    }
    function scheduleAsyncIterable(input, scheduler) {
        if (!input) {
            throw new Error('Iterable cannot be null');
        }
        return new Observable$1(function(subscriber) {
            executeSchedule(subscriber, scheduler, function() {
                var iterator = input[Symbol.asyncIterator]();
                executeSchedule(subscriber, scheduler, function() {
                    iterator.next().then(function(result) {
                        if (result.done) {
                            subscriber.complete();
                        } else {
                            subscriber.next(result.value);
                        }
                    });
                }, 0, true);
            });
        });
    }
    function scheduleReadableStreamLike(input, scheduler) {
        return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    function scheduled(input, scheduler) {
        if (input != null) {
            if (isInteropObservable(input)) {
                return scheduleObservable(input, scheduler);
            }
            if (isArrayLike(input)) {
                return scheduleArray(input, scheduler);
            }
            if (isPromise$1(input)) {
                return schedulePromise(input, scheduler);
            }
            if (isAsyncIterable$1(input)) {
                return scheduleAsyncIterable(input, scheduler);
            }
            if (isIterable(input)) {
                return scheduleIterable(input, scheduler);
            }
            if (isReadableStreamLike(input)) {
                return scheduleReadableStreamLike(input, scheduler);
            }
        }
        throw createInvalidObservableTypeError(input);
    }
    function from$1(input, scheduler) {
        return scheduler ? scheduled(input, scheduler) : innerFrom(input);
    }
    function of() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        return from$1(args, scheduler);
    }
    function throwError(errorOrErrorFactory, scheduler) {
        var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
            return errorOrErrorFactory;
        };
        var init = function(subscriber) {
            return subscriber.error(errorFactory());
        };
        return new Observable$1(init);
    }
    var EmptyError = createErrorClass(function(_super) {
        return function EmptyErrorImpl() {
            _super(this);
            this.name = 'EmptyError';
            this.message = 'no elements in sequence';
        };
    });
    function firstValueFrom(source, config) {
        return new Promise(function(resolve, reject) {
            var subscriber = new SafeSubscriber({
                next: function(value) {
                    resolve(value);
                    subscriber.unsubscribe();
                },
                error: reject,
                complete: function() {
                    {
                        reject(new EmptyError());
                    }
                }
            });
            source.subscribe(subscriber);
        });
    }
    function isValidDate(value) {
        return value instanceof Date && !isNaN(value);
    }
    var TimeoutError = createErrorClass(function(_super) {
        return function TimeoutErrorImpl(info) {
            if (info === void 0) {
                info = null;
            }
            _super(this);
            this.message = 'Timeout has occurred';
            this.name = 'TimeoutError';
            this.info = info;
        };
    });
    function timeout(config, schedulerArg) {
        var _a = (isValidDate(config) ? {
            first: config
        } : typeof config === 'number' ? {
            each: config
        } : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
        if (first == null && each == null) {
            throw new TypeError('No timeout provided.');
        }
        return operate(function(source, subscriber) {
            var originalSourceSubscription;
            var timerSubscription;
            var lastValue = null;
            var seen = 0;
            var startTimer = function(delay) {
                timerSubscription = executeSchedule(subscriber, scheduler, function() {
                    try {
                        originalSourceSubscription.unsubscribe();
                        innerFrom(_with({
                            meta: meta,
                            lastValue: lastValue,
                            seen: seen
                        })).subscribe(subscriber);
                    } catch (err) {
                        subscriber.error(err);
                    }
                }, delay);
            };
            originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                seen++;
                subscriber.next((lastValue = value));
                each > 0 && startTimer(each);
            }, undefined, undefined, function() {
                if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
                    timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                }
                lastValue = null;
            }));
            !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
        });
    }
    function timeoutErrorFactory(info) {
        throw new TimeoutError(info);
    }
    function map(project, thisArg) {
        return operate(function(source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
                subscriber.next(project.call(thisArg, value, index++));
            }));
        });
    }
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
        var buffer = [];
        var active = 0;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
            if (isComplete && !buffer.length && !active) {
                subscriber.complete();
            }
        };
        var outerNext = function(value) {
            return (active < concurrent ? doInnerSub(value) : buffer.push(value));
        };
        var doInnerSub = function(value) {
            active++;
            var innerComplete = false;
            innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
                {
                    subscriber.next(innerValue);
                }
            }, function() {
                innerComplete = true;
            }, undefined, function() {
                if (innerComplete) {
                    try {
                        active--;
                        var _loop_1 = function() {
                            var bufferedValue = buffer.shift();
                            if (innerSubScheduler) ;
                            else {
                                doInnerSub(bufferedValue);
                            }
                        };
                        while(buffer.length && active < concurrent){
                            _loop_1();
                        }
                        checkComplete();
                    } catch (err) {
                        subscriber.error(err);
                    }
                }
            }));
        };
        source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
            isComplete = true;
            checkComplete();
        }));
        return function() {};
    }
    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Infinity;
        }
        if (isFunction(resultSelector)) {
            return mergeMap(function(a, i) {
                return map(function(b, ii) {
                    return resultSelector(a, b, i, ii);
                })(innerFrom(project(a, i)));
            }, concurrent);
        } else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return operate(function(source, subscriber) {
            return mergeInternals(source, subscriber, project, concurrent);
        });
    }
    function defer(observableFactory) {
        return new Observable$1(function(subscriber) {
            innerFrom(observableFactory()).subscribe(subscriber);
        });
    }
    function iif(condition, trueResult, falseResult) {
        return defer(function() {
            return (condition() ? trueResult : falseResult);
        });
    }
    function timer(dueTime, intervalOrScheduler, scheduler) {
        if (scheduler === void 0) {
            scheduler = async;
        }
        var intervalDuration = -1;
        {
            if (isScheduler(intervalOrScheduler)) {
                scheduler = intervalOrScheduler;
            } else {
                intervalDuration = intervalOrScheduler;
            }
        }
        return new Observable$1(function(subscriber) {
            var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
            if (due < 0) {
                due = 0;
            }
            var n = 0;
            return scheduler.schedule(function() {
                if (!subscriber.closed) {
                    subscriber.next(n++);
                    if (0 <= intervalDuration) {
                        this.schedule(undefined, intervalDuration);
                    } else {
                        subscriber.complete();
                    }
                }
            }, due);
        });
    }
    function interval(period, scheduler) {
        if (scheduler === void 0) {
            scheduler = asyncScheduler;
        }
        return timer(period, period, scheduler);
    }
    var isArray$3 = Array.isArray;
    function argsOrArgArray(args) {
        return args.length === 1 && isArray$3(args[0]) ? args[0] : args;
    }
    function filter(predicate, thisArg) {
        return operate(function(source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
                return predicate.call(thisArg, value, index++) && subscriber.next(value);
            }));
        });
    }
    function zip() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        var resultSelector = popResultSelector(args);
        var sources = argsOrArgArray(args);
        return sources.length ? new Observable$1(function(subscriber) {
            var buffers = sources.map(function() {
                return [];
            });
            var completed = sources.map(function() {
                return false;
            });
            subscriber.add(function() {
                buffers = completed = null;
            });
            var _loop_1 = function(sourceIndex) {
                innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function(value) {
                    buffers[sourceIndex].push(value);
                    if (buffers.every(function(buffer) {
                        return buffer.length;
                    })) {
                        var result = buffers.map(function(buffer) {
                            return buffer.shift();
                        });
                        subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
                        if (buffers.some(function(buffer, i) {
                            return !buffer.length && completed[i];
                        })) {
                            subscriber.complete();
                        }
                    }
                }, function() {
                    completed[sourceIndex] = true;
                    !buffers[sourceIndex].length && subscriber.complete();
                }));
            };
            for(var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++){
                _loop_1(sourceIndex);
            }
            return function() {
                buffers = completed = null;
            };
        }) : EMPTY;
    }
    function catchError(selector) {
        return operate(function(source, subscriber) {
            var innerSub = null;
            var syncUnsub = false;
            var handledResult;
            innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
                handledResult = innerFrom(selector(err, catchError(selector)(source)));
                if (innerSub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    handledResult.subscribe(subscriber);
                } else {
                    syncUnsub = true;
                }
            }));
            if (syncUnsub) {
                innerSub.unsubscribe();
                innerSub = null;
                handledResult.subscribe(subscriber);
            }
        });
    }
    function concatMap(project, resultSelector) {
        return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
    }
    function take(count) {
        return count <= 0 ? function() {
            return EMPTY;
        } : operate(function(source, subscriber) {
            var seen = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
                if (++seen <= count) {
                    subscriber.next(value);
                    if (count <= seen) {
                        subscriber.complete();
                    }
                }
            }));
        });
    }
    function skip(count) {
        return filter(function(_, index) {
            return count <= index;
        });
    }
    function skipWhile(predicate) {
        return operate(function(source, subscriber) {
            var taking = false;
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
                return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
            }));
        });
    }
    function tap(observerOrNext, error, complete) {
        var tapObserver = isFunction(observerOrNext) || error || complete ? {
            next: observerOrNext,
            error: error,
            complete: complete
        } : observerOrNext;
        return tapObserver ? operate(function(source, subscriber) {
            var _a;
            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
            var isUnsub = true;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
                var _a;
                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
                subscriber.next(value);
            }, function() {
                var _a;
                isUnsub = false;
                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                subscriber.complete();
            }, function(err) {
                var _a;
                isUnsub = false;
                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
                subscriber.error(err);
            }, function() {
                var _a, _b;
                if (isUnsub) {
                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                }
                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
            }));
        }) : identity$1;
    }
    (undefined && undefined.__spreadArray) || function(to, from, pack) {
        if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
        switch(arguments.length){
            case 1:
                return a;
            case 2:
                return ab(a);
            case 3:
                return bc(ab(a));
            case 4:
                return cd(bc(ab(a)));
            case 5:
                return de(cd(bc(ab(a))));
            case 6:
                return ef(de(cd(bc(ab(a)))));
            case 7:
                return fg(ef(de(cd(bc(ab(a))))));
            case 8:
                return gh(fg(ef(de(cd(bc(ab(a)))))));
            case 9:
                return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
            default:
                {
                    var ret = arguments[0];
                    for(var i = 1; i < arguments.length; i++){
                        ret = arguments[i](ret);
                    }
                    return ret;
                }
        }
    }
    var buffer = {};
    var base64Js = {};
    var hasRequiredBase64Js;
    function requireBase64Js() {
        if (hasRequiredBase64Js) return base64Js;
        hasRequiredBase64Js = 1;
        base64Js.byteLength = byteLength;
        base64Js.toByteArray = toByteArray;
        base64Js.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        for(var i = 0, len = code.length; i < len; ++i){
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
        }
        revLookup['-'.charCodeAt(0)] = 62;
        revLookup['_'.charCodeAt(0)] = 63;
        function getLens(b64) {
            var len = b64.length;
            if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4');
            }
            var validLen = b64.indexOf('=');
            if (validLen === -1) validLen = len;
            var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
            return [
                validLen,
                placeHoldersLen
            ];
        }
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
            return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;
        }
        function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i;
            for(i = 0; i < len; i += 4){
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                arr[curByte++] = (tmp >> 16) & 0xFF;
                arr[curByte++] = (tmp >> 8) & 0xFF;
                arr[curByte++] = tmp & 0xFF;
            }
            if (placeHoldersLen === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                arr[curByte++] = tmp & 0xFF;
            }
            if (placeHoldersLen === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                arr[curByte++] = (tmp >> 8) & 0xFF;
                arr[curByte++] = tmp & 0xFF;
            }
            return arr;
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
        }
        function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for(var i = start; i < end; i += 3){
                tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF);
                output.push(tripletToBase64(tmp));
            }
            return output.join('');
        }
        function fromByteArray(uint8) {
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
            }
            if (extraBytes === 1) {
                tmp = uint8[len - 1];
                parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3F] + '==');
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3F] + lookup[(tmp << 2) & 0x3F] + '=');
            }
            return parts.join('');
        }
        return base64Js;
    }
    var ieee754 = {};
    var hasRequiredIeee754;
    function requireIeee754() {
        if (hasRequiredIeee754) return ieee754;
        hasRequiredIeee754 = 1;
        ieee754.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = (nBytes * 8) - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? (nBytes - 1) : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & ((1 << (-nBits)) - 1);
            s >>= (-nBits);
            nBits += eLen;
            for(; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8){}
            m = e & ((1 << (-nBits)) - 1);
            e >>= (-nBits);
            nBits += mLen;
            for(; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8){}
            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity);
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        ieee754.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = (nBytes * 8) - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
            var i = isLE ? 0 : (nBytes - 1);
            var d = isLE ? 1 : -1;
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }
                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = ((value * c) - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }
            for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}
            e = (e << mLen) | m;
            eLen += mLen;
            for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}
            buffer[offset + i - d] |= s * 128;
        };
        return ieee754;
    }
    var hasRequiredBuffer;
    function requireBuffer() {
        if (hasRequiredBuffer) return buffer;
        hasRequiredBuffer = 1;
        (function(exports) {
            const base64 = requireBase64Js();
            const ieee754 = requireIeee754();
            const customInspectSymbol = (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') ? Symbol['for']('nodejs.util.inspect.custom') : null;
            exports.Buffer = Buffer;
            exports.SlowBuffer = SlowBuffer;
            exports.INSPECT_MAX_BYTES = 50;
            const K_MAX_LENGTH = 0x7fffffff;
            exports.kMaxLength = K_MAX_LENGTH;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
                console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
            }
            function typedArraySupport() {
                try {
                    const arr = new Uint8Array(1);
                    const proto = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(proto, Uint8Array.prototype);
                    Object.setPrototypeOf(arr, proto);
                    return arr.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, 'parent', {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, 'offset', {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(length) {
                if (length > K_MAX_LENGTH) {
                    throw new RangeError('The value "' + length + '" is invalid for option "size"');
                }
                const buf = new Uint8Array(length);
                Object.setPrototypeOf(buf, Buffer.prototype);
                return buf;
            }
            function Buffer(arg, encodingOrOffset, length) {
                if (typeof arg === 'number') {
                    if (typeof encodingOrOffset === 'string') {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(arg);
                }
                return from(arg, encodingOrOffset, length);
            }
            Buffer.poolSize = 8192;
            function from(value, encodingOrOffset, length) {
                if (typeof value === 'string') {
                    return fromString(value, encodingOrOffset);
                }
                if (ArrayBuffer.isView(value)) {
                    return fromArrayView(value);
                }
                if (value == null) {
                    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + (typeof value));
                }
                if (isInstance(value, ArrayBuffer) || (value && isInstance(value.buffer, ArrayBuffer))) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                }
                if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || (value && isInstance(value.buffer, SharedArrayBuffer)))) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                }
                if (typeof value === 'number') {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                const valueOf = value.valueOf && value.valueOf();
                if (valueOf != null && valueOf !== value) {
                    return Buffer.from(valueOf, encodingOrOffset, length);
                }
                const b = fromObject(value);
                if (b) return b;
                if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
                    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
                }
                throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + (typeof value));
            }
            Buffer.from = function(value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(size) {
                if (typeof size !== 'number') {
                    throw new TypeError('"size" argument must be of type number');
                } else if (size < 0) {
                    throw new RangeError('The value "' + size + '" is invalid for option "size"');
                }
            }
            function alloc(size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                    return createBuffer(size);
                }
                if (fill !== undefined) {
                    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                }
                return createBuffer(size);
            }
            Buffer.alloc = function(size, fill, encoding) {
                return alloc(size, fill, encoding);
            };
            function allocUnsafe(size) {
                assertSize(size);
                return createBuffer(size < 0 ? 0 : checked(size) | 0);
            }
            Buffer.allocUnsafe = function(size) {
                return allocUnsafe(size);
            };
            Buffer.allocUnsafeSlow = function(size) {
                return allocUnsafe(size);
            };
            function fromString(string, encoding) {
                if (typeof encoding !== 'string' || encoding === '') {
                    encoding = 'utf8';
                }
                if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError('Unknown encoding: ' + encoding);
                }
                const length = byteLength(string, encoding) | 0;
                let buf = createBuffer(length);
                const actual = buf.write(string, encoding);
                if (actual !== length) {
                    buf = buf.slice(0, actual);
                }
                return buf;
            }
            function fromArrayLike(array) {
                const length = array.length < 0 ? 0 : checked(array.length) | 0;
                const buf = createBuffer(length);
                for(let i = 0; i < length; i += 1){
                    buf[i] = array[i] & 255;
                }
                return buf;
            }
            function fromArrayView(arrayView) {
                if (isInstance(arrayView, Uint8Array)) {
                    const copy = new Uint8Array(arrayView);
                    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
                }
                return fromArrayLike(arrayView);
            }
            function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                let buf;
                if (byteOffset === undefined && length === undefined) {
                    buf = new Uint8Array(array);
                } else if (length === undefined) {
                    buf = new Uint8Array(array, byteOffset);
                } else {
                    buf = new Uint8Array(array, byteOffset, length);
                }
                Object.setPrototypeOf(buf, Buffer.prototype);
                return buf;
            }
            function fromObject(obj) {
                if (Buffer.isBuffer(obj)) {
                    const len = checked(obj.length) | 0;
                    const buf = createBuffer(len);
                    if (buf.length === 0) {
                        return buf;
                    }
                    obj.copy(buf, 0, 0, len);
                    return buf;
                }
                if (obj.length !== undefined) {
                    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(obj);
                }
                if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data);
                }
            }
            function checked(length) {
                if (length >= K_MAX_LENGTH) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
                }
                return length | 0;
            }
            function SlowBuffer(length) {
                if (+length != length) {
                    length = 0;
                }
                return Buffer.alloc(+length);
            }
            Buffer.isBuffer = function isBuffer(b) {
                return b != null && b._isBuffer === true && b !== Buffer.prototype;
            };
            Buffer.compare = function compare(a, b) {
                if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
                if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (a === b) return 0;
                let x = a.length;
                let y = b.length;
                for(let i = 0, len = Math.min(x, y); i < len; ++i){
                    if (a[i] !== b[i]) {
                        x = a[i];
                        y = b[i];
                        break;
                    }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(encoding) {
                switch(String(encoding).toLowerCase()){
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(list, length) {
                if (!Array.isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                    return Buffer.alloc(0);
                }
                let i;
                if (length === undefined) {
                    length = 0;
                    for(i = 0; i < list.length; ++i){
                        length += list[i].length;
                    }
                }
                const buffer = Buffer.allocUnsafe(length);
                let pos = 0;
                for(i = 0; i < list.length; ++i){
                    let buf = list[i];
                    if (isInstance(buf, Uint8Array)) {
                        if (pos + buf.length > buffer.length) {
                            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                            buf.copy(buffer, pos);
                        } else {
                            Uint8Array.prototype.set.call(buffer, buf, pos);
                        }
                    } else if (!Buffer.isBuffer(buf)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    } else {
                        buf.copy(buffer, pos);
                    }
                    pos += buf.length;
                }
                return buffer;
            };
            function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                    return string.length;
                }
                if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                    return string.byteLength;
                }
                if (typeof string !== 'string') {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
                }
                const len = string.length;
                const mustMatch = (arguments.length > 2 && arguments[2] === true);
                if (!mustMatch && len === 0) return 0;
                let loweredCase = false;
                for(;;){
                    switch(encoding){
                        case 'ascii':
                        case 'latin1':
                        case 'binary':
                            return len;
                        case 'utf8':
                        case 'utf-8':
                            return utf8ToBytes(string).length;
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return len * 2;
                        case 'hex':
                            return len >>> 1;
                        case 'base64':
                            return base64ToBytes(string).length;
                        default:
                            if (loweredCase) {
                                return mustMatch ? -1 : utf8ToBytes(string).length;
                            }
                            encoding = ('' + encoding).toLowerCase();
                            loweredCase = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(encoding, start, end) {
                let loweredCase = false;
                if (start === undefined || start < 0) {
                    start = 0;
                }
                if (start > this.length) {
                    return '';
                }
                if (end === undefined || end > this.length) {
                    end = this.length;
                }
                if (end <= 0) {
                    return '';
                }
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                    return '';
                }
                if (!encoding) encoding = 'utf8';
                while(true){
                    switch(encoding){
                        case 'hex':
                            return hexSlice(this, start, end);
                        case 'utf8':
                        case 'utf-8':
                            return utf8Slice(this, start, end);
                        case 'ascii':
                            return asciiSlice(this, start, end);
                        case 'latin1':
                        case 'binary':
                            return latin1Slice(this, start, end);
                        case 'base64':
                            return base64Slice(this, start, end);
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return utf16leSlice(this, start, end);
                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                            encoding = (encoding + '').toLowerCase();
                            loweredCase = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(b, n, m) {
                const i = b[n];
                b[n] = b[m];
                b[m] = i;
            }
            Buffer.prototype.swap16 = function swap16() {
                const len = this.length;
                if (len % 2 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 16-bits');
                }
                for(let i = 0; i < len; i += 2){
                    swap(this, i, i + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                const len = this.length;
                if (len % 4 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 32-bits');
                }
                for(let i = 0; i < len; i += 4){
                    swap(this, i, i + 3);
                    swap(this, i + 1, i + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                const len = this.length;
                if (len % 8 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 64-bits');
                }
                for(let i = 0; i < len; i += 8){
                    swap(this, i, i + 7);
                    swap(this, i + 1, i + 6);
                    swap(this, i + 2, i + 5);
                    swap(this, i + 3, i + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                const length = this.length;
                if (length === 0) return '';
                if (arguments.length === 0) return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
                if (this === b) return true;
                return Buffer.compare(this, b) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                let str = '';
                const max = exports.INSPECT_MAX_BYTES;
                str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
                if (this.length > max) str += ' ... ';
                return '<Buffer ' + str + '>';
            };
            if (customInspectSymbol) {
                Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (isInstance(target, Uint8Array)) {
                    target = Buffer.from(target, target.offset, target.byteLength);
                }
                if (!Buffer.isBuffer(target)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + (typeof target));
                }
                if (start === undefined) {
                    start = 0;
                }
                if (end === undefined) {
                    end = target ? target.length : 0;
                }
                if (thisStart === undefined) {
                    thisStart = 0;
                }
                if (thisEnd === undefined) {
                    thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError('out of range index');
                }
                if (thisStart >= thisEnd && start >= end) {
                    return 0;
                }
                if (thisStart >= thisEnd) {
                    return -1;
                }
                if (start >= end) {
                    return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target) return 0;
                let x = thisEnd - thisStart;
                let y = end - start;
                const len = Math.min(x, y);
                const thisCopy = this.slice(thisStart, thisEnd);
                const targetCopy = target.slice(start, end);
                for(let i = 0; i < len; ++i){
                    if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i];
                        y = targetCopy[i];
                        break;
                    }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0) return -1;
                if (typeof byteOffset === 'string') {
                    encoding = byteOffset;
                    byteOffset = 0;
                } else if (byteOffset > 0x7fffffff) {
                    byteOffset = 0x7fffffff;
                } else if (byteOffset < -2147483648) {
                    byteOffset = -2147483648;
                }
                byteOffset = +byteOffset;
                if (numberIsNaN(byteOffset)) {
                    byteOffset = dir ? 0 : (buffer.length - 1);
                }
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                    if (dir) return -1;
                    else byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                    if (dir) byteOffset = 0;
                    else return -1;
                }
                if (typeof val === 'string') {
                    val = Buffer.from(val, encoding);
                }
                if (Buffer.isBuffer(val)) {
                    if (val.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === 'number') {
                    val = val & 0xFF;
                    if (typeof Uint8Array.prototype.indexOf === 'function') {
                        if (dir) {
                            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                        }
                    }
                    return arrayIndexOf(buffer, [
                        val
                    ], byteOffset, encoding, dir);
                }
                throw new TypeError('val must be string, number or Buffer');
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                let indexSize = 1;
                let arrLength = arr.length;
                let valLength = val.length;
                if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase();
                    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
                        if (arr.length < 2 || val.length < 2) {
                            return -1;
                        }
                        indexSize = 2;
                        arrLength /= 2;
                        valLength /= 2;
                        byteOffset /= 2;
                    }
                }
                function read(buf, i) {
                    if (indexSize === 1) {
                        return buf[i];
                    } else {
                        return buf.readUInt16BE(i * indexSize);
                    }
                }
                let i;
                if (dir) {
                    let foundIndex = -1;
                    for(i = byteOffset; i < arrLength; i++){
                        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                            if (foundIndex === -1) foundIndex = i;
                            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                        } else {
                            if (foundIndex !== -1) i -= i - foundIndex;
                            foundIndex = -1;
                        }
                    }
                } else {
                    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                    for(i = byteOffset; i >= 0; i--){
                        let found = true;
                        for(let j = 0; j < valLength; j++){
                            if (read(arr, i + j) !== read(val, j)) {
                                found = false;
                                break;
                            }
                        }
                        if (found) return i;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                const remaining = buf.length - offset;
                if (!length) {
                    length = remaining;
                } else {
                    length = Number(length);
                    if (length > remaining) {
                        length = remaining;
                    }
                }
                const strLen = string.length;
                if (length > strLen / 2) {
                    length = strLen / 2;
                }
                let i;
                for(i = 0; i < length; ++i){
                    const parsed = parseInt(string.substr(i * 2, 2), 16);
                    if (numberIsNaN(parsed)) return i;
                    buf[offset + i] = parsed;
                }
                return i;
            }
            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            }
            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
            }
            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
            }
            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            }
            Buffer.prototype.write = function write(string, offset, length, encoding) {
                if (offset === undefined) {
                    encoding = 'utf8';
                    length = this.length;
                    offset = 0;
                } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset;
                    length = this.length;
                    offset = 0;
                } else if (isFinite(offset)) {
                    offset = offset >>> 0;
                    if (isFinite(length)) {
                        length = length >>> 0;
                        if (encoding === undefined) encoding = 'utf8';
                    } else {
                        encoding = length;
                        length = undefined;
                    }
                } else {
                    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
                }
                const remaining = this.length - offset;
                if (length === undefined || length > remaining) length = remaining;
                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError('Attempt to write outside buffer bounds');
                }
                if (!encoding) encoding = 'utf8';
                let loweredCase = false;
                for(;;){
                    switch(encoding){
                        case 'hex':
                            return hexWrite(this, string, offset, length);
                        case 'utf8':
                        case 'utf-8':
                            return utf8Write(this, string, offset, length);
                        case 'ascii':
                        case 'latin1':
                        case 'binary':
                            return asciiWrite(this, string, offset, length);
                        case 'base64':
                            return base64Write(this, string, offset, length);
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return ucs2Write(this, string, offset, length);
                        default:
                            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                            encoding = ('' + encoding).toLowerCase();
                            loweredCase = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf);
                } else {
                    return base64.fromByteArray(buf.slice(start, end));
                }
            }
            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                const res = [];
                let i = start;
                while(i < end){
                    const firstByte = buf[i];
                    let codePoint = null;
                    let bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                        let secondByte, thirdByte, fourthByte, tempCodePoint;
                        switch(bytesPerSequence){
                            case 1:
                                if (firstByte < 0x80) {
                                    codePoint = firstByte;
                                }
                                break;
                            case 2:
                                secondByte = buf[i + 1];
                                if ((secondByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                                    if (tempCodePoint > 0x7F) {
                                        codePoint = tempCodePoint;
                                    }
                                }
                                break;
                            case 3:
                                secondByte = buf[i + 1];
                                thirdByte = buf[i + 2];
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                        codePoint = tempCodePoint;
                                    }
                                }
                                break;
                            case 4:
                                secondByte = buf[i + 1];
                                thirdByte = buf[i + 2];
                                fourthByte = buf[i + 3];
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                        codePoint = tempCodePoint;
                                    }
                                }
                        }
                    }
                    if (codePoint === null) {
                        codePoint = 0xFFFD;
                        bytesPerSequence = 1;
                    } else if (codePoint > 0xFFFF) {
                        codePoint -= 0x10000;
                        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                        codePoint = 0xDC00 | codePoint & 0x3FF;
                    }
                    res.push(codePoint);
                    i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
            }
            const MAX_ARGUMENTS_LENGTH = 0x1000;
            function decodeCodePointsArray(codePoints) {
                const len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints);
                }
                let res = '';
                let i = 0;
                while(i < len){
                    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                }
                return res;
            }
            function asciiSlice(buf, start, end) {
                let ret = '';
                end = Math.min(buf.length, end);
                for(let i = start; i < end; ++i){
                    ret += String.fromCharCode(buf[i] & 0x7F);
                }
                return ret;
            }
            function latin1Slice(buf, start, end) {
                let ret = '';
                end = Math.min(buf.length, end);
                for(let i = start; i < end; ++i){
                    ret += String.fromCharCode(buf[i]);
                }
                return ret;
            }
            function hexSlice(buf, start, end) {
                const len = buf.length;
                if (!start || start < 0) start = 0;
                if (!end || end < 0 || end > len) end = len;
                let out = '';
                for(let i = start; i < end; ++i){
                    out += hexSliceLookupTable[buf[i]];
                }
                return out;
            }
            function utf16leSlice(buf, start, end) {
                const bytes = buf.slice(start, end);
                let res = '';
                for(let i = 0; i < bytes.length - 1; i += 2){
                    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
                }
                return res;
            }
            Buffer.prototype.slice = function slice(start, end) {
                const len = this.length;
                start = ~~start;
                end = end === undefined ? len : ~~end;
                if (start < 0) {
                    start += len;
                    if (start < 0) start = 0;
                } else if (start > len) {
                    start = len;
                }
                if (end < 0) {
                    end += len;
                    if (end < 0) end = 0;
                } else if (end > len) {
                    end = len;
                }
                if (end < start) end = start;
                const newBuf = this.subarray(start, end);
                Object.setPrototypeOf(newBuf, Buffer.prototype);
                return newBuf;
            };
            function checkOffset(offset, ext, length) {
                if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint');
                if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
            }
            Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                let val = this[offset];
                let mul = 1;
                let i = 0;
                while(++i < byteLength && (mul *= 0x100)){
                    val += this[offset + i] * mul;
                }
                return val;
            };
            Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length);
                }
                let val = this[offset + --byteLength];
                let mul = 1;
                while(byteLength > 0 && (mul *= 0x100)){
                    val += this[offset + --byteLength] * mul;
                }
                return val;
            };
            Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                return this[offset];
            };
            Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] | (this[offset + 1] << 8);
            };
            Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return (this[offset] << 8) | this[offset + 1];
            };
            Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
            };
            Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
            };
            Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, 'offset');
                const first = this[offset];
                const last = this[offset + 7];
                if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8);
                }
                const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
                const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
                return BigInt(lo) + (BigInt(hi) << BigInt(32));
            });
            Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, 'offset');
                const first = this[offset];
                const last = this[offset + 7];
                if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8);
                }
                const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
                return (BigInt(hi) << BigInt(32)) + BigInt(lo);
            });
            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                let val = this[offset];
                let mul = 1;
                let i = 0;
                while(++i < byteLength && (mul *= 0x100)){
                    val += this[offset + i] * mul;
                }
                mul *= 0x80;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                return val;
            };
            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) checkOffset(offset, byteLength, this.length);
                let i = byteLength;
                let mul = 1;
                let val = this[offset + --i];
                while(i > 0 && (mul *= 0x100)){
                    val += this[offset + --i] * mul;
                }
                mul *= 0x80;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                return val;
            };
            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                if (!(this[offset] & 0x80)) return (this[offset]);
                return ((0xff - this[offset] + 1) * -1);
            };
            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                const val = this[offset] | (this[offset + 1] << 8);
                return (val & 0x8000) ? val | 0xFFFF0000 : val;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                const val = this[offset + 1] | (this[offset] << 8);
                return (val & 0x8000) ? val | 0xFFFF0000 : val;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
            };
            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
            };
            Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, 'offset');
                const first = this[offset];
                const last = this[offset + 7];
                if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8);
                }
                const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
                return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
            });
            Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
                offset = offset >>> 0;
                validateNumber(offset, 'offset');
                const first = this[offset];
                const last = this[offset + 7];
                if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8);
                }
                const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
            });
            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
            };
            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length) throw new RangeError('Index out of range');
            }
            Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                let mul = 1;
                let i = 0;
                this[offset] = value & 0xFF;
                while(++i < byteLength && (mul *= 0x100)){
                    this[offset + i] = (value / mul) & 0xFF;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength = byteLength >>> 0;
                if (!noAssert) {
                    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                    checkInt(this, value, offset, byteLength, maxBytes, 0);
                }
                let i = byteLength - 1;
                let mul = 1;
                this[offset + i] = value & 0xFF;
                while(--i >= 0 && (mul *= 0x100)){
                    this[offset + i] = (value / mul) & 0xFF;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
                this[offset] = (value & 0xff);
                return offset + 1;
            };
            Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                return offset + 2;
            };
            Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
                return offset + 2;
            };
            Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                this[offset + 3] = (value >>> 24);
                this[offset + 2] = (value >>> 16);
                this[offset + 1] = (value >>> 8);
                this[offset] = (value & 0xff);
                return offset + 4;
            };
            Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
                return offset + 4;
            };
            function wrtBigUInt64LE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(0xffffffff));
                buf[offset++] = lo;
                lo = lo >> 8;
                buf[offset++] = lo;
                lo = lo >> 8;
                buf[offset++] = lo;
                lo = lo >> 8;
                buf[offset++] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
                buf[offset++] = hi;
                hi = hi >> 8;
                buf[offset++] = hi;
                hi = hi >> 8;
                buf[offset++] = hi;
                hi = hi >> 8;
                buf[offset++] = hi;
                return offset;
            }
            function wrtBigUInt64BE(buf, value, offset, min, max) {
                checkIntBI(value, min, max, buf, offset, 7);
                let lo = Number(value & BigInt(0xffffffff));
                buf[offset + 7] = lo;
                lo = lo >> 8;
                buf[offset + 6] = lo;
                lo = lo >> 8;
                buf[offset + 5] = lo;
                lo = lo >> 8;
                buf[offset + 4] = lo;
                let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
                buf[offset + 3] = hi;
                hi = hi >> 8;
                buf[offset + 2] = hi;
                hi = hi >> 8;
                buf[offset + 1] = hi;
                hi = hi >> 8;
                buf[offset] = hi;
                return offset + 8;
            }
            Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
                return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
            });
            Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
                return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
            });
            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    const limit = Math.pow(2, (8 * byteLength) - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                let i = 0;
                let mul = 1;
                let sub = 0;
                this[offset] = value & 0xFF;
                while(++i < byteLength && (mul *= 0x100)){
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                        sub = 1;
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    const limit = Math.pow(2, (8 * byteLength) - 1);
                    checkInt(this, value, offset, byteLength, limit - 1, -limit);
                }
                let i = byteLength - 1;
                let mul = 1;
                let sub = 0;
                this[offset + i] = value & 0xFF;
                while(--i >= 0 && (mul *= 0x100)){
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                        sub = 1;
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                }
                return offset + byteLength;
            };
            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
                if (value < 0) value = 0xff + value + 1;
                this[offset] = (value & 0xff);
                return offset + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                return offset + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
                return offset + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                this[offset + 2] = (value >>> 16);
                this[offset + 3] = (value >>> 24);
                return offset + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
                if (value < 0) value = 0xffffffff + value + 1;
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
                return offset + 4;
            };
            Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
                return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
            });
            Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
                return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
            });
            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError('Index out of range');
                if (offset < 0) throw new RangeError('Index out of range');
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
            };
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
            };
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
                if (!start) start = 0;
                if (!end && end !== 0) end = this.length;
                if (targetStart >= target.length) targetStart = target.length;
                if (!targetStart) targetStart = 0;
                if (end > 0 && end < start) end = start;
                if (end === start) return 0;
                if (target.length === 0 || this.length === 0) return 0;
                if (targetStart < 0) {
                    throw new RangeError('targetStart out of bounds');
                }
                if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
                if (end < 0) throw new RangeError('sourceEnd out of bounds');
                if (end > this.length) end = this.length;
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start;
                }
                const len = end - start;
                if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
                    this.copyWithin(targetStart, start, end);
                } else {
                    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                }
                return len;
            };
            Buffer.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === 'string') {
                    if (typeof start === 'string') {
                        encoding = start;
                        start = 0;
                        end = this.length;
                    } else if (typeof end === 'string') {
                        encoding = end;
                        end = this.length;
                    }
                    if (encoding !== undefined && typeof encoding !== 'string') {
                        throw new TypeError('encoding must be a string');
                    }
                    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                        throw new TypeError('Unknown encoding: ' + encoding);
                    }
                    if (val.length === 1) {
                        const code = val.charCodeAt(0);
                        if ((encoding === 'utf8' && code < 128) || encoding === 'latin1') {
                            val = code;
                        }
                    }
                } else if (typeof val === 'number') {
                    val = val & 255;
                } else if (typeof val === 'boolean') {
                    val = Number(val);
                }
                if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError('Out of range index');
                }
                if (end <= start) {
                    return this;
                }
                start = start >>> 0;
                end = end === undefined ? this.length : end >>> 0;
                if (!val) val = 0;
                let i;
                if (typeof val === 'number') {
                    for(i = start; i < end; ++i){
                        this[i] = val;
                    }
                } else {
                    const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                    const len = bytes.length;
                    if (len === 0) {
                        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < end - start; ++i){
                        this[i + start] = bytes[i % len];
                    }
                }
                return this;
            };
            const errors = {};
            function E(sym, getMessage, Base) {
                errors[sym] = class NodeError extends Base {
                    constructor(){
                        super();
                        Object.defineProperty(this, 'message', {
                            value: getMessage.apply(this, arguments),
                            writable: true,
                            configurable: true
                        });
                        this.name = `${this.name} [${sym}]`;
                        this.stack;
                        delete this.name;
                    }
                    get code() {
                        return sym;
                    }
                    set code(value) {
                        Object.defineProperty(this, 'code', {
                            configurable: true,
                            enumerable: true,
                            value,
                            writable: true
                        });
                    }
                    toString() {
                        return `${this.name} [${sym}]: ${this.message}`;
                    }
                };
            }
            E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
                if (name) {
                    return `${name} is outside of buffer bounds`;
                }
                return 'Attempt to access memory outside buffer bounds';
            }, RangeError);
            E('ERR_INVALID_ARG_TYPE', function(name, actual) {
                return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
            }, TypeError);
            E('ERR_OUT_OF_RANGE', function(str, range, input) {
                let msg = `The value of "${str}" is out of range.`;
                let received = input;
                if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
                    received = addNumericalSeparator(String(input));
                } else if (typeof input === 'bigint') {
                    received = String(input);
                    if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                        received = addNumericalSeparator(received);
                    }
                    received += 'n';
                }
                msg += ` It must be ${range}. Received ${received}`;
                return msg;
            }, RangeError);
            function addNumericalSeparator(val) {
                let res = '';
                let i = val.length;
                const start = val[0] === '-' ? 1 : 0;
                for(; i >= start + 4; i -= 3){
                    res = `_${val.slice(i - 3, i)}${res}`;
                }
                return `${val.slice(0, i)}${res}`;
            }
            function checkBounds(buf, offset, byteLength) {
                validateNumber(offset, 'offset');
                if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
                    boundsError(offset, buf.length - (byteLength + 1));
                }
            }
            function checkIntBI(value, min, max, buf, offset, byteLength) {
                if (value > max || value < min) {
                    const n = typeof min === 'bigint' ? 'n' : '';
                    let range;
                    {
                        if (min === 0 || min === BigInt(0)) {
                            range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
                        } else {
                            range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
                        }
                    }
                    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
                }
                checkBounds(buf, offset, byteLength);
            }
            function validateNumber(value, name) {
                if (typeof value !== 'number') {
                    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
                }
            }
            function boundsError(value, length, type) {
                if (Math.floor(value) !== value) {
                    validateNumber(value, type);
                    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value);
                }
                if (length < 0) {
                    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
                }
                throw new errors.ERR_OUT_OF_RANGE('offset', `>= ${0} and <= ${length}`, value);
            }
            const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
            function base64clean(str) {
                str = str.split('=')[0];
                str = str.trim().replace(INVALID_BASE64_RE, '');
                if (str.length < 2) return '';
                while(str.length % 4 !== 0){
                    str = str + '=';
                }
                return str;
            }
            function utf8ToBytes(string, units) {
                units = units || Infinity;
                let codePoint;
                const length = string.length;
                let leadSurrogate = null;
                const bytes = [];
                for(let i = 0; i < length; ++i){
                    codePoint = string.charCodeAt(i);
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                        if (!leadSurrogate) {
                            if (codePoint > 0xDBFF) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                continue;
                            } else if (i + 1 === length) {
                                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                                continue;
                            }
                            leadSurrogate = codePoint;
                            continue;
                        }
                        if (codePoint < 0xDC00) {
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                            leadSurrogate = codePoint;
                            continue;
                        }
                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                    } else if (leadSurrogate) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    }
                    leadSurrogate = null;
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0) break;
                        bytes.push(codePoint);
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0) break;
                        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0) break;
                        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0) break;
                        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                    } else {
                        throw new Error('Invalid code point');
                    }
                }
                return bytes;
            }
            function asciiToBytes(str) {
                const byteArray = [];
                for(let i = 0; i < str.length; ++i){
                    byteArray.push(str.charCodeAt(i) & 0xFF);
                }
                return byteArray;
            }
            function utf16leToBytes(str, units) {
                let c, hi, lo;
                const byteArray = [];
                for(let i = 0; i < str.length; ++i){
                    if ((units -= 2) < 0) break;
                    c = str.charCodeAt(i);
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push(lo);
                    byteArray.push(hi);
                }
                return byteArray;
            }
            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset, length) {
                let i;
                for(i = 0; i < length; ++i){
                    if ((i + offset >= dst.length) || (i >= src.length)) break;
                    dst[i + offset] = src[i];
                }
                return i;
            }
            function isInstance(obj, type) {
                return obj instanceof type || (obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name);
            }
            function numberIsNaN(obj) {
                return obj !== obj;
            }
            const hexSliceLookupTable = (function() {
                const alphabet = '0123456789abcdef';
                const table = new Array(256);
                for(let i = 0; i < 16; ++i){
                    const i16 = i * 16;
                    for(let j = 0; j < 16; ++j){
                        table[i16 + j] = alphabet[i] + alphabet[j];
                    }
                }
                return table;
            })();
            function defineBigIntMethod(fn) {
                return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
            }
            function BufferBigIntNotDefined() {
                throw new Error('BigInt not supported');
            }
        }(buffer));
        return buffer;
    }
    var bufferExports = requireBuffer();
    var browser = {};
    var browserLevel = {};
    var abstractLevel$1 = {};
    var abstractLevel = {};
    var levelSupports = {};
    var hasRequiredLevelSupports;
    function requireLevelSupports() {
        if (hasRequiredLevelSupports) return levelSupports;
        hasRequiredLevelSupports = 1;
        levelSupports.supports = function supports(...manifests) {
            const manifest = manifests.reduce((acc, m)=>Object.assign(acc, m), {});
            const implicitSnapshots = manifest.implicitSnapshots || manifest.snapshots || false;
            const explicitSnapshots = manifest.explicitSnapshots || false;
            return Object.assign(manifest, {
                implicitSnapshots,
                explicitSnapshots,
                snapshots: implicitSnapshots,
                has: manifest.has || false,
                permanence: manifest.permanence || false,
                seek: manifest.seek || false,
                createIfMissing: manifest.createIfMissing || false,
                errorIfExists: manifest.errorIfExists || false,
                deferredOpen: manifest.deferredOpen || false,
                streams: manifest.streams || false,
                encodings: Object.assign({}, manifest.encodings),
                events: Object.assign({}, manifest.events),
                additionalMethods: Object.assign({}, manifest.additionalMethods),
                signals: Object.assign({}, manifest.signals)
            });
        };
        return levelSupports;
    }
    var levelTranscoder = {};
    var moduleError;
    var hasRequiredModuleError;
    function requireModuleError() {
        if (hasRequiredModuleError) return moduleError;
        hasRequiredModuleError = 1;
        moduleError = class ModuleError extends Error {
            constructor(message, options){
                super(message || '');
                if (typeof options === 'object' && options !== null) {
                    if (options.code) this.code = String(options.code);
                    if (options.expected) this.expected = true;
                    if (options.transient) this.transient = true;
                    if (options.cause) this.cause = options.cause;
                }
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, this.constructor);
                }
            }
        };
        return moduleError;
    }
    var encodings = {};
    var textEndec;
    var hasRequiredTextEndec;
    function requireTextEndec() {
        if (hasRequiredTextEndec) return textEndec;
        hasRequiredTextEndec = 1;
        let lazy = null;
        textEndec = function() {
            if (lazy === null) {
                lazy = {
                    textEncoder: new TextEncoder(),
                    textDecoder: new TextDecoder()
                };
            }
            return lazy;
        };
        return textEndec;
    }
    var formats = {};
    var encoding = {};
    var hasRequiredEncoding;
    function requireEncoding() {
        if (hasRequiredEncoding) return encoding;
        hasRequiredEncoding = 1;
        const ModuleError = requireModuleError();
        const formats = new Set([
            'buffer',
            'view',
            'utf8'
        ]);
        class Encoding {
            constructor(options){
                this.encode = options.encode || this.encode;
                this.decode = options.decode || this.decode;
                this.name = options.name || this.name;
                this.format = options.format || this.format;
                if (typeof this.encode !== 'function') {
                    throw new TypeError("The 'encode' property must be a function");
                }
                if (typeof this.decode !== 'function') {
                    throw new TypeError("The 'decode' property must be a function");
                }
                this.encode = this.encode.bind(this);
                this.decode = this.decode.bind(this);
                if (typeof this.name !== 'string' || this.name === '') {
                    throw new TypeError("The 'name' property must be a string");
                }
                if (typeof this.format !== 'string' || !formats.has(this.format)) {
                    throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
                }
                if (options.createViewTranscoder) {
                    this.createViewTranscoder = options.createViewTranscoder;
                }
                if (options.createBufferTranscoder) {
                    this.createBufferTranscoder = options.createBufferTranscoder;
                }
                if (options.createUTF8Transcoder) {
                    this.createUTF8Transcoder = options.createUTF8Transcoder;
                }
            }
            get commonName() {
                return (this.name.split('+')[0]);
            }
            createBufferTranscoder() {
                throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
                    code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                });
            }
            createViewTranscoder() {
                throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
                    code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                });
            }
            createUTF8Transcoder() {
                throw new ModuleError(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
                    code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                });
            }
        }
        encoding.Encoding = Encoding;
        return encoding;
    }
    var hasRequiredFormats;
    function requireFormats() {
        if (hasRequiredFormats) return formats;
        hasRequiredFormats = 1;
        const { Buffer } = requireBuffer() || {};
        const { Encoding } = requireEncoding();
        const textEndec = requireTextEndec();
        class BufferFormat extends Encoding {
            constructor(options){
                super({
                    ...options,
                    format: 'buffer'
                });
            }
            createViewTranscoder() {
                return new ViewFormat({
                    encode: this.encode,
                    decode: (data)=>this.decode(Buffer.from(data.buffer, data.byteOffset, data.byteLength)),
                    name: `${this.name}+view`
                });
            }
            createBufferTranscoder() {
                return this;
            }
        }
        class ViewFormat extends Encoding {
            constructor(options){
                super({
                    ...options,
                    format: 'view'
                });
            }
            createBufferTranscoder() {
                return new BufferFormat({
                    encode: (data)=>{
                        const view = this.encode(data);
                        return Buffer.from(view.buffer, view.byteOffset, view.byteLength);
                    },
                    decode: this.decode,
                    name: `${this.name}+buffer`
                });
            }
            createViewTranscoder() {
                return this;
            }
        }
        class UTF8Format extends Encoding {
            constructor(options){
                super({
                    ...options,
                    format: 'utf8'
                });
            }
            createBufferTranscoder() {
                return new BufferFormat({
                    encode: (data)=>Buffer.from(this.encode(data), 'utf8'),
                    decode: (data)=>this.decode(data.toString('utf8')),
                    name: `${this.name}+buffer`
                });
            }
            createViewTranscoder() {
                const { textEncoder, textDecoder } = textEndec();
                return new ViewFormat({
                    encode: (data)=>textEncoder.encode(this.encode(data)),
                    decode: (data)=>this.decode(textDecoder.decode(data)),
                    name: `${this.name}+view`
                });
            }
            createUTF8Transcoder() {
                return this;
            }
        }
        formats.BufferFormat = BufferFormat;
        formats.ViewFormat = ViewFormat;
        formats.UTF8Format = UTF8Format;
        return formats;
    }
    var hasRequiredEncodings;
    function requireEncodings() {
        if (hasRequiredEncodings) return encodings;
        hasRequiredEncodings = 1;
        const { Buffer } = requireBuffer() || {
            Buffer: {
                isBuffer: ()=>false
            }
        };
        const { textEncoder, textDecoder } = requireTextEndec()();
        const { BufferFormat, ViewFormat, UTF8Format } = requireFormats();
        const identity = (v)=>v;
        encodings.utf8 = new UTF8Format({
            encode: function(data) {
                return Buffer.isBuffer(data) ? data.toString('utf8') : ArrayBuffer.isView(data) ? textDecoder.decode(data) : String(data);
            },
            decode: identity,
            name: 'utf8',
            createViewTranscoder () {
                return new ViewFormat({
                    encode: function(data) {
                        return ArrayBuffer.isView(data) ? data : textEncoder.encode(data);
                    },
                    decode: function(data) {
                        return textDecoder.decode(data);
                    },
                    name: `${this.name}+view`
                });
            },
            createBufferTranscoder () {
                return new BufferFormat({
                    encode: function(data) {
                        return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), 'utf8');
                    },
                    decode: function(data) {
                        return data.toString('utf8');
                    },
                    name: `${this.name}+buffer`
                });
            }
        });
        encodings.json = new UTF8Format({
            encode: JSON.stringify,
            decode: JSON.parse,
            name: 'json'
        });
        encodings.buffer = new BufferFormat({
            encode: function(data) {
                return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), 'utf8');
            },
            decode: identity,
            name: 'buffer',
            createViewTranscoder () {
                return new ViewFormat({
                    encode: function(data) {
                        return ArrayBuffer.isView(data) ? data : Buffer.from(String(data), 'utf8');
                    },
                    decode: function(data) {
                        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                    },
                    name: `${this.name}+view`
                });
            }
        });
        encodings.view = new ViewFormat({
            encode: function(data) {
                return ArrayBuffer.isView(data) ? data : textEncoder.encode(data);
            },
            decode: identity,
            name: 'view',
            createBufferTranscoder () {
                return new BufferFormat({
                    encode: function(data) {
                        return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), 'utf8');
                    },
                    decode: identity,
                    name: `${this.name}+buffer`
                });
            }
        });
        encodings.hex = new BufferFormat({
            encode: function(data) {
                return Buffer.isBuffer(data) ? data : Buffer.from(String(data), 'hex');
            },
            decode: function(buffer) {
                return buffer.toString('hex');
            },
            name: 'hex'
        });
        encodings.base64 = new BufferFormat({
            encode: function(data) {
                return Buffer.isBuffer(data) ? data : Buffer.from(String(data), 'base64');
            },
            decode: function(buffer) {
                return buffer.toString('base64');
            },
            name: 'base64'
        });
        return encodings;
    }
    var hasRequiredLevelTranscoder;
    function requireLevelTranscoder() {
        if (hasRequiredLevelTranscoder) return levelTranscoder;
        hasRequiredLevelTranscoder = 1;
        const ModuleError = requireModuleError();
        const encodings = requireEncodings();
        const { Encoding } = requireEncoding();
        const { BufferFormat, ViewFormat, UTF8Format } = requireFormats();
        const kFormats = Symbol('formats');
        const kEncodings = Symbol('encodings');
        const validFormats = new Set([
            'buffer',
            'view',
            'utf8'
        ]);
        class Transcoder {
            constructor(formats){
                if (!Array.isArray(formats)) {
                    throw new TypeError("The first argument 'formats' must be an array");
                } else if (!formats.every((f)=>validFormats.has(f))) {
                    throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
                }
                this[kEncodings] = new Map();
                this[kFormats] = new Set(formats);
                for(const k in encodings){
                    try {
                        this.encoding(k);
                    } catch (err) {
                        if (err.code !== 'LEVEL_ENCODING_NOT_SUPPORTED') throw err;
                    }
                }
            }
            encodings() {
                return Array.from(new Set(this[kEncodings].values()));
            }
            encoding(encoding) {
                let resolved = this[kEncodings].get(encoding);
                if (resolved === undefined) {
                    if (typeof encoding === 'string' && encoding !== '') {
                        resolved = lookup[encoding];
                        if (!resolved) {
                            throw new ModuleError(`Encoding '${encoding}' is not found`, {
                                code: 'LEVEL_ENCODING_NOT_FOUND'
                            });
                        }
                    } else if (typeof encoding !== 'object' || encoding === null) {
                        throw new TypeError("First argument 'encoding' must be a string or object");
                    } else {
                        resolved = from(encoding);
                    }
                    const { name, format } = resolved;
                    if (!this[kFormats].has(format)) {
                        if (this[kFormats].has('view')) {
                            resolved = resolved.createViewTranscoder();
                        } else if (this[kFormats].has('buffer')) {
                            resolved = resolved.createBufferTranscoder();
                        } else if (this[kFormats].has('utf8')) {
                            resolved = resolved.createUTF8Transcoder();
                        } else {
                            throw new ModuleError(`Encoding '${name}' cannot be transcoded`, {
                                code: 'LEVEL_ENCODING_NOT_SUPPORTED'
                            });
                        }
                    }
                    for (const k of [
                        encoding,
                        name,
                        resolved.name,
                        resolved.commonName
                    ]){
                        this[kEncodings].set(k, resolved);
                    }
                }
                return resolved;
            }
        }
        levelTranscoder.Transcoder = Transcoder;
        function from(options) {
            if (options instanceof Encoding) {
                return options;
            }
            const maybeType = 'type' in options && typeof options.type === 'string' ? options.type : undefined;
            const name = options.name || maybeType || `anonymous-${anonymousCount++}`;
            switch(detectFormat(options)){
                case 'view':
                    return new ViewFormat({
                        ...options,
                        name
                    });
                case 'utf8':
                    return new UTF8Format({
                        ...options,
                        name
                    });
                case 'buffer':
                    return new BufferFormat({
                        ...options,
                        name
                    });
                default:
                    {
                        throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
                    }
            }
        }
        function detectFormat(options) {
            if ('format' in options && options.format !== undefined) {
                return options.format;
            } else if ('buffer' in options && typeof options.buffer === 'boolean') {
                return options.buffer ? 'buffer' : 'utf8';
            } else if ('code' in options && Number.isInteger(options.code)) {
                return 'view';
            } else {
                return 'buffer';
            }
        }
        const aliases = {
            binary: encodings.buffer,
            'utf-8': encodings.utf8
        };
        const lookup = {
            ...encodings,
            ...aliases
        };
        let anonymousCount = 0;
        return levelTranscoder;
    }
    var events = {
        exports: {}
    };
    var hasRequiredEvents;
    function requireEvents() {
        if (hasRequiredEvents) return events.exports;
        hasRequiredEvents = 1;
        var R = typeof Reflect === 'object' ? Reflect : null;
        var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
            return Function.prototype.apply.call(target, receiver, args);
        };
        var ReflectOwnKeys;
        if (R && typeof R.ownKeys === 'function') {
            ReflectOwnKeys = R.ownKeys;
        } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
            };
        } else {
            ReflectOwnKeys = function ReflectOwnKeys(target) {
                return Object.getOwnPropertyNames(target);
            };
        }
        function ProcessEmitWarning(warning) {
            if (console && console.warn) console.warn(warning);
        }
        var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
            return value !== value;
        };
        function EventEmitter() {
            EventEmitter.init.call(this);
        }
        events.exports = EventEmitter;
        events.exports.once = once;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = undefined;
        var defaultMaxListeners = 10;
        function checkListener(listener) {
            if (typeof listener !== 'function') {
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
            }
        }
        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
            enumerable: true,
            get: function() {
                return defaultMaxListeners;
            },
            set: function(arg) {
                if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
                    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
                }
                defaultMaxListeners = arg;
            }
        });
        EventEmitter.init = function() {
            if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
                this._events = Object.create(null);
                this._eventsCount = 0;
            }
            this._maxListeners = this._maxListeners || undefined;
        };
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
            }
            this._maxListeners = n;
            return this;
        };
        function _getMaxListeners(that) {
            if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this);
        };
        EventEmitter.prototype.emit = function emit(type) {
            var args = [];
            for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
            var doError = (type === 'error');
            var events = this._events;
            if (events !== undefined) doError = (doError && events.error === undefined);
            else if (!doError) return false;
            if (doError) {
                var er;
                if (args.length > 0) er = args[0];
                if (er instanceof Error) {
                    throw er;
                }
                var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
                err.context = er;
                throw err;
            }
            var handler = events[type];
            if (handler === undefined) return false;
            if (typeof handler === 'function') {
                ReflectApply(handler, this, args);
            } else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
            }
            return true;
        };
        function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;
            checkListener(listener);
            events = target._events;
            if (events === undefined) {
                events = target._events = Object.create(null);
                target._eventsCount = 0;
            } else {
                if (events.newListener !== undefined) {
                    target.emit('newListener', type, listener.listener ? listener.listener : listener);
                    events = target._events;
                }
                existing = events[type];
            }
            if (existing === undefined) {
                existing = events[type] = listener;
                ++target._eventsCount;
            } else {
                if (typeof existing === 'function') {
                    existing = events[type] = prepend ? [
                        listener,
                        existing
                    ] : [
                        existing,
                        listener
                    ];
                } else if (prepend) {
                    existing.unshift(listener);
                } else {
                    existing.push(listener);
                }
                m = _getMaxListeners(target);
                if (m > 0 && existing.length > m && !existing.warned) {
                    existing.warned = true;
                    var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
                    w.name = 'MaxListenersExceededWarning';
                    w.emitter = target;
                    w.type = type;
                    w.count = existing.length;
                    ProcessEmitWarning(w);
                }
            }
            return target;
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
            return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
            return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
            if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                if (arguments.length === 0) return this.listener.call(this.target);
                return this.listener.apply(this.target, arguments);
            }
        }
        function _onceWrap(target, type, listener) {
            var state = {
                fired: false,
                wrapFn: undefined,
                target: target,
                type: type,
                listener: listener
            };
            var wrapped = onceWrapper.bind(state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
        }
        EventEmitter.prototype.once = function once(type, listener) {
            checkListener(listener);
            this.on(type, _onceWrap(this, type, listener));
            return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
            checkListener(listener);
            this.prependListener(type, _onceWrap(this, type, listener));
            return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
            var list, events, position, i, originalListener;
            checkListener(listener);
            events = this._events;
            if (events === undefined) return this;
            list = events[type];
            if (list === undefined) return this;
            if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0) this._events = Object.create(null);
                else {
                    delete events[type];
                    if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
                }
            } else if (typeof list !== 'function') {
                position = -1;
                for(i = list.length - 1; i >= 0; i--){
                    if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                    }
                }
                if (position < 0) return this;
                if (position === 0) list.shift();
                else {
                    spliceOne(list, position);
                }
                if (list.length === 1) events[type] = list[0];
                if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
            }
            return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
            var listeners, events, i;
            events = this._events;
            if (events === undefined) return this;
            if (events.removeListener === undefined) {
                if (arguments.length === 0) {
                    this._events = Object.create(null);
                    this._eventsCount = 0;
                } else if (events[type] !== undefined) {
                    if (--this._eventsCount === 0) this._events = Object.create(null);
                    else delete events[type];
                }
                return this;
            }
            if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for(i = 0; i < keys.length; ++i){
                    key = keys[i];
                    if (key === 'removeListener') continue;
                    this.removeAllListeners(key);
                }
                this.removeAllListeners('removeListener');
                this._events = Object.create(null);
                this._eventsCount = 0;
                return this;
            }
            listeners = events[type];
            if (typeof listeners === 'function') {
                this.removeListener(type, listeners);
            } else if (listeners !== undefined) {
                for(i = listeners.length - 1; i >= 0; i--){
                    this.removeListener(type, listeners[i]);
                }
            }
            return this;
        };
        function _listeners(target, type, unwrap) {
            var events = target._events;
            if (events === undefined) return [];
            var evlistener = events[type];
            if (evlistener === undefined) return [];
            if (typeof evlistener === 'function') return unwrap ? [
                evlistener.listener || evlistener
            ] : [
                evlistener
            ];
            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
            if (typeof emitter.listenerCount === 'function') {
                return emitter.listenerCount(type);
            } else {
                return listenerCount.call(emitter, type);
            }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
            var events = this._events;
            if (events !== undefined) {
                var evlistener = events[type];
                if (typeof evlistener === 'function') {
                    return 1;
                } else if (evlistener !== undefined) {
                    return evlistener.length;
                }
            }
            return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };
        function arrayClone(arr, n) {
            var copy = new Array(n);
            for(var i = 0; i < n; ++i)copy[i] = arr[i];
            return copy;
        }
        function spliceOne(list, index) {
            for(; index + 1 < list.length; index++)list[index] = list[index + 1];
            list.pop();
        }
        function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for(var i = 0; i < ret.length; ++i){
                ret[i] = arr[i].listener || arr[i];
            }
            return ret;
        }
        function once(emitter, name) {
            return new Promise(function(resolve, reject) {
                function errorListener(err) {
                    emitter.removeListener(name, resolver);
                    reject(err);
                }
                function resolver() {
                    if (typeof emitter.removeListener === 'function') {
                        emitter.removeListener('error', errorListener);
                    }
                    resolve([].slice.call(arguments));
                }
                eventTargetAgnosticAddListener(emitter, name, resolver, {
                    once: true
                });
                if (name !== 'error') {
                    addErrorHandlerIfEventEmitter(emitter, errorListener, {
                        once: true
                    });
                }
            });
        }
        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
            if (typeof emitter.on === 'function') {
                eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
            }
        }
        function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
            if (typeof emitter.on === 'function') {
                if (flags.once) {
                    emitter.once(name, listener);
                } else {
                    emitter.on(name, listener);
                }
            } else if (typeof emitter.addEventListener === 'function') {
                emitter.addEventListener(name, function wrapListener(arg) {
                    if (flags.once) {
                        emitter.removeEventListener(name, wrapListener);
                    }
                    listener(arg);
                });
            } else {
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
            }
        }
        return events.exports;
    }
    var maybeCombineErrors;
    var hasRequiredMaybeCombineErrors;
    function requireMaybeCombineErrors() {
        if (hasRequiredMaybeCombineErrors) return maybeCombineErrors;
        hasRequiredMaybeCombineErrors = 1;
        const kErrors = Symbol('kErrors');
        maybeCombineErrors = function(errors) {
            errors = errors.filter(defined);
            if (errors.length === 0) return;
            if (errors.length === 1) return errors[0];
            return new CombinedError(errors);
        };
        class CombinedError extends Error {
            constructor(errors){
                const unique = new Set(errors.map(getMessage).filter(Boolean));
                const message = Array.from(unique).join('; ');
                super(message);
                value(this, 'name', 'CombinedError');
                value(this, kErrors, errors);
                getter(this, 'stack', ()=>errors.map(getStack).join('\n\n'));
                getter(this, 'transient', ()=>errors.length > 0 && errors.every(transient));
                getter(this, 'expected', ()=>errors.length > 0 && errors.every(expected));
            }
            [Symbol.iterator]() {
                return this[kErrors][Symbol.iterator]();
            }
        }
        function value(obj, prop, value) {
            Object.defineProperty(obj, prop, {
                value
            });
        }
        function getter(obj, prop, get) {
            Object.defineProperty(obj, prop, {
                get
            });
        }
        function defined(err) {
            return err != null;
        }
        function getMessage(err) {
            return err.message;
        }
        function getStack(err) {
            return err.stack;
        }
        function transient(err) {
            return err.transient === true;
        }
        function expected(err) {
            return err.expected === true;
        }
        return maybeCombineErrors;
    }
    var abstractIterator = {};
    var common = {};
    var hasRequiredCommon;
    function requireCommon() {
        if (hasRequiredCommon) return common;
        hasRequiredCommon = 1;
        const ModuleError = requireModuleError();
        const deprecations = new Set();
        common.getOptions = function(options, def) {
            if (typeof options === 'object' && options !== null) {
                return options;
            }
            if (def !== undefined) {
                return def;
            }
            return {};
        };
        common.emptyOptions = Object.freeze({});
        common.noop = function() {};
        common.resolvedPromise = Promise.resolve();
        common.deprecate = function(message) {
            if (!deprecations.has(message)) {
                deprecations.add(message);
                const c = globalThis.console;
                if (typeof c !== 'undefined' && typeof c.warn === 'function') {
                    c.warn(new ModuleError(message, {
                        code: 'LEVEL_LEGACY'
                    }));
                }
            }
        };
        return common;
    }
    var errors$1 = {};
    var hasRequiredErrors;
    function requireErrors() {
        if (hasRequiredErrors) return errors$1;
        hasRequiredErrors = 1;
        const ModuleError = requireModuleError();
        class AbortError extends ModuleError {
            constructor(cause){
                super('Operation has been aborted', {
                    code: 'LEVEL_ABORTED',
                    cause
                });
            }
            get name() {
                return 'AbortError';
            }
        }
        errors$1.AbortError = AbortError;
        return errors$1;
    }
    var hasRequiredAbstractIterator;
    function requireAbstractIterator() {
        if (hasRequiredAbstractIterator) return abstractIterator;
        hasRequiredAbstractIterator = 1;
        const ModuleError = requireModuleError();
        const combineErrors = requireMaybeCombineErrors();
        const { getOptions, emptyOptions, noop } = requireCommon();
        const { AbortError } = requireErrors();
        const kWorking = Symbol('working');
        const kDecodeOne = Symbol('decodeOne');
        const kDecodeMany = Symbol('decodeMany');
        const kSignal = Symbol('signal');
        const kPendingClose = Symbol('pendingClose');
        const kClosingPromise = Symbol('closingPromise');
        const kKeyEncoding = Symbol('keyEncoding');
        const kValueEncoding = Symbol('valueEncoding');
        const kKeys = Symbol('keys');
        const kValues = Symbol('values');
        const kLimit = Symbol('limit');
        const kCount = Symbol('count');
        const kEnded = Symbol('ended');
        class CommonIterator {
            constructor(db, options){
                if (typeof db !== 'object' || db === null) {
                    const hint = db === null ? 'null' : typeof db;
                    throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
                }
                if (typeof options !== 'object' || options === null) {
                    throw new TypeError('The second argument must be an options object');
                }
                this[kWorking] = false;
                this[kPendingClose] = null;
                this[kClosingPromise] = null;
                this[kKeyEncoding] = options[kKeyEncoding];
                this[kValueEncoding] = options[kValueEncoding];
                this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
                this[kCount] = 0;
                this[kSignal] = options.signal != null ? options.signal : null;
                this[kEnded] = false;
                this.db = db;
                this.db.attachResource(this);
            }
            get count() {
                return this[kCount];
            }
            get limit() {
                return this[kLimit];
            }
            async next() {
                startWork(this);
                try {
                    if (this[kEnded] || this[kCount] >= this[kLimit]) {
                        this[kEnded] = true;
                        return undefined;
                    }
                    let item = await this._next();
                    if (item === undefined) {
                        this[kEnded] = true;
                        return undefined;
                    }
                    try {
                        item = this[kDecodeOne](item);
                    } catch (err) {
                        throw new IteratorDecodeError(err);
                    }
                    this[kCount]++;
                    return item;
                } finally{
                    endWork(this);
                }
            }
            async _next() {}
            async nextv(size, options) {
                if (!Number.isInteger(size)) {
                    throw new TypeError("The first argument 'size' must be an integer");
                }
                options = getOptions(options, emptyOptions);
                if (size < 1) size = 1;
                if (this[kLimit] < Infinity) size = Math.min(size, this[kLimit] - this[kCount]);
                startWork(this);
                try {
                    if (this[kEnded] || size <= 0) {
                        this[kEnded] = true;
                        return [];
                    }
                    const items = await this._nextv(size, options);
                    if (items.length === 0) {
                        this[kEnded] = true;
                        return items;
                    }
                    try {
                        this[kDecodeMany](items);
                    } catch (err) {
                        throw new IteratorDecodeError(err);
                    }
                    this[kCount] += items.length;
                    return items;
                } finally{
                    endWork(this);
                }
            }
            async _nextv(size, options) {
                const acc = [];
                while(acc.length < size){
                    const item = await this._next(options);
                    if (item !== undefined) {
                        acc.push(item);
                    } else {
                        this[kEnded] = true;
                        break;
                    }
                }
                return acc;
            }
            async all(options) {
                options = getOptions(options, emptyOptions);
                startWork(this);
                try {
                    if (this[kEnded] || this[kCount] >= this[kLimit]) {
                        return [];
                    }
                    const items = await this._all(options);
                    try {
                        this[kDecodeMany](items);
                    } catch (err) {
                        throw new IteratorDecodeError(err);
                    }
                    this[kCount] += items.length;
                    return items;
                } catch (err) {
                    endWork(this);
                    await destroy(this, err);
                } finally{
                    this[kEnded] = true;
                    if (this[kWorking]) {
                        endWork(this);
                        await this.close();
                    }
                }
            }
            async _all(options) {
                let count = this[kCount];
                const acc = [];
                while(true){
                    const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
                    if (size <= 0) {
                        return acc;
                    }
                    const items = await this._nextv(size, options);
                    if (items.length === 0) {
                        return acc;
                    }
                    acc.push.apply(acc, items);
                    count += items.length;
                }
            }
            seek(target, options) {
                options = getOptions(options, emptyOptions);
                if (this[kClosingPromise] !== null) ;
                else if (this[kWorking]) {
                    throw new ModuleError('Iterator is busy: cannot call seek() until next() has completed', {
                        code: 'LEVEL_ITERATOR_BUSY'
                    });
                } else {
                    const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding]);
                    const keyFormat = keyEncoding.format;
                    if (options.keyEncoding !== keyFormat) {
                        options = {
                            ...options,
                            keyEncoding: keyFormat
                        };
                    }
                    const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat, false);
                    this._seek(mapped, options);
                    this[kEnded] = false;
                }
            }
            _seek(target, options) {
                throw new ModuleError('Iterator does not support seek()', {
                    code: 'LEVEL_NOT_SUPPORTED'
                });
            }
            async close() {
                if (this[kClosingPromise] !== null) {
                    return this[kClosingPromise].catch(noop);
                }
                this[kClosingPromise] = new Promise((resolve, reject)=>{
                    this[kPendingClose] = ()=>{
                        this[kPendingClose] = null;
                        privateClose(this).then(resolve, reject);
                    };
                });
                if (!this[kWorking]) {
                    this[kPendingClose]();
                }
                return this[kClosingPromise];
            }
            async _close() {}
            async *[Symbol.asyncIterator]() {
                try {
                    let item;
                    while((item = (await this.next())) !== undefined){
                        yield item;
                    }
                } catch (err) {
                    await destroy(this, err);
                } finally{
                    await this.close();
                }
            }
        }
        class AbstractIterator extends CommonIterator {
            constructor(db, options){
                super(db, options);
                this[kKeys] = options.keys !== false;
                this[kValues] = options.values !== false;
            }
            [kDecodeOne](entry) {
                const key = entry[0];
                const value = entry[1];
                if (key !== undefined) {
                    entry[0] = this[kKeys] ? this[kKeyEncoding].decode(key) : undefined;
                }
                if (value !== undefined) {
                    entry[1] = this[kValues] ? this[kValueEncoding].decode(value) : undefined;
                }
                return entry;
            }
            [kDecodeMany](entries) {
                const keyEncoding = this[kKeyEncoding];
                const valueEncoding = this[kValueEncoding];
                for (const entry of entries){
                    const key = entry[0];
                    const value = entry[1];
                    if (key !== undefined) entry[0] = this[kKeys] ? keyEncoding.decode(key) : undefined;
                    if (value !== undefined) entry[1] = this[kValues] ? valueEncoding.decode(value) : undefined;
                }
            }
        }
        class AbstractKeyIterator extends CommonIterator {
            [kDecodeOne](key) {
                return this[kKeyEncoding].decode(key);
            }
            [kDecodeMany](keys) {
                const keyEncoding = this[kKeyEncoding];
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    if (key !== undefined) keys[i] = keyEncoding.decode(key);
                }
            }
        }
        class AbstractValueIterator extends CommonIterator {
            [kDecodeOne](value) {
                return this[kValueEncoding].decode(value);
            }
            [kDecodeMany](values) {
                const valueEncoding = this[kValueEncoding];
                for(let i = 0; i < values.length; i++){
                    const value = values[i];
                    if (value !== undefined) values[i] = valueEncoding.decode(value);
                }
            }
        }
        class IteratorDecodeError extends ModuleError {
            constructor(cause){
                super('Iterator could not decode data', {
                    code: 'LEVEL_DECODE_ERROR',
                    cause
                });
            }
        }
        const startWork = function(iterator) {
            if (iterator[kClosingPromise] !== null) {
                throw new ModuleError('Iterator is not open: cannot read after close()', {
                    code: 'LEVEL_ITERATOR_NOT_OPEN'
                });
            } else if (iterator[kWorking]) {
                throw new ModuleError('Iterator is busy: cannot read until previous read has completed', {
                    code: 'LEVEL_ITERATOR_BUSY'
                });
            } else if (iterator[kSignal] !== null && iterator[kSignal].aborted) {
                throw new AbortError();
            }
            iterator[kWorking] = true;
        };
        const endWork = function(iterator) {
            iterator[kWorking] = false;
            if (iterator[kPendingClose] !== null) {
                iterator[kPendingClose]();
            }
        };
        const privateClose = async function(iterator) {
            await iterator._close();
            iterator.db.detachResource(iterator);
        };
        const destroy = async function(iterator, err) {
            try {
                await iterator.close();
            } catch (closeErr) {
                throw combineErrors([
                    err,
                    closeErr
                ]);
            }
            throw err;
        };
        AbstractIterator.keyEncoding = kKeyEncoding;
        AbstractIterator.valueEncoding = kValueEncoding;
        abstractIterator.AbstractIterator = AbstractIterator;
        abstractIterator.AbstractKeyIterator = AbstractKeyIterator;
        abstractIterator.AbstractValueIterator = AbstractValueIterator;
        return abstractIterator;
    }
    var defaultKvIterator = {};
    var hasRequiredDefaultKvIterator;
    function requireDefaultKvIterator() {
        if (hasRequiredDefaultKvIterator) return defaultKvIterator;
        hasRequiredDefaultKvIterator = 1;
        const { AbstractKeyIterator, AbstractValueIterator } = requireAbstractIterator();
        const kIterator = Symbol('iterator');
        const kHandleOne = Symbol('handleOne');
        const kHandleMany = Symbol('handleMany');
        class DefaultKeyIterator extends AbstractKeyIterator {
            constructor(db, options){
                super(db, options);
                this[kIterator] = db.iterator({
                    ...options,
                    keys: true,
                    values: false
                });
            }
            [kHandleOne](entry) {
                return entry[0];
            }
            [kHandleMany](entries) {
                for(let i = 0; i < entries.length; i++){
                    entries[i] = entries[i][0];
                }
            }
        }
        class DefaultValueIterator extends AbstractValueIterator {
            constructor(db, options){
                super(db, options);
                this[kIterator] = db.iterator({
                    ...options,
                    keys: false,
                    values: true
                });
            }
            [kHandleOne](entry) {
                return entry[1];
            }
            [kHandleMany](entries) {
                for(let i = 0; i < entries.length; i++){
                    entries[i] = entries[i][1];
                }
            }
        }
        for (const Iterator of [
            DefaultKeyIterator,
            DefaultValueIterator
        ]){
            Iterator.prototype._next = async function() {
                const entry = await this[kIterator].next();
                return entry === undefined ? entry : this[kHandleOne](entry);
            };
            Iterator.prototype._nextv = async function(size, options) {
                const entries = await this[kIterator].nextv(size, options);
                this[kHandleMany](entries);
                return entries;
            };
            Iterator.prototype._all = async function(options) {
                const entries = await this[kIterator].all(options);
                this[kHandleMany](entries);
                return entries;
            };
            Iterator.prototype._seek = function(target, options) {
                this[kIterator].seek(target, options);
            };
            Iterator.prototype._close = async function() {
                return this[kIterator].close();
            };
        }
        defaultKvIterator.DefaultKeyIterator = DefaultKeyIterator;
        defaultKvIterator.DefaultValueIterator = DefaultValueIterator;
        return defaultKvIterator;
    }
    var deferredIterator = {};
    var hasRequiredDeferredIterator;
    function requireDeferredIterator() {
        if (hasRequiredDeferredIterator) return deferredIterator;
        hasRequiredDeferredIterator = 1;
        const { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = requireAbstractIterator();
        const ModuleError = requireModuleError();
        const kNut = Symbol('nut');
        const kUndefer = Symbol('undefer');
        const kFactory = Symbol('factory');
        const kSignalOptions = Symbol('signalOptions');
        class DeferredIterator extends AbstractIterator {
            constructor(db, options){
                super(db, options);
                this[kNut] = null;
                this[kFactory] = ()=>db.iterator(options);
                this[kSignalOptions] = {
                    signal: options.signal
                };
                this.db.defer(()=>this[kUndefer](), this[kSignalOptions]);
            }
        }
        class DeferredKeyIterator extends AbstractKeyIterator {
            constructor(db, options){
                super(db, options);
                this[kNut] = null;
                this[kFactory] = ()=>db.keys(options);
                this[kSignalOptions] = {
                    signal: options.signal
                };
                this.db.defer(()=>this[kUndefer](), this[kSignalOptions]);
            }
        }
        class DeferredValueIterator extends AbstractValueIterator {
            constructor(db, options){
                super(db, options);
                this[kNut] = null;
                this[kFactory] = ()=>db.values(options);
                this[kSignalOptions] = {
                    signal: options.signal
                };
                this.db.defer(()=>this[kUndefer](), this[kSignalOptions]);
            }
        }
        for (const Iterator of [
            DeferredIterator,
            DeferredKeyIterator,
            DeferredValueIterator
        ]){
            Iterator.prototype[kUndefer] = function() {
                if (this.db.status === 'open') {
                    this[kNut] = this[kFactory]();
                }
            };
            Iterator.prototype._next = async function() {
                if (this[kNut] !== null) {
                    return this[kNut].next();
                } else if (this.db.status === 'opening') {
                    return this.db.deferAsync(()=>this._next(), this[kSignalOptions]);
                } else {
                    throw new ModuleError('Iterator is not open: cannot call next() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    });
                }
            };
            Iterator.prototype._nextv = async function(size, options) {
                if (this[kNut] !== null) {
                    return this[kNut].nextv(size, options);
                } else if (this.db.status === 'opening') {
                    return this.db.deferAsync(()=>this._nextv(size, options), this[kSignalOptions]);
                } else {
                    throw new ModuleError('Iterator is not open: cannot call nextv() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    });
                }
            };
            Iterator.prototype._all = async function(options) {
                if (this[kNut] !== null) {
                    return this[kNut].all();
                } else if (this.db.status === 'opening') {
                    return this.db.deferAsync(()=>this._all(options), this[kSignalOptions]);
                } else {
                    throw new ModuleError('Iterator is not open: cannot call all() after close()', {
                        code: 'LEVEL_ITERATOR_NOT_OPEN'
                    });
                }
            };
            Iterator.prototype._seek = function(target, options) {
                if (this[kNut] !== null) {
                    this[kNut]._seek(target, options);
                } else if (this.db.status === 'opening') {
                    this.db.defer(()=>this._seek(target, options), this[kSignalOptions]);
                }
            };
            Iterator.prototype._close = async function() {
                if (this[kNut] !== null) {
                    return this[kNut].close();
                } else if (this.db.status === 'opening') {
                    return this.db.deferAsync(()=>this._close());
                }
            };
        }
        deferredIterator.DeferredIterator = DeferredIterator;
        deferredIterator.DeferredKeyIterator = DeferredKeyIterator;
        deferredIterator.DeferredValueIterator = DeferredValueIterator;
        return deferredIterator;
    }
    var defaultChainedBatch = {};
    var abstractChainedBatch = {};
    var prefixes = {};
    var hasRequiredPrefixes;
    function requirePrefixes() {
        if (hasRequiredPrefixes) return prefixes;
        hasRequiredPrefixes = 1;
        prefixes.prefixDescendantKey = function(key, keyFormat, descendant, ancestor) {
            while(descendant !== null && descendant !== ancestor){
                key = descendant.prefixKey(key, keyFormat, true);
                descendant = descendant.parent;
            }
            return key;
        };
        prefixes.isDescendant = function(db, ancestor) {
            while(true){
                if (db.parent == null) return false;
                if (db.parent === ancestor) return true;
                db = db.parent;
            }
        };
        return prefixes;
    }
    var prewriteBatch = {};
    var hasRequiredPrewriteBatch;
    function requirePrewriteBatch() {
        if (hasRequiredPrewriteBatch) return prewriteBatch;
        hasRequiredPrewriteBatch = 1;
        const { prefixDescendantKey, isDescendant } = requirePrefixes();
        const kDb = Symbol('db');
        const kPrivateOperations = Symbol('privateOperations');
        const kPublicOperations = Symbol('publicOperations');
        class PrewriteBatch {
            constructor(db, privateOperations, publicOperations){
                this[kDb] = db;
                this[kPrivateOperations] = privateOperations;
                this[kPublicOperations] = publicOperations;
            }
            add(op) {
                const isPut = op.type === 'put';
                const delegated = op.sublevel != null;
                const db = delegated ? op.sublevel : this[kDb];
                const keyError = db._checkKey(op.key);
                if (keyError != null) throw keyError;
                op.keyEncoding = db.keyEncoding(op.keyEncoding);
                if (isPut) {
                    const valueError = db._checkValue(op.value);
                    if (valueError != null) throw valueError;
                    op.valueEncoding = db.valueEncoding(op.valueEncoding);
                } else if (op.type !== 'del') {
                    throw new TypeError("A batch operation must have a type property that is 'put' or 'del'");
                }
                const keyEncoding = op.keyEncoding;
                const preencodedKey = keyEncoding.encode(op.key);
                const keyFormat = keyEncoding.format;
                const siblings = delegated && !isDescendant(op.sublevel, this[kDb]) && op.sublevel !== this[kDb];
                const encodedKey = delegated && !siblings ? prefixDescendantKey(preencodedKey, keyFormat, db, this[kDb]) : preencodedKey;
                if (delegated && !siblings) {
                    op.sublevel = null;
                }
                let publicOperation = null;
                if (this[kPublicOperations] !== null && !siblings) {
                    publicOperation = Object.assign({}, op);
                    publicOperation.encodedKey = encodedKey;
                    if (delegated) {
                        publicOperation.key = encodedKey;
                        publicOperation.keyEncoding = this[kDb].keyEncoding(keyFormat);
                    }
                    this[kPublicOperations].push(publicOperation);
                }
                op.key = siblings ? encodedKey : this[kDb].prefixKey(encodedKey, keyFormat, true);
                op.keyEncoding = keyFormat;
                if (isPut) {
                    const valueEncoding = op.valueEncoding;
                    const encodedValue = valueEncoding.encode(op.value);
                    const valueFormat = valueEncoding.format;
                    op.value = encodedValue;
                    op.valueEncoding = valueFormat;
                    if (publicOperation !== null) {
                        publicOperation.encodedValue = encodedValue;
                        if (delegated) {
                            publicOperation.value = encodedValue;
                            publicOperation.valueEncoding = this[kDb].valueEncoding(valueFormat);
                        }
                    }
                }
                this[kPrivateOperations].push(op);
                return this;
            }
        }
        prewriteBatch.PrewriteBatch = PrewriteBatch;
        return prewriteBatch;
    }
    var hasRequiredAbstractChainedBatch;
    function requireAbstractChainedBatch() {
        if (hasRequiredAbstractChainedBatch) return abstractChainedBatch;
        hasRequiredAbstractChainedBatch = 1;
        const combineErrors = requireMaybeCombineErrors();
        const ModuleError = requireModuleError();
        const { getOptions, emptyOptions, noop } = requireCommon();
        const { prefixDescendantKey, isDescendant } = requirePrefixes();
        const { PrewriteBatch } = requirePrewriteBatch();
        const kStatus = Symbol('status');
        const kPublicOperations = Symbol('publicOperations');
        const kLegacyOperations = Symbol('legacyOperations');
        const kPrivateOperations = Symbol('privateOperations');
        const kClosePromise = Symbol('closePromise');
        const kLength = Symbol('length');
        const kPrewriteRun = Symbol('prewriteRun');
        const kPrewriteBatch = Symbol('prewriteBatch');
        const kPrewriteData = Symbol('prewriteData');
        const kAddMode = Symbol('addMode');
        class AbstractChainedBatch {
            constructor(db, options){
                if (typeof db !== 'object' || db === null) {
                    const hint = db === null ? 'null' : typeof db;
                    throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
                }
                const enableWriteEvent = db.listenerCount('write') > 0;
                const enablePrewriteHook = !db.hooks.prewrite.noop;
                this[kPublicOperations] = enableWriteEvent ? [] : null;
                this[kLegacyOperations] = enableWriteEvent || enablePrewriteHook ? null : [];
                this[kLength] = 0;
                this[kStatus] = 'open';
                this[kClosePromise] = null;
                this[kAddMode] = getOptions(options, emptyOptions).add === true;
                if (enablePrewriteHook) {
                    const data = new PrewriteData([], enableWriteEvent ? [] : null);
                    this[kPrewriteData] = data;
                    this[kPrewriteBatch] = new PrewriteBatch(db, data[kPrivateOperations], data[kPublicOperations]);
                    this[kPrewriteRun] = db.hooks.prewrite.run;
                } else {
                    this[kPrewriteData] = null;
                    this[kPrewriteBatch] = null;
                    this[kPrewriteRun] = null;
                }
                this.db = db;
                this.db.attachResource(this);
            }
            get length() {
                if (this[kPrewriteData] !== null) {
                    return this[kLength] + this[kPrewriteData].length;
                } else {
                    return this[kLength];
                }
            }
            put(key, value, options) {
                assertStatus(this);
                options = getOptions(options, emptyOptions);
                const delegated = options.sublevel != null;
                const db = delegated ? options.sublevel : this.db;
                const original = options;
                const keyError = db._checkKey(key);
                const valueError = db._checkValue(value);
                if (keyError != null) throw keyError;
                if (valueError != null) throw valueError;
                const op = Object.assign({}, options, {
                    type: 'put',
                    key,
                    value,
                    keyEncoding: db.keyEncoding(options.keyEncoding),
                    valueEncoding: db.valueEncoding(options.valueEncoding)
                });
                if (this[kPrewriteRun] !== null) {
                    try {
                        this[kPrewriteRun](op, this[kPrewriteBatch]);
                        op.keyEncoding = db.keyEncoding(op.keyEncoding);
                        op.valueEncoding = db.valueEncoding(op.valueEncoding);
                    } catch (err) {
                        throw new ModuleError('The prewrite hook failed on batch.put()', {
                            code: 'LEVEL_HOOK_ERROR',
                            cause: err
                        });
                    }
                }
                const keyEncoding = op.keyEncoding;
                const preencodedKey = keyEncoding.encode(op.key);
                const keyFormat = keyEncoding.format;
                const siblings = delegated && !isDescendant(op.sublevel, this.db) && op.sublevel !== this.db;
                const encodedKey = delegated && !siblings ? prefixDescendantKey(preencodedKey, keyFormat, db, this.db) : preencodedKey;
                const valueEncoding = op.valueEncoding;
                const encodedValue = valueEncoding.encode(op.value);
                const valueFormat = valueEncoding.format;
                if (delegated && !siblings) {
                    op.sublevel = null;
                }
                if (this[kPublicOperations] !== null && !siblings) {
                    const publicOperation = Object.assign({}, op);
                    publicOperation.encodedKey = encodedKey;
                    publicOperation.encodedValue = encodedValue;
                    if (delegated) {
                        publicOperation.key = encodedKey;
                        publicOperation.value = encodedValue;
                        publicOperation.keyEncoding = this.db.keyEncoding(keyFormat);
                        publicOperation.valueEncoding = this.db.valueEncoding(valueFormat);
                    }
                    this[kPublicOperations].push(publicOperation);
                } else if (this[kLegacyOperations] !== null && !siblings) {
                    const legacyOperation = Object.assign({}, original);
                    legacyOperation.type = 'put';
                    legacyOperation.key = key;
                    legacyOperation.value = value;
                    this[kLegacyOperations].push(legacyOperation);
                }
                op.key = siblings ? encodedKey : this.db.prefixKey(encodedKey, keyFormat, true);
                op.value = encodedValue;
                op.keyEncoding = keyFormat;
                op.valueEncoding = valueFormat;
                if (this[kAddMode]) {
                    this._add(op);
                } else {
                    this._put(op.key, encodedValue, op);
                }
                this[kLength]++;
                return this;
            }
            _put(key, value, options) {}
            del(key, options) {
                assertStatus(this);
                options = getOptions(options, emptyOptions);
                const delegated = options.sublevel != null;
                const db = delegated ? options.sublevel : this.db;
                const original = options;
                const keyError = db._checkKey(key);
                if (keyError != null) throw keyError;
                const op = Object.assign({}, options, {
                    type: 'del',
                    key,
                    keyEncoding: db.keyEncoding(options.keyEncoding)
                });
                if (this[kPrewriteRun] !== null) {
                    try {
                        this[kPrewriteRun](op, this[kPrewriteBatch]);
                        op.keyEncoding = db.keyEncoding(op.keyEncoding);
                    } catch (err) {
                        throw new ModuleError('The prewrite hook failed on batch.del()', {
                            code: 'LEVEL_HOOK_ERROR',
                            cause: err
                        });
                    }
                }
                const keyEncoding = op.keyEncoding;
                const preencodedKey = keyEncoding.encode(op.key);
                const keyFormat = keyEncoding.format;
                const encodedKey = delegated ? prefixDescendantKey(preencodedKey, keyFormat, db, this.db) : preencodedKey;
                if (delegated) op.sublevel = null;
                if (this[kPublicOperations] !== null) {
                    const publicOperation = Object.assign({}, op);
                    publicOperation.encodedKey = encodedKey;
                    if (delegated) {
                        publicOperation.key = encodedKey;
                        publicOperation.keyEncoding = this.db.keyEncoding(keyFormat);
                    }
                    this[kPublicOperations].push(publicOperation);
                } else if (this[kLegacyOperations] !== null) {
                    const legacyOperation = Object.assign({}, original);
                    legacyOperation.type = 'del';
                    legacyOperation.key = key;
                    this[kLegacyOperations].push(legacyOperation);
                }
                op.key = this.db.prefixKey(encodedKey, keyFormat, true);
                op.keyEncoding = keyFormat;
                if (this[kAddMode]) {
                    this._add(op);
                } else {
                    this._del(op.key, op);
                }
                this[kLength]++;
                return this;
            }
            _del(key, options) {}
            _add(op) {}
            clear() {
                assertStatus(this);
                this._clear();
                if (this[kPublicOperations] !== null) this[kPublicOperations] = [];
                if (this[kLegacyOperations] !== null) this[kLegacyOperations] = [];
                if (this[kPrewriteData] !== null) this[kPrewriteData].clear();
                this[kLength] = 0;
                return this;
            }
            _clear() {}
            async write(options) {
                assertStatus(this);
                options = getOptions(options);
                if (this[kLength] === 0) {
                    return this.close();
                } else {
                    this[kStatus] = 'writing';
                    const close = prepareClose(this);
                    try {
                        if (this[kPrewriteData] !== null) {
                            const publicOperations = this[kPrewriteData][kPublicOperations];
                            const privateOperations = this[kPrewriteData][kPrivateOperations];
                            const length = this[kPrewriteData].length;
                            for(let i = 0; i < length; i++){
                                const op = privateOperations[i];
                                if (this[kAddMode]) {
                                    this._add(op);
                                } else if (op.type === 'put') {
                                    this._put(op.key, op.value, op);
                                } else {
                                    this._del(op.key, op);
                                }
                            }
                            if (publicOperations !== null && length !== 0) {
                                this[kPublicOperations] = this[kPublicOperations].concat(publicOperations);
                            }
                        }
                        await this._write(options);
                    } catch (err) {
                        close();
                        try {
                            await this[kClosePromise];
                        } catch (closeErr) {
                            err = combineErrors([
                                err,
                                closeErr
                            ]);
                        }
                        throw err;
                    }
                    close();
                    if (this[kPublicOperations] !== null) {
                        this.db.emit('write', this[kPublicOperations]);
                    } else if (this[kLegacyOperations] !== null) {
                        this.db.emit('batch', this[kLegacyOperations]);
                    }
                    return this[kClosePromise];
                }
            }
            async _write(options) {}
            async close() {
                if (this[kClosePromise] !== null) {
                    return this[kClosePromise].catch(noop);
                } else {
                    prepareClose(this)();
                    return this[kClosePromise];
                }
            }
            async _close() {}
        }
        const prepareClose = function(batch) {
            let close;
            batch[kClosePromise] = new Promise((resolve, reject)=>{
                close = ()=>{
                    privateClose(batch).then(resolve, reject);
                };
            });
            return close;
        };
        const privateClose = async function(batch) {
            batch[kStatus] = 'closing';
            await batch._close();
            batch.db.detachResource(batch);
        };
        class PrewriteData {
            constructor(privateOperations, publicOperations){
                this[kPrivateOperations] = privateOperations;
                this[kPublicOperations] = publicOperations;
            }
            get length() {
                return this[kPrivateOperations].length;
            }
            clear() {
                for (const k of [
                    kPublicOperations,
                    kPrivateOperations
                ]){
                    const ops = this[k];
                    if (ops !== null) {
                        ops.splice(0, ops.length);
                    }
                }
            }
        }
        const assertStatus = function(batch) {
            if (batch[kStatus] !== 'open') {
                throw new ModuleError('Batch is not open: cannot change operations after write() or close()', {
                    code: 'LEVEL_BATCH_NOT_OPEN'
                });
            }
            if (batch.db.status !== 'open') {
                throw new ModuleError('Database is not open', {
                    code: 'LEVEL_DATABASE_NOT_OPEN'
                });
            }
        };
        abstractChainedBatch.AbstractChainedBatch = AbstractChainedBatch;
        return abstractChainedBatch;
    }
    var hasRequiredDefaultChainedBatch;
    function requireDefaultChainedBatch() {
        if (hasRequiredDefaultChainedBatch) return defaultChainedBatch;
        hasRequiredDefaultChainedBatch = 1;
        const { AbstractChainedBatch } = requireAbstractChainedBatch();
        const kEncoded = Symbol('encoded');
        class DefaultChainedBatch extends AbstractChainedBatch {
            constructor(db){
                super(db, {
                    add: true
                });
                this[kEncoded] = [];
            }
            _add(op) {
                this[kEncoded].push(op);
            }
            _clear() {
                this[kEncoded] = [];
            }
            async _write(options) {
                return this.db._batch(this[kEncoded], options);
            }
        }
        defaultChainedBatch.DefaultChainedBatch = DefaultChainedBatch;
        return defaultChainedBatch;
    }
    var hooks = {};
    var hasRequiredHooks;
    function requireHooks() {
        if (hasRequiredHooks) return hooks;
        hasRequiredHooks = 1;
        const { noop } = requireCommon();
        const kFunctions = Symbol('functions');
        const kAsync = Symbol('async');
        class DatabaseHooks {
            constructor(){
                this.postopen = new Hook({
                    async: true
                });
                this.prewrite = new Hook({
                    async: false
                });
                this.newsub = new Hook({
                    async: false
                });
            }
        }
        class Hook {
            constructor(options){
                this[kAsync] = options.async;
                this[kFunctions] = new Set();
                this.noop = true;
                this.run = runner(this);
            }
            add(fn) {
                assertFunction(fn);
                this[kFunctions].add(fn);
                this.noop = false;
                this.run = runner(this);
            }
            delete(fn) {
                assertFunction(fn);
                this[kFunctions].delete(fn);
                this.noop = this[kFunctions].size === 0;
                this.run = runner(this);
            }
        }
        const assertFunction = function(fn) {
            if (typeof fn !== 'function') {
                const hint = fn === null ? 'null' : typeof fn;
                throw new TypeError(`The first argument must be a function, received ${hint}`);
            }
        };
        const runner = function(hook) {
            if (hook.noop) {
                return noop;
            } else if (hook[kFunctions].size === 1) {
                const [fn] = hook[kFunctions];
                return fn;
            } else if (hook[kAsync]) {
                const run = async function(functions, ...args) {
                    for (const fn of functions){
                        await fn(...args);
                    }
                };
                return run.bind(null, Array.from(hook[kFunctions]));
            } else {
                const run = function(functions, ...args) {
                    for (const fn of functions){
                        fn(...args);
                    }
                };
                return run.bind(null, Array.from(hook[kFunctions]));
            }
        };
        hooks.DatabaseHooks = DatabaseHooks;
        return hooks;
    }
    var eventMonitor = {};
    var hasRequiredEventMonitor;
    function requireEventMonitor() {
        if (hasRequiredEventMonitor) return eventMonitor;
        hasRequiredEventMonitor = 1;
        const { deprecate } = requireCommon();
        eventMonitor.EventMonitor = class EventMonitor {
            constructor(emitter, events){
                for (const event of events){
                    this[event.name] = false;
                    if (event.deprecated) {
                        event.message = `The '${event.name}' event is deprecated in favor of '${event.alt}' and will be removed in a future version of abstract-level`;
                    }
                }
                const map = new Map(events.map((e)=>[
                        e.name,
                        e
                    ]));
                const monitor = this;
                emitter.on('newListener', beforeAdded);
                emitter.on('removeListener', afterRemoved);
                function beforeAdded(name) {
                    const event = map.get(name);
                    if (event !== undefined) {
                        monitor[name] = true;
                        if (event.deprecated) {
                            deprecate(event.message);
                        }
                    }
                }
                function afterRemoved(name) {
                    if (map.has(name)) {
                        monitor[name] = this.listenerCount(name) > 0;
                    }
                }
            }
        };
        return eventMonitor;
    }
    var deferredQueue = {};
    var hasRequiredDeferredQueue;
    function requireDeferredQueue() {
        if (hasRequiredDeferredQueue) return deferredQueue;
        hasRequiredDeferredQueue = 1;
        const { getOptions, emptyOptions } = requireCommon();
        const { AbortError } = requireErrors();
        const kOperations = Symbol('operations');
        const kSignals = Symbol('signals');
        const kHandleAbort = Symbol('handleAbort');
        class DeferredOperation {
            constructor(fn, signal){
                this.fn = fn;
                this.signal = signal;
            }
        }
        class DeferredQueue {
            constructor(){
                this[kOperations] = [];
                this[kSignals] = new Set();
                this[kHandleAbort] = this[kHandleAbort].bind(this);
            }
            add(fn, options) {
                options = getOptions(options, emptyOptions);
                const signal = options.signal;
                if (signal == null) {
                    this[kOperations].push(new DeferredOperation(fn, null));
                    return;
                }
                if (signal.aborted) {
                    fn(new AbortError());
                    return;
                }
                if (!this[kSignals].has(signal)) {
                    this[kSignals].add(signal);
                    signal.addEventListener('abort', this[kHandleAbort], {
                        once: true
                    });
                }
                this[kOperations].push(new DeferredOperation(fn, signal));
            }
            drain() {
                const operations = this[kOperations];
                const signals = this[kSignals];
                this[kOperations] = [];
                this[kSignals] = new Set();
                for (const signal of signals){
                    signal.removeEventListener('abort', this[kHandleAbort]);
                }
                for (const operation of operations){
                    operation.fn.call(null);
                }
            }
            [kHandleAbort](ev) {
                const signal = ev.target;
                const err = new AbortError();
                const aborted = [];
                this[kOperations] = this[kOperations].filter(function(operation) {
                    if (operation.signal !== null && operation.signal === signal) {
                        aborted.push(operation);
                        return false;
                    } else {
                        return true;
                    }
                });
                this[kSignals].delete(signal);
                for (const operation of aborted){
                    operation.fn.call(null, err);
                }
            }
        }
        deferredQueue.DeferredQueue = DeferredQueue;
        return deferredQueue;
    }
    var rangeOptions_1;
    var hasRequiredRangeOptions;
    function requireRangeOptions() {
        if (hasRequiredRangeOptions) return rangeOptions_1;
        hasRequiredRangeOptions = 1;
        const hasOwnProperty = Object.prototype.hasOwnProperty;
        const rangeOptions = new Set([
            'lt',
            'lte',
            'gt',
            'gte'
        ]);
        rangeOptions_1 = function(options, keyEncoding) {
            const result = {};
            for(const k in options){
                if (!hasOwnProperty.call(options, k)) continue;
                if (k === 'keyEncoding' || k === 'valueEncoding') continue;
                if (rangeOptions.has(k)) {
                    result[k] = keyEncoding.encode(options[k]);
                } else {
                    result[k] = options[k];
                }
            }
            result.reverse = !!result.reverse;
            result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
            return result;
        };
        return rangeOptions_1;
    }
    var abstractSublevelIterator = {};
    var hasRequiredAbstractSublevelIterator;
    function requireAbstractSublevelIterator() {
        if (hasRequiredAbstractSublevelIterator) return abstractSublevelIterator;
        hasRequiredAbstractSublevelIterator = 1;
        const { AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = requireAbstractIterator();
        const kUnfix = Symbol('unfix');
        const kIterator = Symbol('iterator');
        class AbstractSublevelIterator extends AbstractIterator {
            constructor(db, options, iterator, unfix){
                super(db, options);
                this[kIterator] = iterator;
                this[kUnfix] = unfix;
            }
            async _next() {
                const entry = await this[kIterator].next();
                if (entry !== undefined) {
                    const key = entry[0];
                    if (key !== undefined) entry[0] = this[kUnfix](key);
                }
                return entry;
            }
            async _nextv(size, options) {
                const entries = await this[kIterator].nextv(size, options);
                const unfix = this[kUnfix];
                for (const entry of entries){
                    const key = entry[0];
                    if (key !== undefined) entry[0] = unfix(key);
                }
                return entries;
            }
            async _all(options) {
                const entries = await this[kIterator].all(options);
                const unfix = this[kUnfix];
                for (const entry of entries){
                    const key = entry[0];
                    if (key !== undefined) entry[0] = unfix(key);
                }
                return entries;
            }
        }
        class AbstractSublevelKeyIterator extends AbstractKeyIterator {
            constructor(db, options, iterator, unfix){
                super(db, options);
                this[kIterator] = iterator;
                this[kUnfix] = unfix;
            }
            async _next() {
                const key = await this[kIterator].next();
                return key === undefined ? key : this[kUnfix](key);
            }
            async _nextv(size, options) {
                const keys = await this[kIterator].nextv(size, options);
                const unfix = this[kUnfix];
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    if (key !== undefined) keys[i] = unfix(key);
                }
                return keys;
            }
            async _all(options) {
                const keys = await this[kIterator].all(options);
                const unfix = this[kUnfix];
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    if (key !== undefined) keys[i] = unfix(key);
                }
                return keys;
            }
        }
        class AbstractSublevelValueIterator extends AbstractValueIterator {
            constructor(db, options, iterator){
                super(db, options);
                this[kIterator] = iterator;
            }
            async _next() {
                return this[kIterator].next();
            }
            async _nextv(size, options) {
                return this[kIterator].nextv(size, options);
            }
            async _all(options) {
                return this[kIterator].all(options);
            }
        }
        for (const Iterator of [
            AbstractSublevelIterator,
            AbstractSublevelKeyIterator,
            AbstractSublevelValueIterator
        ]){
            Iterator.prototype._seek = function(target, options) {
                this[kIterator].seek(target, options);
            };
            Iterator.prototype._close = async function() {
                return this[kIterator].close();
            };
        }
        abstractSublevelIterator.AbstractSublevelIterator = AbstractSublevelIterator;
        abstractSublevelIterator.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
        abstractSublevelIterator.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
        return abstractSublevelIterator;
    }
    var abstractSublevel;
    var hasRequiredAbstractSublevel;
    function requireAbstractSublevel() {
        if (hasRequiredAbstractSublevel) return abstractSublevel;
        hasRequiredAbstractSublevel = 1;
        const ModuleError = requireModuleError();
        const { Buffer } = requireBuffer() || {};
        const { AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator } = requireAbstractSublevelIterator();
        const kGlobalPrefix = Symbol('prefix');
        const kLocalPrefix = Symbol('localPrefix');
        const kLocalPath = Symbol('localPath');
        const kGlobalPath = Symbol('globalPath');
        const kGlobalUpperBound = Symbol('upperBound');
        const kPrefixRange = Symbol('prefixRange');
        const kRoot = Symbol('root');
        const kParent = Symbol('parent');
        const kUnfix = Symbol('unfix');
        const textEncoder = new TextEncoder();
        const defaults = {
            separator: '!'
        };
        abstractSublevel = function({ AbstractLevel }) {
            class AbstractSublevel extends AbstractLevel {
                static defaults(options) {
                    if (options == null) {
                        return defaults;
                    } else if (!options.separator) {
                        return {
                            ...options,
                            separator: '!'
                        };
                    } else {
                        return options;
                    }
                }
                constructor(db, name, options){
                    const { separator, manifest, ...forward } = AbstractSublevel.defaults(options);
                    const names = [].concat(name).map((name)=>trim(name, separator));
                    const reserved = separator.charCodeAt(0) + 1;
                    const root = db[kRoot] || db;
                    if (!names.every((name)=>textEncoder.encode(name).every((x)=>x > reserved && x < 127))) {
                        throw new ModuleError(`Sublevel name must use bytes > ${reserved} < ${127}`, {
                            code: 'LEVEL_INVALID_PREFIX'
                        });
                    }
                    super(mergeManifests(db, manifest), forward);
                    const localPrefix = names.map((name)=>separator + name + separator).join('');
                    const globalPrefix = (db.prefix || '') + localPrefix;
                    const globalUpperBound = globalPrefix.slice(0, -1) + String.fromCharCode(reserved);
                    this[kRoot] = root;
                    this[kParent] = db;
                    this[kLocalPath] = names;
                    this[kGlobalPath] = db.prefix ? db.path().concat(names) : names;
                    this[kGlobalPrefix] = new MultiFormat(globalPrefix);
                    this[kGlobalUpperBound] = new MultiFormat(globalUpperBound);
                    this[kLocalPrefix] = new MultiFormat(localPrefix);
                    this[kUnfix] = new Unfixer();
                }
                prefixKey(key, keyFormat, local) {
                    const prefix = local ? this[kLocalPrefix] : this[kGlobalPrefix];
                    if (keyFormat === 'utf8') {
                        return prefix.utf8 + key;
                    } else if (key.byteLength === 0) {
                        return prefix[keyFormat];
                    } else if (keyFormat === 'view') {
                        const view = prefix.view;
                        const result = new Uint8Array(view.byteLength + key.byteLength);
                        result.set(view, 0);
                        result.set(key, view.byteLength);
                        return result;
                    } else {
                        const buffer = prefix.buffer;
                        return Buffer.concat([
                            buffer,
                            key
                        ], buffer.byteLength + key.byteLength);
                    }
                }
                [kPrefixRange](range, keyFormat) {
                    if (range.gte !== undefined) {
                        range.gte = this.prefixKey(range.gte, keyFormat, false);
                    } else if (range.gt !== undefined) {
                        range.gt = this.prefixKey(range.gt, keyFormat, false);
                    } else {
                        range.gte = this[kGlobalPrefix][keyFormat];
                    }
                    if (range.lte !== undefined) {
                        range.lte = this.prefixKey(range.lte, keyFormat, false);
                    } else if (range.lt !== undefined) {
                        range.lt = this.prefixKey(range.lt, keyFormat, false);
                    } else {
                        range.lte = this[kGlobalUpperBound][keyFormat];
                    }
                }
                get prefix() {
                    return this[kGlobalPrefix].utf8;
                }
                get db() {
                    return this[kRoot];
                }
                get parent() {
                    return this[kParent];
                }
                path(local = false) {
                    return local ? this[kLocalPath] : this[kGlobalPath];
                }
                async _open(options) {
                    return this[kParent].open({
                        passive: true
                    });
                }
                async _put(key, value, options) {
                    return this[kParent].put(key, value, options);
                }
                async _get(key, options) {
                    return this[kParent].get(key, options);
                }
                async _getMany(keys, options) {
                    return this[kParent].getMany(keys, options);
                }
                async _del(key, options) {
                    return this[kParent].del(key, options);
                }
                async _batch(operations, options) {
                    return this[kParent].batch(operations, options);
                }
                async _clear(options) {
                    this[kPrefixRange](options, options.keyEncoding);
                    return this[kRoot].clear(options);
                }
                _iterator(options) {
                    this[kPrefixRange](options, options.keyEncoding);
                    const iterator = this[kRoot].iterator(options);
                    const unfix = this[kUnfix].get(this[kGlobalPrefix].utf8.length, options.keyEncoding);
                    return new AbstractSublevelIterator(this, options, iterator, unfix);
                }
                _keys(options) {
                    this[kPrefixRange](options, options.keyEncoding);
                    const iterator = this[kRoot].keys(options);
                    const unfix = this[kUnfix].get(this[kGlobalPrefix].utf8.length, options.keyEncoding);
                    return new AbstractSublevelKeyIterator(this, options, iterator, unfix);
                }
                _values(options) {
                    this[kPrefixRange](options, options.keyEncoding);
                    const iterator = this[kRoot].values(options);
                    return new AbstractSublevelValueIterator(this, options, iterator);
                }
            }
            return {
                AbstractSublevel
            };
        };
        const mergeManifests = function(parent, manifest) {
            return {
                ...parent.supports,
                createIfMissing: false,
                errorIfExists: false,
                events: {},
                additionalMethods: {},
                ...manifest,
                encodings: {
                    utf8: supportsEncoding(parent, 'utf8'),
                    buffer: supportsEncoding(parent, 'buffer'),
                    view: supportsEncoding(parent, 'view')
                }
            };
        };
        const supportsEncoding = function(parent, encoding) {
            return parent.supports.encodings[encoding] ? parent.keyEncoding(encoding).name === encoding : false;
        };
        class MultiFormat {
            constructor(key){
                this.utf8 = key;
                this.view = textEncoder.encode(key);
                this.buffer = Buffer ? Buffer.from(this.view.buffer, 0, this.view.byteLength) : {};
            }
        }
        class Unfixer {
            constructor(){
                this.cache = new Map();
            }
            get(prefixLength, keyFormat) {
                let unfix = this.cache.get(keyFormat);
                if (unfix === undefined) {
                    if (keyFormat === 'view') {
                        unfix = function(prefixLength, key) {
                            return key.subarray(prefixLength);
                        }.bind(null, prefixLength);
                    } else {
                        unfix = function(prefixLength, key) {
                            return key.slice(prefixLength);
                        }.bind(null, prefixLength);
                    }
                    this.cache.set(keyFormat, unfix);
                }
                return unfix;
            }
        }
        const trim = function(str, char) {
            let start = 0;
            let end = str.length;
            while(start < end && str[start] === char)start++;
            while(end > start && str[end - 1] === char)end--;
            return str.slice(start, end);
        };
        return abstractSublevel;
    }
    var hasRequiredAbstractLevel$1;
    function requireAbstractLevel$1() {
        if (hasRequiredAbstractLevel$1) return abstractLevel;
        hasRequiredAbstractLevel$1 = 1;
        const { supports } = requireLevelSupports();
        const { Transcoder } = requireLevelTranscoder();
        const { EventEmitter } = requireEvents();
        const ModuleError = requireModuleError();
        const combineErrors = requireMaybeCombineErrors();
        const { AbstractIterator } = requireAbstractIterator();
        const { DefaultKeyIterator, DefaultValueIterator } = requireDefaultKvIterator();
        const { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = requireDeferredIterator();
        const { DefaultChainedBatch } = requireDefaultChainedBatch();
        const { DatabaseHooks } = requireHooks();
        const { PrewriteBatch } = requirePrewriteBatch();
        const { EventMonitor } = requireEventMonitor();
        const { getOptions, noop, emptyOptions, resolvedPromise } = requireCommon();
        const { prefixDescendantKey, isDescendant } = requirePrefixes();
        const { DeferredQueue } = requireDeferredQueue();
        const rangeOptions = requireRangeOptions();
        const kResources = Symbol('resources');
        const kCloseResources = Symbol('closeResources');
        const kQueue = Symbol('queue');
        const kDeferOpen = Symbol('deferOpen');
        const kOptions = Symbol('options');
        const kStatus = Symbol('status');
        const kStatusChange = Symbol('statusChange');
        const kStatusLocked = Symbol('statusLocked');
        const kDefaultOptions = Symbol('defaultOptions');
        const kTranscoder = Symbol('transcoder');
        const kKeyEncoding = Symbol('keyEncoding');
        const kValueEncoding = Symbol('valueEncoding');
        const kEventMonitor = Symbol('eventMonitor');
        const kArrayBatch = Symbol('arrayBatch');
        class AbstractLevel extends EventEmitter {
            constructor(manifest, options){
                super();
                if (typeof manifest !== 'object' || manifest === null) {
                    throw new TypeError("The first argument 'manifest' must be an object");
                }
                options = getOptions(options);
                const { keyEncoding, valueEncoding, passive, ...forward } = options;
                this[kResources] = new Set();
                this[kQueue] = new DeferredQueue();
                this[kDeferOpen] = true;
                this[kOptions] = forward;
                this[kStatus] = 'opening';
                this[kStatusChange] = null;
                this[kStatusLocked] = false;
                this.hooks = new DatabaseHooks();
                this.supports = supports(manifest, {
                    deferredOpen: true,
                    snapshots: manifest.snapshots !== false,
                    permanence: manifest.permanence !== false,
                    encodings: manifest.encodings || {},
                    events: Object.assign({}, manifest.events, {
                        opening: true,
                        open: true,
                        closing: true,
                        closed: true,
                        write: true,
                        put: true,
                        del: true,
                        batch: true,
                        clear: true
                    })
                });
                this[kEventMonitor] = new EventMonitor(this, [
                    {
                        name: 'write'
                    },
                    {
                        name: 'put',
                        deprecated: true,
                        alt: 'write'
                    },
                    {
                        name: 'del',
                        deprecated: true,
                        alt: 'write'
                    },
                    {
                        name: 'batch',
                        deprecated: true,
                        alt: 'write'
                    }
                ]);
                this[kTranscoder] = new Transcoder(formats(this));
                this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || 'utf8');
                this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || 'utf8');
                for (const encoding of this[kTranscoder].encodings()){
                    if (!this.supports.encodings[encoding.commonName]) {
                        this.supports.encodings[encoding.commonName] = true;
                    }
                }
                this[kDefaultOptions] = {
                    empty: emptyOptions,
                    entry: Object.freeze({
                        keyEncoding: this[kKeyEncoding].commonName,
                        valueEncoding: this[kValueEncoding].commonName
                    }),
                    entryFormat: Object.freeze({
                        keyEncoding: this[kKeyEncoding].format,
                        valueEncoding: this[kValueEncoding].format
                    }),
                    key: Object.freeze({
                        keyEncoding: this[kKeyEncoding].commonName
                    }),
                    keyFormat: Object.freeze({
                        keyEncoding: this[kKeyEncoding].format
                    })
                };
                queueMicrotask(()=>{
                    if (this[kDeferOpen]) {
                        this.open({
                            passive: false
                        }).catch(noop);
                    }
                });
            }
            get status() {
                return this[kStatus];
            }
            get parent() {
                return null;
            }
            keyEncoding(encoding) {
                return this[kTranscoder].encoding(encoding != null ? encoding : this[kKeyEncoding]);
            }
            valueEncoding(encoding) {
                return this[kTranscoder].encoding(encoding != null ? encoding : this[kValueEncoding]);
            }
            async open(options) {
                options = {
                    ...this[kOptions],
                    ...getOptions(options)
                };
                options.createIfMissing = options.createIfMissing !== false;
                options.errorIfExists = !!options.errorIfExists;
                const postopen = this.hooks.postopen.noop ? null : this.hooks.postopen.run;
                const passive = options.passive;
                if (passive && this[kDeferOpen]) {
                    await undefined;
                }
                assertUnlocked(this);
                while(this[kStatusChange] !== null)await this[kStatusChange].catch(noop);
                assertUnlocked(this);
                if (passive) {
                    if (this[kStatus] !== 'open') throw new NotOpenError();
                } else if (this[kStatus] === 'closed' || this[kDeferOpen]) {
                    this[kDeferOpen] = false;
                    this[kStatusChange] = resolvedPromise;
                    this[kStatusChange] = (async ()=>{
                        this[kStatus] = 'opening';
                        try {
                            this.emit('opening');
                            await this._open(options);
                        } catch (err) {
                            this[kStatus] = 'closed';
                            this[kQueue].drain();
                            try {
                                await this[kCloseResources]();
                            } catch (resourceErr) {
                                err = combineErrors([
                                    err,
                                    resourceErr
                                ]);
                            }
                            throw new NotOpenError(err);
                        }
                        this[kStatus] = 'open';
                        if (postopen !== null) {
                            let hookErr;
                            try {
                                this[kStatusLocked] = true;
                                await postopen(options);
                            } catch (err) {
                                hookErr = convertRejection(err);
                            } finally{
                                this[kStatusLocked] = false;
                            }
                            if (hookErr) {
                                this[kStatus] = 'closing';
                                this[kQueue].drain();
                                try {
                                    await this[kCloseResources]();
                                    await this._close();
                                } catch (closeErr) {
                                    this[kStatusLocked] = true;
                                    hookErr = combineErrors([
                                        hookErr,
                                        closeErr
                                    ]);
                                }
                                this[kStatus] = 'closed';
                                throw new ModuleError('The postopen hook failed on open()', {
                                    code: 'LEVEL_HOOK_ERROR',
                                    cause: hookErr
                                });
                            }
                        }
                        this[kQueue].drain();
                        this.emit('open');
                    })();
                    try {
                        await this[kStatusChange];
                    } finally{
                        this[kStatusChange] = null;
                    }
                } else if (this[kStatus] !== 'open') {
                    throw new NotOpenError();
                }
            }
            async _open(options) {}
            async close() {
                assertUnlocked(this);
                while(this[kStatusChange] !== null)await this[kStatusChange].catch(noop);
                assertUnlocked(this);
                if (this[kStatus] === 'open' || this[kDeferOpen]) {
                    const fromInitial = this[kDeferOpen];
                    this[kDeferOpen] = false;
                    this[kStatusChange] = resolvedPromise;
                    this[kStatusChange] = (async ()=>{
                        this[kStatus] = 'closing';
                        this[kQueue].drain();
                        try {
                            this.emit('closing');
                            await this[kCloseResources]();
                            if (!fromInitial) await this._close();
                        } catch (err) {
                            this[kStatus] = 'open';
                            this[kQueue].drain();
                            throw new NotClosedError(err);
                        }
                        this[kStatus] = 'closed';
                        this[kQueue].drain();
                        this.emit('closed');
                    })();
                    try {
                        await this[kStatusChange];
                    } finally{
                        this[kStatusChange] = null;
                    }
                } else if (this[kStatus] !== 'closed') {
                    throw new NotClosedError();
                }
            }
            async [kCloseResources]() {
                if (this[kResources].size === 0) {
                    return;
                }
                const resources = Array.from(this[kResources]);
                const promises = resources.map(closeResource);
                return Promise.allSettled(promises).then(async (results)=>{
                    const errors = [];
                    for(let i = 0; i < results.length; i++){
                        if (results[i].status === 'fulfilled') {
                            this[kResources].delete(resources[i]);
                        } else {
                            errors.push(convertRejection(results[i].reason));
                        }
                    }
                    if (errors.length > 0) {
                        throw combineErrors(errors);
                    }
                });
            }
            async _close() {}
            async get(key, options) {
                options = getOptions(options, this[kDefaultOptions].entry);
                if (this[kStatus] === 'opening') {
                    return this.deferAsync(()=>this.get(key, options));
                }
                assertOpen(this);
                const err = this._checkKey(key);
                if (err) throw err;
                const keyEncoding = this.keyEncoding(options.keyEncoding);
                const valueEncoding = this.valueEncoding(options.valueEncoding);
                const keyFormat = keyEncoding.format;
                const valueFormat = valueEncoding.format;
                if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
                    options = Object.assign({}, options, {
                        keyEncoding: keyFormat,
                        valueEncoding: valueFormat
                    });
                }
                const encodedKey = keyEncoding.encode(key);
                const value = await this._get(this.prefixKey(encodedKey, keyFormat, true), options);
                try {
                    return value === undefined ? value : valueEncoding.decode(value);
                } catch (err) {
                    throw new ModuleError('Could not decode value', {
                        code: 'LEVEL_DECODE_ERROR',
                        cause: err
                    });
                }
            }
            async _get(key, options) {
                return undefined;
            }
            async getMany(keys, options) {
                options = getOptions(options, this[kDefaultOptions].entry);
                if (this[kStatus] === 'opening') {
                    return this.deferAsync(()=>this.getMany(keys, options));
                }
                assertOpen(this);
                if (!Array.isArray(keys)) {
                    throw new TypeError("The first argument 'keys' must be an array");
                }
                if (keys.length === 0) {
                    return [];
                }
                const keyEncoding = this.keyEncoding(options.keyEncoding);
                const valueEncoding = this.valueEncoding(options.valueEncoding);
                const keyFormat = keyEncoding.format;
                const valueFormat = valueEncoding.format;
                if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
                    options = Object.assign({}, options, {
                        keyEncoding: keyFormat,
                        valueEncoding: valueFormat
                    });
                }
                const mappedKeys = new Array(keys.length);
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    const err = this._checkKey(key);
                    if (err) throw err;
                    mappedKeys[i] = this.prefixKey(keyEncoding.encode(key), keyFormat, true);
                }
                const values = await this._getMany(mappedKeys, options);
                try {
                    for(let i = 0; i < values.length; i++){
                        if (values[i] !== undefined) {
                            values[i] = valueEncoding.decode(values[i]);
                        }
                    }
                } catch (err) {
                    throw new ModuleError(`Could not decode one or more of ${values.length} value(s)`, {
                        code: 'LEVEL_DECODE_ERROR',
                        cause: err
                    });
                }
                return values;
            }
            async _getMany(keys, options) {
                return new Array(keys.length).fill(undefined);
            }
            async put(key, value, options) {
                if (!this.hooks.prewrite.noop) {
                    return this.batch([
                        {
                            type: 'put',
                            key,
                            value
                        }
                    ], options);
                }
                options = getOptions(options, this[kDefaultOptions].entry);
                if (this[kStatus] === 'opening') {
                    return this.deferAsync(()=>this.put(key, value, options));
                }
                assertOpen(this);
                const err = this._checkKey(key) || this._checkValue(value);
                if (err) throw err;
                const keyEncoding = this.keyEncoding(options.keyEncoding);
                const valueEncoding = this.valueEncoding(options.valueEncoding);
                const keyFormat = keyEncoding.format;
                const valueFormat = valueEncoding.format;
                const enableWriteEvent = this[kEventMonitor].write;
                const original = options;
                if (options === this[kDefaultOptions].entry) {
                    options = this[kDefaultOptions].entryFormat;
                } else if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
                    options = Object.assign({}, options, {
                        keyEncoding: keyFormat,
                        valueEncoding: valueFormat
                    });
                }
                const encodedKey = keyEncoding.encode(key);
                const prefixedKey = this.prefixKey(encodedKey, keyFormat, true);
                const encodedValue = valueEncoding.encode(value);
                await this._put(prefixedKey, encodedValue, options);
                if (enableWriteEvent) {
                    const op = Object.assign({}, original, {
                        type: 'put',
                        key,
                        value,
                        keyEncoding,
                        valueEncoding,
                        encodedKey,
                        encodedValue
                    });
                    this.emit('write', [
                        op
                    ]);
                } else {
                    this.emit('put', key, value);
                }
            }
            async _put(key, value, options) {}
            async del(key, options) {
                if (!this.hooks.prewrite.noop) {
                    return this.batch([
                        {
                            type: 'del',
                            key
                        }
                    ], options);
                }
                options = getOptions(options, this[kDefaultOptions].key);
                if (this[kStatus] === 'opening') {
                    return this.deferAsync(()=>this.del(key, options));
                }
                assertOpen(this);
                const err = this._checkKey(key);
                if (err) throw err;
                const keyEncoding = this.keyEncoding(options.keyEncoding);
                const keyFormat = keyEncoding.format;
                const enableWriteEvent = this[kEventMonitor].write;
                const original = options;
                if (options === this[kDefaultOptions].key) {
                    options = this[kDefaultOptions].keyFormat;
                } else if (options.keyEncoding !== keyFormat) {
                    options = Object.assign({}, options, {
                        keyEncoding: keyFormat
                    });
                }
                const encodedKey = keyEncoding.encode(key);
                const prefixedKey = this.prefixKey(encodedKey, keyFormat, true);
                await this._del(prefixedKey, options);
                if (enableWriteEvent) {
                    const op = Object.assign({}, original, {
                        type: 'del',
                        key,
                        keyEncoding,
                        encodedKey
                    });
                    this.emit('write', [
                        op
                    ]);
                } else {
                    this.emit('del', key);
                }
            }
            async _del(key, options) {}
            batch(operations, options) {
                if (!arguments.length) {
                    assertOpen(this);
                    return this._chainedBatch();
                }
                options = getOptions(options, this[kDefaultOptions].empty);
                return this[kArrayBatch](operations, options);
            }
            async [kArrayBatch](operations, options) {
                if (this[kStatus] === 'opening') {
                    return this.deferAsync(()=>this[kArrayBatch](operations, options));
                }
                assertOpen(this);
                if (!Array.isArray(operations)) {
                    throw new TypeError("The first argument 'operations' must be an array");
                }
                if (operations.length === 0) {
                    return;
                }
                const length = operations.length;
                const enablePrewriteHook = !this.hooks.prewrite.noop;
                const enableWriteEvent = this[kEventMonitor].write;
                const publicOperations = enableWriteEvent ? new Array(length) : null;
                const privateOperations = new Array(length);
                const prewriteBatch = enablePrewriteHook ? new PrewriteBatch(this, privateOperations, publicOperations) : null;
                for(let i = 0; i < length; i++){
                    const op = Object.assign({}, options, operations[i]);
                    const isPut = op.type === 'put';
                    const delegated = op.sublevel != null;
                    const db = delegated ? op.sublevel : this;
                    const keyError = db._checkKey(op.key);
                    if (keyError != null) throw keyError;
                    op.keyEncoding = db.keyEncoding(op.keyEncoding);
                    if (isPut) {
                        const valueError = db._checkValue(op.value);
                        if (valueError != null) throw valueError;
                        op.valueEncoding = db.valueEncoding(op.valueEncoding);
                    } else if (op.type !== 'del') {
                        throw new TypeError("A batch operation must have a type property that is 'put' or 'del'");
                    }
                    if (enablePrewriteHook) {
                        try {
                            this.hooks.prewrite.run(op, prewriteBatch);
                            op.keyEncoding = db.keyEncoding(op.keyEncoding);
                            if (isPut) op.valueEncoding = db.valueEncoding(op.valueEncoding);
                        } catch (err) {
                            throw new ModuleError('The prewrite hook failed on batch()', {
                                code: 'LEVEL_HOOK_ERROR',
                                cause: err
                            });
                        }
                    }
                    const keyEncoding = op.keyEncoding;
                    const preencodedKey = keyEncoding.encode(op.key);
                    const keyFormat = keyEncoding.format;
                    const siblings = delegated && !isDescendant(op.sublevel, this) && op.sublevel !== this;
                    const encodedKey = delegated && !siblings ? prefixDescendantKey(preencodedKey, keyFormat, db, this) : preencodedKey;
                    if (delegated && !siblings) {
                        op.sublevel = null;
                    }
                    let publicOperation = null;
                    if (enableWriteEvent && !siblings) {
                        publicOperation = Object.assign({}, op);
                        publicOperation.encodedKey = encodedKey;
                        if (delegated) {
                            publicOperation.key = encodedKey;
                            publicOperation.keyEncoding = this.keyEncoding(keyFormat);
                        }
                        publicOperations[i] = publicOperation;
                    }
                    op.key = siblings ? encodedKey : this.prefixKey(encodedKey, keyFormat, true);
                    op.keyEncoding = keyFormat;
                    if (isPut) {
                        const valueEncoding = op.valueEncoding;
                        const encodedValue = valueEncoding.encode(op.value);
                        const valueFormat = valueEncoding.format;
                        op.value = encodedValue;
                        op.valueEncoding = valueFormat;
                        if (enableWriteEvent && !siblings) {
                            publicOperation.encodedValue = encodedValue;
                            if (delegated) {
                                publicOperation.value = encodedValue;
                                publicOperation.valueEncoding = this.valueEncoding(valueFormat);
                            }
                        }
                    }
                    privateOperations[i] = op;
                }
                await this._batch(privateOperations, options);
                if (enableWriteEvent) {
                    this.emit('write', publicOperations);
                } else if (!enablePrewriteHook) {
                    this.emit('batch', operations);
                }
            }
            async _batch(operations, options) {}
            sublevel(name, options) {
                const xopts = AbstractSublevel.defaults(options);
                const sublevel = this._sublevel(name, xopts);
                if (!this.hooks.newsub.noop) {
                    try {
                        this.hooks.newsub.run(sublevel, xopts);
                    } catch (err) {
                        throw new ModuleError('The newsub hook failed on sublevel()', {
                            code: 'LEVEL_HOOK_ERROR',
                            cause: err
                        });
                    }
                }
                return sublevel;
            }
            _sublevel(name, options) {
                return new AbstractSublevel(this, name, options);
            }
            prefixKey(key, keyFormat, local) {
                return key;
            }
            async clear(options) {
                options = getOptions(options, this[kDefaultOptions].empty);
                if (this[kStatus] === 'opening') {
                    return this.deferAsync(()=>this.clear(options));
                }
                assertOpen(this);
                const original = options;
                const keyEncoding = this.keyEncoding(options.keyEncoding);
                options = rangeOptions(options, keyEncoding);
                options.keyEncoding = keyEncoding.format;
                if (options.limit !== 0) {
                    await this._clear(options);
                    this.emit('clear', original);
                }
            }
            async _clear(options) {}
            iterator(options) {
                const keyEncoding = this.keyEncoding(options && options.keyEncoding);
                const valueEncoding = this.valueEncoding(options && options.valueEncoding);
                options = rangeOptions(options, keyEncoding);
                options.keys = options.keys !== false;
                options.values = options.values !== false;
                options[AbstractIterator.keyEncoding] = keyEncoding;
                options[AbstractIterator.valueEncoding] = valueEncoding;
                options.keyEncoding = keyEncoding.format;
                options.valueEncoding = valueEncoding.format;
                if (this[kStatus] === 'opening') {
                    return new DeferredIterator(this, options);
                }
                assertOpen(this);
                return this._iterator(options);
            }
            _iterator(options) {
                return new AbstractIterator(this, options);
            }
            keys(options) {
                const keyEncoding = this.keyEncoding(options && options.keyEncoding);
                const valueEncoding = this.valueEncoding(options && options.valueEncoding);
                options = rangeOptions(options, keyEncoding);
                options[AbstractIterator.keyEncoding] = keyEncoding;
                options[AbstractIterator.valueEncoding] = valueEncoding;
                options.keyEncoding = keyEncoding.format;
                options.valueEncoding = valueEncoding.format;
                if (this[kStatus] === 'opening') {
                    return new DeferredKeyIterator(this, options);
                }
                assertOpen(this);
                return this._keys(options);
            }
            _keys(options) {
                return new DefaultKeyIterator(this, options);
            }
            values(options) {
                const keyEncoding = this.keyEncoding(options && options.keyEncoding);
                const valueEncoding = this.valueEncoding(options && options.valueEncoding);
                options = rangeOptions(options, keyEncoding);
                options[AbstractIterator.keyEncoding] = keyEncoding;
                options[AbstractIterator.valueEncoding] = valueEncoding;
                options.keyEncoding = keyEncoding.format;
                options.valueEncoding = valueEncoding.format;
                if (this[kStatus] === 'opening') {
                    return new DeferredValueIterator(this, options);
                }
                assertOpen(this);
                return this._values(options);
            }
            _values(options) {
                return new DefaultValueIterator(this, options);
            }
            defer(fn, options) {
                if (typeof fn !== 'function') {
                    throw new TypeError('The first argument must be a function');
                }
                this[kQueue].add(function(abortError) {
                    if (!abortError) fn();
                }, options);
            }
            deferAsync(fn, options) {
                if (typeof fn !== 'function') {
                    throw new TypeError('The first argument must be a function');
                }
                return new Promise((resolve, reject)=>{
                    this[kQueue].add(function(abortError) {
                        if (abortError) reject(abortError);
                        else fn().then(resolve, reject);
                    }, options);
                });
            }
            attachResource(resource) {
                if (typeof resource !== 'object' || resource === null || typeof resource.close !== 'function') {
                    throw new TypeError('The first argument must be a resource object');
                }
                this[kResources].add(resource);
            }
            detachResource(resource) {
                this[kResources].delete(resource);
            }
            _chainedBatch() {
                return new DefaultChainedBatch(this);
            }
            _checkKey(key) {
                if (key === null || key === undefined) {
                    return new ModuleError('Key cannot be null or undefined', {
                        code: 'LEVEL_INVALID_KEY'
                    });
                }
            }
            _checkValue(value) {
                if (value === null || value === undefined) {
                    return new ModuleError('Value cannot be null or undefined', {
                        code: 'LEVEL_INVALID_VALUE'
                    });
                }
            }
        }
        const { AbstractSublevel } = requireAbstractSublevel()({
            AbstractLevel
        });
        abstractLevel.AbstractLevel = AbstractLevel;
        abstractLevel.AbstractSublevel = AbstractSublevel;
        const assertOpen = function(db) {
            if (db[kStatus] !== 'open') {
                throw new ModuleError('Database is not open', {
                    code: 'LEVEL_DATABASE_NOT_OPEN'
                });
            }
        };
        const assertUnlocked = function(db) {
            if (db[kStatusLocked]) {
                throw new ModuleError('Database status is locked', {
                    code: 'LEVEL_STATUS_LOCKED'
                });
            }
        };
        const formats = function(db) {
            return Object.keys(db.supports.encodings).filter((k)=>!!db.supports.encodings[k]);
        };
        const closeResource = function(resource) {
            return resource.close();
        };
        const convertRejection = function(reason) {
            if (reason instanceof Error) {
                return reason;
            }
            if (Object.prototype.toString.call(reason) === '[object Error]') {
                return reason;
            }
            const hint = reason === null ? 'null' : typeof reason;
            const msg = `Promise rejection reason must be an Error, received ${hint}`;
            return new TypeError(msg);
        };
        class NotOpenError extends ModuleError {
            constructor(cause){
                super('Database failed to open', {
                    code: 'LEVEL_DATABASE_NOT_OPEN',
                    cause
                });
            }
        }
        class NotClosedError extends ModuleError {
            constructor(cause){
                super('Database failed to close', {
                    code: 'LEVEL_DATABASE_NOT_CLOSED',
                    cause
                });
            }
        }
        return abstractLevel;
    }
    var hasRequiredAbstractLevel;
    function requireAbstractLevel() {
        if (hasRequiredAbstractLevel) return abstractLevel$1;
        hasRequiredAbstractLevel = 1;
        abstractLevel$1.AbstractLevel = requireAbstractLevel$1().AbstractLevel;
        abstractLevel$1.AbstractSublevel = requireAbstractLevel$1().AbstractSublevel;
        abstractLevel$1.AbstractIterator = requireAbstractIterator().AbstractIterator;
        abstractLevel$1.AbstractKeyIterator = requireAbstractIterator().AbstractKeyIterator;
        abstractLevel$1.AbstractValueIterator = requireAbstractIterator().AbstractValueIterator;
        abstractLevel$1.AbstractChainedBatch = requireAbstractChainedBatch().AbstractChainedBatch;
        return abstractLevel$1;
    }
    var iterator = {};
    var keyRange;
    var hasRequiredKeyRange;
    function requireKeyRange() {
        if (hasRequiredKeyRange) return keyRange;
        hasRequiredKeyRange = 1;
        keyRange = function createKeyRange(options) {
            const lower = options.gte !== undefined ? options.gte : options.gt !== undefined ? options.gt : undefined;
            const upper = options.lte !== undefined ? options.lte : options.lt !== undefined ? options.lt : undefined;
            const lowerExclusive = options.gte === undefined;
            const upperExclusive = options.lte === undefined;
            if (lower !== undefined && upper !== undefined) {
                return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
            } else if (lower !== undefined) {
                return IDBKeyRange.lowerBound(lower, lowerExclusive);
            } else if (upper !== undefined) {
                return IDBKeyRange.upperBound(upper, upperExclusive);
            } else {
                return null;
            }
        };
        return keyRange;
    }
    var deserialize;
    var hasRequiredDeserialize;
    function requireDeserialize() {
        if (hasRequiredDeserialize) return deserialize;
        hasRequiredDeserialize = 1;
        const textEncoder = new TextEncoder();
        deserialize = function(data) {
            if (data === undefined) {
                return data;
            } else if (data instanceof Uint8Array) {
                return data;
            } else if (data instanceof ArrayBuffer) {
                return new Uint8Array(data);
            } else {
                return textEncoder.encode(data);
            }
        };
        return deserialize;
    }
    var hasRequiredIterator;
    function requireIterator() {
        if (hasRequiredIterator) return iterator;
        hasRequiredIterator = 1;
        const { AbstractIterator } = requireAbstractLevel();
        const createKeyRange = requireKeyRange();
        const deserialize = requireDeserialize();
        const kCache = Symbol('cache');
        const kFinished = Symbol('finished');
        const kOptions = Symbol('options');
        const kCurrentOptions = Symbol('currentOptions');
        const kPosition = Symbol('position');
        const kLocation = Symbol('location');
        const kFirst = Symbol('first');
        const emptyOptions = {};
        class Iterator extends AbstractIterator {
            constructor(db, location, options){
                super(db, options);
                this[kCache] = [];
                this[kFinished] = this.limit === 0;
                this[kOptions] = options;
                this[kCurrentOptions] = {
                    ...options
                };
                this[kPosition] = undefined;
                this[kLocation] = location;
                this[kFirst] = true;
            }
            async _nextv(size, options) {
                this[kFirst] = false;
                if (this[kFinished]) {
                    return [];
                }
                if (this[kCache].length > 0) {
                    size = Math.min(size, this[kCache].length);
                    return this[kCache].splice(0, size);
                }
                if (this[kPosition] !== undefined) {
                    if (this[kOptions].reverse) {
                        this[kCurrentOptions].lt = this[kPosition];
                        this[kCurrentOptions].lte = undefined;
                    } else {
                        this[kCurrentOptions].gt = this[kPosition];
                        this[kCurrentOptions].gte = undefined;
                    }
                }
                let keyRange;
                try {
                    keyRange = createKeyRange(this[kCurrentOptions]);
                } catch (_) {
                    this[kFinished] = true;
                    return [];
                }
                const transaction = this.db.db.transaction([
                    this[kLocation]
                ], 'readonly');
                const store = transaction.objectStore(this[kLocation]);
                const entries = [];
                const promise = new Promise(function(resolve, reject) {
                    transaction.onabort = ()=>{
                        reject(transaction.error || new Error('aborted by user'));
                    };
                    transaction.oncomplete = ()=>{
                        resolve(entries);
                    };
                });
                if (!this[kOptions].reverse) {
                    let keys;
                    let values;
                    const complete = ()=>{
                        if (keys === undefined || values === undefined) return;
                        const length = Math.max(keys.length, values.length);
                        if (length === 0 || size === Infinity) {
                            this[kFinished] = true;
                        } else {
                            this[kPosition] = keys[length - 1];
                        }
                        entries.length = length;
                        for(let i = 0; i < length; i++){
                            const key = keys[i];
                            const value = values[i];
                            entries[i] = [
                                this[kOptions].keys ? deserialize(key) : undefined,
                                this[kOptions].values ? deserialize(value) : undefined
                            ];
                        }
                        maybeCommit(transaction);
                    };
                    if (this[kOptions].keys || size < Infinity) {
                        store.getAllKeys(keyRange, size < Infinity ? size : undefined).onsuccess = (ev)=>{
                            keys = ev.target.result;
                            complete();
                        };
                    } else {
                        keys = [];
                        complete();
                    }
                    if (this[kOptions].values) {
                        store.getAll(keyRange, size < Infinity ? size : undefined).onsuccess = (ev)=>{
                            values = ev.target.result;
                            complete();
                        };
                    } else {
                        values = [];
                        complete();
                    }
                } else {
                    const method = !this[kOptions].values && store.openKeyCursor ? 'openKeyCursor' : 'openCursor';
                    store[method](keyRange, 'prev').onsuccess = (ev)=>{
                        const cursor = ev.target.result;
                        if (cursor) {
                            const { key, value } = cursor;
                            this[kPosition] = key;
                            entries.push([
                                this[kOptions].keys && key !== undefined ? deserialize(key) : undefined,
                                this[kOptions].values && value !== undefined ? deserialize(value) : undefined
                            ]);
                            if (entries.length < size) {
                                cursor.continue();
                            } else {
                                maybeCommit(transaction);
                            }
                        } else {
                            this[kFinished] = true;
                        }
                    };
                }
                return promise;
            }
            async _next() {
                if (this[kCache].length > 0) {
                    return this[kCache].shift();
                }
                if (!this[kFinished]) {
                    let size = Math.min(100, this.limit - this.count);
                    if (this[kFirst]) {
                        this[kFirst] = false;
                        size = 1;
                    }
                    this[kCache] = await this._nextv(size, emptyOptions);
                    return this[kCache].shift();
                }
            }
            async _all(options) {
                this[kFirst] = false;
                const cache = this[kCache].splice(0, this[kCache].length);
                const size = this.limit - this.count - cache.length;
                if (size <= 0) {
                    return cache;
                }
                let entries = await this._nextv(size, emptyOptions);
                if (cache.length > 0) entries = cache.concat(entries);
                return entries;
            }
            _seek(target, options) {
                this[kFirst] = true;
                this[kCache] = [];
                this[kFinished] = false;
                this[kPosition] = undefined;
                this[kCurrentOptions] = {
                    ...this[kOptions]
                };
                let keyRange;
                try {
                    keyRange = createKeyRange(this[kOptions]);
                } catch (_) {
                    this[kFinished] = true;
                    return;
                }
                if (keyRange !== null && !keyRange.includes(target)) {
                    this[kFinished] = true;
                } else if (this[kOptions].reverse) {
                    this[kCurrentOptions].lte = target;
                } else {
                    this[kCurrentOptions].gte = target;
                }
            }
        }
        iterator.Iterator = Iterator;
        function maybeCommit(transaction) {
            if (typeof transaction.commit === 'function') {
                transaction.commit();
            }
        }
        return iterator;
    }
    var clear;
    var hasRequiredClear;
    function requireClear() {
        if (hasRequiredClear) return clear;
        hasRequiredClear = 1;
        clear = async function clear(db, location, keyRange, options) {
            if (options.limit === 0) return;
            const transaction = db.db.transaction([
                location
            ], 'readwrite');
            const store = transaction.objectStore(location);
            let count = 0;
            const promise = new Promise(function(resolve, reject) {
                transaction.oncomplete = resolve;
                transaction.onabort = function() {
                    reject(transaction.error || new Error('aborted by user'));
                };
            });
            const method = store.openKeyCursor ? 'openKeyCursor' : 'openCursor';
            const direction = options.reverse ? 'prev' : 'next';
            store[method](keyRange, direction).onsuccess = function(ev) {
                const cursor = ev.target.result;
                if (cursor) {
                    store.delete(cursor.key).onsuccess = function() {
                        if (options.limit <= 0 || ++count < options.limit) {
                            cursor.continue();
                        }
                    };
                }
            };
            return promise;
        };
        return clear;
    }
    var hasRequiredBrowserLevel;
    function requireBrowserLevel() {
        if (hasRequiredBrowserLevel) return browserLevel;
        hasRequiredBrowserLevel = 1;
        const { AbstractLevel } = requireAbstractLevel();
        const { Iterator } = requireIterator();
        const deserialize = requireDeserialize();
        const clear = requireClear();
        const createKeyRange = requireKeyRange();
        const DEFAULT_PREFIX = 'level-js-';
        const kIDB = Symbol('idb');
        const kNamePrefix = Symbol('namePrefix');
        const kLocation = Symbol('location');
        const kVersion = Symbol('version');
        const kStore = Symbol('store');
        const kOnComplete = Symbol('onComplete');
        class BrowserLevel extends AbstractLevel {
            constructor(location, options){
                const { prefix, version, ...forward } = options || {};
                super({
                    encodings: {
                        view: true
                    },
                    snapshots: false,
                    createIfMissing: false,
                    errorIfExists: false,
                    seek: true
                }, forward);
                if (typeof location !== 'string' || location === '') {
                    throw new TypeError("The first argument 'location' must be a non-empty string");
                }
                this[kLocation] = location;
                this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
                this[kVersion] = parseInt(version || 1, 10);
                this[kIDB] = null;
            }
            get location() {
                return this[kLocation];
            }
            get namePrefix() {
                return this[kNamePrefix];
            }
            get version() {
                return this[kVersion];
            }
            get db() {
                return this[kIDB];
            }
            get type() {
                return 'browser-level';
            }
            async _open(options) {
                const request = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
                request.onupgradeneeded = (ev)=>{
                    const db = ev.target.result;
                    if (!db.objectStoreNames.contains(this[kLocation])) {
                        db.createObjectStore(this[kLocation]);
                    }
                };
                return new Promise((resolve, reject)=>{
                    request.onerror = function() {
                        reject(request.error || new Error('unknown error'));
                    };
                    request.onsuccess = ()=>{
                        this[kIDB] = request.result;
                        resolve();
                    };
                });
            }
            [kStore](mode) {
                const transaction = this[kIDB].transaction([
                    this[kLocation]
                ], mode);
                return transaction.objectStore(this[kLocation]);
            }
            [kOnComplete](request) {
                const transaction = request.transaction;
                return new Promise(function(resolve, reject) {
                    transaction.onabort = function() {
                        reject(transaction.error || new Error('aborted by user'));
                    };
                    transaction.oncomplete = function() {
                        resolve(request.result);
                    };
                });
            }
            async _get(key, options) {
                const store = this[kStore]('readonly');
                const request = store.get(key);
                const value = await this[kOnComplete](request);
                return deserialize(value);
            }
            async _getMany(keys, options) {
                const store = this[kStore]('readonly');
                const iterator = keys.values();
                const n = Math.min(16, keys.length);
                const bees = new Array(n);
                const values = new Array(keys.length);
                let keyIndex = 0;
                let abort = false;
                const bee = async function() {
                    try {
                        for (const key of iterator){
                            if (abort) break;
                            const valueIndex = keyIndex++;
                            const request = store.get(key);
                            await new Promise(function(resolve, reject) {
                                request.onsuccess = ()=>{
                                    values[valueIndex] = deserialize(request.result);
                                    resolve();
                                };
                                request.onerror = (ev)=>{
                                    ev.stopPropagation();
                                    reject(request.error);
                                };
                            });
                        }
                    } catch (err) {
                        abort = true;
                        throw err;
                    }
                };
                for(let i = 0; i < n; i++){
                    bees[i] = bee();
                }
                await Promise.allSettled(bees);
                return values;
            }
            async _del(key, options) {
                const store = this[kStore]('readwrite');
                const request = store.delete(key);
                return this[kOnComplete](request);
            }
            async _put(key, value, options) {
                const store = this[kStore]('readwrite');
                const request = store.put(value, key);
                return this[kOnComplete](request);
            }
            _iterator(options) {
                return new Iterator(this, this[kLocation], options);
            }
            async _batch(operations, options) {
                const store = this[kStore]('readwrite');
                const transaction = store.transaction;
                let index = 0;
                let error;
                const promise = new Promise(function(resolve, reject) {
                    transaction.onabort = function() {
                        reject(error || transaction.error || new Error('aborted by user'));
                    };
                    transaction.oncomplete = resolve;
                });
                function loop() {
                    const op = operations[index++];
                    const key = op.key;
                    let req;
                    try {
                        req = op.type === 'del' ? store.delete(key) : store.put(op.value, key);
                    } catch (err) {
                        error = err;
                        transaction.abort();
                        return;
                    }
                    if (index < operations.length) {
                        req.onsuccess = loop;
                    } else if (typeof transaction.commit === 'function') {
                        transaction.commit();
                    }
                }
                loop();
                return promise;
            }
            async _clear(options) {
                let keyRange;
                try {
                    keyRange = createKeyRange(options);
                } catch (e) {
                    return;
                }
                if (options.limit >= 0) {
                    return clear(this, this[kLocation], keyRange, options);
                }
                const store = this[kStore]('readwrite');
                const request = keyRange ? store.delete(keyRange) : store.clear();
                return this[kOnComplete](request);
            }
            async _close() {
                this[kIDB].close();
            }
        }
        BrowserLevel.destroy = async function(location, prefix) {
            if (prefix == null) {
                prefix = DEFAULT_PREFIX;
            }
            const request = indexedDB.deleteDatabase(prefix + location);
            return new Promise(function(resolve, reject) {
                request.onsuccess = resolve;
                request.onerror = reject;
            });
        };
        browserLevel.BrowserLevel = BrowserLevel;
        return browserLevel;
    }
    var hasRequiredBrowser;
    function requireBrowser() {
        if (hasRequiredBrowser) return browser;
        hasRequiredBrowser = 1;
        browser.Level = requireBrowserLevel().BrowserLevel;
        return browser;
    }
    var browserExports = requireBrowser();
    var lodash$1 = {
        exports: {}
    };
    var lodash = lodash$1.exports;
    var hasRequiredLodash;
    function requireLodash() {
        if (hasRequiredLodash) return lodash$1.exports;
        hasRequiredLodash = 1;
        (function(module, exports) {
            (function() {
                var undefined$1;
                var VERSION = '4.17.21';
                var LARGE_ARRAY_SIZE = 200;
                var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.', FUNC_ERROR_TEXT = 'Expected a function', INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';
                var HASH_UNDEFINED = '__lodash_hash_undefined__';
                var MAX_MEMOIZE_SIZE = 500;
                var PLACEHOLDER = '__lodash_placeholder__';
                var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
                var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
                var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
                var HOT_COUNT = 800, HOT_SPAN = 16;
                var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
                var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
                var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                var wrapFlags = [
                    [
                        'ary',
                        WRAP_ARY_FLAG
                    ],
                    [
                        'bind',
                        WRAP_BIND_FLAG
                    ],
                    [
                        'bindKey',
                        WRAP_BIND_KEY_FLAG
                    ],
                    [
                        'curry',
                        WRAP_CURRY_FLAG
                    ],
                    [
                        'curryRight',
                        WRAP_CURRY_RIGHT_FLAG
                    ],
                    [
                        'flip',
                        WRAP_FLIP_FLAG
                    ],
                    [
                        'partial',
                        WRAP_PARTIAL_FLAG
                    ],
                    [
                        'partialRight',
                        WRAP_PARTIAL_RIGHT_FLAG
                    ],
                    [
                        'rearg',
                        WRAP_REARG_FLAG
                    ]
                ];
                var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', domExcTag = '[object DOMException]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';
                var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
                var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
                var reTrimStart = /^\s+/;
                var reWhitespace = /\s/;
                var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
                var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
                var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
                var reEscapeChar = /\\(\\)?/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
                var reIsBinary = /^0b[01]+$/i;
                var reIsHostCtor = /^\[object .+?Constructor\]$/;
                var reIsOctal = /^0o[0-7]+$/i;
                var reIsUint = /^(?:0|[1-9]\d*)$/;
                var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
                var reNoMatch = /($^)/;
                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
                var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
                var rsApos = "['\u2019]", rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
                var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [
                    rsNonAstral,
                    rsRegional,
                    rsSurrPair
                ].join('|') + ')' + rsOptVar + reOptMod + ')*', rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])', rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [
                    rsDingbat,
                    rsRegional,
                    rsSurrPair
                ].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [
                    rsNonAstral + rsCombo + '?',
                    rsCombo,
                    rsRegional,
                    rsSurrPair,
                    rsAstral
                ].join('|') + ')';
                var reApos = RegExp(rsApos, 'g');
                var reComboMark = RegExp(rsCombo, 'g');
                var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
                var reUnicodeWord = RegExp([
                    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [
                        rsBreak,
                        rsUpper,
                        '$'
                    ].join('|') + ')',
                    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [
                        rsBreak,
                        rsUpper + rsMiscLower,
                        '$'
                    ].join('|') + ')',
                    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
                    rsUpper + '+' + rsOptContrUpper,
                    rsOrdUpper,
                    rsOrdLower,
                    rsDigits,
                    rsEmoji
                ].join('|'), 'g');
                var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
                var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
                var contextProps = [
                    'Array',
                    'Buffer',
                    'DataView',
                    'Date',
                    'Error',
                    'Float32Array',
                    'Float64Array',
                    'Function',
                    'Int8Array',
                    'Int16Array',
                    'Int32Array',
                    'Map',
                    'Math',
                    'Object',
                    'Promise',
                    'RegExp',
                    'Set',
                    'String',
                    'Symbol',
                    'TypeError',
                    'Uint8Array',
                    'Uint8ClampedArray',
                    'Uint16Array',
                    'Uint32Array',
                    'WeakMap',
                    '_',
                    'clearTimeout',
                    'isFinite',
                    'parseInt',
                    'setTimeout'
                ];
                var templateCounter = -1;
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
                var deburredLetters = {
                    '\xc0': 'A',
                    '\xc1': 'A',
                    '\xc2': 'A',
                    '\xc3': 'A',
                    '\xc4': 'A',
                    '\xc5': 'A',
                    '\xe0': 'a',
                    '\xe1': 'a',
                    '\xe2': 'a',
                    '\xe3': 'a',
                    '\xe4': 'a',
                    '\xe5': 'a',
                    '\xc7': 'C',
                    '\xe7': 'c',
                    '\xd0': 'D',
                    '\xf0': 'd',
                    '\xc8': 'E',
                    '\xc9': 'E',
                    '\xca': 'E',
                    '\xcb': 'E',
                    '\xe8': 'e',
                    '\xe9': 'e',
                    '\xea': 'e',
                    '\xeb': 'e',
                    '\xcc': 'I',
                    '\xcd': 'I',
                    '\xce': 'I',
                    '\xcf': 'I',
                    '\xec': 'i',
                    '\xed': 'i',
                    '\xee': 'i',
                    '\xef': 'i',
                    '\xd1': 'N',
                    '\xf1': 'n',
                    '\xd2': 'O',
                    '\xd3': 'O',
                    '\xd4': 'O',
                    '\xd5': 'O',
                    '\xd6': 'O',
                    '\xd8': 'O',
                    '\xf2': 'o',
                    '\xf3': 'o',
                    '\xf4': 'o',
                    '\xf5': 'o',
                    '\xf6': 'o',
                    '\xf8': 'o',
                    '\xd9': 'U',
                    '\xda': 'U',
                    '\xdb': 'U',
                    '\xdc': 'U',
                    '\xf9': 'u',
                    '\xfa': 'u',
                    '\xfb': 'u',
                    '\xfc': 'u',
                    '\xdd': 'Y',
                    '\xfd': 'y',
                    '\xff': 'y',
                    '\xc6': 'Ae',
                    '\xe6': 'ae',
                    '\xde': 'Th',
                    '\xfe': 'th',
                    '\xdf': 'ss',
                    '\u0100': 'A',
                    '\u0102': 'A',
                    '\u0104': 'A',
                    '\u0101': 'a',
                    '\u0103': 'a',
                    '\u0105': 'a',
                    '\u0106': 'C',
                    '\u0108': 'C',
                    '\u010a': 'C',
                    '\u010c': 'C',
                    '\u0107': 'c',
                    '\u0109': 'c',
                    '\u010b': 'c',
                    '\u010d': 'c',
                    '\u010e': 'D',
                    '\u0110': 'D',
                    '\u010f': 'd',
                    '\u0111': 'd',
                    '\u0112': 'E',
                    '\u0114': 'E',
                    '\u0116': 'E',
                    '\u0118': 'E',
                    '\u011a': 'E',
                    '\u0113': 'e',
                    '\u0115': 'e',
                    '\u0117': 'e',
                    '\u0119': 'e',
                    '\u011b': 'e',
                    '\u011c': 'G',
                    '\u011e': 'G',
                    '\u0120': 'G',
                    '\u0122': 'G',
                    '\u011d': 'g',
                    '\u011f': 'g',
                    '\u0121': 'g',
                    '\u0123': 'g',
                    '\u0124': 'H',
                    '\u0126': 'H',
                    '\u0125': 'h',
                    '\u0127': 'h',
                    '\u0128': 'I',
                    '\u012a': 'I',
                    '\u012c': 'I',
                    '\u012e': 'I',
                    '\u0130': 'I',
                    '\u0129': 'i',
                    '\u012b': 'i',
                    '\u012d': 'i',
                    '\u012f': 'i',
                    '\u0131': 'i',
                    '\u0134': 'J',
                    '\u0135': 'j',
                    '\u0136': 'K',
                    '\u0137': 'k',
                    '\u0138': 'k',
                    '\u0139': 'L',
                    '\u013b': 'L',
                    '\u013d': 'L',
                    '\u013f': 'L',
                    '\u0141': 'L',
                    '\u013a': 'l',
                    '\u013c': 'l',
                    '\u013e': 'l',
                    '\u0140': 'l',
                    '\u0142': 'l',
                    '\u0143': 'N',
                    '\u0145': 'N',
                    '\u0147': 'N',
                    '\u014a': 'N',
                    '\u0144': 'n',
                    '\u0146': 'n',
                    '\u0148': 'n',
                    '\u014b': 'n',
                    '\u014c': 'O',
                    '\u014e': 'O',
                    '\u0150': 'O',
                    '\u014d': 'o',
                    '\u014f': 'o',
                    '\u0151': 'o',
                    '\u0154': 'R',
                    '\u0156': 'R',
                    '\u0158': 'R',
                    '\u0155': 'r',
                    '\u0157': 'r',
                    '\u0159': 'r',
                    '\u015a': 'S',
                    '\u015c': 'S',
                    '\u015e': 'S',
                    '\u0160': 'S',
                    '\u015b': 's',
                    '\u015d': 's',
                    '\u015f': 's',
                    '\u0161': 's',
                    '\u0162': 'T',
                    '\u0164': 'T',
                    '\u0166': 'T',
                    '\u0163': 't',
                    '\u0165': 't',
                    '\u0167': 't',
                    '\u0168': 'U',
                    '\u016a': 'U',
                    '\u016c': 'U',
                    '\u016e': 'U',
                    '\u0170': 'U',
                    '\u0172': 'U',
                    '\u0169': 'u',
                    '\u016b': 'u',
                    '\u016d': 'u',
                    '\u016f': 'u',
                    '\u0171': 'u',
                    '\u0173': 'u',
                    '\u0174': 'W',
                    '\u0175': 'w',
                    '\u0176': 'Y',
                    '\u0177': 'y',
                    '\u0178': 'Y',
                    '\u0179': 'Z',
                    '\u017b': 'Z',
                    '\u017d': 'Z',
                    '\u017a': 'z',
                    '\u017c': 'z',
                    '\u017e': 'z',
                    '\u0132': 'IJ',
                    '\u0133': 'ij',
                    '\u0152': 'Oe',
                    '\u0153': 'oe',
                    '\u0149': "'n",
                    '\u017f': 's'
                };
                var htmlEscapes = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                };
                var htmlUnescapes = {
                    '&amp;': '&',
                    '&lt;': '<',
                    '&gt;': '>',
                    '&quot;': '"',
                    '&#39;': "'"
                };
                var stringEscapes = {
                    '\\': '\\',
                    "'": "'",
                    '\n': 'n',
                    '\r': 'r',
                    '\u2028': 'u2028',
                    '\u2029': 'u2029'
                };
                var freeParseFloat = parseFloat, freeParseInt = parseInt;
                var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
                var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
                var root = freeGlobal || freeSelf || Function('return this')();
                var freeExports = exports && !exports.nodeType && exports;
                var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports;
                var freeProcess = moduleExports && freeGlobal.process;
                var nodeUtil = (function() {
                    try {
                        var types = freeModule && freeModule.require && freeModule.require('util').types;
                        if (types) {
                            return types;
                        }
                        return freeProcess && freeProcess.binding && freeProcess.binding('util');
                    } catch (e) {}
                }());
                var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
                function apply(func, thisArg, args) {
                    switch(args.length){
                        case 0:
                            return func.call(thisArg);
                        case 1:
                            return func.call(thisArg, args[0]);
                        case 2:
                            return func.call(thisArg, args[0], args[1]);
                        case 3:
                            return func.call(thisArg, args[0], args[1], args[2]);
                    }
                    return func.apply(thisArg, args);
                }
                function arrayAggregator(array, setter, iteratee, accumulator) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        var value = array[index];
                        setter(accumulator, value, iteratee(value), array);
                    }
                    return accumulator;
                }
                function arrayEach(array, iteratee) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        if (iteratee(array[index], index, array) === false) {
                            break;
                        }
                    }
                    return array;
                }
                function arrayEachRight(array, iteratee) {
                    var length = array == null ? 0 : array.length;
                    while(length--){
                        if (iteratee(array[length], length, array) === false) {
                            break;
                        }
                    }
                    return array;
                }
                function arrayEvery(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        if (!predicate(array[index], index, array)) {
                            return false;
                        }
                    }
                    return true;
                }
                function arrayFilter(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                    while(++index < length){
                        var value = array[index];
                        if (predicate(value, index, array)) {
                            result[resIndex++] = value;
                        }
                    }
                    return result;
                }
                function arrayIncludes(array, value) {
                    var length = array == null ? 0 : array.length;
                    return !!length && baseIndexOf(array, value, 0) > -1;
                }
                function arrayIncludesWith(array, value, comparator) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        if (comparator(value, array[index])) {
                            return true;
                        }
                    }
                    return false;
                }
                function arrayMap(array, iteratee) {
                    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                    while(++index < length){
                        result[index] = iteratee(array[index], index, array);
                    }
                    return result;
                }
                function arrayPush(array, values) {
                    var index = -1, length = values.length, offset = array.length;
                    while(++index < length){
                        array[offset + index] = values[index];
                    }
                    return array;
                }
                function arrayReduce(array, iteratee, accumulator, initAccum) {
                    var index = -1, length = array == null ? 0 : array.length;
                    if (initAccum && length) {
                        accumulator = array[++index];
                    }
                    while(++index < length){
                        accumulator = iteratee(accumulator, array[index], index, array);
                    }
                    return accumulator;
                }
                function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                    var length = array == null ? 0 : array.length;
                    if (initAccum && length) {
                        accumulator = array[--length];
                    }
                    while(length--){
                        accumulator = iteratee(accumulator, array[length], length, array);
                    }
                    return accumulator;
                }
                function arraySome(array, predicate) {
                    var index = -1, length = array == null ? 0 : array.length;
                    while(++index < length){
                        if (predicate(array[index], index, array)) {
                            return true;
                        }
                    }
                    return false;
                }
                var asciiSize = baseProperty('length');
                function asciiToArray(string) {
                    return string.split('');
                }
                function asciiWords(string) {
                    return string.match(reAsciiWord) || [];
                }
                function baseFindKey(collection, predicate, eachFunc) {
                    var result;
                    eachFunc(collection, function(value, key, collection) {
                        if (predicate(value, key, collection)) {
                            result = key;
                            return false;
                        }
                    });
                    return result;
                }
                function baseFindIndex(array, predicate, fromIndex, fromRight) {
                    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                    while((fromRight ? index-- : ++index < length)){
                        if (predicate(array[index], index, array)) {
                            return index;
                        }
                    }
                    return -1;
                }
                function baseIndexOf(array, value, fromIndex) {
                    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
                }
                function baseIndexOfWith(array, value, fromIndex, comparator) {
                    var index = fromIndex - 1, length = array.length;
                    while(++index < length){
                        if (comparator(array[index], value)) {
                            return index;
                        }
                    }
                    return -1;
                }
                function baseIsNaN(value) {
                    return value !== value;
                }
                function baseMean(array, iteratee) {
                    var length = array == null ? 0 : array.length;
                    return length ? (baseSum(array, iteratee) / length) : NAN;
                }
                function baseProperty(key) {
                    return function(object) {
                        return object == null ? undefined$1 : object[key];
                    };
                }
                function basePropertyOf(object) {
                    return function(key) {
                        return object == null ? undefined$1 : object[key];
                    };
                }
                function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                    eachFunc(collection, function(value, index, collection) {
                        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
                    });
                    return accumulator;
                }
                function baseSortBy(array, comparer) {
                    var length = array.length;
                    array.sort(comparer);
                    while(length--){
                        array[length] = array[length].value;
                    }
                    return array;
                }
                function baseSum(array, iteratee) {
                    var result, index = -1, length = array.length;
                    while(++index < length){
                        var current = iteratee(array[index]);
                        if (current !== undefined$1) {
                            result = result === undefined$1 ? current : (result + current);
                        }
                    }
                    return result;
                }
                function baseTimes(n, iteratee) {
                    var index = -1, result = Array(n);
                    while(++index < n){
                        result[index] = iteratee(index);
                    }
                    return result;
                }
                function baseToPairs(object, props) {
                    return arrayMap(props, function(key) {
                        return [
                            key,
                            object[key]
                        ];
                    });
                }
                function baseTrim(string) {
                    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
                }
                function baseUnary(func) {
                    return function(value) {
                        return func(value);
                    };
                }
                function baseValues(object, props) {
                    return arrayMap(props, function(key) {
                        return object[key];
                    });
                }
                function cacheHas(cache, key) {
                    return cache.has(key);
                }
                function charsStartIndex(strSymbols, chrSymbols) {
                    var index = -1, length = strSymbols.length;
                    while(++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1){}
                    return index;
                }
                function charsEndIndex(strSymbols, chrSymbols) {
                    var index = strSymbols.length;
                    while(index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1){}
                    return index;
                }
                function countHolders(array, placeholder) {
                    var length = array.length, result = 0;
                    while(length--){
                        if (array[length] === placeholder) {
                            ++result;
                        }
                    }
                    return result;
                }
                var deburrLetter = basePropertyOf(deburredLetters);
                var escapeHtmlChar = basePropertyOf(htmlEscapes);
                function escapeStringChar(chr) {
                    return '\\' + stringEscapes[chr];
                }
                function getValue(object, key) {
                    return object == null ? undefined$1 : object[key];
                }
                function hasUnicode(string) {
                    return reHasUnicode.test(string);
                }
                function hasUnicodeWord(string) {
                    return reHasUnicodeWord.test(string);
                }
                function iteratorToArray(iterator) {
                    var data, result = [];
                    while(!(data = iterator.next()).done){
                        result.push(data.value);
                    }
                    return result;
                }
                function mapToArray(map) {
                    var index = -1, result = Array(map.size);
                    map.forEach(function(value, key) {
                        result[++index] = [
                            key,
                            value
                        ];
                    });
                    return result;
                }
                function overArg(func, transform) {
                    return function(arg) {
                        return func(transform(arg));
                    };
                }
                function replaceHolders(array, placeholder) {
                    var index = -1, length = array.length, resIndex = 0, result = [];
                    while(++index < length){
                        var value = array[index];
                        if (value === placeholder || value === PLACEHOLDER) {
                            array[index] = PLACEHOLDER;
                            result[resIndex++] = index;
                        }
                    }
                    return result;
                }
                function setToArray(set) {
                    var index = -1, result = Array(set.size);
                    set.forEach(function(value) {
                        result[++index] = value;
                    });
                    return result;
                }
                function setToPairs(set) {
                    var index = -1, result = Array(set.size);
                    set.forEach(function(value) {
                        result[++index] = [
                            value,
                            value
                        ];
                    });
                    return result;
                }
                function strictIndexOf(array, value, fromIndex) {
                    var index = fromIndex - 1, length = array.length;
                    while(++index < length){
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function strictLastIndexOf(array, value, fromIndex) {
                    var index = fromIndex + 1;
                    while(index--){
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return index;
                }
                function stringSize(string) {
                    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
                }
                function stringToArray(string) {
                    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
                }
                function trimmedEndIndex(string) {
                    var index = string.length;
                    while(index-- && reWhitespace.test(string.charAt(index))){}
                    return index;
                }
                var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
                function unicodeSize(string) {
                    var result = reUnicode.lastIndex = 0;
                    while(reUnicode.test(string)){
                        ++result;
                    }
                    return result;
                }
                function unicodeToArray(string) {
                    return string.match(reUnicode) || [];
                }
                function unicodeWords(string) {
                    return string.match(reUnicodeWord) || [];
                }
                var runInContext = (function runInContext(context) {
                    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                    var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
                    var coreJsData = context['__core-js_shared__'];
                    var funcToString = funcProto.toString;
                    var hasOwnProperty = objectProto.hasOwnProperty;
                    var idCounter = 0;
                    var maskSrcKey = (function() {
                        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
                        return uid ? ('Symbol(src)_1.' + uid) : '';
                    }());
                    var nativeObjectToString = objectProto.toString;
                    var objectCtorString = funcToString.call(Object);
                    var oldDash = root._;
                    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
                    var Buffer = moduleExports ? context.Buffer : undefined$1, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1, symIterator = Symbol ? Symbol.iterator : undefined$1, symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;
                    var defineProperty = (function() {
                        try {
                            var func = getNative(Object, 'defineProperty');
                            func({}, '', {});
                            return func;
                        } catch (e) {}
                    }());
                    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                    var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
                    var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create');
                    var metaMap = WeakMap && new WeakMap;
                    var realNames = {};
                    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
                    var symbolProto = Symbol ? Symbol.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper) {
                                return value;
                            }
                            if (hasOwnProperty.call(value, '__wrapped__')) {
                                return wrapperClone(value);
                            }
                        }
                        return new LodashWrapper(value);
                    }
                    var baseCreate = (function() {
                        function object() {}
                        return function(proto) {
                            if (!isObject(proto)) {
                                return {};
                            }
                            if (objectCreate) {
                                return objectCreate(proto);
                            }
                            object.prototype = proto;
                            var result = new object;
                            object.prototype = undefined$1;
                            return result;
                        };
                    }());
                    function baseLodash() {}
                    function LodashWrapper(value, chainAll) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__chain__ = !!chainAll;
                        this.__index__ = 0;
                        this.__values__ = undefined$1;
                    }
                    lodash.templateSettings = {
                        'escape': reEscape,
                        'evaluate': reEvaluate,
                        'interpolate': reInterpolate,
                        'variable': '',
                        'imports': {
                            '_': lodash
                        }
                    };
                    lodash.prototype = baseLodash.prototype;
                    lodash.prototype.constructor = lodash;
                    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                    LodashWrapper.prototype.constructor = LodashWrapper;
                    function LazyWrapper(value) {
                        this.__wrapped__ = value;
                        this.__actions__ = [];
                        this.__dir__ = 1;
                        this.__filtered__ = false;
                        this.__iteratees__ = [];
                        this.__takeCount__ = MAX_ARRAY_LENGTH;
                        this.__views__ = [];
                    }
                    function lazyClone() {
                        var result = new LazyWrapper(this.__wrapped__);
                        result.__actions__ = copyArray(this.__actions__);
                        result.__dir__ = this.__dir__;
                        result.__filtered__ = this.__filtered__;
                        result.__iteratees__ = copyArray(this.__iteratees__);
                        result.__takeCount__ = this.__takeCount__;
                        result.__views__ = copyArray(this.__views__);
                        return result;
                    }
                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1;
                            result.__filtered__ = true;
                        } else {
                            result = this.clone();
                            result.__dir__ *= -1;
                        }
                        return result;
                    }
                    function lazyValue() {
                        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                        if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
                            return baseWrapperValue(array, this.__actions__);
                        }
                        var result = [];
                        outer: while(length-- && resIndex < takeCount){
                            index += dir;
                            var iterIndex = -1, value = array[index];
                            while(++iterIndex < iterLength){
                                var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                                if (type == LAZY_MAP_FLAG) {
                                    value = computed;
                                } else if (!computed) {
                                    if (type == LAZY_FILTER_FLAG) {
                                        continue outer;
                                    } else {
                                        break outer;
                                    }
                                }
                            }
                            result[resIndex++] = value;
                        }
                        return result;
                    }
                    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                    LazyWrapper.prototype.constructor = LazyWrapper;
                    function Hash(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while(++index < length){
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    }
                    function hashClear() {
                        this.__data__ = nativeCreate ? nativeCreate(null) : {};
                        this.size = 0;
                    }
                    function hashDelete(key) {
                        var result = this.has(key) && delete this.__data__[key];
                        this.size -= result ? 1 : 0;
                        return result;
                    }
                    function hashGet(key) {
                        var data = this.__data__;
                        if (nativeCreate) {
                            var result = data[key];
                            return result === HASH_UNDEFINED ? undefined$1 : result;
                        }
                        return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
                    }
                    function hashHas(key) {
                        var data = this.__data__;
                        return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
                    }
                    function hashSet(key, value) {
                        var data = this.__data__;
                        this.size += this.has(key) ? 0 : 1;
                        data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
                        return this;
                    }
                    Hash.prototype.clear = hashClear;
                    Hash.prototype['delete'] = hashDelete;
                    Hash.prototype.get = hashGet;
                    Hash.prototype.has = hashHas;
                    Hash.prototype.set = hashSet;
                    function ListCache(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while(++index < length){
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    }
                    function listCacheClear() {
                        this.__data__ = [];
                        this.size = 0;
                    }
                    function listCacheDelete(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        if (index < 0) {
                            return false;
                        }
                        var lastIndex = data.length - 1;
                        if (index == lastIndex) {
                            data.pop();
                        } else {
                            splice.call(data, index, 1);
                        }
                        --this.size;
                        return true;
                    }
                    function listCacheGet(key) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        return index < 0 ? undefined$1 : data[index][1];
                    }
                    function listCacheHas(key) {
                        return assocIndexOf(this.__data__, key) > -1;
                    }
                    function listCacheSet(key, value) {
                        var data = this.__data__, index = assocIndexOf(data, key);
                        if (index < 0) {
                            ++this.size;
                            data.push([
                                key,
                                value
                            ]);
                        } else {
                            data[index][1] = value;
                        }
                        return this;
                    }
                    ListCache.prototype.clear = listCacheClear;
                    ListCache.prototype['delete'] = listCacheDelete;
                    ListCache.prototype.get = listCacheGet;
                    ListCache.prototype.has = listCacheHas;
                    ListCache.prototype.set = listCacheSet;
                    function MapCache(entries) {
                        var index = -1, length = entries == null ? 0 : entries.length;
                        this.clear();
                        while(++index < length){
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    }
                    function mapCacheClear() {
                        this.size = 0;
                        this.__data__ = {
                            'hash': new Hash,
                            'map': new (Map || ListCache),
                            'string': new Hash
                        };
                    }
                    function mapCacheDelete(key) {
                        var result = getMapData(this, key)['delete'](key);
                        this.size -= result ? 1 : 0;
                        return result;
                    }
                    function mapCacheGet(key) {
                        return getMapData(this, key).get(key);
                    }
                    function mapCacheHas(key) {
                        return getMapData(this, key).has(key);
                    }
                    function mapCacheSet(key, value) {
                        var data = getMapData(this, key), size = data.size;
                        data.set(key, value);
                        this.size += data.size == size ? 0 : 1;
                        return this;
                    }
                    MapCache.prototype.clear = mapCacheClear;
                    MapCache.prototype['delete'] = mapCacheDelete;
                    MapCache.prototype.get = mapCacheGet;
                    MapCache.prototype.has = mapCacheHas;
                    MapCache.prototype.set = mapCacheSet;
                    function SetCache(values) {
                        var index = -1, length = values == null ? 0 : values.length;
                        this.__data__ = new MapCache;
                        while(++index < length){
                            this.add(values[index]);
                        }
                    }
                    function setCacheAdd(value) {
                        this.__data__.set(value, HASH_UNDEFINED);
                        return this;
                    }
                    function setCacheHas(value) {
                        return this.__data__.has(value);
                    }
                    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                    SetCache.prototype.has = setCacheHas;
                    function Stack(entries) {
                        var data = this.__data__ = new ListCache(entries);
                        this.size = data.size;
                    }
                    function stackClear() {
                        this.__data__ = new ListCache;
                        this.size = 0;
                    }
                    function stackDelete(key) {
                        var data = this.__data__, result = data['delete'](key);
                        this.size = data.size;
                        return result;
                    }
                    function stackGet(key) {
                        return this.__data__.get(key);
                    }
                    function stackHas(key) {
                        return this.__data__.has(key);
                    }
                    function stackSet(key, value) {
                        var data = this.__data__;
                        if (data instanceof ListCache) {
                            var pairs = data.__data__;
                            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                                pairs.push([
                                    key,
                                    value
                                ]);
                                this.size = ++data.size;
                                return this;
                            }
                            data = this.__data__ = new MapCache(pairs);
                        }
                        data.set(key, value);
                        this.size = data.size;
                        return this;
                    }
                    Stack.prototype.clear = stackClear;
                    Stack.prototype['delete'] = stackDelete;
                    Stack.prototype.get = stackGet;
                    Stack.prototype.has = stackHas;
                    Stack.prototype.set = stackSet;
                    function arrayLikeKeys(value, inherited) {
                        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                        for(var key in value){
                            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || (isBuff && (key == 'offset' || key == 'parent')) || (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) || isIndex(key, length)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function arraySample(array) {
                        var length = array.length;
                        return length ? array[baseRandom(0, length - 1)] : undefined$1;
                    }
                    function arraySampleSize(array, n) {
                        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                    }
                    function arrayShuffle(array) {
                        return shuffleSelf(copyArray(array));
                    }
                    function assignMergeValue(object, key, value) {
                        if ((value !== undefined$1 && !eq(object[key], value)) || (value === undefined$1 && !(key in object))) {
                            baseAssignValue(object, key, value);
                        }
                    }
                    function assignValue(object, key, value) {
                        var objValue = object[key];
                        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === undefined$1 && !(key in object))) {
                            baseAssignValue(object, key, value);
                        }
                    }
                    function assocIndexOf(array, key) {
                        var length = array.length;
                        while(length--){
                            if (eq(array[length][0], key)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function baseAggregator(collection, setter, iteratee, accumulator) {
                        baseEach(collection, function(value, key, collection) {
                            setter(accumulator, value, iteratee(value), collection);
                        });
                        return accumulator;
                    }
                    function baseAssign(object, source) {
                        return object && copyObject(source, keys(source), object);
                    }
                    function baseAssignIn(object, source) {
                        return object && copyObject(source, keysIn(source), object);
                    }
                    function baseAssignValue(object, key, value) {
                        if (key == '__proto__' && defineProperty) {
                            defineProperty(object, key, {
                                'configurable': true,
                                'enumerable': true,
                                'value': value,
                                'writable': true
                            });
                        } else {
                            object[key] = value;
                        }
                    }
                    function baseAt(object, paths) {
                        var index = -1, length = paths.length, result = Array(length), skip = object == null;
                        while(++index < length){
                            result[index] = skip ? undefined$1 : get(object, paths[index]);
                        }
                        return result;
                    }
                    function baseClamp(number, lower, upper) {
                        if (number === number) {
                            if (upper !== undefined$1) {
                                number = number <= upper ? number : upper;
                            }
                            if (lower !== undefined$1) {
                                number = number >= lower ? number : lower;
                            }
                        }
                        return number;
                    }
                    function baseClone(value, bitmask, customizer, key, object, stack) {
                        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                        if (customizer) {
                            result = object ? customizer(value, key, object, stack) : customizer(value);
                        }
                        if (result !== undefined$1) {
                            return result;
                        }
                        if (!isObject(value)) {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isArr) {
                            result = initCloneArray(value);
                            if (!isDeep) {
                                return copyArray(value, result);
                            }
                        } else {
                            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                            if (isBuffer(value)) {
                                return cloneBuffer(value, isDeep);
                            }
                            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                                result = (isFlat || isFunc) ? {} : initCloneObject(value);
                                if (!isDeep) {
                                    return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                                }
                            } else {
                                if (!cloneableTags[tag]) {
                                    return object ? value : {};
                                }
                                result = initCloneByTag(value, tag, isDeep);
                            }
                        }
                        stack || (stack = new Stack);
                        var stacked = stack.get(value);
                        if (stacked) {
                            return stacked;
                        }
                        stack.set(value, result);
                        if (isSet(value)) {
                            value.forEach(function(subValue) {
                                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                            });
                        } else if (isMap(value)) {
                            value.forEach(function(subValue, key) {
                                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
                            });
                        }
                        var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys);
                        var props = isArr ? undefined$1 : keysFunc(value);
                        arrayEach(props || value, function(subValue, key) {
                            if (props) {
                                key = subValue;
                                subValue = value[key];
                            }
                            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
                        });
                        return result;
                    }
                    function baseConforms(source) {
                        var props = keys(source);
                        return function(object) {
                            return baseConformsTo(object, source, props);
                        };
                    }
                    function baseConformsTo(object, source, props) {
                        var length = props.length;
                        if (object == null) {
                            return !length;
                        }
                        object = Object(object);
                        while(length--){
                            var key = props[length], predicate = source[key], value = object[key];
                            if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function baseDelay(func, wait, args) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return setTimeout(function() {
                            func.apply(undefined$1, args);
                        }, wait);
                    }
                    function baseDifference(array, values, iteratee, comparator) {
                        var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
                        if (!length) {
                            return result;
                        }
                        if (iteratee) {
                            values = arrayMap(values, baseUnary(iteratee));
                        }
                        if (comparator) {
                            includes = arrayIncludesWith;
                            isCommon = false;
                        } else if (values.length >= LARGE_ARRAY_SIZE) {
                            includes = cacheHas;
                            isCommon = false;
                            values = new SetCache(values);
                        }
                        outer: while(++index < length){
                            var value = array[index], computed = iteratee == null ? value : iteratee(value);
                            value = (comparator || value !== 0) ? value : 0;
                            if (isCommon && computed === computed) {
                                var valuesIndex = valuesLength;
                                while(valuesIndex--){
                                    if (values[valuesIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            } else if (!includes(values, computed, comparator)) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    var baseEach = createBaseEach(baseForOwn);
                    var baseEachRight = createBaseEach(baseForOwnRight, true);
                    function baseEvery(collection, predicate) {
                        var result = true;
                        baseEach(collection, function(value, index, collection) {
                            result = !!predicate(value, index, collection);
                            return result;
                        });
                        return result;
                    }
                    function baseExtremum(array, iteratee, comparator) {
                        var index = -1, length = array.length;
                        while(++index < length){
                            var value = array[index], current = iteratee(value);
                            if (current != null && (computed === undefined$1 ? (current === current && !isSymbol(current)) : comparator(current, computed))) {
                                var computed = current, result = value;
                            }
                        }
                        return result;
                    }
                    function baseFill(array, value, start, end) {
                        var length = array.length;
                        start = toInteger(start);
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = (end === undefined$1 || end > length) ? length : toInteger(end);
                        if (end < 0) {
                            end += length;
                        }
                        end = start > end ? 0 : toLength(end);
                        while(start < end){
                            array[start++] = value;
                        }
                        return array;
                    }
                    function baseFilter(collection, predicate) {
                        var result = [];
                        baseEach(collection, function(value, index, collection) {
                            if (predicate(value, index, collection)) {
                                result.push(value);
                            }
                        });
                        return result;
                    }
                    function baseFlatten(array, depth, predicate, isStrict, result) {
                        var index = -1, length = array.length;
                        predicate || (predicate = isFlattenable);
                        result || (result = []);
                        while(++index < length){
                            var value = array[index];
                            if (depth > 0 && predicate(value)) {
                                if (depth > 1) {
                                    baseFlatten(value, depth - 1, predicate, isStrict, result);
                                } else {
                                    arrayPush(result, value);
                                }
                            } else if (!isStrict) {
                                result[result.length] = value;
                            }
                        }
                        return result;
                    }
                    var baseFor = createBaseFor();
                    var baseForRight = createBaseFor(true);
                    function baseForOwn(object, iteratee) {
                        return object && baseFor(object, iteratee, keys);
                    }
                    function baseForOwnRight(object, iteratee) {
                        return object && baseForRight(object, iteratee, keys);
                    }
                    function baseFunctions(object, props) {
                        return arrayFilter(props, function(key) {
                            return isFunction(object[key]);
                        });
                    }
                    function baseGet(object, path) {
                        path = castPath(path, object);
                        var index = 0, length = path.length;
                        while(object != null && index < length){
                            object = object[toKey(path[index++])];
                        }
                        return (index && index == length) ? object : undefined$1;
                    }
                    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                        var result = keysFunc(object);
                        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
                    }
                    function baseGetTag(value) {
                        if (value == null) {
                            return value === undefined$1 ? undefinedTag : nullTag;
                        }
                        return (symToStringTag && symToStringTag in Object(value)) ? getRawTag(value) : objectToString(value);
                    }
                    function baseGt(value, other) {
                        return value > other;
                    }
                    function baseHas(object, key) {
                        return object != null && hasOwnProperty.call(object, key);
                    }
                    function baseHasIn(object, key) {
                        return object != null && key in Object(object);
                    }
                    function baseInRange(number, start, end) {
                        return number >= nativeMin(start, end) && number < nativeMax(start, end);
                    }
                    function baseIntersection(arrays, iteratee, comparator) {
                        var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
                        while(othIndex--){
                            var array = arrays[othIndex];
                            if (othIndex && iteratee) {
                                array = arrayMap(array, baseUnary(iteratee));
                            }
                            maxLength = nativeMin(array.length, maxLength);
                            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120)) ? new SetCache(othIndex && array) : undefined$1;
                        }
                        array = arrays[0];
                        var index = -1, seen = caches[0];
                        outer: while(++index < length && result.length < maxLength){
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            value = (comparator || value !== 0) ? value : 0;
                            if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                                othIndex = othLength;
                                while(--othIndex){
                                    var cache = caches[othIndex];
                                    if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                                        continue outer;
                                    }
                                }
                                if (seen) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseInverter(object, setter, iteratee, accumulator) {
                        baseForOwn(object, function(value, key, object) {
                            setter(accumulator, iteratee(value), key, object);
                        });
                        return accumulator;
                    }
                    function baseInvoke(object, path, args) {
                        path = castPath(path, object);
                        object = parent(object, path);
                        var func = object == null ? object : object[toKey(last(path))];
                        return func == null ? undefined$1 : apply(func, object, args);
                    }
                    function baseIsArguments(value) {
                        return isObjectLike(value) && baseGetTag(value) == argsTag;
                    }
                    function baseIsArrayBuffer(value) {
                        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                    }
                    function baseIsDate(value) {
                        return isObjectLike(value) && baseGetTag(value) == dateTag;
                    }
                    function baseIsEqual(value, other, bitmask, customizer, stack) {
                        if (value === other) {
                            return true;
                        }
                        if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
                            return value !== value && other !== other;
                        }
                        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                    }
                    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                        objTag = objTag == argsTag ? objectTag : objTag;
                        othTag = othTag == argsTag ? objectTag : othTag;
                        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                        if (isSameTag && isBuffer(object)) {
                            if (!isBuffer(other)) {
                                return false;
                            }
                            objIsArr = true;
                            objIsObj = false;
                        }
                        if (isSameTag && !objIsObj) {
                            stack || (stack = new Stack);
                            return (objIsArr || isTypedArray(object)) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                        }
                        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                            if (objIsWrapped || othIsWrapped) {
                                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                                stack || (stack = new Stack);
                                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                            }
                        }
                        if (!isSameTag) {
                            return false;
                        }
                        stack || (stack = new Stack);
                        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                    }
                    function baseIsMap(value) {
                        return isObjectLike(value) && getTag(value) == mapTag;
                    }
                    function baseIsMatch(object, source, matchData, customizer) {
                        var index = matchData.length, length = index, noCustomizer = !customizer;
                        if (object == null) {
                            return !length;
                        }
                        object = Object(object);
                        while(index--){
                            var data = matchData[index];
                            if ((noCustomizer && data[2]) ? data[1] !== object[data[0]] : !(data[0] in object)) {
                                return false;
                            }
                        }
                        while(++index < length){
                            data = matchData[index];
                            var key = data[0], objValue = object[key], srcValue = data[1];
                            if (noCustomizer && data[2]) {
                                if (objValue === undefined$1 && !(key in object)) {
                                    return false;
                                }
                            } else {
                                var stack = new Stack;
                                if (customizer) {
                                    var result = customizer(objValue, srcValue, key, object, source, stack);
                                }
                                if (!(result === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    function baseIsNative(value) {
                        if (!isObject(value) || isMasked(value)) {
                            return false;
                        }
                        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                        return pattern.test(toSource(value));
                    }
                    function baseIsRegExp(value) {
                        return isObjectLike(value) && baseGetTag(value) == regexpTag;
                    }
                    function baseIsSet(value) {
                        return isObjectLike(value) && getTag(value) == setTag;
                    }
                    function baseIsTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                    }
                    function baseIteratee(value) {
                        if (typeof value == 'function') {
                            return value;
                        }
                        if (value == null) {
                            return identity;
                        }
                        if (typeof value == 'object') {
                            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                        }
                        return property(value);
                    }
                    function baseKeys(object) {
                        if (!isPrototype(object)) {
                            return nativeKeys(object);
                        }
                        var result = [];
                        for(var key in Object(object)){
                            if (hasOwnProperty.call(object, key) && key != 'constructor') {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function baseKeysIn(object) {
                        if (!isObject(object)) {
                            return nativeKeysIn(object);
                        }
                        var isProto = isPrototype(object), result = [];
                        for(var key in object){
                            if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function baseLt(value, other) {
                        return value < other;
                    }
                    function baseMap(collection, iteratee) {
                        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
                        baseEach(collection, function(value, key, collection) {
                            result[++index] = iteratee(value, key, collection);
                        });
                        return result;
                    }
                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        if (matchData.length == 1 && matchData[0][2]) {
                            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                        }
                        return function(object) {
                            return object === source || baseIsMatch(object, source, matchData);
                        };
                    }
                    function baseMatchesProperty(path, srcValue) {
                        if (isKey(path) && isStrictComparable(srcValue)) {
                            return matchesStrictComparable(toKey(path), srcValue);
                        }
                        return function(object) {
                            var objValue = get(object, path);
                            return (objValue === undefined$1 && objValue === srcValue) ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                        };
                    }
                    function baseMerge(object, source, srcIndex, customizer, stack) {
                        if (object === source) {
                            return;
                        }
                        baseFor(source, function(srcValue, key) {
                            stack || (stack = new Stack);
                            if (isObject(srcValue)) {
                                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                            } else {
                                var newValue = customizer ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack) : undefined$1;
                                if (newValue === undefined$1) {
                                    newValue = srcValue;
                                }
                                assignMergeValue(object, key, newValue);
                            }
                        }, keysIn);
                    }
                    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                        if (stacked) {
                            assignMergeValue(object, key, stacked);
                            return;
                        }
                        var newValue = customizer ? customizer(objValue, srcValue, (key + ''), object, source, stack) : undefined$1;
                        var isCommon = newValue === undefined$1;
                        if (isCommon) {
                            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                            newValue = srcValue;
                            if (isArr || isBuff || isTyped) {
                                if (isArray(objValue)) {
                                    newValue = objValue;
                                } else if (isArrayLikeObject(objValue)) {
                                    newValue = copyArray(objValue);
                                } else if (isBuff) {
                                    isCommon = false;
                                    newValue = cloneBuffer(srcValue, true);
                                } else if (isTyped) {
                                    isCommon = false;
                                    newValue = cloneTypedArray(srcValue, true);
                                } else {
                                    newValue = [];
                                }
                            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                newValue = objValue;
                                if (isArguments(objValue)) {
                                    newValue = toPlainObject(objValue);
                                } else if (!isObject(objValue) || isFunction(objValue)) {
                                    newValue = initCloneObject(srcValue);
                                }
                            } else {
                                isCommon = false;
                            }
                        }
                        if (isCommon) {
                            stack.set(srcValue, newValue);
                            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                            stack['delete'](srcValue);
                        }
                        assignMergeValue(object, key, newValue);
                    }
                    function baseNth(array, n) {
                        var length = array.length;
                        if (!length) {
                            return;
                        }
                        n += n < 0 ? length : 0;
                        return isIndex(n, length) ? array[n] : undefined$1;
                    }
                    function baseOrderBy(collection, iteratees, orders) {
                        if (iteratees.length) {
                            iteratees = arrayMap(iteratees, function(iteratee) {
                                if (isArray(iteratee)) {
                                    return function(value) {
                                        return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                                    };
                                }
                                return iteratee;
                            });
                        } else {
                            iteratees = [
                                identity
                            ];
                        }
                        var index = -1;
                        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                        var result = baseMap(collection, function(value, key, collection) {
                            var criteria = arrayMap(iteratees, function(iteratee) {
                                return iteratee(value);
                            });
                            return {
                                'criteria': criteria,
                                'index': ++index,
                                'value': value
                            };
                        });
                        return baseSortBy(result, function(object, other) {
                            return compareMultiple(object, other, orders);
                        });
                    }
                    function basePick(object, paths) {
                        return basePickBy(object, paths, function(value, path) {
                            return hasIn(object, path);
                        });
                    }
                    function basePickBy(object, paths, predicate) {
                        var index = -1, length = paths.length, result = {};
                        while(++index < length){
                            var path = paths[index], value = baseGet(object, path);
                            if (predicate(value, path)) {
                                baseSet(result, castPath(path, object), value);
                            }
                        }
                        return result;
                    }
                    function basePropertyDeep(path) {
                        return function(object) {
                            return baseGet(object, path);
                        };
                    }
                    function basePullAll(array, values, iteratee, comparator) {
                        var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
                        if (array === values) {
                            values = copyArray(values);
                        }
                        if (iteratee) {
                            seen = arrayMap(array, baseUnary(iteratee));
                        }
                        while(++index < length){
                            var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                            while((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1){
                                if (seen !== array) {
                                    splice.call(seen, fromIndex, 1);
                                }
                                splice.call(array, fromIndex, 1);
                            }
                        }
                        return array;
                    }
                    function basePullAt(array, indexes) {
                        var length = array ? indexes.length : 0, lastIndex = length - 1;
                        while(length--){
                            var index = indexes[length];
                            if (length == lastIndex || index !== previous) {
                                var previous = index;
                                if (isIndex(index)) {
                                    splice.call(array, index, 1);
                                } else {
                                    baseUnset(array, index);
                                }
                            }
                        }
                        return array;
                    }
                    function baseRandom(lower, upper) {
                        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                    }
                    function baseRange(start, end, step, fromRight) {
                        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
                        while(length--){
                            result[fromRight ? length : ++index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function baseRepeat(string, n) {
                        var result = '';
                        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                            return result;
                        }
                        do {
                            if (n % 2) {
                                result += string;
                            }
                            n = nativeFloor(n / 2);
                            if (n) {
                                string += string;
                            }
                        }while (n);
                        return result;
                    }
                    function baseRest(func, start) {
                        return setToString(overRest(func, start, identity), func + '');
                    }
                    function baseSample(collection) {
                        return arraySample(values(collection));
                    }
                    function baseSampleSize(collection, n) {
                        var array = values(collection);
                        return shuffleSelf(array, baseClamp(n, 0, array.length));
                    }
                    function baseSet(object, path, value, customizer) {
                        if (!isObject(object)) {
                            return object;
                        }
                        path = castPath(path, object);
                        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                        while(nested != null && ++index < length){
                            var key = toKey(path[index]), newValue = value;
                            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                                return object;
                            }
                            if (index != lastIndex) {
                                var objValue = nested[key];
                                newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
                                if (newValue === undefined$1) {
                                    newValue = isObject(objValue) ? objValue : (isIndex(path[index + 1]) ? [] : {});
                                }
                            }
                            assignValue(nested, key, newValue);
                            nested = nested[key];
                        }
                        return object;
                    }
                    var baseSetData = !metaMap ? identity : function(func, data) {
                        metaMap.set(func, data);
                        return func;
                    };
                    var baseSetToString = !defineProperty ? identity : function(func, string) {
                        return defineProperty(func, 'toString', {
                            'configurable': true,
                            'enumerable': false,
                            'value': constant(string),
                            'writable': true
                        });
                    };
                    function baseShuffle(collection) {
                        return shuffleSelf(values(collection));
                    }
                    function baseSlice(array, start, end) {
                        var index = -1, length = array.length;
                        if (start < 0) {
                            start = -start > length ? 0 : (length + start);
                        }
                        end = end > length ? length : end;
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : ((end - start) >>> 0);
                        start >>>= 0;
                        var result = Array(length);
                        while(++index < length){
                            result[index] = array[index + start];
                        }
                        return result;
                    }
                    function baseSome(collection, predicate) {
                        var result;
                        baseEach(collection, function(value, index, collection) {
                            result = predicate(value, index, collection);
                            return !result;
                        });
                        return !!result;
                    }
                    function baseSortedIndex(array, value, retHighest) {
                        var low = 0, high = array == null ? low : array.length;
                        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                            while(low < high){
                                var mid = (low + high) >>> 1, computed = array[mid];
                                if (computed !== null && !isSymbol(computed) && (retHighest ? (computed <= value) : (computed < value))) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return high;
                        }
                        return baseSortedIndexBy(array, value, identity, retHighest);
                    }
                    function baseSortedIndexBy(array, value, iteratee, retHighest) {
                        var low = 0, high = array == null ? 0 : array.length;
                        if (high === 0) {
                            return 0;
                        }
                        value = iteratee(value);
                        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
                        while(low < high){
                            var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                            if (valIsNaN) {
                                var setLow = retHighest || othIsReflexive;
                            } else if (valIsUndefined) {
                                setLow = othIsReflexive && (retHighest || othIsDefined);
                            } else if (valIsNull) {
                                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                            } else if (valIsSymbol) {
                                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                            } else if (othIsNull || othIsSymbol) {
                                setLow = false;
                            } else {
                                setLow = retHighest ? (computed <= value) : (computed < value);
                            }
                            if (setLow) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX);
                    }
                    function baseSortedUniq(array, iteratee) {
                        var index = -1, length = array.length, resIndex = 0, result = [];
                        while(++index < length){
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            if (!index || !eq(computed, seen)) {
                                var seen = computed;
                                result[resIndex++] = value === 0 ? 0 : value;
                            }
                        }
                        return result;
                    }
                    function baseToNumber(value) {
                        if (typeof value == 'number') {
                            return value;
                        }
                        if (isSymbol(value)) {
                            return NAN;
                        }
                        return +value;
                    }
                    function baseToString(value) {
                        if (typeof value == 'string') {
                            return value;
                        }
                        if (isArray(value)) {
                            return arrayMap(value, baseToString) + '';
                        }
                        if (isSymbol(value)) {
                            return symbolToString ? symbolToString.call(value) : '';
                        }
                        var result = (value + '');
                        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                    }
                    function baseUniq(array, iteratee, comparator) {
                        var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
                        if (comparator) {
                            isCommon = false;
                            includes = arrayIncludesWith;
                        } else if (length >= LARGE_ARRAY_SIZE) {
                            var set = iteratee ? null : createSet(array);
                            if (set) {
                                return setToArray(set);
                            }
                            isCommon = false;
                            includes = cacheHas;
                            seen = new SetCache;
                        } else {
                            seen = iteratee ? [] : result;
                        }
                        outer: while(++index < length){
                            var value = array[index], computed = iteratee ? iteratee(value) : value;
                            value = (comparator || value !== 0) ? value : 0;
                            if (isCommon && computed === computed) {
                                var seenIndex = seen.length;
                                while(seenIndex--){
                                    if (seen[seenIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                if (iteratee) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            } else if (!includes(seen, computed, comparator)) {
                                if (seen !== result) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseUnset(object, path) {
                        path = castPath(path, object);
                        object = parent(object, path);
                        return object == null || delete object[toKey(last(path))];
                    }
                    function baseUpdate(object, path, updater, customizer) {
                        return baseSet(object, path, updater(baseGet(object, path)), customizer);
                    }
                    function baseWhile(array, predicate, isDrop, fromRight) {
                        var length = array.length, index = fromRight ? length : -1;
                        while((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)){}
                        return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
                    }
                    function baseWrapperValue(value, actions) {
                        var result = value;
                        if (result instanceof LazyWrapper) {
                            result = result.value();
                        }
                        return arrayReduce(actions, function(result, action) {
                            return action.func.apply(action.thisArg, arrayPush([
                                result
                            ], action.args));
                        }, result);
                    }
                    function baseXor(arrays, iteratee, comparator) {
                        var length = arrays.length;
                        if (length < 2) {
                            return length ? baseUniq(arrays[0]) : [];
                        }
                        var index = -1, result = Array(length);
                        while(++index < length){
                            var array = arrays[index], othIndex = -1;
                            while(++othIndex < length){
                                if (othIndex != index) {
                                    result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                                }
                            }
                        }
                        return baseUniq(baseFlatten(result, 1), iteratee, comparator);
                    }
                    function baseZipObject(props, values, assignFunc) {
                        var index = -1, length = props.length, valsLength = values.length, result = {};
                        while(++index < length){
                            var value = index < valsLength ? values[index] : undefined$1;
                            assignFunc(result, props[index], value);
                        }
                        return result;
                    }
                    function castArrayLikeObject(value) {
                        return isArrayLikeObject(value) ? value : [];
                    }
                    function castFunction(value) {
                        return typeof value == 'function' ? value : identity;
                    }
                    function castPath(value, object) {
                        if (isArray(value)) {
                            return value;
                        }
                        return isKey(value, object) ? [
                            value
                        ] : stringToPath(toString(value));
                    }
                    var castRest = baseRest;
                    function castSlice(array, start, end) {
                        var length = array.length;
                        end = end === undefined$1 ? length : end;
                        return (!start && end >= length) ? array : baseSlice(array, start, end);
                    }
                    var clearTimeout = ctxClearTimeout || function(id) {
                        return root.clearTimeout(id);
                    };
                    function cloneBuffer(buffer, isDeep) {
                        if (isDeep) {
                            return buffer.slice();
                        }
                        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                        buffer.copy(result);
                        return result;
                    }
                    function cloneArrayBuffer(arrayBuffer) {
                        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                        return result;
                    }
                    function cloneDataView(dataView, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                    }
                    function cloneRegExp(regexp) {
                        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                        result.lastIndex = regexp.lastIndex;
                        return result;
                    }
                    function cloneSymbol(symbol) {
                        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
                    }
                    function cloneTypedArray(typedArray, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                    }
                    function compareAscending(value, other) {
                        if (value !== other) {
                            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                            if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) || (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) || (valIsNull && othIsDefined && othIsReflexive) || (!valIsDefined && othIsReflexive) || !valIsReflexive) {
                                return 1;
                            }
                            if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) || (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) || (othIsNull && valIsDefined && valIsReflexive) || (!othIsDefined && valIsReflexive) || !othIsReflexive) {
                                return -1;
                            }
                        }
                        return 0;
                    }
                    function compareMultiple(object, other, orders) {
                        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                        while(++index < length){
                            var result = compareAscending(objCriteria[index], othCriteria[index]);
                            if (result) {
                                if (index >= ordersLength) {
                                    return result;
                                }
                                var order = orders[index];
                                return result * (order == 'desc' ? -1 : 1);
                            }
                        }
                        return object.index - other.index;
                    }
                    function composeArgs(args, partials, holders, isCurried) {
                        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
                        while(++leftIndex < leftLength){
                            result[leftIndex] = partials[leftIndex];
                        }
                        while(++argsIndex < holdersLength){
                            if (isUncurried || argsIndex < argsLength) {
                                result[holders[argsIndex]] = args[argsIndex];
                            }
                        }
                        while(rangeLength--){
                            result[leftIndex++] = args[argsIndex++];
                        }
                        return result;
                    }
                    function composeArgsRight(args, partials, holders, isCurried) {
                        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
                        while(++argsIndex < rangeLength){
                            result[argsIndex] = args[argsIndex];
                        }
                        var offset = argsIndex;
                        while(++rightIndex < rightLength){
                            result[offset + rightIndex] = partials[rightIndex];
                        }
                        while(++holdersIndex < holdersLength){
                            if (isUncurried || argsIndex < argsLength) {
                                result[offset + holders[holdersIndex]] = args[argsIndex++];
                            }
                        }
                        return result;
                    }
                    function copyArray(source, array) {
                        var index = -1, length = source.length;
                        array || (array = Array(length));
                        while(++index < length){
                            array[index] = source[index];
                        }
                        return array;
                    }
                    function copyObject(source, props, object, customizer) {
                        var isNew = !object;
                        object || (object = {});
                        var index = -1, length = props.length;
                        while(++index < length){
                            var key = props[index];
                            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
                            if (newValue === undefined$1) {
                                newValue = source[key];
                            }
                            if (isNew) {
                                baseAssignValue(object, key, newValue);
                            } else {
                                assignValue(object, key, newValue);
                            }
                        }
                        return object;
                    }
                    function copySymbols(source, object) {
                        return copyObject(source, getSymbols(source), object);
                    }
                    function copySymbolsIn(source, object) {
                        return copyObject(source, getSymbolsIn(source), object);
                    }
                    function createAggregator(setter, initializer) {
                        return function(collection, iteratee) {
                            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
                        };
                    }
                    function createAssigner(assigner) {
                        return baseRest(function(object, sources) {
                            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
                            customizer = (assigner.length > 3 && typeof customizer == 'function') ? (length--, customizer) : undefined$1;
                            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                                customizer = length < 3 ? undefined$1 : customizer;
                                length = 1;
                            }
                            object = Object(object);
                            while(++index < length){
                                var source = sources[index];
                                if (source) {
                                    assigner(object, source, index, customizer);
                                }
                            }
                            return object;
                        });
                    }
                    function createBaseEach(eachFunc, fromRight) {
                        return function(collection, iteratee) {
                            if (collection == null) {
                                return collection;
                            }
                            if (!isArrayLike(collection)) {
                                return eachFunc(collection, iteratee);
                            }
                            var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                            while((fromRight ? index-- : ++index < length)){
                                if (iteratee(iterable[index], index, iterable) === false) {
                                    break;
                                }
                            }
                            return collection;
                        };
                    }
                    function createBaseFor(fromRight) {
                        return function(object, iteratee, keysFunc) {
                            var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
                            while(length--){
                                var key = props[fromRight ? length : ++index];
                                if (iteratee(iterable[key], key, iterable) === false) {
                                    break;
                                }
                            }
                            return object;
                        };
                    }
                    function createBind(func, bitmask, thisArg) {
                        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                        function wrapper() {
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, arguments);
                        }
                        return wrapper;
                    }
                    function createCaseFirst(methodName) {
                        return function(string) {
                            string = toString(string);
                            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
                            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                            var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
                            return chr[methodName]() + trailing;
                        };
                    }
                    function createCompounder(callback) {
                        return function(string) {
                            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
                        };
                    }
                    function createCtor(Ctor) {
                        return function() {
                            var args = arguments;
                            switch(args.length){
                                case 0:
                                    return new Ctor;
                                case 1:
                                    return new Ctor(args[0]);
                                case 2:
                                    return new Ctor(args[0], args[1]);
                                case 3:
                                    return new Ctor(args[0], args[1], args[2]);
                                case 4:
                                    return new Ctor(args[0], args[1], args[2], args[3]);
                                case 5:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                                case 6:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                                case 7:
                                    return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                            }
                            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
                            return isObject(result) ? result : thisBinding;
                        };
                    }
                    function createCurry(func, bitmask, arity) {
                        var Ctor = createCtor(func);
                        function wrapper() {
                            var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
                            while(index--){
                                args[index] = arguments[index];
                            }
                            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder) ? [] : replaceHolders(args, placeholder);
                            length -= holders.length;
                            if (length < arity) {
                                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
                            }
                            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            return apply(fn, this, args);
                        }
                        return wrapper;
                    }
                    function createFind(findIndexFunc) {
                        return function(collection, predicate, fromIndex) {
                            var iterable = Object(collection);
                            if (!isArrayLike(collection)) {
                                var iteratee = getIteratee(predicate, 3);
                                collection = keys(collection);
                                predicate = function(key) {
                                    return iteratee(iterable[key], key, iterable);
                                };
                            }
                            var index = findIndexFunc(collection, predicate, fromIndex);
                            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
                        };
                    }
                    function createFlow(fromRight) {
                        return flatRest(function(funcs) {
                            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                            if (fromRight) {
                                funcs.reverse();
                            }
                            while(index--){
                                var func = funcs[index];
                                if (typeof func != 'function') {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                                    var wrapper = new LodashWrapper([], true);
                                }
                            }
                            index = wrapper ? index : length;
                            while(++index < length){
                                func = funcs[index];
                                var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined$1;
                                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                                    wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                } else {
                                    wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                                }
                            }
                            return function() {
                                var args = arguments, value = args[0];
                                if (wrapper && args.length == 1 && isArray(value)) {
                                    return wrapper.plant(value).value();
                                }
                                var index = 0, result = length ? funcs[index].apply(this, args) : value;
                                while(++index < length){
                                    result = funcs[index].call(this, result);
                                }
                                return result;
                            };
                        });
                    }
                    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
                        function wrapper() {
                            var length = arguments.length, args = Array(length), index = length;
                            while(index--){
                                args[index] = arguments[index];
                            }
                            if (isCurried) {
                                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                            }
                            if (partials) {
                                args = composeArgs(args, partials, holders, isCurried);
                            }
                            if (partialsRight) {
                                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                            }
                            length -= holdersCount;
                            if (isCurried && length < arity) {
                                var newHolders = replaceHolders(args, placeholder);
                                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
                            }
                            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                            length = args.length;
                            if (argPos) {
                                args = reorder(args, argPos);
                            } else if (isFlip && length > 1) {
                                args.reverse();
                            }
                            if (isAry && ary < length) {
                                args.length = ary;
                            }
                            if (this && this !== root && this instanceof wrapper) {
                                fn = Ctor || createCtor(fn);
                            }
                            return fn.apply(thisBinding, args);
                        }
                        return wrapper;
                    }
                    function createInverter(setter, toIteratee) {
                        return function(object, iteratee) {
                            return baseInverter(object, setter, toIteratee(iteratee), {});
                        };
                    }
                    function createMathOperation(operator, defaultValue) {
                        return function(value, other) {
                            var result;
                            if (value === undefined$1 && other === undefined$1) {
                                return defaultValue;
                            }
                            if (value !== undefined$1) {
                                result = value;
                            }
                            if (other !== undefined$1) {
                                if (result === undefined$1) {
                                    return other;
                                }
                                if (typeof value == 'string' || typeof other == 'string') {
                                    value = baseToString(value);
                                    other = baseToString(other);
                                } else {
                                    value = baseToNumber(value);
                                    other = baseToNumber(other);
                                }
                                result = operator(value, other);
                            }
                            return result;
                        };
                    }
                    function createOver(arrayFunc) {
                        return flatRest(function(iteratees) {
                            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                            return baseRest(function(args) {
                                var thisArg = this;
                                return arrayFunc(iteratees, function(iteratee) {
                                    return apply(iteratee, thisArg, args);
                                });
                            });
                        });
                    }
                    function createPadding(length, chars) {
                        chars = chars === undefined$1 ? ' ' : baseToString(chars);
                        var charsLength = chars.length;
                        if (charsLength < 2) {
                            return charsLength ? baseRepeat(chars, length) : chars;
                        }
                        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
                    }
                    function createPartial(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                        function wrapper() {
                            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
                            while(++leftIndex < leftLength){
                                args[leftIndex] = partials[leftIndex];
                            }
                            while(argsLength--){
                                args[leftIndex++] = arguments[++argsIndex];
                            }
                            return apply(fn, isBind ? thisArg : this, args);
                        }
                        return wrapper;
                    }
                    function createRange(fromRight) {
                        return function(start, end, step) {
                            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                                end = step = undefined$1;
                            }
                            start = toFinite(start);
                            if (end === undefined$1) {
                                end = start;
                                start = 0;
                            } else {
                                end = toFinite(end);
                            }
                            step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
                            return baseRange(start, end, step, fromRight);
                        };
                    }
                    function createRelationalOperation(operator) {
                        return function(value, other) {
                            if (!(typeof value == 'string' && typeof other == 'string')) {
                                value = toNumber(value);
                                other = toNumber(other);
                            }
                            return operator(value, other);
                        };
                    }
                    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
                        bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
                        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                            bitmask &= -4;
                        }
                        var newData = [
                            func,
                            bitmask,
                            thisArg,
                            newPartials,
                            newHolders,
                            newPartialsRight,
                            newHoldersRight,
                            argPos,
                            ary,
                            arity
                        ];
                        var result = wrapFunc.apply(undefined$1, newData);
                        if (isLaziable(func)) {
                            setData(result, newData);
                        }
                        result.placeholder = placeholder;
                        return setWrapToString(result, func, bitmask);
                    }
                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function(number, precision) {
                            number = toNumber(number);
                            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                            if (precision && nativeIsFinite(number)) {
                                var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
                                pair = (toString(value) + 'e').split('e');
                                return +(pair[0] + 'e' + (+pair[1] - precision));
                            }
                            return func(number);
                        };
                    }
                    var createSet = !(Set && (1 / setToArray(new Set([
                        ,
                        -0
                    ]))[1]) == INFINITY) ? noop : function(values) {
                        return new Set(values);
                    };
                    function createToPairs(keysFunc) {
                        return function(object) {
                            var tag = getTag(object);
                            if (tag == mapTag) {
                                return mapToArray(object);
                            }
                            if (tag == setTag) {
                                return setToPairs(object);
                            }
                            return baseToPairs(object, keysFunc(object));
                        };
                    }
                    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                        if (!isBindKey && typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = partials ? partials.length : 0;
                        if (!length) {
                            bitmask &= -97;
                            partials = holders = undefined$1;
                        }
                        ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
                        arity = arity === undefined$1 ? arity : toInteger(arity);
                        length -= holders ? holders.length : 0;
                        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials, holdersRight = holders;
                            partials = holders = undefined$1;
                        }
                        var data = isBindKey ? undefined$1 : getData(func);
                        var newData = [
                            func,
                            bitmask,
                            thisArg,
                            partials,
                            holders,
                            partialsRight,
                            holdersRight,
                            argPos,
                            ary,
                            arity
                        ];
                        if (data) {
                            mergeData(newData, data);
                        }
                        func = newData[0];
                        bitmask = newData[1];
                        thisArg = newData[2];
                        partials = newData[3];
                        holders = newData[4];
                        arity = newData[9] = newData[9] === undefined$1 ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0);
                        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                            bitmask &= -25;
                        }
                        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                            var result = createBind(func, bitmask, thisArg);
                        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                            result = createCurry(func, bitmask, arity);
                        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                            result = createPartial(func, bitmask, thisArg, partials);
                        } else {
                            result = createHybrid.apply(undefined$1, newData);
                        }
                        var setter = data ? baseSetData : setData;
                        return setWrapToString(setter(result, newData), func, bitmask);
                    }
                    function customDefaultsAssignIn(objValue, srcValue, key, object) {
                        if (objValue === undefined$1 || (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                            return srcValue;
                        }
                        return objValue;
                    }
                    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                        if (isObject(objValue) && isObject(srcValue)) {
                            stack.set(srcValue, objValue);
                            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
                            stack['delete'](srcValue);
                        }
                        return objValue;
                    }
                    function customOmitClone(value) {
                        return isPlainObject(value) ? undefined$1 : value;
                    }
                    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                            return false;
                        }
                        var arrStacked = stack.get(array);
                        var othStacked = stack.get(other);
                        if (arrStacked && othStacked) {
                            return arrStacked == other && othStacked == array;
                        }
                        var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;
                        stack.set(array, other);
                        stack.set(other, array);
                        while(++index < arrLength){
                            var arrValue = array[index], othValue = other[index];
                            if (customizer) {
                                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                            }
                            if (compared !== undefined$1) {
                                if (compared) {
                                    continue;
                                }
                                result = false;
                                break;
                            }
                            if (seen) {
                                if (!arraySome(other, function(othValue, othIndex) {
                                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                        return seen.push(othIndex);
                                    }
                                })) {
                                    result = false;
                                    break;
                                }
                            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                                result = false;
                                break;
                            }
                        }
                        stack['delete'](array);
                        stack['delete'](other);
                        return result;
                    }
                    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                        switch(tag){
                            case dataViewTag:
                                if ((object.byteLength != other.byteLength) || (object.byteOffset != other.byteOffset)) {
                                    return false;
                                }
                                object = object.buffer;
                                other = other.buffer;
                            case arrayBufferTag:
                                if ((object.byteLength != other.byteLength) || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                                    return false;
                                }
                                return true;
                            case boolTag:
                            case dateTag:
                            case numberTag:
                                return eq(+object, +other);
                            case errorTag:
                                return object.name == other.name && object.message == other.message;
                            case regexpTag:
                            case stringTag:
                                return object == (other + '');
                            case mapTag:
                                var convert = mapToArray;
                            case setTag:
                                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                                convert || (convert = setToArray);
                                if (object.size != other.size && !isPartial) {
                                    return false;
                                }
                                var stacked = stack.get(object);
                                if (stacked) {
                                    return stacked == other;
                                }
                                bitmask |= COMPARE_UNORDERED_FLAG;
                                stack.set(object, other);
                                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                                stack['delete'](object);
                                return result;
                            case symbolTag:
                                if (symbolValueOf) {
                                    return symbolValueOf.call(object) == symbolValueOf.call(other);
                                }
                        }
                        return false;
                    }
                    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                        if (objLength != othLength && !isPartial) {
                            return false;
                        }
                        var index = objLength;
                        while(index--){
                            var key = objProps[index];
                            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                                return false;
                            }
                        }
                        var objStacked = stack.get(object);
                        var othStacked = stack.get(other);
                        if (objStacked && othStacked) {
                            return objStacked == other && othStacked == object;
                        }
                        var result = true;
                        stack.set(object, other);
                        stack.set(other, object);
                        var skipCtor = isPartial;
                        while(++index < objLength){
                            key = objProps[index];
                            var objValue = object[key], othValue = other[key];
                            if (customizer) {
                                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                            }
                            if (!(compared === undefined$1 ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)) : compared)) {
                                result = false;
                                break;
                            }
                            skipCtor || (skipCtor = key == 'constructor');
                        }
                        if (result && !skipCtor) {
                            var objCtor = object.constructor, othCtor = other.constructor;
                            if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                                result = false;
                            }
                        }
                        stack['delete'](object);
                        stack['delete'](other);
                        return result;
                    }
                    function flatRest(func) {
                        return setToString(overRest(func, undefined$1, flatten), func + '');
                    }
                    function getAllKeys(object) {
                        return baseGetAllKeys(object, keys, getSymbols);
                    }
                    function getAllKeysIn(object) {
                        return baseGetAllKeys(object, keysIn, getSymbolsIn);
                    }
                    var getData = !metaMap ? noop : function(func) {
                        return metaMap.get(func);
                    };
                    function getFuncName(func) {
                        var result = (func.name + ''), array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
                        while(length--){
                            var data = array[length], otherFunc = data.func;
                            if (otherFunc == null || otherFunc == func) {
                                return data.name;
                            }
                        }
                        return result;
                    }
                    function getHolder(func) {
                        var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
                        return object.placeholder;
                    }
                    function getIteratee() {
                        var result = lodash.iteratee || iteratee;
                        result = result === iteratee ? baseIteratee : result;
                        return arguments.length ? result(arguments[0], arguments[1]) : result;
                    }
                    function getMapData(map, key) {
                        var data = map.__data__;
                        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
                    }
                    function getMatchData(object) {
                        var result = keys(object), length = result.length;
                        while(length--){
                            var key = result[length], value = object[key];
                            result[length] = [
                                key,
                                value,
                                isStrictComparable(value)
                            ];
                        }
                        return result;
                    }
                    function getNative(object, key) {
                        var value = getValue(object, key);
                        return baseIsNative(value) ? value : undefined$1;
                    }
                    function getRawTag(value) {
                        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                        try {
                            value[symToStringTag] = undefined$1;
                            var unmasked = true;
                        } catch (e) {}
                        var result = nativeObjectToString.call(value);
                        if (unmasked) {
                            if (isOwn) {
                                value[symToStringTag] = tag;
                            } else {
                                delete value[symToStringTag];
                            }
                        }
                        return result;
                    }
                    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                        if (object == null) {
                            return [];
                        }
                        object = Object(object);
                        return arrayFilter(nativeGetSymbols(object), function(symbol) {
                            return propertyIsEnumerable.call(object, symbol);
                        });
                    };
                    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                        var result = [];
                        while(object){
                            arrayPush(result, getSymbols(object));
                            object = getPrototype(object);
                        }
                        return result;
                    };
                    var getTag = baseGetTag;
                    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) || (Map && getTag(new Map) != mapTag) || (Promise && getTag(Promise.resolve()) != promiseTag) || (Set && getTag(new Set) != setTag) || (WeakMap && getTag(new WeakMap) != weakMapTag)) {
                        getTag = function(value) {
                            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : '';
                            if (ctorString) {
                                switch(ctorString){
                                    case dataViewCtorString:
                                        return dataViewTag;
                                    case mapCtorString:
                                        return mapTag;
                                    case promiseCtorString:
                                        return promiseTag;
                                    case setCtorString:
                                        return setTag;
                                    case weakMapCtorString:
                                        return weakMapTag;
                                }
                            }
                            return result;
                        };
                    }
                    function getView(start, end, transforms) {
                        var index = -1, length = transforms.length;
                        while(++index < length){
                            var data = transforms[index], size = data.size;
                            switch(data.type){
                                case 'drop':
                                    start += size;
                                    break;
                                case 'dropRight':
                                    end -= size;
                                    break;
                                case 'take':
                                    end = nativeMin(end, start + size);
                                    break;
                                case 'takeRight':
                                    start = nativeMax(start, end - size);
                                    break;
                            }
                        }
                        return {
                            'start': start,
                            'end': end
                        };
                    }
                    function getWrapDetails(source) {
                        var match = source.match(reWrapDetails);
                        return match ? match[1].split(reSplitDetails) : [];
                    }
                    function hasPath(object, path, hasFunc) {
                        path = castPath(path, object);
                        var index = -1, length = path.length, result = false;
                        while(++index < length){
                            var key = toKey(path[index]);
                            if (!(result = object != null && hasFunc(object, key))) {
                                break;
                            }
                            object = object[key];
                        }
                        if (result || ++index != length) {
                            return result;
                        }
                        length = object == null ? 0 : object.length;
                        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
                    }
                    function initCloneArray(array) {
                        var length = array.length, result = new array.constructor(length);
                        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                            result.index = array.index;
                            result.input = array.input;
                        }
                        return result;
                    }
                    function initCloneObject(object) {
                        return (typeof object.constructor == 'function' && !isPrototype(object)) ? baseCreate(getPrototype(object)) : {};
                    }
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch(tag){
                            case arrayBufferTag:
                                return cloneArrayBuffer(object);
                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);
                            case dataViewTag:
                                return cloneDataView(object, isDeep);
                            case float32Tag:
                            case float64Tag:
                            case int8Tag:
                            case int16Tag:
                            case int32Tag:
                            case uint8Tag:
                            case uint8ClampedTag:
                            case uint16Tag:
                            case uint32Tag:
                                return cloneTypedArray(object, isDeep);
                            case mapTag:
                                return new Ctor;
                            case numberTag:
                            case stringTag:
                                return new Ctor(object);
                            case regexpTag:
                                return cloneRegExp(object);
                            case setTag:
                                return new Ctor;
                            case symbolTag:
                                return cloneSymbol(object);
                        }
                    }
                    function insertWrapDetails(source, details) {
                        var length = details.length;
                        if (!length) {
                            return source;
                        }
                        var lastIndex = length - 1;
                        details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
                        details = details.join(length > 2 ? ', ' : ' ');
                        return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
                    }
                    function isFlattenable(value) {
                        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                    }
                    function isIndex(value, length) {
                        var type = typeof value;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return !!length && (type == 'number' || (type != 'symbol' && reIsUint.test(value))) && (value > -1 && value % 1 == 0 && value < length);
                    }
                    function isIterateeCall(value, index, object) {
                        if (!isObject(object)) {
                            return false;
                        }
                        var type = typeof index;
                        if (type == 'number' ? (isArrayLike(object) && isIndex(index, object.length)) : (type == 'string' && index in object)) {
                            return eq(object[index], value);
                        }
                        return false;
                    }
                    function isKey(value, object) {
                        if (isArray(value)) {
                            return false;
                        }
                        var type = typeof value;
                        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
                            return true;
                        }
                        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object));
                    }
                    function isKeyable(value) {
                        var type = typeof value;
                        return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean') ? (value !== '__proto__') : (value === null);
                    }
                    function isLaziable(func) {
                        var funcName = getFuncName(func), other = lodash[funcName];
                        if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
                            return false;
                        }
                        if (func === other) {
                            return true;
                        }
                        var data = getData(other);
                        return !!data && func === data[0];
                    }
                    function isMasked(func) {
                        return !!maskSrcKey && (maskSrcKey in func);
                    }
                    var isMaskable = coreJsData ? isFunction : stubFalse;
                    function isPrototype(value) {
                        var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
                        return value === proto;
                    }
                    function isStrictComparable(value) {
                        return value === value && !isObject(value);
                    }
                    function matchesStrictComparable(key, srcValue) {
                        return function(object) {
                            if (object == null) {
                                return false;
                            }
                            return object[key] === srcValue && (srcValue !== undefined$1 || (key in Object(object)));
                        };
                    }
                    function memoizeCapped(func) {
                        var result = memoize(func, function(key) {
                            if (cache.size === MAX_MEMOIZE_SIZE) {
                                cache.clear();
                            }
                            return key;
                        });
                        var cache = result.cache;
                        return result;
                    }
                    function mergeData(data, source) {
                        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                        var isCombo = ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) || ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) || ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
                        if (!(isCommon || isCombo)) {
                            return data;
                        }
                        if (srcBitmask & WRAP_BIND_FLAG) {
                            data[2] = source[2];
                            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                        }
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                        }
                        value = source[5];
                        if (value) {
                            partials = data[5];
                            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                        }
                        value = source[7];
                        if (value) {
                            data[7] = value;
                        }
                        if (srcBitmask & WRAP_ARY_FLAG) {
                            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                        }
                        if (data[9] == null) {
                            data[9] = source[9];
                        }
                        data[0] = source[0];
                        data[1] = newBitmask;
                        return data;
                    }
                    function nativeKeysIn(object) {
                        var result = [];
                        if (object != null) {
                            for(var key in Object(object)){
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function objectToString(value) {
                        return nativeObjectToString.call(value);
                    }
                    function overRest(func, start, transform) {
                        start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
                        return function() {
                            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                            while(++index < length){
                                array[index] = args[start + index];
                            }
                            index = -1;
                            var otherArgs = Array(start + 1);
                            while(++index < start){
                                otherArgs[index] = args[index];
                            }
                            otherArgs[start] = transform(array);
                            return apply(func, this, otherArgs);
                        };
                    }
                    function parent(object, path) {
                        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                    }
                    function reorder(array, indexes) {
                        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                        while(length--){
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
                        }
                        return array;
                    }
                    function safeGet(object, key) {
                        if (key === 'constructor' && typeof object[key] === 'function') {
                            return;
                        }
                        if (key == '__proto__') {
                            return;
                        }
                        return object[key];
                    }
                    var setData = shortOut(baseSetData);
                    var setTimeout = ctxSetTimeout || function(func, wait) {
                        return root.setTimeout(func, wait);
                    };
                    var setToString = shortOut(baseSetToString);
                    function setWrapToString(wrapper, reference, bitmask) {
                        var source = (reference + '');
                        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                    }
                    function shortOut(func) {
                        var count = 0, lastCalled = 0;
                        return function() {
                            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                            lastCalled = stamp;
                            if (remaining > 0) {
                                if (++count >= HOT_COUNT) {
                                    return arguments[0];
                                }
                            } else {
                                count = 0;
                            }
                            return func.apply(undefined$1, arguments);
                        };
                    }
                    function shuffleSelf(array, size) {
                        var index = -1, length = array.length, lastIndex = length - 1;
                        size = size === undefined$1 ? length : size;
                        while(++index < size){
                            var rand = baseRandom(index, lastIndex), value = array[rand];
                            array[rand] = array[index];
                            array[index] = value;
                        }
                        array.length = size;
                        return array;
                    }
                    var stringToPath = memoizeCapped(function(string) {
                        var result = [];
                        if (string.charCodeAt(0) === 46) {
                            result.push('');
                        }
                        string.replace(rePropName, function(match, number, quote, subString) {
                            result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
                        });
                        return result;
                    });
                    function toKey(value) {
                        if (typeof value == 'string' || isSymbol(value)) {
                            return value;
                        }
                        var result = (value + '');
                        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
                    }
                    function toSource(func) {
                        if (func != null) {
                            try {
                                return funcToString.call(func);
                            } catch (e) {}
                            try {
                                return (func + '');
                            } catch (e) {}
                        }
                        return '';
                    }
                    function updateWrapDetails(details, bitmask) {
                        arrayEach(wrapFlags, function(pair) {
                            var value = '_.' + pair[0];
                            if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
                                details.push(value);
                            }
                        });
                        return details.sort();
                    }
                    function wrapperClone(wrapper) {
                        if (wrapper instanceof LazyWrapper) {
                            return wrapper.clone();
                        }
                        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                        result.__actions__ = copyArray(wrapper.__actions__);
                        result.__index__ = wrapper.__index__;
                        result.__values__ = wrapper.__values__;
                        return result;
                    }
                    function chunk(array, size, guard) {
                        if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
                            size = 1;
                        } else {
                            size = nativeMax(toInteger(size), 0);
                        }
                        var length = array == null ? 0 : array.length;
                        if (!length || size < 1) {
                            return [];
                        }
                        var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
                        while(index < length){
                            result[resIndex++] = baseSlice(array, index, (index += size));
                        }
                        return result;
                    }
                    function compact(array) {
                        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                        while(++index < length){
                            var value = array[index];
                            if (value) {
                                result[resIndex++] = value;
                            }
                        }
                        return result;
                    }
                    function concat() {
                        var length = arguments.length;
                        if (!length) {
                            return [];
                        }
                        var args = Array(length - 1), array = arguments[0], index = length;
                        while(index--){
                            args[index - 1] = arguments[index];
                        }
                        return arrayPush(isArray(array) ? copyArray(array) : [
                            array
                        ], baseFlatten(args, 1));
                    }
                    var difference = baseRest(function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
                    });
                    var differenceBy = baseRest(function(array, values) {
                        var iteratee = last(values);
                        if (isArrayLikeObject(iteratee)) {
                            iteratee = undefined$1;
                        }
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
                    });
                    var differenceWith = baseRest(function(array, values) {
                        var comparator = last(values);
                        if (isArrayLikeObject(comparator)) {
                            comparator = undefined$1;
                        }
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
                    });
                    function drop(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        n = (guard || n === undefined$1) ? 1 : toInteger(n);
                        return baseSlice(array, n < 0 ? 0 : n, length);
                    }
                    function dropRight(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        n = (guard || n === undefined$1) ? 1 : toInteger(n);
                        n = length - n;
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }
                    function dropRightWhile(array, predicate) {
                        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                    }
                    function dropWhile(array, predicate) {
                        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                    }
                    function fill(array, value, start, end) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                            start = 0;
                            end = length;
                        }
                        return baseFill(array, value, start, end);
                    }
                    function findIndex(array, predicate, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = fromIndex == null ? 0 : toInteger(fromIndex);
                        if (index < 0) {
                            index = nativeMax(length + index, 0);
                        }
                        return baseFindIndex(array, getIteratee(predicate, 3), index);
                    }
                    function findLastIndex(array, predicate, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = length - 1;
                        if (fromIndex !== undefined$1) {
                            index = toInteger(fromIndex);
                            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                        }
                        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                    }
                    function flatten(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseFlatten(array, 1) : [];
                    }
                    function flattenDeep(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseFlatten(array, INFINITY) : [];
                    }
                    function flattenDepth(array, depth) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        depth = depth === undefined$1 ? 1 : toInteger(depth);
                        return baseFlatten(array, depth);
                    }
                    function fromPairs(pairs) {
                        var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
                        while(++index < length){
                            var pair = pairs[index];
                            result[pair[0]] = pair[1];
                        }
                        return result;
                    }
                    function head(array) {
                        return (array && array.length) ? array[0] : undefined$1;
                    }
                    function indexOf(array, value, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = fromIndex == null ? 0 : toInteger(fromIndex);
                        if (index < 0) {
                            index = nativeMax(length + index, 0);
                        }
                        return baseIndexOf(array, value, index);
                    }
                    function initial(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseSlice(array, 0, -1) : [];
                    }
                    var intersection = baseRest(function(arrays) {
                        var mapped = arrayMap(arrays, castArrayLikeObject);
                        return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped) : [];
                    });
                    var intersectionBy = baseRest(function(arrays) {
                        var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        if (iteratee === last(mapped)) {
                            iteratee = undefined$1;
                        } else {
                            mapped.pop();
                        }
                        return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
                    });
                    var intersectionWith = baseRest(function(arrays) {
                        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                        comparator = typeof comparator == 'function' ? comparator : undefined$1;
                        if (comparator) {
                            mapped.pop();
                        }
                        return (mapped.length && mapped[0] === arrays[0]) ? baseIntersection(mapped, undefined$1, comparator) : [];
                    });
                    function join(array, separator) {
                        return array == null ? '' : nativeJoin.call(array, separator);
                    }
                    function last(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? array[length - 1] : undefined$1;
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return -1;
                        }
                        var index = length;
                        if (fromIndex !== undefined$1) {
                            index = toInteger(fromIndex);
                            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                        }
                        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                    }
                    function nth(array, n) {
                        return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
                    }
                    var pull = baseRest(pullAll);
                    function pullAll(array, values) {
                        return (array && array.length && values && values.length) ? basePullAll(array, values) : array;
                    }
                    function pullAllBy(array, values, iteratee) {
                        return (array && array.length && values && values.length) ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
                    }
                    function pullAllWith(array, values, comparator) {
                        return (array && array.length && values && values.length) ? basePullAll(array, values, undefined$1, comparator) : array;
                    }
                    var pullAt = flatRest(function(array, indexes) {
                        var length = array == null ? 0 : array.length, result = baseAt(array, indexes);
                        basePullAt(array, arrayMap(indexes, function(index) {
                            return isIndex(index, length) ? +index : index;
                        }).sort(compareAscending));
                        return result;
                    });
                    function remove(array, predicate) {
                        var result = [];
                        if (!(array && array.length)) {
                            return result;
                        }
                        var index = -1, indexes = [], length = array.length;
                        predicate = getIteratee(predicate, 3);
                        while(++index < length){
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result.push(value);
                                indexes.push(index);
                            }
                        }
                        basePullAt(array, indexes);
                        return result;
                    }
                    function reverse(array) {
                        return array == null ? array : nativeReverse.call(array);
                    }
                    function slice(array, start, end) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                            start = 0;
                            end = length;
                        } else {
                            start = start == null ? 0 : toInteger(start);
                            end = end === undefined$1 ? length : toInteger(end);
                        }
                        return baseSlice(array, start, end);
                    }
                    function sortedIndex(array, value) {
                        return baseSortedIndex(array, value);
                    }
                    function sortedIndexBy(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
                    }
                    function sortedIndexOf(array, value) {
                        var length = array == null ? 0 : array.length;
                        if (length) {
                            var index = baseSortedIndex(array, value);
                            if (index < length && eq(array[index], value)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function sortedLastIndex(array, value) {
                        return baseSortedIndex(array, value, true);
                    }
                    function sortedLastIndexBy(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
                    }
                    function sortedLastIndexOf(array, value) {
                        var length = array == null ? 0 : array.length;
                        if (length) {
                            var index = baseSortedIndex(array, value, true) - 1;
                            if (eq(array[index], value)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function sortedUniq(array) {
                        return (array && array.length) ? baseSortedUniq(array) : [];
                    }
                    function sortedUniqBy(array, iteratee) {
                        return (array && array.length) ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
                    }
                    function tail(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseSlice(array, 1, length) : [];
                    }
                    function take(array, n, guard) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        n = (guard || n === undefined$1) ? 1 : toInteger(n);
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }
                    function takeRight(array, n, guard) {
                        var length = array == null ? 0 : array.length;
                        if (!length) {
                            return [];
                        }
                        n = (guard || n === undefined$1) ? 1 : toInteger(n);
                        n = length - n;
                        return baseSlice(array, n < 0 ? 0 : n, length);
                    }
                    function takeRightWhile(array, predicate) {
                        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                    }
                    function takeWhile(array, predicate) {
                        return (array && array.length) ? baseWhile(array, getIteratee(predicate, 3)) : [];
                    }
                    var union = baseRest(function(arrays) {
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                    });
                    var unionBy = baseRest(function(arrays) {
                        var iteratee = last(arrays);
                        if (isArrayLikeObject(iteratee)) {
                            iteratee = undefined$1;
                        }
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
                    });
                    var unionWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        comparator = typeof comparator == 'function' ? comparator : undefined$1;
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
                    });
                    function uniq(array) {
                        return (array && array.length) ? baseUniq(array) : [];
                    }
                    function uniqBy(array, iteratee) {
                        return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
                    }
                    function uniqWith(array, comparator) {
                        comparator = typeof comparator == 'function' ? comparator : undefined$1;
                        return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
                    }
                    function unzip(array) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        var length = 0;
                        array = arrayFilter(array, function(group) {
                            if (isArrayLikeObject(group)) {
                                length = nativeMax(group.length, length);
                                return true;
                            }
                        });
                        return baseTimes(length, function(index) {
                            return arrayMap(array, baseProperty(index));
                        });
                    }
                    function unzipWith(array, iteratee) {
                        if (!(array && array.length)) {
                            return [];
                        }
                        var result = unzip(array);
                        if (iteratee == null) {
                            return result;
                        }
                        return arrayMap(result, function(group) {
                            return apply(iteratee, undefined$1, group);
                        });
                    }
                    var without = baseRest(function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, values) : [];
                    });
                    var xor = baseRest(function(arrays) {
                        return baseXor(arrayFilter(arrays, isArrayLikeObject));
                    });
                    var xorBy = baseRest(function(arrays) {
                        var iteratee = last(arrays);
                        if (isArrayLikeObject(iteratee)) {
                            iteratee = undefined$1;
                        }
                        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
                    });
                    var xorWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        comparator = typeof comparator == 'function' ? comparator : undefined$1;
                        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
                    });
                    var zip = baseRest(unzip);
                    function zipObject(props, values) {
                        return baseZipObject(props || [], values || [], assignValue);
                    }
                    function zipObjectDeep(props, values) {
                        return baseZipObject(props || [], values || [], baseSet);
                    }
                    var zipWith = baseRest(function(arrays) {
                        var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined$1;
                        iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
                        return unzipWith(arrays, iteratee);
                    });
                    function chain(value) {
                        var result = lodash(value);
                        result.__chain__ = true;
                        return result;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function thru(value, interceptor) {
                        return interceptor(value);
                    }
                    var wrapperAt = flatRest(function(paths) {
                        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                            return baseAt(object, paths);
                        };
                        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                            return this.thru(interceptor);
                        }
                        value = value.slice(start, +start + (length ? 1 : 0));
                        value.__actions__.push({
                            'func': thru,
                            'args': [
                                interceptor
                            ],
                            'thisArg': undefined$1
                        });
                        return new LodashWrapper(value, this.__chain__).thru(function(array) {
                            if (length && !array.length) {
                                array.push(undefined$1);
                            }
                            return array;
                        });
                    });
                    function wrapperChain() {
                        return chain(this);
                    }
                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__);
                    }
                    function wrapperNext() {
                        if (this.__values__ === undefined$1) {
                            this.__values__ = toArray(this.value());
                        }
                        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
                        return {
                            'done': done,
                            'value': value
                        };
                    }
                    function wrapperToIterator() {
                        return this;
                    }
                    function wrapperPlant(value) {
                        var result, parent = this;
                        while(parent instanceof baseLodash){
                            var clone = wrapperClone(parent);
                            clone.__index__ = 0;
                            clone.__values__ = undefined$1;
                            if (result) {
                                previous.__wrapped__ = clone;
                            } else {
                                result = clone;
                            }
                            var previous = clone;
                            parent = parent.__wrapped__;
                        }
                        previous.__wrapped__ = value;
                        return result;
                    }
                    function wrapperReverse() {
                        var value = this.__wrapped__;
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            if (this.__actions__.length) {
                                wrapped = new LazyWrapper(this);
                            }
                            wrapped = wrapped.reverse();
                            wrapped.__actions__.push({
                                'func': thru,
                                'args': [
                                    reverse
                                ],
                                'thisArg': undefined$1
                            });
                            return new LodashWrapper(wrapped, this.__chain__);
                        }
                        return this.thru(reverse);
                    }
                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            ++result[key];
                        } else {
                            baseAssignValue(result, key, 1);
                        }
                    });
                    function every(collection, predicate, guard) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        if (guard && isIterateeCall(collection, predicate, guard)) {
                            predicate = undefined$1;
                        }
                        return func(collection, getIteratee(predicate, 3));
                    }
                    function filter(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return func(collection, getIteratee(predicate, 3));
                    }
                    var find = createFind(findIndex);
                    var findLast = createFind(findLastIndex);
                    function flatMap(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), 1);
                    }
                    function flatMapDeep(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), INFINITY);
                    }
                    function flatMapDepth(collection, iteratee, depth) {
                        depth = depth === undefined$1 ? 1 : toInteger(depth);
                        return baseFlatten(map(collection, iteratee), depth);
                    }
                    function forEach(collection, iteratee) {
                        var func = isArray(collection) ? arrayEach : baseEach;
                        return func(collection, getIteratee(iteratee, 3));
                    }
                    function forEachRight(collection, iteratee) {
                        var func = isArray(collection) ? arrayEachRight : baseEachRight;
                        return func(collection, getIteratee(iteratee, 3));
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            result[key].push(value);
                        } else {
                            baseAssignValue(result, key, [
                                value
                            ]);
                        }
                    });
                    function includes(collection, value, fromIndex, guard) {
                        collection = isArrayLike(collection) ? collection : values(collection);
                        fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
                        var length = collection.length;
                        if (fromIndex < 0) {
                            fromIndex = nativeMax(length + fromIndex, 0);
                        }
                        return isString(collection) ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1) : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
                    }
                    var invokeMap = baseRest(function(collection, path, args) {
                        var index = -1, isFunc = typeof path == 'function', result = isArrayLike(collection) ? Array(collection.length) : [];
                        baseEach(collection, function(value) {
                            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                        });
                        return result;
                    });
                    var keyBy = createAggregator(function(result, value, key) {
                        baseAssignValue(result, key, value);
                    });
                    function map(collection, iteratee) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        return func(collection, getIteratee(iteratee, 3));
                    }
                    function orderBy(collection, iteratees, orders, guard) {
                        if (collection == null) {
                            return [];
                        }
                        if (!isArray(iteratees)) {
                            iteratees = iteratees == null ? [] : [
                                iteratees
                            ];
                        }
                        orders = guard ? undefined$1 : orders;
                        if (!isArray(orders)) {
                            orders = orders == null ? [] : [
                                orders
                            ];
                        }
                        return baseOrderBy(collection, iteratees, orders);
                    }
                    var partition = createAggregator(function(result, value, key) {
                        result[key ? 0 : 1].push(value);
                    }, function() {
                        return [
                            [],
                            []
                        ];
                    });
                    function reduce(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
                    }
                    function reduceRight(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
                    }
                    function reject(collection, predicate) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        return func(collection, negate(getIteratee(predicate, 3)));
                    }
                    function sample(collection) {
                        var func = isArray(collection) ? arraySample : baseSample;
                        return func(collection);
                    }
                    function sampleSize(collection, n, guard) {
                        if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
                            n = 1;
                        } else {
                            n = toInteger(n);
                        }
                        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                        return func(collection, n);
                    }
                    function shuffle(collection) {
                        var func = isArray(collection) ? arrayShuffle : baseShuffle;
                        return func(collection);
                    }
                    function size(collection) {
                        if (collection == null) {
                            return 0;
                        }
                        if (isArrayLike(collection)) {
                            return isString(collection) ? stringSize(collection) : collection.length;
                        }
                        var tag = getTag(collection);
                        if (tag == mapTag || tag == setTag) {
                            return collection.size;
                        }
                        return baseKeys(collection).length;
                    }
                    function some(collection, predicate, guard) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        if (guard && isIterateeCall(collection, predicate, guard)) {
                            predicate = undefined$1;
                        }
                        return func(collection, getIteratee(predicate, 3));
                    }
                    var sortBy = baseRest(function(collection, iteratees) {
                        if (collection == null) {
                            return [];
                        }
                        var length = iteratees.length;
                        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                            iteratees = [];
                        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                            iteratees = [
                                iteratees[0]
                            ];
                        }
                        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                    });
                    var now = ctxNow || function() {
                        return root.Date.now();
                    };
                    function after(n, func) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        n = toInteger(n);
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function ary(func, n, guard) {
                        n = guard ? undefined$1 : n;
                        n = (func && n == null) ? func.length : n;
                        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
                    }
                    function before(n, func) {
                        var result;
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        n = toInteger(n);
                        return function() {
                            if (--n > 0) {
                                result = func.apply(this, arguments);
                            }
                            if (n <= 1) {
                                func = undefined$1;
                            }
                            return result;
                        };
                    }
                    var bind = baseRest(function(func, thisArg, partials) {
                        var bitmask = WRAP_BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bind));
                            bitmask |= WRAP_PARTIAL_FLAG;
                        }
                        return createWrap(func, bitmask, thisArg, partials, holders);
                    });
                    var bindKey = baseRest(function(object, key, partials) {
                        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bindKey));
                            bitmask |= WRAP_PARTIAL_FLAG;
                        }
                        return createWrap(key, bitmask, object, partials, holders);
                    });
                    function curry(func, arity, guard) {
                        arity = guard ? undefined$1 : arity;
                        var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                        result.placeholder = curry.placeholder;
                        return result;
                    }
                    function curryRight(func, arity, guard) {
                        arity = guard ? undefined$1 : arity;
                        var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                        result.placeholder = curryRight.placeholder;
                        return result;
                    }
                    function debounce(func, wait, options) {
                        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        wait = toNumber(wait) || 0;
                        if (isObject(options)) {
                            leading = !!options.leading;
                            maxing = 'maxWait' in options;
                            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }
                        function invokeFunc(time) {
                            var args = lastArgs, thisArg = lastThis;
                            lastArgs = lastThis = undefined$1;
                            lastInvokeTime = time;
                            result = func.apply(thisArg, args);
                            return result;
                        }
                        function leadingEdge(time) {
                            lastInvokeTime = time;
                            timerId = setTimeout(timerExpired, wait);
                            return leading ? invokeFunc(time) : result;
                        }
                        function remainingWait(time) {
                            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                        }
                        function shouldInvoke(time) {
                            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                            return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
                        }
                        function timerExpired() {
                            var time = now();
                            if (shouldInvoke(time)) {
                                return trailingEdge(time);
                            }
                            timerId = setTimeout(timerExpired, remainingWait(time));
                        }
                        function trailingEdge(time) {
                            timerId = undefined$1;
                            if (trailing && lastArgs) {
                                return invokeFunc(time);
                            }
                            lastArgs = lastThis = undefined$1;
                            return result;
                        }
                        function cancel() {
                            if (timerId !== undefined$1) {
                                clearTimeout(timerId);
                            }
                            lastInvokeTime = 0;
                            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
                        }
                        function flush() {
                            return timerId === undefined$1 ? result : trailingEdge(now());
                        }
                        function debounced() {
                            var time = now(), isInvoking = shouldInvoke(time);
                            lastArgs = arguments;
                            lastThis = this;
                            lastCallTime = time;
                            if (isInvoking) {
                                if (timerId === undefined$1) {
                                    return leadingEdge(lastCallTime);
                                }
                                if (maxing) {
                                    clearTimeout(timerId);
                                    timerId = setTimeout(timerExpired, wait);
                                    return invokeFunc(lastCallTime);
                                }
                            }
                            if (timerId === undefined$1) {
                                timerId = setTimeout(timerExpired, wait);
                            }
                            return result;
                        }
                        debounced.cancel = cancel;
                        debounced.flush = flush;
                        return debounced;
                    }
                    var defer = baseRest(function(func, args) {
                        return baseDelay(func, 1, args);
                    });
                    var delay = baseRest(function(func, wait, args) {
                        return baseDelay(func, toNumber(wait) || 0, args);
                    });
                    function flip(func) {
                        return createWrap(func, WRAP_FLIP_FLAG);
                    }
                    function memoize(func, resolver) {
                        if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var memoized = function() {
                            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                            if (cache.has(key)) {
                                return cache.get(key);
                            }
                            var result = func.apply(this, args);
                            memoized.cache = cache.set(key, result) || cache;
                            return result;
                        };
                        memoized.cache = new (memoize.Cache || MapCache);
                        return memoized;
                    }
                    memoize.Cache = MapCache;
                    function negate(predicate) {
                        if (typeof predicate != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function() {
                            var args = arguments;
                            switch(args.length){
                                case 0:
                                    return !predicate.call(this);
                                case 1:
                                    return !predicate.call(this, args[0]);
                                case 2:
                                    return !predicate.call(this, args[0], args[1]);
                                case 3:
                                    return !predicate.call(this, args[0], args[1], args[2]);
                            }
                            return !predicate.apply(this, args);
                        };
                    }
                    function once(func) {
                        return before(2, func);
                    }
                    var overArgs = castRest(function(func, transforms) {
                        transforms = (transforms.length == 1 && isArray(transforms[0])) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                        var funcsLength = transforms.length;
                        return baseRest(function(args) {
                            var index = -1, length = nativeMin(args.length, funcsLength);
                            while(++index < length){
                                args[index] = transforms[index].call(this, args[index]);
                            }
                            return apply(func, this, args);
                        });
                    });
                    var partial = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partial));
                        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
                    });
                    var partialRight = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partialRight));
                        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
                    });
                    var rearg = flatRest(function(func, indexes) {
                        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
                    });
                    function rest(func, start) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = start === undefined$1 ? start : toInteger(start);
                        return baseRest(func, start);
                    }
                    function spread(func, start) {
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = start == null ? 0 : nativeMax(toInteger(start), 0);
                        return baseRest(function(args) {
                            var array = args[start], otherArgs = castSlice(args, 0, start);
                            if (array) {
                                arrayPush(otherArgs, array);
                            }
                            return apply(func, this, otherArgs);
                        });
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (typeof func != 'function') {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        if (isObject(options)) {
                            leading = 'leading' in options ? !!options.leading : leading;
                            trailing = 'trailing' in options ? !!options.trailing : trailing;
                        }
                        return debounce(func, wait, {
                            'leading': leading,
                            'maxWait': wait,
                            'trailing': trailing
                        });
                    }
                    function unary(func) {
                        return ary(func, 1);
                    }
                    function wrap(value, wrapper) {
                        return partial(castFunction(wrapper), value);
                    }
                    function castArray() {
                        if (!arguments.length) {
                            return [];
                        }
                        var value = arguments[0];
                        return isArray(value) ? value : [
                            value
                        ];
                    }
                    function clone(value) {
                        return baseClone(value, CLONE_SYMBOLS_FLAG);
                    }
                    function cloneWith(value, customizer) {
                        customizer = typeof customizer == 'function' ? customizer : undefined$1;
                        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                    }
                    function cloneDeep(value) {
                        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                    }
                    function cloneDeepWith(value, customizer) {
                        customizer = typeof customizer == 'function' ? customizer : undefined$1;
                        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                    }
                    function conformsTo(object, source) {
                        return source == null || baseConformsTo(object, source, keys(source));
                    }
                    function eq(value, other) {
                        return value === other || (value !== value && other !== other);
                    }
                    var gt = createRelationalOperation(baseGt);
                    var gte = createRelationalOperation(function(value, other) {
                        return value >= other;
                    });
                    var isArguments = baseIsArguments(function() {
                        return arguments;
                    }()) ? baseIsArguments : function(value) {
                        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
                    };
                    var isArray = Array.isArray;
                    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                    function isArrayLike(value) {
                        return value != null && isLength(value.length) && !isFunction(value);
                    }
                    function isArrayLikeObject(value) {
                        return isObjectLike(value) && isArrayLike(value);
                    }
                    function isBoolean(value) {
                        return value === true || value === false || (isObjectLike(value) && baseGetTag(value) == boolTag);
                    }
                    var isBuffer = nativeIsBuffer || stubFalse;
                    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                    function isElement(value) {
                        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                    }
                    function isEmpty(value) {
                        if (value == null) {
                            return true;
                        }
                        if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                            return !value.length;
                        }
                        var tag = getTag(value);
                        if (tag == mapTag || tag == setTag) {
                            return !value.size;
                        }
                        if (isPrototype(value)) {
                            return !baseKeys(value).length;
                        }
                        for(var key in value){
                            if (hasOwnProperty.call(value, key)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function isEqual(value, other) {
                        return baseIsEqual(value, other);
                    }
                    function isEqualWith(value, other, customizer) {
                        customizer = typeof customizer == 'function' ? customizer : undefined$1;
                        var result = customizer ? customizer(value, other) : undefined$1;
                        return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
                    }
                    function isError(value) {
                        if (!isObjectLike(value)) {
                            return false;
                        }
                        var tag = baseGetTag(value);
                        return tag == errorTag || tag == domExcTag || (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
                    }
                    function isFinite(value) {
                        return typeof value == 'number' && nativeIsFinite(value);
                    }
                    function isFunction(value) {
                        if (!isObject(value)) {
                            return false;
                        }
                        var tag = baseGetTag(value);
                        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                    }
                    function isInteger(value) {
                        return typeof value == 'number' && value == toInteger(value);
                    }
                    function isLength(value) {
                        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                    }
                    function isObject(value) {
                        var type = typeof value;
                        return value != null && (type == 'object' || type == 'function');
                    }
                    function isObjectLike(value) {
                        return value != null && typeof value == 'object';
                    }
                    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                    function isMatch(object, source) {
                        return object === source || baseIsMatch(object, source, getMatchData(source));
                    }
                    function isMatchWith(object, source, customizer) {
                        customizer = typeof customizer == 'function' ? customizer : undefined$1;
                        return baseIsMatch(object, source, getMatchData(source), customizer);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNative(value) {
                        if (isMaskable(value)) {
                            throw new Error(CORE_ERROR_TEXT);
                        }
                        return baseIsNative(value);
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNil(value) {
                        return value == null;
                    }
                    function isNumber(value) {
                        return typeof value == 'number' || (isObjectLike(value) && baseGetTag(value) == numberTag);
                    }
                    function isPlainObject(value) {
                        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                            return false;
                        }
                        var proto = getPrototype(value);
                        if (proto === null) {
                            return true;
                        }
                        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
                        return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                    }
                    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                    function isSafeInteger(value) {
                        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                    }
                    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                    function isString(value) {
                        return typeof value == 'string' || (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
                    }
                    function isSymbol(value) {
                        return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag);
                    }
                    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                    function isUndefined(value) {
                        return value === undefined$1;
                    }
                    function isWeakMap(value) {
                        return isObjectLike(value) && getTag(value) == weakMapTag;
                    }
                    function isWeakSet(value) {
                        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                    }
                    var lt = createRelationalOperation(baseLt);
                    var lte = createRelationalOperation(function(value, other) {
                        return value <= other;
                    });
                    function toArray(value) {
                        if (!value) {
                            return [];
                        }
                        if (isArrayLike(value)) {
                            return isString(value) ? stringToArray(value) : copyArray(value);
                        }
                        if (symIterator && value[symIterator]) {
                            return iteratorToArray(value[symIterator]());
                        }
                        var tag = getTag(value), func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
                        return func(value);
                    }
                    function toFinite(value) {
                        if (!value) {
                            return value === 0 ? value : 0;
                        }
                        value = toNumber(value);
                        if (value === INFINITY || value === -INFINITY) {
                            var sign = (value < 0 ? -1 : 1);
                            return sign * MAX_INTEGER;
                        }
                        return value === value ? value : 0;
                    }
                    function toInteger(value) {
                        var result = toFinite(value), remainder = result % 1;
                        return result === result ? (remainder ? result - remainder : result) : 0;
                    }
                    function toLength(value) {
                        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                    }
                    function toNumber(value) {
                        if (typeof value == 'number') {
                            return value;
                        }
                        if (isSymbol(value)) {
                            return NAN;
                        }
                        if (isObject(value)) {
                            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                            value = isObject(other) ? (other + '') : other;
                        }
                        if (typeof value != 'string') {
                            return value === 0 ? value : +value;
                        }
                        value = baseTrim(value);
                        var isBinary = reIsBinary.test(value);
                        return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value);
                    }
                    function toPlainObject(value) {
                        return copyObject(value, keysIn(value));
                    }
                    function toSafeInteger(value) {
                        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : (value === 0 ? value : 0);
                    }
                    function toString(value) {
                        return value == null ? '' : baseToString(value);
                    }
                    var assign = createAssigner(function(object, source) {
                        if (isPrototype(source) || isArrayLike(source)) {
                            copyObject(source, keys(source), object);
                            return;
                        }
                        for(var key in source){
                            if (hasOwnProperty.call(source, key)) {
                                assignValue(object, key, source[key]);
                            }
                        }
                    });
                    var assignIn = createAssigner(function(object, source) {
                        copyObject(source, keysIn(source), object);
                    });
                    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keysIn(source), object, customizer);
                    });
                    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keys(source), object, customizer);
                    });
                    var at = flatRest(baseAt);
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties == null ? result : baseAssign(result, properties);
                    }
                    var defaults = baseRest(function(object, sources) {
                        object = Object(object);
                        var index = -1;
                        var length = sources.length;
                        var guard = length > 2 ? sources[2] : undefined$1;
                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                            length = 1;
                        }
                        while(++index < length){
                            var source = sources[index];
                            var props = keysIn(source);
                            var propsIndex = -1;
                            var propsLength = props.length;
                            while(++propsIndex < propsLength){
                                var key = props[propsIndex];
                                var value = object[key];
                                if (value === undefined$1 || (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                                    object[key] = source[key];
                                }
                            }
                        }
                        return object;
                    });
                    var defaultsDeep = baseRest(function(args) {
                        args.push(undefined$1, customDefaultsMerge);
                        return apply(mergeWith, undefined$1, args);
                    });
                    function findKey(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                    }
                    function findLastKey(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                    }
                    function forIn(object, iteratee) {
                        return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
                    }
                    function forInRight(object, iteratee) {
                        return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
                    }
                    function forOwn(object, iteratee) {
                        return object && baseForOwn(object, getIteratee(iteratee, 3));
                    }
                    function forOwnRight(object, iteratee) {
                        return object && baseForOwnRight(object, getIteratee(iteratee, 3));
                    }
                    function functions(object) {
                        return object == null ? [] : baseFunctions(object, keys(object));
                    }
                    function functionsIn(object) {
                        return object == null ? [] : baseFunctions(object, keysIn(object));
                    }
                    function get(object, path, defaultValue) {
                        var result = object == null ? undefined$1 : baseGet(object, path);
                        return result === undefined$1 ? defaultValue : result;
                    }
                    function has(object, path) {
                        return object != null && hasPath(object, path, baseHas);
                    }
                    function hasIn(object, path) {
                        return object != null && hasPath(object, path, baseHasIn);
                    }
                    var invert = createInverter(function(result, value, key) {
                        if (value != null && typeof value.toString != 'function') {
                            value = nativeObjectToString.call(value);
                        }
                        result[value] = key;
                    }, constant(identity));
                    var invertBy = createInverter(function(result, value, key) {
                        if (value != null && typeof value.toString != 'function') {
                            value = nativeObjectToString.call(value);
                        }
                        if (hasOwnProperty.call(result, value)) {
                            result[value].push(key);
                        } else {
                            result[value] = [
                                key
                            ];
                        }
                    }, getIteratee);
                    var invoke = baseRest(baseInvoke);
                    function keys(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                    }
                    function keysIn(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                    }
                    function mapKeys(object, iteratee) {
                        var result = {};
                        iteratee = getIteratee(iteratee, 3);
                        baseForOwn(object, function(value, key, object) {
                            baseAssignValue(result, iteratee(value, key, object), value);
                        });
                        return result;
                    }
                    function mapValues(object, iteratee) {
                        var result = {};
                        iteratee = getIteratee(iteratee, 3);
                        baseForOwn(object, function(value, key, object) {
                            baseAssignValue(result, key, iteratee(value, key, object));
                        });
                        return result;
                    }
                    var merge = createAssigner(function(object, source, srcIndex) {
                        baseMerge(object, source, srcIndex);
                    });
                    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                        baseMerge(object, source, srcIndex, customizer);
                    });
                    var omit = flatRest(function(object, paths) {
                        var result = {};
                        if (object == null) {
                            return result;
                        }
                        var isDeep = false;
                        paths = arrayMap(paths, function(path) {
                            path = castPath(path, object);
                            isDeep || (isDeep = path.length > 1);
                            return path;
                        });
                        copyObject(object, getAllKeysIn(object), result);
                        if (isDeep) {
                            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                        }
                        var length = paths.length;
                        while(length--){
                            baseUnset(result, paths[length]);
                        }
                        return result;
                    });
                    function omitBy(object, predicate) {
                        return pickBy(object, negate(getIteratee(predicate)));
                    }
                    var pick = flatRest(function(object, paths) {
                        return object == null ? {} : basePick(object, paths);
                    });
                    function pickBy(object, predicate) {
                        if (object == null) {
                            return {};
                        }
                        var props = arrayMap(getAllKeysIn(object), function(prop) {
                            return [
                                prop
                            ];
                        });
                        predicate = getIteratee(predicate);
                        return basePickBy(object, props, function(value, path) {
                            return predicate(value, path[0]);
                        });
                    }
                    function result(object, path, defaultValue) {
                        path = castPath(path, object);
                        var index = -1, length = path.length;
                        if (!length) {
                            length = 1;
                            object = undefined$1;
                        }
                        while(++index < length){
                            var value = object == null ? undefined$1 : object[toKey(path[index])];
                            if (value === undefined$1) {
                                index = length;
                                value = defaultValue;
                            }
                            object = isFunction(value) ? value.call(object) : value;
                        }
                        return object;
                    }
                    function set(object, path, value) {
                        return object == null ? object : baseSet(object, path, value);
                    }
                    function setWith(object, path, value, customizer) {
                        customizer = typeof customizer == 'function' ? customizer : undefined$1;
                        return object == null ? object : baseSet(object, path, value, customizer);
                    }
                    var toPairs = createToPairs(keys);
                    var toPairsIn = createToPairs(keysIn);
                    function transform(object, iteratee, accumulator) {
                        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                        iteratee = getIteratee(iteratee, 4);
                        if (accumulator == null) {
                            var Ctor = object && object.constructor;
                            if (isArrLike) {
                                accumulator = isArr ? new Ctor : [];
                            } else if (isObject(object)) {
                                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                            } else {
                                accumulator = {};
                            }
                        }
                        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                            return iteratee(accumulator, value, index, object);
                        });
                        return accumulator;
                    }
                    function unset(object, path) {
                        return object == null ? true : baseUnset(object, path);
                    }
                    function update(object, path, updater) {
                        return object == null ? object : baseUpdate(object, path, castFunction(updater));
                    }
                    function updateWith(object, path, updater, customizer) {
                        customizer = typeof customizer == 'function' ? customizer : undefined$1;
                        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                    }
                    function values(object) {
                        return object == null ? [] : baseValues(object, keys(object));
                    }
                    function valuesIn(object) {
                        return object == null ? [] : baseValues(object, keysIn(object));
                    }
                    function clamp(number, lower, upper) {
                        if (upper === undefined$1) {
                            upper = lower;
                            lower = undefined$1;
                        }
                        if (upper !== undefined$1) {
                            upper = toNumber(upper);
                            upper = upper === upper ? upper : 0;
                        }
                        if (lower !== undefined$1) {
                            lower = toNumber(lower);
                            lower = lower === lower ? lower : 0;
                        }
                        return baseClamp(toNumber(number), lower, upper);
                    }
                    function inRange(number, start, end) {
                        start = toFinite(start);
                        if (end === undefined$1) {
                            end = start;
                            start = 0;
                        } else {
                            end = toFinite(end);
                        }
                        number = toNumber(number);
                        return baseInRange(number, start, end);
                    }
                    function random(lower, upper, floating) {
                        if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
                            upper = floating = undefined$1;
                        }
                        if (floating === undefined$1) {
                            if (typeof upper == 'boolean') {
                                floating = upper;
                                upper = undefined$1;
                            } else if (typeof lower == 'boolean') {
                                floating = lower;
                                lower = undefined$1;
                            }
                        }
                        if (lower === undefined$1 && upper === undefined$1) {
                            lower = 0;
                            upper = 1;
                        } else {
                            lower = toFinite(lower);
                            if (upper === undefined$1) {
                                upper = lower;
                                lower = 0;
                            } else {
                                upper = toFinite(upper);
                            }
                        }
                        if (lower > upper) {
                            var temp = lower;
                            lower = upper;
                            upper = temp;
                        }
                        if (floating || lower % 1 || upper % 1) {
                            var rand = nativeRandom();
                            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
                        }
                        return baseRandom(lower, upper);
                    }
                    var camelCase = createCompounder(function(result, word, index) {
                        word = word.toLowerCase();
                        return result + (index ? capitalize(word) : word);
                    });
                    function capitalize(string) {
                        return upperFirst(toString(string).toLowerCase());
                    }
                    function deburr(string) {
                        string = toString(string);
                        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
                    }
                    function endsWith(string, target, position) {
                        string = toString(string);
                        target = baseToString(target);
                        var length = string.length;
                        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
                        var end = position;
                        position -= target.length;
                        return position >= 0 && string.slice(position, end) == target;
                    }
                    function escape(string) {
                        string = toString(string);
                        return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                    }
                    function escapeRegExp(string) {
                        string = toString(string);
                        return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string;
                    }
                    var kebabCase = createCompounder(function(result, word, index) {
                        return result + (index ? '-' : '') + word.toLowerCase();
                    });
                    var lowerCase = createCompounder(function(result, word, index) {
                        return result + (index ? ' ' : '') + word.toLowerCase();
                    });
                    var lowerFirst = createCaseFirst('toLowerCase');
                    function pad(string, length, chars) {
                        string = toString(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        if (!length || strLength >= length) {
                            return string;
                        }
                        var mid = (length - strLength) / 2;
                        return (createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars));
                    }
                    function padEnd(string, length, chars) {
                        string = toString(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string;
                    }
                    function padStart(string, length, chars) {
                        string = toString(string);
                        length = toInteger(length);
                        var strLength = length ? stringSize(string) : 0;
                        return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string;
                    }
                    function parseInt(string, radix, guard) {
                        if (guard || radix == null) {
                            radix = 0;
                        } else if (radix) {
                            radix = +radix;
                        }
                        return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
                    }
                    function repeat(string, n, guard) {
                        if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
                            n = 1;
                        } else {
                            n = toInteger(n);
                        }
                        return baseRepeat(toString(string), n);
                    }
                    function replace() {
                        var args = arguments, string = toString(args[0]);
                        return args.length < 3 ? string : string.replace(args[1], args[2]);
                    }
                    var snakeCase = createCompounder(function(result, word, index) {
                        return result + (index ? '_' : '') + word.toLowerCase();
                    });
                    function split(string, separator, limit) {
                        if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
                            separator = limit = undefined$1;
                        }
                        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
                        if (!limit) {
                            return [];
                        }
                        string = toString(string);
                        if (string && (typeof separator == 'string' || (separator != null && !isRegExp(separator)))) {
                            separator = baseToString(separator);
                            if (!separator && hasUnicode(string)) {
                                return castSlice(stringToArray(string), 0, limit);
                            }
                        }
                        return string.split(separator, limit);
                    }
                    var startCase = createCompounder(function(result, word, index) {
                        return result + (index ? ' ' : '') + upperFirst(word);
                    });
                    function startsWith(string, target, position) {
                        string = toString(string);
                        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                        target = baseToString(target);
                        return string.slice(position, position + target.length) == target;
                    }
                    function template(string, options, guard) {
                        var settings = lodash.templateSettings;
                        if (guard && isIterateeCall(string, options, guard)) {
                            options = undefined$1;
                        }
                        string = toString(string);
                        options = assignInWith({}, options, settings, customDefaultsAssignIn);
                        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
                        var sourceURL = '//# sourceURL=' + (hasOwnProperty.call(options, 'sourceURL') ? (options.sourceURL + '').replace(/\s/g, ' ') : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\n';
                        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                isEscaping = true;
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = hasOwnProperty.call(options, 'variable') && options.variable;
                        if (!variable) {
                            source = 'with (obj) {\n' + source + '\n}\n';
                        } else if (reForbiddenIdentifierChars.test(variable)) {
                            throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
                        source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
                        var result = attempt(function() {
                            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined$1, importsValues);
                        });
                        result.source = source;
                        if (isError(result)) {
                            throw result;
                        }
                        return result;
                    }
                    function toLower(value) {
                        return toString(value).toLowerCase();
                    }
                    function toUpper(value) {
                        return toString(value).toUpperCase();
                    }
                    function trim(string, chars, guard) {
                        string = toString(string);
                        if (string && (guard || chars === undefined$1)) {
                            return baseTrim(string);
                        }
                        if (!string || !(chars = baseToString(chars))) {
                            return string;
                        }
                        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                        return castSlice(strSymbols, start, end).join('');
                    }
                    function trimEnd(string, chars, guard) {
                        string = toString(string);
                        if (string && (guard || chars === undefined$1)) {
                            return string.slice(0, trimmedEndIndex(string) + 1);
                        }
                        if (!string || !(chars = baseToString(chars))) {
                            return string;
                        }
                        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                        return castSlice(strSymbols, 0, end).join('');
                    }
                    function trimStart(string, chars, guard) {
                        string = toString(string);
                        if (string && (guard || chars === undefined$1)) {
                            return string.replace(reTrimStart, '');
                        }
                        if (!string || !(chars = baseToString(chars))) {
                            return string;
                        }
                        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                        return castSlice(strSymbols, start).join('');
                    }
                    function truncate(string, options) {
                        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                        if (isObject(options)) {
                            var separator = 'separator' in options ? options.separator : separator;
                            length = 'length' in options ? toInteger(options.length) : length;
                            omission = 'omission' in options ? baseToString(options.omission) : omission;
                        }
                        string = toString(string);
                        var strLength = string.length;
                        if (hasUnicode(string)) {
                            var strSymbols = stringToArray(string);
                            strLength = strSymbols.length;
                        }
                        if (length >= strLength) {
                            return string;
                        }
                        var end = length - stringSize(omission);
                        if (end < 1) {
                            return omission;
                        }
                        var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
                        if (separator === undefined$1) {
                            return result + omission;
                        }
                        if (strSymbols) {
                            end += (result.length - end);
                        }
                        if (isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match, substring = result;
                                if (!separator.global) {
                                    separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                                }
                                separator.lastIndex = 0;
                                while((match = separator.exec(substring))){
                                    var newEnd = match.index;
                                }
                                result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
                            }
                        } else if (string.indexOf(baseToString(separator), end) != end) {
                            var index = result.lastIndexOf(separator);
                            if (index > -1) {
                                result = result.slice(0, index);
                            }
                        }
                        return result + omission;
                    }
                    function unescape(string) {
                        string = toString(string);
                        return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                    }
                    var upperCase = createCompounder(function(result, word, index) {
                        return result + (index ? ' ' : '') + word.toUpperCase();
                    });
                    var upperFirst = createCaseFirst('toUpperCase');
                    function words(string, pattern, guard) {
                        string = toString(string);
                        pattern = guard ? undefined$1 : pattern;
                        if (pattern === undefined$1) {
                            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                        }
                        return string.match(pattern) || [];
                    }
                    var attempt = baseRest(function(func, args) {
                        try {
                            return apply(func, undefined$1, args);
                        } catch (e) {
                            return isError(e) ? e : new Error(e);
                        }
                    });
                    var bindAll = flatRest(function(object, methodNames) {
                        arrayEach(methodNames, function(key) {
                            key = toKey(key);
                            baseAssignValue(object, key, bind(object[key], object));
                        });
                        return object;
                    });
                    function cond(pairs) {
                        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                        pairs = !length ? [] : arrayMap(pairs, function(pair) {
                            if (typeof pair[1] != 'function') {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                            return [
                                toIteratee(pair[0]),
                                pair[1]
                            ];
                        });
                        return baseRest(function(args) {
                            var index = -1;
                            while(++index < length){
                                var pair = pairs[index];
                                if (apply(pair[0], this, args)) {
                                    return apply(pair[1], this, args);
                                }
                            }
                        });
                    }
                    function conforms(source) {
                        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function defaultTo(value, defaultValue) {
                        return (value == null || value !== value) ? defaultValue : value;
                    }
                    var flow = createFlow();
                    var flowRight = createFlow(true);
                    function identity(value) {
                        return value;
                    }
                    function iteratee(func) {
                        return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
                    }
                    function matches(source) {
                        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                    }
                    function matchesProperty(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                    }
                    var method = baseRest(function(path, args) {
                        return function(object) {
                            return baseInvoke(object, path, args);
                        };
                    });
                    var methodOf = baseRest(function(object, args) {
                        return function(path) {
                            return baseInvoke(object, path, args);
                        };
                    });
                    function mixin(object, source, options) {
                        var props = keys(source), methodNames = baseFunctions(source, props);
                        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                            options = source;
                            source = object;
                            object = this;
                            methodNames = baseFunctions(source, keys(source));
                        }
                        var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);
                        arrayEach(methodNames, function(methodName) {
                            var func = source[methodName];
                            object[methodName] = func;
                            if (isFunc) {
                                object.prototype[methodName] = function() {
                                    var chainAll = this.__chain__;
                                    if (chain || chainAll) {
                                        var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                                        actions.push({
                                            'func': func,
                                            'args': arguments,
                                            'thisArg': object
                                        });
                                        result.__chain__ = chainAll;
                                        return result;
                                    }
                                    return func.apply(object, arrayPush([
                                        this.value()
                                    ], arguments));
                                };
                            }
                        });
                        return object;
                    }
                    function noConflict() {
                        if (root._ === this) {
                            root._ = oldDash;
                        }
                        return this;
                    }
                    function noop() {}
                    function nthArg(n) {
                        n = toInteger(n);
                        return baseRest(function(args) {
                            return baseNth(args, n);
                        });
                    }
                    var over = createOver(arrayMap);
                    var overEvery = createOver(arrayEvery);
                    var overSome = createOver(arraySome);
                    function property(path) {
                        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                    }
                    function propertyOf(object) {
                        return function(path) {
                            return object == null ? undefined$1 : baseGet(object, path);
                        };
                    }
                    var range = createRange();
                    var rangeRight = createRange(true);
                    function stubArray() {
                        return [];
                    }
                    function stubFalse() {
                        return false;
                    }
                    function stubObject() {
                        return {};
                    }
                    function stubString() {
                        return '';
                    }
                    function stubTrue() {
                        return true;
                    }
                    function times(n, iteratee) {
                        n = toInteger(n);
                        if (n < 1 || n > MAX_SAFE_INTEGER) {
                            return [];
                        }
                        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                        iteratee = getIteratee(iteratee);
                        n -= MAX_ARRAY_LENGTH;
                        var result = baseTimes(length, iteratee);
                        while(++index < n){
                            iteratee(index);
                        }
                        return result;
                    }
                    function toPath(value) {
                        if (isArray(value)) {
                            return arrayMap(value, toKey);
                        }
                        return isSymbol(value) ? [
                            value
                        ] : copyArray(stringToPath(toString(value)));
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return toString(prefix) + id;
                    }
                    var add = createMathOperation(function(augend, addend) {
                        return augend + addend;
                    }, 0);
                    var ceil = createRound('ceil');
                    var divide = createMathOperation(function(dividend, divisor) {
                        return dividend / divisor;
                    }, 1);
                    var floor = createRound('floor');
                    function max(array) {
                        return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined$1;
                    }
                    function maxBy(array, iteratee) {
                        return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined$1;
                    }
                    function mean(array) {
                        return baseMean(array, identity);
                    }
                    function meanBy(array, iteratee) {
                        return baseMean(array, getIteratee(iteratee, 2));
                    }
                    function min(array) {
                        return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined$1;
                    }
                    function minBy(array, iteratee) {
                        return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined$1;
                    }
                    var multiply = createMathOperation(function(multiplier, multiplicand) {
                        return multiplier * multiplicand;
                    }, 1);
                    var round = createRound('round');
                    var subtract = createMathOperation(function(minuend, subtrahend) {
                        return minuend - subtrahend;
                    }, 0);
                    function sum(array) {
                        return (array && array.length) ? baseSum(array, identity) : 0;
                    }
                    function sumBy(array, iteratee) {
                        return (array && array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0;
                    }
                    lodash.after = after;
                    lodash.ary = ary;
                    lodash.assign = assign;
                    lodash.assignIn = assignIn;
                    lodash.assignInWith = assignInWith;
                    lodash.assignWith = assignWith;
                    lodash.at = at;
                    lodash.before = before;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.castArray = castArray;
                    lodash.chain = chain;
                    lodash.chunk = chunk;
                    lodash.compact = compact;
                    lodash.concat = concat;
                    lodash.cond = cond;
                    lodash.conforms = conforms;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.curry = curry;
                    lodash.curryRight = curryRight;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defaultsDeep = defaultsDeep;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.differenceBy = differenceBy;
                    lodash.differenceWith = differenceWith;
                    lodash.drop = drop;
                    lodash.dropRight = dropRight;
                    lodash.dropRightWhile = dropRightWhile;
                    lodash.dropWhile = dropWhile;
                    lodash.fill = fill;
                    lodash.filter = filter;
                    lodash.flatMap = flatMap;
                    lodash.flatMapDeep = flatMapDeep;
                    lodash.flatMapDepth = flatMapDepth;
                    lodash.flatten = flatten;
                    lodash.flattenDeep = flattenDeep;
                    lodash.flattenDepth = flattenDepth;
                    lodash.flip = flip;
                    lodash.flow = flow;
                    lodash.flowRight = flowRight;
                    lodash.fromPairs = fromPairs;
                    lodash.functions = functions;
                    lodash.functionsIn = functionsIn;
                    lodash.groupBy = groupBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.intersectionBy = intersectionBy;
                    lodash.intersectionWith = intersectionWith;
                    lodash.invert = invert;
                    lodash.invertBy = invertBy;
                    lodash.invokeMap = invokeMap;
                    lodash.iteratee = iteratee;
                    lodash.keyBy = keyBy;
                    lodash.keys = keys;
                    lodash.keysIn = keysIn;
                    lodash.map = map;
                    lodash.mapKeys = mapKeys;
                    lodash.mapValues = mapValues;
                    lodash.matches = matches;
                    lodash.matchesProperty = matchesProperty;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.mergeWith = mergeWith;
                    lodash.method = method;
                    lodash.methodOf = methodOf;
                    lodash.mixin = mixin;
                    lodash.negate = negate;
                    lodash.nthArg = nthArg;
                    lodash.omit = omit;
                    lodash.omitBy = omitBy;
                    lodash.once = once;
                    lodash.orderBy = orderBy;
                    lodash.over = over;
                    lodash.overArgs = overArgs;
                    lodash.overEvery = overEvery;
                    lodash.overSome = overSome;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.partition = partition;
                    lodash.pick = pick;
                    lodash.pickBy = pickBy;
                    lodash.property = property;
                    lodash.propertyOf = propertyOf;
                    lodash.pull = pull;
                    lodash.pullAll = pullAll;
                    lodash.pullAllBy = pullAllBy;
                    lodash.pullAllWith = pullAllWith;
                    lodash.pullAt = pullAt;
                    lodash.range = range;
                    lodash.rangeRight = rangeRight;
                    lodash.rearg = rearg;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.reverse = reverse;
                    lodash.sampleSize = sampleSize;
                    lodash.set = set;
                    lodash.setWith = setWith;
                    lodash.shuffle = shuffle;
                    lodash.slice = slice;
                    lodash.sortBy = sortBy;
                    lodash.sortedUniq = sortedUniq;
                    lodash.sortedUniqBy = sortedUniqBy;
                    lodash.split = split;
                    lodash.spread = spread;
                    lodash.tail = tail;
                    lodash.take = take;
                    lodash.takeRight = takeRight;
                    lodash.takeRightWhile = takeRightWhile;
                    lodash.takeWhile = takeWhile;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.thru = thru;
                    lodash.toArray = toArray;
                    lodash.toPairs = toPairs;
                    lodash.toPairsIn = toPairsIn;
                    lodash.toPath = toPath;
                    lodash.toPlainObject = toPlainObject;
                    lodash.transform = transform;
                    lodash.unary = unary;
                    lodash.union = union;
                    lodash.unionBy = unionBy;
                    lodash.unionWith = unionWith;
                    lodash.uniq = uniq;
                    lodash.uniqBy = uniqBy;
                    lodash.uniqWith = uniqWith;
                    lodash.unset = unset;
                    lodash.unzip = unzip;
                    lodash.unzipWith = unzipWith;
                    lodash.update = update;
                    lodash.updateWith = updateWith;
                    lodash.values = values;
                    lodash.valuesIn = valuesIn;
                    lodash.without = without;
                    lodash.words = words;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.xorBy = xorBy;
                    lodash.xorWith = xorWith;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.zipObjectDeep = zipObjectDeep;
                    lodash.zipWith = zipWith;
                    lodash.entries = toPairs;
                    lodash.entriesIn = toPairsIn;
                    lodash.extend = assignIn;
                    lodash.extendWith = assignInWith;
                    mixin(lodash, lodash);
                    lodash.add = add;
                    lodash.attempt = attempt;
                    lodash.camelCase = camelCase;
                    lodash.capitalize = capitalize;
                    lodash.ceil = ceil;
                    lodash.clamp = clamp;
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.cloneDeepWith = cloneDeepWith;
                    lodash.cloneWith = cloneWith;
                    lodash.conformsTo = conformsTo;
                    lodash.deburr = deburr;
                    lodash.defaultTo = defaultTo;
                    lodash.divide = divide;
                    lodash.endsWith = endsWith;
                    lodash.eq = eq;
                    lodash.escape = escape;
                    lodash.escapeRegExp = escapeRegExp;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.floor = floor;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.get = get;
                    lodash.gt = gt;
                    lodash.gte = gte;
                    lodash.has = has;
                    lodash.hasIn = hasIn;
                    lodash.head = head;
                    lodash.identity = identity;
                    lodash.includes = includes;
                    lodash.indexOf = indexOf;
                    lodash.inRange = inRange;
                    lodash.invoke = invoke;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isArrayBuffer = isArrayBuffer;
                    lodash.isArrayLike = isArrayLike;
                    lodash.isArrayLikeObject = isArrayLikeObject;
                    lodash.isBoolean = isBoolean;
                    lodash.isBuffer = isBuffer;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isEqualWith = isEqualWith;
                    lodash.isError = isError;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isInteger = isInteger;
                    lodash.isLength = isLength;
                    lodash.isMap = isMap;
                    lodash.isMatch = isMatch;
                    lodash.isMatchWith = isMatchWith;
                    lodash.isNaN = isNaN;
                    lodash.isNative = isNative;
                    lodash.isNil = isNil;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isObjectLike = isObjectLike;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isSafeInteger = isSafeInteger;
                    lodash.isSet = isSet;
                    lodash.isString = isString;
                    lodash.isSymbol = isSymbol;
                    lodash.isTypedArray = isTypedArray;
                    lodash.isUndefined = isUndefined;
                    lodash.isWeakMap = isWeakMap;
                    lodash.isWeakSet = isWeakSet;
                    lodash.join = join;
                    lodash.kebabCase = kebabCase;
                    lodash.last = last;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.lowerCase = lowerCase;
                    lodash.lowerFirst = lowerFirst;
                    lodash.lt = lt;
                    lodash.lte = lte;
                    lodash.max = max;
                    lodash.maxBy = maxBy;
                    lodash.mean = mean;
                    lodash.meanBy = meanBy;
                    lodash.min = min;
                    lodash.minBy = minBy;
                    lodash.stubArray = stubArray;
                    lodash.stubFalse = stubFalse;
                    lodash.stubObject = stubObject;
                    lodash.stubString = stubString;
                    lodash.stubTrue = stubTrue;
                    lodash.multiply = multiply;
                    lodash.nth = nth;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.pad = pad;
                    lodash.padEnd = padEnd;
                    lodash.padStart = padStart;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.repeat = repeat;
                    lodash.replace = replace;
                    lodash.result = result;
                    lodash.round = round;
                    lodash.runInContext = runInContext;
                    lodash.sample = sample;
                    lodash.size = size;
                    lodash.snakeCase = snakeCase;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.sortedIndexBy = sortedIndexBy;
                    lodash.sortedIndexOf = sortedIndexOf;
                    lodash.sortedLastIndex = sortedLastIndex;
                    lodash.sortedLastIndexBy = sortedLastIndexBy;
                    lodash.sortedLastIndexOf = sortedLastIndexOf;
                    lodash.startCase = startCase;
                    lodash.startsWith = startsWith;
                    lodash.subtract = subtract;
                    lodash.sum = sum;
                    lodash.sumBy = sumBy;
                    lodash.template = template;
                    lodash.times = times;
                    lodash.toFinite = toFinite;
                    lodash.toInteger = toInteger;
                    lodash.toLength = toLength;
                    lodash.toLower = toLower;
                    lodash.toNumber = toNumber;
                    lodash.toSafeInteger = toSafeInteger;
                    lodash.toString = toString;
                    lodash.toUpper = toUpper;
                    lodash.trim = trim;
                    lodash.trimEnd = trimEnd;
                    lodash.trimStart = trimStart;
                    lodash.truncate = truncate;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.upperCase = upperCase;
                    lodash.upperFirst = upperFirst;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.first = head;
                    mixin(lodash, (function() {
                        var source = {};
                        baseForOwn(lodash, function(func, methodName) {
                            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }()), {
                        'chain': false
                    });
                    lodash.VERSION = VERSION;
                    arrayEach([
                        'bind',
                        'bindKey',
                        'curry',
                        'curryRight',
                        'partial',
                        'partialRight'
                    ], function(methodName) {
                        lodash[methodName].placeholder = lodash;
                    });
                    arrayEach([
                        'drop',
                        'take'
                    ], function(methodName, index) {
                        LazyWrapper.prototype[methodName] = function(n) {
                            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
                            var result = (this.__filtered__ && !index) ? new LazyWrapper(this) : this.clone();
                            if (result.__filtered__) {
                                result.__takeCount__ = nativeMin(n, result.__takeCount__);
                            } else {
                                result.__views__.push({
                                    'size': nativeMin(n, MAX_ARRAY_LENGTH),
                                    'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                                });
                            }
                            return result;
                        };
                        LazyWrapper.prototype[methodName + 'Right'] = function(n) {
                            return this.reverse()[methodName](n).reverse();
                        };
                    });
                    arrayEach([
                        'filter',
                        'map',
                        'takeWhile'
                    ], function(methodName, index) {
                        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                        LazyWrapper.prototype[methodName] = function(iteratee) {
                            var result = this.clone();
                            result.__iteratees__.push({
                                'iteratee': getIteratee(iteratee, 3),
                                'type': type
                            });
                            result.__filtered__ = result.__filtered__ || isFilter;
                            return result;
                        };
                    });
                    arrayEach([
                        'head',
                        'last'
                    ], function(methodName, index) {
                        var takeName = 'take' + (index ? 'Right' : '');
                        LazyWrapper.prototype[methodName] = function() {
                            return this[takeName](1).value()[0];
                        };
                    });
                    arrayEach([
                        'initial',
                        'tail'
                    ], function(methodName, index) {
                        var dropName = 'drop' + (index ? '' : 'Right');
                        LazyWrapper.prototype[methodName] = function() {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                        };
                    });
                    LazyWrapper.prototype.compact = function() {
                        return this.filter(identity);
                    };
                    LazyWrapper.prototype.find = function(predicate) {
                        return this.filter(predicate).head();
                    };
                    LazyWrapper.prototype.findLast = function(predicate) {
                        return this.reverse().find(predicate);
                    };
                    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                        if (typeof path == 'function') {
                            return new LazyWrapper(this);
                        }
                        return this.map(function(value) {
                            return baseInvoke(value, path, args);
                        });
                    });
                    LazyWrapper.prototype.reject = function(predicate) {
                        return this.filter(negate(getIteratee(predicate)));
                    };
                    LazyWrapper.prototype.slice = function(start, end) {
                        start = toInteger(start);
                        var result = this;
                        if (result.__filtered__ && (start > 0 || end < 0)) {
                            return new LazyWrapper(result);
                        }
                        if (start < 0) {
                            result = result.takeRight(-start);
                        } else if (start) {
                            result = result.drop(start);
                        }
                        if (end !== undefined$1) {
                            end = toInteger(end);
                            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                        }
                        return result;
                    };
                    LazyWrapper.prototype.takeRightWhile = function(predicate) {
                        return this.reverse().takeWhile(predicate).reverse();
                    };
                    LazyWrapper.prototype.toArray = function() {
                        return this.take(MAX_ARRAY_LENGTH);
                    };
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                        if (!lodashFunc) {
                            return;
                        }
                        lodash.prototype[methodName] = function() {
                            var value = this.__wrapped__, args = isTaker ? [
                                1
                            ] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                            var interceptor = function(value) {
                                var result = lodashFunc.apply(lodash, arrayPush([
                                    value
                                ], args));
                                return (isTaker && chainAll) ? result[0] : result;
                            };
                            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                                isLazy = useLazy = false;
                            }
                            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                result.__actions__.push({
                                    'func': thru,
                                    'args': [
                                        interceptor
                                    ],
                                    'thisArg': undefined$1
                                });
                                return new LodashWrapper(result, chainAll);
                            }
                            if (isUnwrapped && onlyLazy) {
                                return func.apply(this, args);
                            }
                            result = this.thru(interceptor);
                            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
                        };
                    });
                    arrayEach([
                        'pop',
                        'push',
                        'shift',
                        'sort',
                        'splice',
                        'unshift'
                    ], function(methodName) {
                        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                        lodash.prototype[methodName] = function() {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                var value = this.value();
                                return func.apply(isArray(value) ? value : [], args);
                            }
                            return this[chainName](function(value) {
                                return func.apply(isArray(value) ? value : [], args);
                            });
                        };
                    });
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name + '';
                            if (!hasOwnProperty.call(realNames, key)) {
                                realNames[key] = [];
                            }
                            realNames[key].push({
                                'name': methodName,
                                'func': lodashFunc
                            });
                        }
                    });
                    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [
                        {
                            'name': 'wrapper',
                            'func': undefined$1
                        }
                    ];
                    LazyWrapper.prototype.clone = lazyClone;
                    LazyWrapper.prototype.reverse = lazyReverse;
                    LazyWrapper.prototype.value = lazyValue;
                    lodash.prototype.at = wrapperAt;
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.commit = wrapperCommit;
                    lodash.prototype.next = wrapperNext;
                    lodash.prototype.plant = wrapperPlant;
                    lodash.prototype.reverse = wrapperReverse;
                    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                    lodash.prototype.first = lodash.prototype.head;
                    if (symIterator) {
                        lodash.prototype[symIterator] = wrapperToIterator;
                    }
                    return lodash;
                });
                var _ = runInContext();
                if (freeModule) {
                    (freeModule.exports = _)._ = _;
                    freeExports._ = _;
                } else {
                    root._ = _;
                }
            }.call(lodash));
        }(lodash$1, lodash$1.exports));
        return lodash$1.exports;
    }
    var lodashExports = requireLodash();
    const _ = getDefaultExportFromCjs(lodashExports);
    class DoubleIndexedKV {
        constructor(){
            this.keyToValue = new Map();
            this.valueToKey = new Map();
        }
        set(key, value) {
            this.keyToValue.set(key, value);
            this.valueToKey.set(value, key);
        }
        getByKey(key) {
            return this.keyToValue.get(key);
        }
        getByValue(value) {
            return this.valueToKey.get(value);
        }
        clear() {
            this.keyToValue.clear();
            this.valueToKey.clear();
        }
    }
    class Registry {
        constructor(generateIdentifier){
            this.generateIdentifier = generateIdentifier;
            this.kv = new DoubleIndexedKV();
        }
        register(value, identifier) {
            if (this.kv.getByValue(value)) {
                return;
            }
            if (!identifier) {
                identifier = this.generateIdentifier(value);
            }
            this.kv.set(identifier, value);
        }
        clear() {
            this.kv.clear();
        }
        getIdentifier(value) {
            return this.kv.getByValue(value);
        }
        getValue(identifier) {
            return this.kv.getByKey(identifier);
        }
    }
    class ClassRegistry extends Registry {
        constructor(){
            super((c)=>c.name);
            this.classToAllowedProps = new Map();
        }
        register(value, options) {
            if (typeof options === 'object') {
                if (options.allowProps) {
                    this.classToAllowedProps.set(value, options.allowProps);
                }
                super.register(value, options.identifier);
            } else {
                super.register(value, options);
            }
        }
        getAllowedProps(value) {
            return this.classToAllowedProps.get(value);
        }
    }
    function valuesOfObj(record) {
        if ('values' in Object) {
            return Object.values(record);
        }
        const values = [];
        for(const key in record){
            if (record.hasOwnProperty(key)) {
                values.push(record[key]);
            }
        }
        return values;
    }
    function find(record, predicate) {
        const values = valuesOfObj(record);
        if ('find' in values) {
            return values.find(predicate);
        }
        const valuesNotNever = values;
        for(let i = 0; i < valuesNotNever.length; i++){
            const value = valuesNotNever[i];
            if (predicate(value)) {
                return value;
            }
        }
        return undefined;
    }
    function forEach$1(record, run) {
        Object.entries(record).forEach(([key, value])=>run(value, key));
    }
    function includes(arr, value) {
        return arr.indexOf(value) !== -1;
    }
    function findArr(record, predicate) {
        for(let i = 0; i < record.length; i++){
            const value = record[i];
            if (predicate(value)) {
                return value;
            }
        }
        return undefined;
    }
    class CustomTransformerRegistry {
        constructor(){
            this.transfomers = {};
        }
        register(transformer) {
            this.transfomers[transformer.name] = transformer;
        }
        findApplicable(v) {
            return find(this.transfomers, (transformer)=>transformer.isApplicable(v));
        }
        findByName(name) {
            return this.transfomers[name];
        }
    }
    const getType$1 = (payload)=>Object.prototype.toString.call(payload).slice(8, -1);
    const isUndefined = (payload)=>typeof payload === 'undefined';
    const isNull = (payload)=>payload === null;
    const isPlainObject$2 = (payload)=>{
        if (typeof payload !== 'object' || payload === null) return false;
        if (payload === Object.prototype) return false;
        if (Object.getPrototypeOf(payload) === null) return true;
        return Object.getPrototypeOf(payload) === Object.prototype;
    };
    const isEmptyObject = (payload)=>isPlainObject$2(payload) && Object.keys(payload).length === 0;
    const isArray$2 = (payload)=>Array.isArray(payload);
    const isString = (payload)=>typeof payload === 'string';
    const isNumber = (payload)=>typeof payload === 'number' && !isNaN(payload);
    const isBoolean = (payload)=>typeof payload === 'boolean';
    const isRegExp = (payload)=>payload instanceof RegExp;
    const isMap = (payload)=>payload instanceof Map;
    const isSet = (payload)=>payload instanceof Set;
    const isSymbol = (payload)=>getType$1(payload) === 'Symbol';
    const isDate = (payload)=>payload instanceof Date && !isNaN(payload.valueOf());
    const isError = (payload)=>payload instanceof Error;
    const isNaNValue = (payload)=>typeof payload === 'number' && isNaN(payload);
    const isPrimitive = (payload)=>isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
    const isBigint = (payload)=>typeof payload === 'bigint';
    const isInfinite = (payload)=>payload === Infinity || payload === -Infinity;
    const isTypedArray = (payload)=>ArrayBuffer.isView(payload) && !(payload instanceof DataView);
    const isURL = (payload)=>payload instanceof URL;
    const escapeKey = (key)=>key.replace(/\./g, '\\.');
    const stringifyPath = (path)=>path.map(String).map(escapeKey).join('.');
    const parsePath = (string)=>{
        const result = [];
        let segment = '';
        for(let i = 0; i < string.length; i++){
            let char = string.charAt(i);
            const isEscapedDot = char === '\\' && string.charAt(i + 1) === '.';
            if (isEscapedDot) {
                segment += '.';
                i++;
                continue;
            }
            const isEndOfSegment = char === '.';
            if (isEndOfSegment) {
                result.push(segment);
                segment = '';
                continue;
            }
            segment += char;
        }
        const lastSegment = segment;
        result.push(lastSegment);
        return result;
    };
    function simpleTransformation(isApplicable, annotation, transform, untransform) {
        return {
            isApplicable,
            annotation,
            transform,
            untransform
        };
    }
    const simpleRules = [
        simpleTransformation(isUndefined, 'undefined', ()=>null, ()=>undefined),
        simpleTransformation(isBigint, 'bigint', (v)=>v.toString(), (v)=>{
            if (typeof BigInt !== 'undefined') {
                return BigInt(v);
            }
            console.error('Please add a BigInt polyfill.');
            return v;
        }),
        simpleTransformation(isDate, 'Date', (v)=>v.toISOString(), (v)=>new Date(v)),
        simpleTransformation(isError, 'Error', (v, superJson)=>{
            const baseError = {
                name: v.name,
                message: v.message
            };
            superJson.allowedErrorProps.forEach((prop)=>{
                baseError[prop] = v[prop];
            });
            return baseError;
        }, (v, superJson)=>{
            const e = new Error(v.message);
            e.name = v.name;
            e.stack = v.stack;
            superJson.allowedErrorProps.forEach((prop)=>{
                e[prop] = v[prop];
            });
            return e;
        }),
        simpleTransformation(isRegExp, 'regexp', (v)=>'' + v, (regex)=>{
            const body = regex.slice(1, regex.lastIndexOf('/'));
            const flags = regex.slice(regex.lastIndexOf('/') + 1);
            return new RegExp(body, flags);
        }),
        simpleTransformation(isSet, 'set', (v)=>[
                ...v.values()
            ], (v)=>new Set(v)),
        simpleTransformation(isMap, 'map', (v)=>[
                ...v.entries()
            ], (v)=>new Map(v)),
        simpleTransformation((v)=>isNaNValue(v) || isInfinite(v), 'number', (v)=>{
            if (isNaNValue(v)) {
                return 'NaN';
            }
            if (v > 0) {
                return 'Infinity';
            } else {
                return '-Infinity';
            }
        }, Number),
        simpleTransformation((v)=>v === 0 && 1 / v === -Infinity, 'number', ()=>{
            return '-0';
        }, Number),
        simpleTransformation(isURL, 'URL', (v)=>v.toString(), (v)=>new URL(v))
    ];
    function compositeTransformation(isApplicable, annotation, transform, untransform) {
        return {
            isApplicable,
            annotation,
            transform,
            untransform
        };
    }
    const symbolRule = compositeTransformation((s, superJson)=>{
        if (isSymbol(s)) {
            const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
            return isRegistered;
        }
        return false;
    }, (s, superJson)=>{
        const identifier = superJson.symbolRegistry.getIdentifier(s);
        return [
            'symbol',
            identifier
        ];
    }, (v)=>v.description, (_, a, superJson)=>{
        const value = superJson.symbolRegistry.getValue(a[1]);
        if (!value) {
            throw new Error('Trying to deserialize unknown symbol');
        }
        return value;
    });
    const constructorToName = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,
        Uint8ClampedArray
    ].reduce((obj, ctor)=>{
        obj[ctor.name] = ctor;
        return obj;
    }, {});
    const typedArrayRule = compositeTransformation(isTypedArray, (v)=>[
            'typed-array',
            v.constructor.name
        ], (v)=>[
            ...v
        ], (v, a)=>{
        const ctor = constructorToName[a[1]];
        if (!ctor) {
            throw new Error('Trying to deserialize unknown typed array');
        }
        return new ctor(v);
    });
    function isInstanceOfRegisteredClass(potentialClass, superJson) {
        if (potentialClass?.constructor) {
            const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
            return isRegistered;
        }
        return false;
    }
    const classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson)=>{
        const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
        return [
            'class',
            identifier
        ];
    }, (clazz, superJson)=>{
        const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
        if (!allowedProps) {
            return {
                ...clazz
            };
        }
        const result = {};
        allowedProps.forEach((prop)=>{
            result[prop] = clazz[prop];
        });
        return result;
    }, (v, a, superJson)=>{
        const clazz = superJson.classRegistry.getValue(a[1]);
        if (!clazz) {
            throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
        }
        return Object.assign(Object.create(clazz.prototype), v);
    });
    const customRule = compositeTransformation((value, superJson)=>{
        return !!superJson.customTransformerRegistry.findApplicable(value);
    }, (value, superJson)=>{
        const transformer = superJson.customTransformerRegistry.findApplicable(value);
        return [
            'custom',
            transformer.name
        ];
    }, (value, superJson)=>{
        const transformer = superJson.customTransformerRegistry.findApplicable(value);
        return transformer.serialize(value);
    }, (v, a, superJson)=>{
        const transformer = superJson.customTransformerRegistry.findByName(a[1]);
        if (!transformer) {
            throw new Error('Trying to deserialize unknown custom value');
        }
        return transformer.deserialize(v);
    });
    const compositeRules = [
        classRule,
        symbolRule,
        customRule,
        typedArrayRule
    ];
    const transformValue = (value, superJson)=>{
        const applicableCompositeRule = findArr(compositeRules, (rule)=>rule.isApplicable(value, superJson));
        if (applicableCompositeRule) {
            return {
                value: applicableCompositeRule.transform(value, superJson),
                type: applicableCompositeRule.annotation(value, superJson)
            };
        }
        const applicableSimpleRule = findArr(simpleRules, (rule)=>rule.isApplicable(value, superJson));
        if (applicableSimpleRule) {
            return {
                value: applicableSimpleRule.transform(value, superJson),
                type: applicableSimpleRule.annotation
            };
        }
        return undefined;
    };
    const simpleRulesByAnnotation = {};
    simpleRules.forEach((rule)=>{
        simpleRulesByAnnotation[rule.annotation] = rule;
    });
    const untransformValue = (json, type, superJson)=>{
        if (isArray$2(type)) {
            switch(type[0]){
                case 'symbol':
                    return symbolRule.untransform(json, type, superJson);
                case 'class':
                    return classRule.untransform(json, type, superJson);
                case 'custom':
                    return customRule.untransform(json, type, superJson);
                case 'typed-array':
                    return typedArrayRule.untransform(json, type, superJson);
                default:
                    throw new Error('Unknown transformation: ' + type);
            }
        } else {
            const transformation = simpleRulesByAnnotation[type];
            if (!transformation) {
                throw new Error('Unknown transformation: ' + type);
            }
            return transformation.untransform(json, superJson);
        }
    };
    const getNthKey = (value, n)=>{
        if (n > value.size) throw new Error('index out of bounds');
        const keys = value.keys();
        while(n > 0){
            keys.next();
            n--;
        }
        return keys.next().value;
    };
    function validatePath(path) {
        if (includes(path, '__proto__')) {
            throw new Error('__proto__ is not allowed as a property');
        }
        if (includes(path, 'prototype')) {
            throw new Error('prototype is not allowed as a property');
        }
        if (includes(path, 'constructor')) {
            throw new Error('constructor is not allowed as a property');
        }
    }
    const getDeep = (object, path)=>{
        validatePath(path);
        for(let i = 0; i < path.length; i++){
            const key = path[i];
            if (isSet(object)) {
                object = getNthKey(object, +key);
            } else if (isMap(object)) {
                const row = +key;
                const type = +path[++i] === 0 ? 'key' : 'value';
                const keyOfRow = getNthKey(object, row);
                switch(type){
                    case 'key':
                        object = keyOfRow;
                        break;
                    case 'value':
                        object = object.get(keyOfRow);
                        break;
                }
            } else {
                object = object[key];
            }
        }
        return object;
    };
    const setDeep = (object, path, mapper)=>{
        validatePath(path);
        if (path.length === 0) {
            return mapper(object);
        }
        let parent = object;
        for(let i = 0; i < path.length - 1; i++){
            const key = path[i];
            if (isArray$2(parent)) {
                const index = +key;
                parent = parent[index];
            } else if (isPlainObject$2(parent)) {
                parent = parent[key];
            } else if (isSet(parent)) {
                const row = +key;
                parent = getNthKey(parent, row);
            } else if (isMap(parent)) {
                const isEnd = i === path.length - 2;
                if (isEnd) {
                    break;
                }
                const row = +key;
                const type = +path[++i] === 0 ? 'key' : 'value';
                const keyOfRow = getNthKey(parent, row);
                switch(type){
                    case 'key':
                        parent = keyOfRow;
                        break;
                    case 'value':
                        parent = parent.get(keyOfRow);
                        break;
                }
            }
        }
        const lastKey = path[path.length - 1];
        if (isArray$2(parent)) {
            parent[+lastKey] = mapper(parent[+lastKey]);
        } else if (isPlainObject$2(parent)) {
            parent[lastKey] = mapper(parent[lastKey]);
        }
        if (isSet(parent)) {
            const oldValue = getNthKey(parent, +lastKey);
            const newValue = mapper(oldValue);
            if (oldValue !== newValue) {
                parent.delete(oldValue);
                parent.add(newValue);
            }
        }
        if (isMap(parent)) {
            const row = +path[path.length - 2];
            const keyToRow = getNthKey(parent, row);
            const type = +lastKey === 0 ? 'key' : 'value';
            switch(type){
                case 'key':
                    {
                        const newKey = mapper(keyToRow);
                        parent.set(newKey, parent.get(keyToRow));
                        if (newKey !== keyToRow) {
                            parent.delete(keyToRow);
                        }
                        break;
                    }
                case 'value':
                    {
                        parent.set(keyToRow, mapper(parent.get(keyToRow)));
                        break;
                    }
            }
        }
        return object;
    };
    function traverse(tree, walker, origin = []) {
        if (!tree) {
            return;
        }
        if (!isArray$2(tree)) {
            forEach$1(tree, (subtree, key)=>traverse(subtree, walker, [
                    ...origin,
                    ...parsePath(key)
                ]));
            return;
        }
        const [nodeValue, children] = tree;
        if (children) {
            forEach$1(children, (child, key)=>{
                traverse(child, walker, [
                    ...origin,
                    ...parsePath(key)
                ]);
            });
        }
        walker(nodeValue, origin);
    }
    function applyValueAnnotations(plain, annotations, superJson) {
        traverse(annotations, (type, path)=>{
            plain = setDeep(plain, path, (v)=>untransformValue(v, type, superJson));
        });
        return plain;
    }
    function applyReferentialEqualityAnnotations(plain, annotations) {
        function apply(identicalPaths, path) {
            const object = getDeep(plain, parsePath(path));
            identicalPaths.map(parsePath).forEach((identicalObjectPath)=>{
                plain = setDeep(plain, identicalObjectPath, ()=>object);
            });
        }
        if (isArray$2(annotations)) {
            const [root, other] = annotations;
            root.forEach((identicalPath)=>{
                plain = setDeep(plain, parsePath(identicalPath), ()=>plain);
            });
            if (other) {
                forEach$1(other, apply);
            }
        } else {
            forEach$1(annotations, apply);
        }
        return plain;
    }
    const isDeep = (object, superJson)=>isPlainObject$2(object) || isArray$2(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
    function addIdentity(object, path, identities) {
        const existingSet = identities.get(object);
        if (existingSet) {
            existingSet.push(path);
        } else {
            identities.set(object, [
                path
            ]);
        }
    }
    function generateReferentialEqualityAnnotations(identitites, dedupe) {
        const result = {};
        let rootEqualityPaths = undefined;
        identitites.forEach((paths)=>{
            if (paths.length <= 1) {
                return;
            }
            if (!dedupe) {
                paths = paths.map((path)=>path.map(String)).sort((a, b)=>a.length - b.length);
            }
            const [representativePath, ...identicalPaths] = paths;
            if (representativePath.length === 0) {
                rootEqualityPaths = identicalPaths.map(stringifyPath);
            } else {
                result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
            }
        });
        if (rootEqualityPaths) {
            if (isEmptyObject(result)) {
                return [
                    rootEqualityPaths
                ];
            } else {
                return [
                    rootEqualityPaths,
                    result
                ];
            }
        } else {
            return isEmptyObject(result) ? undefined : result;
        }
    }
    const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = new Map())=>{
        const primitive = isPrimitive(object);
        if (!primitive) {
            addIdentity(object, path, identities);
            const seen = seenObjects.get(object);
            if (seen) {
                return dedupe ? {
                    transformedValue: null
                } : seen;
            }
        }
        if (!isDeep(object, superJson)) {
            const transformed = transformValue(object, superJson);
            const result = transformed ? {
                transformedValue: transformed.value,
                annotations: [
                    transformed.type
                ]
            } : {
                transformedValue: object
            };
            if (!primitive) {
                seenObjects.set(object, result);
            }
            return result;
        }
        if (includes(objectsInThisPath, object)) {
            return {
                transformedValue: null
            };
        }
        const transformationResult = transformValue(object, superJson);
        const transformed = transformationResult?.value ?? object;
        const transformedValue = isArray$2(transformed) ? [] : {};
        const innerAnnotations = {};
        forEach$1(transformed, (value, index)=>{
            if (index === '__proto__' || index === 'constructor' || index === 'prototype') {
                throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
            }
            const recursiveResult = walker(value, identities, superJson, dedupe, [
                ...path,
                index
            ], [
                ...objectsInThisPath,
                object
            ], seenObjects);
            transformedValue[index] = recursiveResult.transformedValue;
            if (isArray$2(recursiveResult.annotations)) {
                innerAnnotations[index] = recursiveResult.annotations;
            } else if (isPlainObject$2(recursiveResult.annotations)) {
                forEach$1(recursiveResult.annotations, (tree, key)=>{
                    innerAnnotations[escapeKey(index) + '.' + key] = tree;
                });
            }
        });
        const result = isEmptyObject(innerAnnotations) ? {
            transformedValue,
            annotations: !!transformationResult ? [
                transformationResult.type
            ] : undefined
        } : {
            transformedValue,
            annotations: !!transformationResult ? [
                transformationResult.type,
                innerAnnotations
            ] : innerAnnotations
        };
        if (!primitive) {
            seenObjects.set(object, result);
        }
        return result;
    };
    function getType(payload) {
        return Object.prototype.toString.call(payload).slice(8, -1);
    }
    function isArray$1(payload) {
        return getType(payload) === "Array";
    }
    function isPlainObject$1(payload) {
        if (getType(payload) !== "Object") return false;
        const prototype = Object.getPrototypeOf(payload);
        return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
    }
    function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
        const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
        if (propType === "enumerable") carry[key] = newVal;
        if (includeNonenumerable && propType === "nonenumerable") {
            Object.defineProperty(carry, key, {
                value: newVal,
                enumerable: false,
                writable: true,
                configurable: true
            });
        }
    }
    function copy(target, options = {}) {
        if (isArray$1(target)) {
            return target.map((item)=>copy(item, options));
        }
        if (!isPlainObject$1(target)) {
            return target;
        }
        const props = Object.getOwnPropertyNames(target);
        const symbols = Object.getOwnPropertySymbols(target);
        return [
            ...props,
            ...symbols
        ].reduce((carry, key)=>{
            if (isArray$1(options.props) && !options.props.includes(key)) {
                return carry;
            }
            const val = target[key];
            const newVal = copy(val, options);
            assignProp(carry, key, newVal, target, options.nonenumerable);
            return carry;
        }, {});
    }
    class SuperJSON {
        constructor({ dedupe = false } = {}){
            this.classRegistry = new ClassRegistry();
            this.symbolRegistry = new Registry((s)=>s.description ?? '');
            this.customTransformerRegistry = new CustomTransformerRegistry();
            this.allowedErrorProps = [];
            this.dedupe = dedupe;
        }
        serialize(object) {
            const identities = new Map();
            const output = walker(object, identities, this, this.dedupe);
            const res = {
                json: output.transformedValue
            };
            if (output.annotations) {
                res.meta = {
                    ...res.meta,
                    values: output.annotations
                };
            }
            const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
            if (equalityAnnotations) {
                res.meta = {
                    ...res.meta,
                    referentialEqualities: equalityAnnotations
                };
            }
            return res;
        }
        deserialize(payload) {
            const { json, meta } = payload;
            let result = copy(json);
            if (meta?.values) {
                result = applyValueAnnotations(result, meta.values, this);
            }
            if (meta?.referentialEqualities) {
                result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
            }
            return result;
        }
        stringify(object) {
            return JSON.stringify(this.serialize(object));
        }
        parse(string) {
            return this.deserialize(JSON.parse(string));
        }
        registerClass(v, options) {
            this.classRegistry.register(v, options);
        }
        registerSymbol(v, identifier) {
            this.symbolRegistry.register(v, identifier);
        }
        registerCustom(transformer, name) {
            this.customTransformerRegistry.register({
                name,
                ...transformer
            });
        }
        allowErrorProps(...props) {
            this.allowedErrorProps.push(...props);
        }
    }
    SuperJSON.defaultInstance = new SuperJSON();
    SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
    SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
    SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
    SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
    SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
    SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
    SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
    SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
    const stringify$1 = SuperJSON.stringify;
    const parse$1 = SuperJSON.parse;
    const registerCustom = SuperJSON.registerCustom;
    const MN_LDB_DEFAULT_DB_NAME = 'midnight-level-db';
    const MN_LDB_DEFAULT_PRIS_STORE_NAME = 'private-states';
    const MN_LDB_DEFAULT_KEY_STORE_NAME = 'signing-keys';
    const DEFAULT_CONFIG$1 = {
        midnightDbName: MN_LDB_DEFAULT_DB_NAME,
        privateStateStoreName: MN_LDB_DEFAULT_PRIS_STORE_NAME,
        signingKeyStoreName: MN_LDB_DEFAULT_KEY_STORE_NAME
    };
    registerCustom({
        isApplicable: (v)=>v instanceof bufferExports.Buffer,
        serialize: (v)=>v.toString('hex'),
        deserialize: (v)=>bufferExports.Buffer.from(v, 'hex')
    }, 'buffer');
    const withSubLevel = async (dbName, levelName, thunk)=>{
        const level = new browserExports.Level(dbName, {
            createIfMissing: true
        });
        const subLevel = level.sublevel(levelName, {
            valueEncoding: {
                encode: stringify$1,
                decode: parse$1,
                name: 'super-json-values'
            }
        });
        try {
            await level.open();
            await subLevel.open();
            return await thunk(subLevel);
        } finally{
            await subLevel.close();
            await level.close();
        }
    };
    const subLevelMaybeGet = (dbName, levelName, key)=>{
        return withSubLevel(dbName, levelName, async (subLevel)=>{
            const value = await subLevel.get(key);
            if (value === undefined) {
                return null;
            }
            return value;
        });
    };
    const levelPrivateStateProvider = (partialConfig = {})=>{
        const config = _.defaults(partialConfig, DEFAULT_CONFIG$1);
        return {
            get (privateStateId) {
                return subLevelMaybeGet(config.midnightDbName, config.privateStateStoreName, privateStateId);
            },
            remove (privateStateId) {
                return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel)=>subLevel.del(privateStateId));
            },
            set (privateStateId, state) {
                return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel)=>subLevel.put(privateStateId, state));
            },
            clear () {
                return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel)=>subLevel.clear());
            },
            getSigningKey (address) {
                return subLevelMaybeGet(config.midnightDbName, config.signingKeyStoreName, address);
            },
            removeSigningKey (address) {
                return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel)=>subLevel.del(address));
            },
            setSigningKey (address, signingKey) {
                return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel)=>subLevel.put(address, signingKey));
            },
            clearSigningKeys () {
                return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel)=>subLevel.clear());
            }
        };
    };
    const __vite__wasmUrl$2 = "/assets/midnight_ledger_wasm_bg-CdJVOlAF.wasm";
    let wasm$5;
    function __wbg_set_wasm$2(val) {
        wasm$5 = val;
    }
    function addToExternrefTable0$2(obj) {
        const idx = wasm$5.__externref_table_alloc();
        wasm$5.__wbindgen_export_2.set(idx, obj);
        return idx;
    }
    function handleError$3(f, args) {
        try {
            return f.apply(this, args);
        } catch (e) {
            const idx = addToExternrefTable0$2(e);
            wasm$5.__wbindgen_exn_store(idx);
        }
    }
    let WASM_VECTOR_LEN$2 = 0;
    let cachedUint8ArrayMemory0$2 = null;
    function getUint8ArrayMemory0$2() {
        if (cachedUint8ArrayMemory0$2 === null || cachedUint8ArrayMemory0$2.byteLength === 0) {
            cachedUint8ArrayMemory0$2 = new Uint8Array(wasm$5.memory.buffer);
        }
        return cachedUint8ArrayMemory0$2;
    }
    const lTextEncoder$2 = typeof TextEncoder === 'undefined' ? (commonjsRequire)('util').TextEncoder : TextEncoder;
    let cachedTextEncoder$2 = new lTextEncoder$2('utf-8');
    const encodeString$2 = (typeof cachedTextEncoder$2.encodeInto === 'function' ? function(arg, view) {
        return cachedTextEncoder$2.encodeInto(arg, view);
    } : function(arg, view) {
        const buf = cachedTextEncoder$2.encode(arg);
        view.set(buf);
        return {
            read: arg.length,
            written: buf.length
        };
    });
    function passStringToWasm0$2(arg, malloc, realloc) {
        if (realloc === undefined) {
            const buf = cachedTextEncoder$2.encode(arg);
            const ptr = malloc(buf.length, 1) >>> 0;
            getUint8ArrayMemory0$2().subarray(ptr, ptr + buf.length).set(buf);
            WASM_VECTOR_LEN$2 = buf.length;
            return ptr;
        }
        let len = arg.length;
        let ptr = malloc(len, 1) >>> 0;
        const mem = getUint8ArrayMemory0$2();
        let offset = 0;
        for(; offset < len; offset++){
            const code = arg.charCodeAt(offset);
            if (code > 0x7F) break;
            mem[ptr + offset] = code;
        }
        if (offset !== len) {
            if (offset !== 0) {
                arg = arg.slice(offset);
            }
            ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
            const view = getUint8ArrayMemory0$2().subarray(ptr + offset, ptr + len);
            const ret = encodeString$2(arg, view);
            offset += ret.written;
            ptr = realloc(ptr, len, offset, 1) >>> 0;
        }
        WASM_VECTOR_LEN$2 = offset;
        return ptr;
    }
    let cachedDataViewMemory0$2 = null;
    function getDataViewMemory0$2() {
        if (cachedDataViewMemory0$2 === null || cachedDataViewMemory0$2.buffer.detached === true || (cachedDataViewMemory0$2.buffer.detached === undefined && cachedDataViewMemory0$2.buffer !== wasm$5.memory.buffer)) {
            cachedDataViewMemory0$2 = new DataView(wasm$5.memory.buffer);
        }
        return cachedDataViewMemory0$2;
    }
    function isLikeNone$2(x) {
        return x === undefined || x === null;
    }
    const lTextDecoder$2 = typeof TextDecoder === 'undefined' ? (commonjsRequire)('util').TextDecoder : TextDecoder;
    let cachedTextDecoder$2 = new lTextDecoder$2('utf-8', {
        ignoreBOM: true,
        fatal: true
    });
    cachedTextDecoder$2.decode();
    function getStringFromWasm0$2(ptr, len) {
        ptr = ptr >>> 0;
        return cachedTextDecoder$2.decode(getUint8ArrayMemory0$2().subarray(ptr, ptr + len));
    }
    const CLOSURE_DTORS$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((state)=>{
        wasm$5.__wbindgen_export_5.get(state.dtor)(state.a, state.b);
    });
    function makeMutClosure$2(arg0, arg1, dtor, f) {
        const state = {
            a: arg0,
            b: arg1,
            cnt: 1,
            dtor
        };
        const real = (...args)=>{
            state.cnt++;
            const a = state.a;
            state.a = 0;
            try {
                return f(a, state.b, ...args);
            } finally{
                if (--state.cnt === 0) {
                    wasm$5.__wbindgen_export_5.get(state.dtor)(a, state.b);
                    CLOSURE_DTORS$2.unregister(state);
                } else {
                    state.a = a;
                }
            }
        };
        real.original = state;
        CLOSURE_DTORS$2.register(real, state, state);
        return real;
    }
    function debugString$2(val) {
        const type = typeof val;
        if (type == 'number' || type == 'boolean' || val == null) {
            return `${val}`;
        }
        if (type == 'string') {
            return `"${val}"`;
        }
        if (type == 'symbol') {
            const description = val.description;
            if (description == null) {
                return 'Symbol';
            } else {
                return `Symbol(${description})`;
            }
        }
        if (type == 'function') {
            const name = val.name;
            if (typeof name == 'string' && name.length > 0) {
                return `Function(${name})`;
            } else {
                return 'Function';
            }
        }
        if (Array.isArray(val)) {
            const length = val.length;
            let debug = '[';
            if (length > 0) {
                debug += debugString$2(val[0]);
            }
            for(let i = 1; i < length; i++){
                debug += ', ' + debugString$2(val[i]);
            }
            debug += ']';
            return debug;
        }
        const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
        let className;
        if (builtInMatches && builtInMatches.length > 1) {
            className = builtInMatches[1];
        } else {
            return toString.call(val);
        }
        if (className == 'Object') {
            try {
                return 'Object(' + JSON.stringify(val) + ')';
            } catch (_) {
                return 'Object';
            }
        }
        if (val instanceof Error) {
            return `${val.name}: ${val.message}\n${val.stack}`;
        }
        return className;
    }
    function takeFromExternrefTable0$2(idx) {
        const value = wasm$5.__wbindgen_export_2.get(idx);
        wasm$5.__externref_table_dealloc(idx);
        return value;
    }
    function _assertClass$2(instance, klass) {
        if (!(instance instanceof klass)) {
            throw new Error(`expected instance of ${klass.name}`);
        }
    }
    function getArrayJsValueFromWasm0$2(ptr, len) {
        ptr = ptr >>> 0;
        const mem = getDataViewMemory0$2();
        const result = [];
        for(let i = ptr; i < ptr + 4 * len; i += 4){
            result.push(wasm$5.__wbindgen_export_2.get(mem.getUint32(i, true)));
        }
        wasm$5.__externref_drop_slice(ptr, len);
        return result;
    }
    function passArrayJsValueToWasm0(array, malloc) {
        const ptr = malloc(array.length * 4, 4) >>> 0;
        for(let i = 0; i < array.length; i++){
            const add = addToExternrefTable0$2(array[i]);
            getDataViewMemory0$2().setUint32(ptr + 4 * i, add, true);
        }
        WASM_VECTOR_LEN$2 = array.length;
        return ptr;
    }
    function getArrayU8FromWasm0$2(ptr, len) {
        ptr = ptr >>> 0;
        return getUint8ArrayMemory0$2().subarray(ptr / 1, ptr / 1 + len);
    }
    function passArray8ToWasm0$2(arg, malloc) {
        const ptr = malloc(arg.length * 1, 1) >>> 0;
        getUint8ArrayMemory0$2().set(arg, ptr / 1);
        WASM_VECTOR_LEN$2 = arg.length;
        return ptr;
    }
    function __wbg_adapter_58(arg0, arg1, arg2) {
        wasm$5.closure1593_externref_shim(arg0, arg1, arg2);
    }
    function __wbg_adapter_657(arg0, arg1, arg2, arg3, arg4) {
        wasm$5.closure1651_externref_shim(arg0, arg1, arg2, arg3, arg4);
    }
    function __wbg_adapter_664(arg0, arg1, arg2, arg3) {
        wasm$5.closure1655_externref_shim(arg0, arg1, arg2, arg3);
    }
    const NetworkId$2 = Object.freeze({
        Undeployed: 0,
        "0": "Undeployed",
        DevNet: 1,
        "1": "DevNet",
        TestNet: 2,
        "2": "TestNet",
        MainNet: 3,
        "3": "MainNet"
    });
    const AuthorizedMintFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_authorizedmint_free(ptr >>> 0, 1));
    let AuthorizedMint$2 = class AuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(AuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            AuthorizedMintFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            AuthorizedMintFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_authorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.authorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            AuthorizedMintFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.authorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.authorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return AuthorizedMint.__wrap(ret[0]);
        }
        eraseProof() {
            const ret = wasm$5.authorizedmint_eraseProof(this.__wbg_ptr);
            return ProofErasedAuthorizedMint$2.__wrap(ret);
        }
        get coin() {
            const ret = wasm$5.authorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.authorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.authorizedmint_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const CoinSecretKeyFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_coinsecretkey_free(ptr >>> 0, 1));
    let CoinSecretKey$2 = class CoinSecretKey {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(CoinSecretKey.prototype);
            obj.__wbg_ptr = ptr;
            CoinSecretKeyFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            CoinSecretKeyFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_coinsecretkey_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.coinsecretkey_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            CoinSecretKeyFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        yesIKnowTheSecurityImplicationsOfThis_serialize(netid) {
            const ret = wasm$5.coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
    };
    const ContractAddressFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractaddress_free(ptr >>> 0, 1));
    let ContractAddress$2 = class ContractAddress {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractAddress.prototype);
            obj.__wbg_ptr = ptr;
            ContractAddressFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractAddressFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractaddress_free(ptr, 0);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$2(raw, wasm$5.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.contractaddress_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ContractAddress.__wrap(ret[0]);
        }
    };
    const ContractCallFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractcall_free(ptr >>> 0, 1));
    class ContractCall {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractCall.prototype);
            obj.__wbg_ptr = ptr;
            ContractCallFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractCallFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractcall_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.contractcall_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ContractCallFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get address() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.contractcall_address(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get entryPoint() {
            const ret = wasm$5.contractcall_entryPoint(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get guaranteedTranscript() {
            const ret = wasm$5.contractcall_guaranteedTranscript(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get fallibleTranscript() {
            const ret = wasm$5.contractcall_fallibleTranscript(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get communicationCommitment() {
            const ret = wasm$5.contractcall_communicationCommitment(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractcall_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractCallPrototypeFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractcallprototype_free(ptr >>> 0, 1));
    class ContractCallPrototype {
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractCallPrototypeFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractcallprototype_free(ptr, 0);
        }
        constructor(address, entry_point, op, guaranteed_public_transcript, fallible_public_transcript, private_transcript_outputs, input, output, communication_commitment_rand, key_location){
            const ptr0 = passStringToWasm0$2(address, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            _assertClass$2(op, ContractOperation);
            const ptr1 = passArrayJsValueToWasm0(private_transcript_outputs, wasm$5.__wbindgen_malloc);
            const len1 = WASM_VECTOR_LEN$2;
            const ptr2 = passStringToWasm0$2(communication_commitment_rand, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len2 = WASM_VECTOR_LEN$2;
            const ptr3 = passStringToWasm0$2(key_location, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len3 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.contractcallprototype_new(ptr0, len0, entry_point, op.__wbg_ptr, guaranteed_public_transcript, fallible_public_transcript, ptr1, len1, input, output, ptr2, len2, ptr3, len3);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ContractCallPrototypeFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractcallprototype_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractCallsPrototypeFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractcallsprototype_free(ptr >>> 0, 1));
    class ContractCallsPrototype {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractCallsPrototype.prototype);
            obj.__wbg_ptr = ptr;
            ContractCallsPrototypeFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractCallsPrototypeFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractcallsprototype_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.contractcallsprototype_new();
            this.__wbg_ptr = ret >>> 0;
            ContractCallsPrototypeFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        addCall(call) {
            _assertClass$2(call, ContractCallPrototype);
            const ret = wasm$5.contractcallsprototype_addCall(this.__wbg_ptr, call.__wbg_ptr);
            return ContractCallsPrototype.__wrap(ret);
        }
        addDeploy(deploy) {
            _assertClass$2(deploy, ContractDeploy);
            const ret = wasm$5.contractcallsprototype_addDeploy(this.__wbg_ptr, deploy.__wbg_ptr);
            return ContractCallsPrototype.__wrap(ret);
        }
        addMaintenanceUpdate(upd) {
            _assertClass$2(upd, MaintenanceUpdate);
            const ret = wasm$5.contractcallsprototype_addMaintenanceUpdate(this.__wbg_ptr, upd.__wbg_ptr);
            return ContractCallsPrototype.__wrap(ret);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractcallsprototype_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractDeployFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractdeploy_free(ptr >>> 0, 1));
    class ContractDeploy {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractDeploy.prototype);
            obj.__wbg_ptr = ptr;
            ContractDeployFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractDeployFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractdeploy_free(ptr, 0);
        }
        constructor(initial_state){
            _assertClass$2(initial_state, ContractState);
            const ret = wasm$5.contractdeploy_new(initial_state.__wbg_ptr);
            this.__wbg_ptr = ret >>> 0;
            ContractDeployFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get initialState() {
            const ret = wasm$5.contractdeploy_initialState(this.__wbg_ptr);
            return ContractState.__wrap(ret);
        }
        get address() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.contractdeploy_address(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractdeploy_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractMaintenanceAuthorityFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractmaintenanceauthority_free(ptr >>> 0, 1));
    class ContractMaintenanceAuthority {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractMaintenanceAuthority.prototype);
            obj.__wbg_ptr = ptr;
            ContractMaintenanceAuthorityFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractMaintenanceAuthorityFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractmaintenanceauthority_free(ptr, 0);
        }
        constructor(committee, threshold, counter){
            const ret = wasm$5.contractmaintenanceauthority_new(committee, threshold, isLikeNone$2(counter) ? 0 : addToExternrefTable0$2(counter));
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ContractMaintenanceAuthorityFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get committee() {
            const ret = wasm$5.contractmaintenanceauthority_committee(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get threshold() {
            const ret = wasm$5.contractmaintenanceauthority_threshold(this.__wbg_ptr);
            return ret >>> 0;
        }
        get counter() {
            const ret = wasm$5.contractmaintenanceauthority_counter(this.__wbg_ptr);
            return ret;
        }
        serialize(netid) {
            const ret = wasm$5.contractmaintenanceauthority_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.contractmaintenanceauthority_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ContractMaintenanceAuthority.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractmaintenanceauthority_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractOperationFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractoperation_free(ptr >>> 0, 1));
    class ContractOperation {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractOperation.prototype);
            obj.__wbg_ptr = ptr;
            ContractOperationFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractOperationFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractoperation_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.contractoperation_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ContractOperationFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get verifierKey() {
            const ret = wasm$5.contractoperation_verifier_key(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        set verifierKey(key) {
            const ret = wasm$5.contractoperation_set_verifier_key(this.__wbg_ptr, key);
            if (ret[1]) {
                throw takeFromExternrefTable0$2(ret[0]);
            }
        }
        serialize(netid) {
            const ret = wasm$5.contractoperation_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.contractoperation_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ContractOperation.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractoperation_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractOperationVersionFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractoperationversion_free(ptr >>> 0, 1));
    class ContractOperationVersion {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractOperationVersion.prototype);
            obj.__wbg_ptr = ptr;
            ContractOperationVersionFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractOperationVersionFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractoperationversion_free(ptr, 0);
        }
        constructor(version){
            const ptr0 = passStringToWasm0$2(version, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.contractoperationversion_new(ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ContractOperationVersionFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get version() {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractoperationversion_version(this.__wbg_ptr);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractoperationversion_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractOperationVersionedVerifierKeyFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractoperationversionedverifierkey_free(ptr >>> 0, 1));
    class ContractOperationVersionedVerifierKey {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractOperationVersionedVerifierKey.prototype);
            obj.__wbg_ptr = ptr;
            ContractOperationVersionedVerifierKeyFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractOperationVersionedVerifierKeyFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractoperationversionedverifierkey_free(ptr, 0);
        }
        constructor(version, raw_vk){
            const ptr0 = passStringToWasm0$2(version, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.contractoperationversionedverifierkey_new(ptr0, len0, raw_vk);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ContractOperationVersionedVerifierKeyFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get version() {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractoperationversionedverifierkey_version(this.__wbg_ptr);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
        get rawVk() {
            const ret = wasm$5.contractoperationversionedverifierkey_raw_vk(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractoperationversionedverifierkey_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ContractStateFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_contractstate_free(ptr >>> 0, 1));
    class ContractState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractState.prototype);
            obj.__wbg_ptr = ptr;
            ContractStateFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractStateFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_contractstate_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.contractstate_new();
            this.__wbg_ptr = ret >>> 0;
            ContractStateFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get data() {
            const ret = wasm$5.contractstate_data(this.__wbg_ptr);
            return StateValue.__wrap(ret);
        }
        set data(data) {
            _assertClass$2(data, StateValue);
            wasm$5.contractstate_set_data(this.__wbg_ptr, data.__wbg_ptr);
        }
        get maintenanceAuthority() {
            const ret = wasm$5.contractstate_maintenance_authority(this.__wbg_ptr);
            return ContractMaintenanceAuthority.__wrap(ret);
        }
        set maintenanceAuthority(authority) {
            _assertClass$2(authority, ContractMaintenanceAuthority);
            wasm$5.contractstate_set_maintenance_authority(this.__wbg_ptr, authority.__wbg_ptr);
        }
        operations() {
            const ret = wasm$5.contractstate_operations(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        operation(operation) {
            const ret = wasm$5.contractstate_operation(this.__wbg_ptr, operation);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ret[0] === 0 ? undefined : ContractOperation.__wrap(ret[0]);
        }
        setOperation(operation, value) {
            _assertClass$2(value, ContractOperation);
            const ret = wasm$5.contractstate_setOperation(this.__wbg_ptr, operation, value.__wbg_ptr);
            if (ret[1]) {
                throw takeFromExternrefTable0$2(ret[0]);
            }
        }
        query(query, cost_model) {
            _assertClass$2(cost_model, CostModel);
            const ret = wasm$5.contractstate_query(this.__wbg_ptr, query, cost_model.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.contractstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.contractstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ContractState.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.contractstate_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const CostModelFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_costmodel_free(ptr >>> 0, 1));
    class CostModel {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(CostModel.prototype);
            obj.__wbg_ptr = ptr;
            CostModelFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            CostModelFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_costmodel_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.costmodel_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            CostModelFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static dummyCostModel() {
            const ret = wasm$5.costmodel_dummyCostModel();
            return CostModel.__wrap(ret);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.costmodel_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const EncryptionSecretKeyFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_encryptionsecretkey_free(ptr >>> 0, 1));
    let EncryptionSecretKey$2 = class EncryptionSecretKey {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(EncryptionSecretKey.prototype);
            obj.__wbg_ptr = ptr;
            EncryptionSecretKeyFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            EncryptionSecretKeyFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_encryptionsecretkey_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.encryptionsecretkey_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            EncryptionSecretKeyFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        test(offer) {
            _assertClass$2(offer, Offer$2);
            const ret = wasm$5.encryptionsecretkey_test(this.__wbg_ptr, offer.__wbg_ptr);
            return ret !== 0;
        }
        yesIKnowTheSecurityImplicationsOfThis_serialize(netid) {
            const ret = wasm$5.encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.encryptionsecretkey_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return EncryptionSecretKey.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$2(raw, wasm$5.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.encryptionsecretkey_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return EncryptionSecretKey.__wrap(ret[0]);
        }
    };
    const InputFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_input_free(ptr >>> 0, 1));
    let Input$2 = class Input {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Input.prototype);
            obj.__wbg_ptr = ptr;
            InputFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            InputFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_input_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.input_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            InputFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.input_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.input_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Input.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.input_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.input_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.input_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$5.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$5.__wbg_intounderlyingsink_free(ptr >>> 0, 1));
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$5.__wbg_intounderlyingsource_free(ptr >>> 0, 1));
    const LedgerParametersFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_ledgerparameters_free(ptr >>> 0, 1));
    let LedgerParameters$2 = class LedgerParameters {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(LedgerParameters.prototype);
            obj.__wbg_ptr = ptr;
            LedgerParametersFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            LedgerParametersFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_ledgerparameters_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.ledgerparameters_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            LedgerParametersFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static dummyParameters() {
            const ret = wasm$5.ledgerparameters_dummyParameters();
            return LedgerParameters.__wrap(ret);
        }
        get transactionCostModel() {
            const ret = wasm$5.ledgerparameters_transactionCostModel(this.__wbg_ptr);
            return TransactionCostModel$2.__wrap(ret);
        }
        serialize(netid) {
            const ret = wasm$5.ledgerparameters_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.ledgerparameters_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LedgerParameters.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.ledgerparameters_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const LedgerStateFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_ledgerstate_free(ptr >>> 0, 1));
    class LedgerState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(LedgerState.prototype);
            obj.__wbg_ptr = ptr;
            LedgerStateFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            LedgerStateFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_ledgerstate_free(ptr, 0);
        }
        constructor(zswap){
            _assertClass$2(zswap, ZswapChainState$2);
            const ret = wasm$5.ledgerstate_new(zswap.__wbg_ptr);
            this.__wbg_ptr = ret >>> 0;
            LedgerStateFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static blank() {
            const ret = wasm$5.ledgerstate_blank();
            return LedgerState.__wrap(ret);
        }
        get parameters() {
            const ret = wasm$5.ledgerstate_parameters(this.__wbg_ptr);
            return LedgerParameters$2.__wrap(ret);
        }
        set parameters(params) {
            _assertClass$2(params, LedgerParameters$2);
            wasm$5.ledgerstate_set_parameters(this.__wbg_ptr, params.__wbg_ptr);
        }
        treasuryBalance(token_type) {
            const ptr0 = passStringToWasm0$2(token_type, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.ledgerstate_treasuryBalance(this.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        unclaimedMints(recipient, token_type) {
            const ptr0 = passStringToWasm0$2(recipient, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ptr1 = passStringToWasm0$2(token_type, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.ledgerstate_unclaimedMints(this.__wbg_ptr, ptr0, len0, ptr1, len1);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get unmintedNativeTokenSupply() {
            const ret = wasm$5.ledgerstate_unminted_native_token_supply(this.__wbg_ptr);
            return ret;
        }
        get zswap() {
            const ret = wasm$5.ledgerstate_zswap(this.__wbg_ptr);
            return ZswapChainState$2.__wrap(ret);
        }
        apply(transaction, context) {
            _assertClass$2(transaction, ProofErasedTransaction$2);
            _assertClass$2(context, TransactionContext);
            const ret = wasm$5.ledgerstate_apply(this.__wbg_ptr, transaction.__wbg_ptr, context.__wbg_ptr);
            return ret;
        }
        applySystemTx(tx) {
            _assertClass$2(tx, SystemTransaction$2);
            const ret = wasm$5.ledgerstate_applySystemTx(this.__wbg_ptr, tx.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LedgerState.__wrap(ret[0]);
        }
        index(address) {
            const ptr0 = passStringToWasm0$2(address, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.ledgerstate_index(this.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ret[0] === 0 ? undefined : ContractState.__wrap(ret[0]);
        }
        updateIndex(address, context) {
            const ptr0 = passStringToWasm0$2(address, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            _assertClass$2(context, QueryContext);
            const ret = wasm$5.ledgerstate_updateIndex(this.__wbg_ptr, ptr0, len0, context.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LedgerState.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.ledgerstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.ledgerstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LedgerState.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.ledgerstate_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const LocalStateFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_localstate_free(ptr >>> 0, 1));
    let LocalState$2 = class LocalState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(LocalState.prototype);
            obj.__wbg_ptr = ptr;
            LocalStateFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            LocalStateFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_localstate_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.localstate_new();
            this.__wbg_ptr = ret >>> 0;
            LocalStateFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        authorizeMint(secret_keys, coin) {
            _assertClass$2(secret_keys, SecretKeys$2);
            const ret = wasm$5.localstate_authorizeMint(this.__wbg_ptr, secret_keys.__wbg_ptr, coin);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenAuthorizedMint$2.__wrap(ret[0]);
        }
        get firstFree() {
            const ret = wasm$5.localstate_firstFree(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        get coins() {
            const ret = wasm$5.localstate_coins(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get pendingSpends() {
            const ret = wasm$5.localstate_pendingSpends(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get pendingOutputs() {
            const ret = wasm$5.localstate_pendingOutputs(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        applyMint(secret_keys, mint) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(mint, AuthorizedMint$2);
            const ret = wasm$5.localstate_applyMint(this.__wbg_ptr, secret_keys.__wbg_ptr, mint.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyProofErasedMint(secret_keys, mint) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(mint, ProofErasedAuthorizedMint$2);
            const ret = wasm$5.localstate_applyProofErasedMint(this.__wbg_ptr, secret_keys.__wbg_ptr, mint.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyFailed(offer) {
            _assertClass$2(offer, Offer$2);
            const ret = wasm$5.localstate_applyFailed(this.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyFailedProofErased(offer) {
            _assertClass$2(offer, ProofErasedOffer$2);
            const ret = wasm$5.localstate_applyFailedProofErased(this.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        apply(secret_keys, offer) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(offer, Offer$2);
            const ret = wasm$5.localstate_apply(this.__wbg_ptr, secret_keys.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyProofErased(secret_keys, offer) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(offer, ProofErasedOffer$2);
            const ret = wasm$5.localstate_applyProofErased(this.__wbg_ptr, secret_keys.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyTx(secret_keys, tx, res) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(tx, Transaction$2);
            const ptr0 = passStringToWasm0$2(res, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.localstate_applyTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        applyProofErasedTx(secret_keys, tx, res) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(tx, ProofErasedTransaction$2);
            const ptr0 = passStringToWasm0$2(res, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.localstate_applyProofErasedTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        applySystemTx(secret_keys, tx) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(tx, SystemTransaction$2);
            const ret = wasm$5.localstate_applySystemTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyCollapsedUpdate(update) {
            _assertClass$2(update, MerkleTreeCollapsedUpdate$2);
            const ret = wasm$5.localstate_applyCollapsedUpdate(this.__wbg_ptr, update.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        spend(secret_keys, coin, segment) {
            _assertClass$2(secret_keys, SecretKeys$2);
            const ret = wasm$5.localstate_spend(this.__wbg_ptr, secret_keys.__wbg_ptr, coin, segment);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        spendFromOutput(secret_keys, coin, segment, output) {
            _assertClass$2(secret_keys, SecretKeys$2);
            _assertClass$2(output, UnprovenOutput$2);
            const ret = wasm$5.localstate_spendFromOutput(this.__wbg_ptr, secret_keys.__wbg_ptr, coin, segment, output.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        watchFor(coin_public_key, coin) {
            const ptr0 = passStringToWasm0$2(coin_public_key, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.localstate_watchFor(this.__wbg_ptr, ptr0, len0, coin);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.localstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.localstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.localstate_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const MaintenanceUpdateFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_maintenanceupdate_free(ptr >>> 0, 1));
    class MaintenanceUpdate {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(MaintenanceUpdate.prototype);
            obj.__wbg_ptr = ptr;
            MaintenanceUpdateFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            MaintenanceUpdateFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_maintenanceupdate_free(ptr, 0);
        }
        constructor(address, updates, counter){
            const ptr0 = passStringToWasm0$2(address, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ptr1 = passArrayJsValueToWasm0(updates, wasm$5.__wbindgen_malloc);
            const len1 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.maintenanceupdate_new(ptr0, len0, ptr1, len1, counter);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            MaintenanceUpdateFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        addSignature(idx, signature) {
            const ptr0 = passStringToWasm0$2(signature, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.maintenanceupdate_addSignature(this.__wbg_ptr, idx, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return MaintenanceUpdate.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.maintenanceupdate_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
        get dataToSign() {
            const ret = wasm$5.maintenanceupdate_data_to_sign(this.__wbg_ptr);
            return ret;
        }
        get address() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.maintenanceupdate_address(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get updates() {
            const ret = wasm$5.maintenanceupdate_updates(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get counter() {
            const ret = wasm$5.maintenanceupdate_counter(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        get signatures() {
            const ret = wasm$5.maintenanceupdate_signatures(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
    }
    const MerkleTreeCollapsedUpdateFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_merkletreecollapsedupdate_free(ptr >>> 0, 1));
    let MerkleTreeCollapsedUpdate$2 = class MerkleTreeCollapsedUpdate {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(MerkleTreeCollapsedUpdate.prototype);
            obj.__wbg_ptr = ptr;
            MerkleTreeCollapsedUpdateFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            MerkleTreeCollapsedUpdateFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_merkletreecollapsedupdate_free(ptr, 0);
        }
        constructor(state, start, end){
            _assertClass$2(state, ZswapChainState$2);
            const ret = wasm$5.merkletreecollapsedupdate_new(state.__wbg_ptr, start, end);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            MerkleTreeCollapsedUpdateFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static new_raw(state, start, end) {
            _assertClass$2(state, ZswapChainState$2);
            const ret = wasm$5.merkletreecollapsedupdate_new_raw(state.__wbg_ptr, start, end);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return MerkleTreeCollapsedUpdate.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.merkletreecollapsedupdate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        serialize_raw(netid) {
            const ret = wasm$5.merkletreecollapsedupdate_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.merkletreecollapsedupdate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return MerkleTreeCollapsedUpdate.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.merkletreecollapsedupdate_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const OfferFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_offer_free(ptr >>> 0, 1));
    let Offer$2 = class Offer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Offer.prototype);
            obj.__wbg_ptr = ptr;
            OfferFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            OfferFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_offer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.offer_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            OfferFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        merge(other) {
            _assertClass$2(other, Offer);
            const ret = wasm$5.offer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.offer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        serialize_raw(netid) {
            const ret = wasm$5.offer_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.offer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$2(raw, wasm$5.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.offer_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$5.offer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$5.offer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$5.offer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$5.offer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.offer_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const OutputFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_output_free(ptr >>> 0, 1));
    let Output$2 = class Output {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Output.prototype);
            obj.__wbg_ptr = ptr;
            OutputFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            OutputFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_output_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.output_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            OutputFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.output_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.output_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Output.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.output_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.output_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.output_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const PreTranscriptFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_pretranscript_free(ptr >>> 0, 1));
    class PreTranscript {
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            PreTranscriptFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_pretranscript_free(ptr, 0);
        }
        constructor(context, program, comm_comm){
            _assertClass$2(context, QueryContext);
            const ret = wasm$5.pretranscript_new(context.__wbg_ptr, program, comm_comm);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            PreTranscriptFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.pretranscript_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ProofErasedAuthorizedMintFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_prooferasedauthorizedmint_free(ptr >>> 0, 1));
    let ProofErasedAuthorizedMint$2 = class ProofErasedAuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedAuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedAuthorizedMintFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedAuthorizedMintFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_prooferasedauthorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.prooferasedauthorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedAuthorizedMintFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.prooferasedauthorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.prooferasedauthorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedAuthorizedMint.__wrap(ret[0]);
        }
        get coin() {
            const ret = wasm$5.prooferasedauthorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.prooferasedauthorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.prooferasedauthorizedmint_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedInputFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_prooferasedinput_free(ptr >>> 0, 1));
    let ProofErasedInput$2 = class ProofErasedInput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedInput.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedInputFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedInputFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_prooferasedinput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.prooferasedinput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedInputFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.prooferasedinput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.prooferasedinput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedInput.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.prooferasedinput_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.prooferasedinput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.prooferasedinput_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedOfferFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_prooferasedoffer_free(ptr >>> 0, 1));
    let ProofErasedOffer$2 = class ProofErasedOffer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedOffer.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedOfferFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedOfferFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_prooferasedoffer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.prooferasedoffer_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedOfferFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        merge(other) {
            _assertClass$2(other, ProofErasedOffer);
            const ret = wasm$5.prooferasedoffer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedOffer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.prooferasedoffer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.prooferasedoffer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedOffer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$5.prooferasedoffer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$5.prooferasedoffer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$5.prooferasedoffer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$5.prooferasedoffer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.prooferasedoffer_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedOutputFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_prooferasedoutput_free(ptr >>> 0, 1));
    let ProofErasedOutput$2 = class ProofErasedOutput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedOutput.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedOutputFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedOutputFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_prooferasedoutput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.prooferasedoutput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedOutputFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.prooferasedoutput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.prooferasedoutput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedOutput.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.prooferasedoutput_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.prooferasedoutput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.prooferasedoutput_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedTransactionFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_prooferasedtransaction_free(ptr >>> 0, 1));
    let ProofErasedTransaction$2 = class ProofErasedTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedTransaction.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedTransactionFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedTransactionFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_prooferasedtransaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.prooferasedtransaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedTransactionFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        get mint() {
            const ret = wasm$5.prooferasedtransaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedAuthorizedMint$2.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$5.prooferasedtransaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedOffer$2.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$5.prooferasedtransaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedOffer$2.__wrap(ret);
        }
        wellFormed(ref_state, strictness) {
            _assertClass$2(ref_state, LedgerState);
            _assertClass$2(strictness, WellFormedStrictness);
            const ret = wasm$5.prooferasedtransaction_wellFormed(this.__wbg_ptr, ref_state.__wbg_ptr, strictness.__wbg_ptr);
            if (ret[1]) {
                throw takeFromExternrefTable0$2(ret[0]);
            }
        }
        identifiers() {
            const ret = wasm$5.prooferasedtransaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass$2(other, ProofErasedTransaction);
            const ret = wasm$5.prooferasedtransaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedTransaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.prooferasedtransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.prooferasedtransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedTransaction.__wrap(ret[0]);
        }
        imbalances(guaranteed, fees) {
            const ret = wasm$5.prooferasedtransaction_imbalances(this.__wbg_ptr, guaranteed, isLikeNone$2(fees) ? 0 : addToExternrefTable0$2(fees));
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        fees(params) {
            _assertClass$2(params, LedgerParameters$2);
            const ret = wasm$5.prooferasedtransaction_fees(this.__wbg_ptr, params.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get contractCalls() {
            const ret = wasm$5.prooferasedtransaction_contractCalls(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.prooferasedtransaction_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedTransientFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_prooferasedtransient_free(ptr >>> 0, 1));
    let ProofErasedTransient$2 = class ProofErasedTransient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedTransient.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedTransientFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedTransientFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_prooferasedtransient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.prooferasedtransient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedTransientFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.prooferasedtransient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.prooferasedtransient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ProofErasedTransient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.prooferasedtransient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.prooferasedtransient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.prooferasedtransient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.prooferasedtransient_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const QueryContextFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_querycontext_free(ptr >>> 0, 1));
    class QueryContext {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(QueryContext.prototype);
            obj.__wbg_ptr = ptr;
            QueryContextFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            QueryContextFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_querycontext_free(ptr, 0);
        }
        constructor(state, address){
            _assertClass$2(state, StateValue);
            const ptr0 = passStringToWasm0$2(address, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.querycontext_new(state.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            QueryContextFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get state() {
            const ret = wasm$5.querycontext_state(this.__wbg_ptr);
            return StateValue.__wrap(ret);
        }
        get address() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.querycontext_address(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get effects() {
            const ret = wasm$5.querycontext_effects(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        set effects(effects) {
            const ret = wasm$5.querycontext_set_effects(this.__wbg_ptr, effects);
            if (ret[1]) {
                throw takeFromExternrefTable0$2(ret[0]);
            }
        }
        get block() {
            const ret = wasm$5.querycontext_block(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        set block(block) {
            const ret = wasm$5.querycontext_set_block(this.__wbg_ptr, block);
            if (ret[1]) {
                throw takeFromExternrefTable0$2(ret[0]);
            }
        }
        get comIndicies() {
            const ret = wasm$5.querycontext_com_indicies(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        insertCommitment(comm, index) {
            const ptr0 = passStringToWasm0$2(comm, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.querycontext_insertCommitment(this.__wbg_ptr, ptr0, len0, index);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return QueryContext.__wrap(ret[0]);
        }
        qualify(coin) {
            const ret = wasm$5.querycontext_qualify(this.__wbg_ptr, coin);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        runTranscript(transcript, cost_model) {
            _assertClass$2(cost_model, CostModel);
            const ret = wasm$5.querycontext_runTranscript(this.__wbg_ptr, transcript, cost_model.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return QueryContext.__wrap(ret[0]);
        }
        query(ops, cost_model, gas_limit) {
            _assertClass$2(cost_model, CostModel);
            const ret = wasm$5.querycontext_query(this.__wbg_ptr, ops, cost_model.__wbg_ptr, !isLikeNone$2(gas_limit), isLikeNone$2(gas_limit) ? BigInt(0) : gas_limit);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return QueryResults.__wrap(ret[0]);
        }
        intoTranscript(program, cost_model) {
            _assertClass$2(cost_model, CostModel);
            const ret = wasm$5.querycontext_intoTranscript(this.__wbg_ptr, program, cost_model.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.querycontext_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const QueryResultsFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_queryresults_free(ptr >>> 0, 1));
    class QueryResults {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(QueryResults.prototype);
            obj.__wbg_ptr = ptr;
            QueryResultsFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            QueryResultsFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_queryresults_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.queryresults_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            QueryResultsFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get context() {
            const ret = wasm$5.queryresults_context(this.__wbg_ptr);
            return QueryContext.__wrap(ret);
        }
        get events() {
            const ret = wasm$5.queryresults_events(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get gasCost() {
            const ret = wasm$5.queryresults_gas_cost(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.queryresults_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ReplaceAuthorityFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_replaceauthority_free(ptr >>> 0, 1));
    class ReplaceAuthority {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ReplaceAuthority.prototype);
            obj.__wbg_ptr = ptr;
            ReplaceAuthorityFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ReplaceAuthorityFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_replaceauthority_free(ptr, 0);
        }
        constructor(authority){
            _assertClass$2(authority, ContractMaintenanceAuthority);
            const ret = wasm$5.replaceauthority_new(authority.__wbg_ptr);
            this.__wbg_ptr = ret >>> 0;
            ReplaceAuthorityFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get authority() {
            const ret = wasm$5.replaceauthority_authority(this.__wbg_ptr);
            return ContractMaintenanceAuthority.__wrap(ret);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.replaceauthority_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const SecretKeysFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_secretkeys_free(ptr >>> 0, 1));
    let SecretKeys$2 = class SecretKeys {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(SecretKeys.prototype);
            obj.__wbg_ptr = ptr;
            SecretKeysFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            SecretKeysFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_secretkeys_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.secretkeys_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            SecretKeysFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromSeed(seed) {
            const ret = wasm$5.secretkeys_fromSeed(seed);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return SecretKeys.__wrap(ret[0]);
        }
        static fromSeedRng(seed) {
            const ret = wasm$5.secretkeys_fromSeedRng(seed);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return SecretKeys.__wrap(ret[0]);
        }
        get coinPublicKey() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.secretkeys_coinPublicKey(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get encryptionPublicKey() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.secretkeys_encryptionPublicKey(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get encryptionSecretKey() {
            const ret = wasm$5.secretkeys_encryptionSecretKey(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return EncryptionSecretKey$2.__wrap(ret[0]);
        }
        get coinSecretKey() {
            const ret = wasm$5.secretkeys_coinSecretKey(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return CoinSecretKey$2.__wrap(ret[0]);
        }
    };
    const StateBoundedMerkleTreeFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_stateboundedmerkletree_free(ptr >>> 0, 1));
    class StateBoundedMerkleTree {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(StateBoundedMerkleTree.prototype);
            obj.__wbg_ptr = ptr;
            StateBoundedMerkleTreeFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            StateBoundedMerkleTreeFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_stateboundedmerkletree_free(ptr, 0);
        }
        constructor(height){
            const ret = wasm$5.stateboundedmerkletree_blank(height);
            this.__wbg_ptr = ret >>> 0;
            StateBoundedMerkleTreeFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get height() {
            const ret = wasm$5.stateboundedmerkletree_height(this.__wbg_ptr);
            return ret;
        }
        root() {
            const ret = wasm$5.stateboundedmerkletree_root(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        findPathForLeaf(leaf) {
            const ret = wasm$5.stateboundedmerkletree_findPathForLeaf(this.__wbg_ptr, leaf);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        pathForLeaf(index, leaf) {
            const ret = wasm$5.stateboundedmerkletree_pathForLeaf(this.__wbg_ptr, index, leaf);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        update(index, leaf) {
            const ret = wasm$5.stateboundedmerkletree_update(this.__wbg_ptr, index, leaf);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return StateBoundedMerkleTree.__wrap(ret[0]);
        }
        collapse(start, end) {
            const ret = wasm$5.stateboundedmerkletree_collapse(this.__wbg_ptr, start, end);
            return StateBoundedMerkleTree.__wrap(ret);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.stateboundedmerkletree_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const StateMapFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_statemap_free(ptr >>> 0, 1));
    class StateMap {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(StateMap.prototype);
            obj.__wbg_ptr = ptr;
            StateMapFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            StateMapFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_statemap_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.statemap_new();
            this.__wbg_ptr = ret >>> 0;
            StateMapFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        keys() {
            const ret = wasm$5.statemap_keys(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get(key) {
            const ret = wasm$5.statemap_get(this.__wbg_ptr, key);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ret[0] === 0 ? undefined : StateValue.__wrap(ret[0]);
        }
        insert(key, value) {
            _assertClass$2(value, StateValue);
            const ret = wasm$5.statemap_insert(this.__wbg_ptr, key, value.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return StateMap.__wrap(ret[0]);
        }
        remove(key) {
            const ret = wasm$5.statemap_remove(this.__wbg_ptr, key);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return StateMap.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.statemap_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const StateValueFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_statevalue_free(ptr >>> 0, 1));
    class StateValue {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(StateValue.prototype);
            obj.__wbg_ptr = ptr;
            StateValueFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            StateValueFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_statevalue_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.statevalue_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            StateValueFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        type() {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.statevalue_type(this.__wbg_ptr);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
        static newNull() {
            const ret = wasm$5.statevalue_newNull();
            return StateValue.__wrap(ret);
        }
        static newCell(value) {
            const ret = wasm$5.statevalue_newCell(value);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return StateValue.__wrap(ret[0]);
        }
        static newMap(map) {
            _assertClass$2(map, StateMap);
            const ret = wasm$5.statevalue_newMap(map.__wbg_ptr);
            return StateValue.__wrap(ret);
        }
        static newBoundedMerkleTree(tree) {
            _assertClass$2(tree, StateBoundedMerkleTree);
            const ret = wasm$5.statevalue_newBoundedMerkleTree(tree.__wbg_ptr);
            return StateValue.__wrap(ret);
        }
        static newArray() {
            const ret = wasm$5.statevalue_newArray();
            return StateValue.__wrap(ret);
        }
        arrayPush(value) {
            _assertClass$2(value, StateValue);
            const ret = wasm$5.statevalue_arrayPush(this.__wbg_ptr, value.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return StateValue.__wrap(ret[0]);
        }
        asCell() {
            const ret = wasm$5.statevalue_asCell(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        asMap() {
            const ret = wasm$5.statevalue_asMap(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ret[0] === 0 ? undefined : StateMap.__wrap(ret[0]);
        }
        asBoundedMerkleTree() {
            const ret = wasm$5.statevalue_asBoundedMerkleTree(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ret[0] === 0 ? undefined : StateBoundedMerkleTree.__wrap(ret[0]);
        }
        asArray() {
            const ret = wasm$5.statevalue_asArray(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            }
            return v1;
        }
        logSize() {
            const ret = wasm$5.statevalue_logSize(this.__wbg_ptr);
            return ret >>> 0;
        }
        encode() {
            const ret = wasm$5.statevalue_encode(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static decode(value) {
            const ret = wasm$5.statevalue_decode(value);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return StateValue.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.statevalue_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const SystemTransactionFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_systemtransaction_free(ptr >>> 0, 1));
    let SystemTransaction$2 = class SystemTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(SystemTransaction.prototype);
            obj.__wbg_ptr = ptr;
            SystemTransactionFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            SystemTransactionFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_systemtransaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.systemtransaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            SystemTransactionFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.systemtransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.systemtransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return SystemTransaction.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.systemtransaction_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const TransactionFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_transaction_free(ptr >>> 0, 1));
    let Transaction$2 = class Transaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Transaction.prototype);
            obj.__wbg_ptr = ptr;
            TransactionFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_transaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.transaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        get mint() {
            const ret = wasm$5.transaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : AuthorizedMint$2.__wrap(ret);
        }
        static fromUnproven(prove, unproven) {
            _assertClass$2(unproven, UnprovenTransaction$2);
            const ret = wasm$5.transaction_fromUnproven(prove, unproven.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        eraseProofs() {
            const ret = wasm$5.transaction_eraseProofs(this.__wbg_ptr);
            return ProofErasedTransaction$2.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$5.transaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : Offer$2.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$5.transaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : Offer$2.__wrap(ret);
        }
        wellFormed(ref_state, strictness) {
            _assertClass$2(ref_state, LedgerState);
            _assertClass$2(strictness, WellFormedStrictness);
            const ret = wasm$5.transaction_wellFormed(this.__wbg_ptr, ref_state.__wbg_ptr, strictness.__wbg_ptr);
            if (ret[1]) {
                throw takeFromExternrefTable0$2(ret[0]);
            }
        }
        transactionHash() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.transaction_transactionHash(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        identifiers() {
            const ret = wasm$5.transaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass$2(other, Transaction);
            const ret = wasm$5.transaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Transaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.transaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.transaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Transaction.__wrap(ret[0]);
        }
        imbalances(guaranteed, fees) {
            const ret = wasm$5.transaction_imbalances(this.__wbg_ptr, guaranteed, isLikeNone$2(fees) ? 0 : addToExternrefTable0$2(fees));
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        fees(params) {
            _assertClass$2(params, LedgerParameters$2);
            const ret = wasm$5.transaction_fees(this.__wbg_ptr, params.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get contractCalls() {
            const ret = wasm$5.transaction_contractCalls(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.transaction_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const TransactionContextFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_transactioncontext_free(ptr >>> 0, 1));
    class TransactionContext {
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionContextFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_transactioncontext_free(ptr, 0);
        }
        constructor(ref_state, block_context, whitelist){
            _assertClass$2(ref_state, LedgerState);
            const ret = wasm$5.transactioncontext_new(ref_state.__wbg_ptr, block_context, whitelist);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionContextFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.transactioncontext_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const TransactionCostModelFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_transactioncostmodel_free(ptr >>> 0, 1));
    let TransactionCostModel$2 = class TransactionCostModel {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(TransactionCostModel.prototype);
            obj.__wbg_ptr = ptr;
            TransactionCostModelFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionCostModelFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_transactioncostmodel_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.transactioncostmodel_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionCostModelFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static dummyTransactionCostModel() {
            const ret = wasm$5.transactioncostmodel_dummyTransactionCostModel();
            return TransactionCostModel.__wrap(ret);
        }
        get inputFeeOverhead() {
            const ret = wasm$5.transactioncostmodel_inputFeeOverhead(this.__wbg_ptr);
            return ret;
        }
        get outputFeeOverhead() {
            const ret = wasm$5.transactioncostmodel_outputFeeOverhead(this.__wbg_ptr);
            return ret;
        }
        serialize(netid) {
            const ret = wasm$5.transactioncostmodel_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.transactioncostmodel_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return TransactionCostModel.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.transactioncostmodel_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const TransactionResultFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_transactionresult_free(ptr >>> 0, 1));
    class TransactionResult {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(TransactionResult.prototype);
            obj.__wbg_ptr = ptr;
            TransactionResultFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionResultFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_transactionresult_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.transactionresult_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionResultFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get type() {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.transactionresult_type_(this.__wbg_ptr);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
        get error() {
            const ret = wasm$5.transactionresult_error(this.__wbg_ptr);
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.transactionresult_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const TransientFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_transient_free(ptr >>> 0, 1));
    let Transient$2 = class Transient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Transient.prototype);
            obj.__wbg_ptr = ptr;
            TransientFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransientFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_transient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.transient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransientFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.transient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.transient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return Transient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.transient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.transient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.transient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.transient_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenAuthorizedMintFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_unprovenauthorizedmint_free(ptr >>> 0, 1));
    let UnprovenAuthorizedMint$2 = class UnprovenAuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenAuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenAuthorizedMintFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenAuthorizedMintFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_unprovenauthorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.unprovenauthorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenAuthorizedMintFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$5.unprovenauthorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.unprovenauthorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenAuthorizedMint.__wrap(ret[0]);
        }
        eraseProof() {
            const ret = wasm$5.authorizedmint_eraseProof(this.__wbg_ptr);
            return ProofErasedAuthorizedMint$2.__wrap(ret);
        }
        get coin() {
            const ret = wasm$5.unprovenauthorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.unprovenauthorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.unprovenauthorizedmint_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenInputFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_unproveninput_free(ptr >>> 0, 1));
    let UnprovenInput$2 = class UnprovenInput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenInput.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenInputFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenInputFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_unproveninput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.unproveninput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenInputFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static newContractOwned(coin, segment, contract, state) {
            const ptr0 = passStringToWasm0$2(contract, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            _assertClass$2(state, ZswapChainState$2);
            const ret = wasm$5.unproveninput_newContractOwned(coin, segment, ptr0, len0, state.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenInput.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.unproveninput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.unproveninput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenInput.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.unproveninput_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.unproveninput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.unproveninput_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenOfferFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_unprovenoffer_free(ptr >>> 0, 1));
    let UnprovenOffer$2 = class UnprovenOffer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenOffer.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenOfferFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenOfferFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_unprovenoffer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.unprovenoffer_new();
            this.__wbg_ptr = ret >>> 0;
            UnprovenOfferFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromInput(input, type_, value) {
            _assertClass$2(input, UnprovenInput$2);
            const ptr0 = passStringToWasm0$2(type_, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.unprovenoffer_fromInput(input.__wbg_ptr, ptr0, len0, value);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        static fromOutput(output, type_, value) {
            _assertClass$2(output, UnprovenOutput$2);
            const ptr0 = passStringToWasm0$2(type_, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.unprovenoffer_fromOutput(output.__wbg_ptr, ptr0, len0, value);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        static fromTransient(transient) {
            _assertClass$2(transient, UnprovenTransient$2);
            const ret = wasm$5.unprovenoffer_fromTransient(transient.__wbg_ptr);
            return UnprovenOffer.__wrap(ret);
        }
        merge(other) {
            _assertClass$2(other, UnprovenOffer);
            const ret = wasm$5.unprovenoffer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.unprovenoffer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.unprovenoffer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$5.unprovenoffer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$5.unprovenoffer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$5.unprovenoffer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$5.unprovenoffer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.unprovenoffer_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenOutputFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_unprovenoutput_free(ptr >>> 0, 1));
    let UnprovenOutput$2 = class UnprovenOutput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenOutput.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenOutputFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenOutputFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_unprovenoutput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.unprovenoutput_construct();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenOutputFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static new(coin, segment, target_cpk, target_epk) {
            const ptr0 = passStringToWasm0$2(target_cpk, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ptr1 = passStringToWasm0$2(target_epk, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.unprovenoutput_new(coin, segment, ptr0, len0, ptr1, len1);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        static newContractOwned(coin, segment, contract) {
            const ptr0 = passStringToWasm0$2(contract, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.unprovenoutput_newContractOwned(coin, segment, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.unprovenoutput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.unprovenoutput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.unprovenoutput_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.unprovenoutput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.unprovenoutput_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenTransactionFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_unproventransaction_free(ptr >>> 0, 1));
    let UnprovenTransaction$2 = class UnprovenTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenTransaction.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenTransactionFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenTransactionFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_unproventransaction_free(ptr, 0);
        }
        static fromMint(mint) {
            _assertClass$2(mint, UnprovenAuthorizedMint$2);
            const ret = wasm$5.unproventransaction_fromMint(mint.__wbg_ptr);
            return UnprovenTransaction.__wrap(ret);
        }
        get mint() {
            const ret = wasm$5.unproventransaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenAuthorizedMint$2.__wrap(ret);
        }
        constructor(guaranteed, fallible, calls){
            _assertClass$2(guaranteed, UnprovenOffer$2);
            const ret = wasm$5.unproventransaction_new(guaranteed.__wbg_ptr, fallible, calls);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenTransactionFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        eraseProofs() {
            const ret = wasm$5.unproventransaction_eraseProofs(this.__wbg_ptr);
            return ProofErasedTransaction$2.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$5.unproventransaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenOffer$2.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$5.unproventransaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenOffer$2.__wrap(ret);
        }
        identifiers() {
            const ret = wasm$5.unproventransaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass$2(other, UnprovenTransaction);
            const ret = wasm$5.unproventransaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenTransaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.unproventransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.unproventransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenTransaction.__wrap(ret[0]);
        }
        imbalances(guaranteed, fees) {
            const ret = wasm$5.unproventransaction_imbalances(this.__wbg_ptr, guaranteed, isLikeNone$2(fees) ? 0 : addToExternrefTable0$2(fees));
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        get contractCalls() {
            const ret = wasm$5.unproventransaction_contractCalls(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.unproventransaction_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenTransientFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_unproventransient_free(ptr >>> 0, 1));
    let UnprovenTransient$2 = class UnprovenTransient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenTransient.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenTransientFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenTransientFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_unproventransient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.unproventransient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenTransientFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        static newFromContractOwnedOutput(coin, segment, output) {
            _assertClass$2(output, UnprovenOutput$2);
            const ret = wasm$5.unproventransient_newFromContractOwnedOutput(coin, segment, output.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenTransient.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$5.unproventransient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.unproventransient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return UnprovenTransient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.unproventransient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$5.unproventransient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$2(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$2(ptr1, len1);
            } finally{
                wasm$5.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$5.unproventransient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$2(ret[0], ret[1]).slice();
                wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.unproventransient_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const VerifierKeyInsertFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_verifierkeyinsert_free(ptr >>> 0, 1));
    class VerifierKeyInsert {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(VerifierKeyInsert.prototype);
            obj.__wbg_ptr = ptr;
            VerifierKeyInsertFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            VerifierKeyInsertFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_verifierkeyinsert_free(ptr, 0);
        }
        constructor(operation, vk){
            _assertClass$2(vk, ContractOperationVersionedVerifierKey);
            const ret = wasm$5.verifierkeyinsert_new(operation, vk.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            VerifierKeyInsertFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get operation() {
            const ret = wasm$5.verifierkeyinsert_operation(this.__wbg_ptr);
            return ret;
        }
        get vk() {
            const ret = wasm$5.verifierkeyinsert_vk(this.__wbg_ptr);
            return ContractOperationVersionedVerifierKey.__wrap(ret);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.verifierkeyinsert_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const VerifierKeyRemoveFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_verifierkeyremove_free(ptr >>> 0, 1));
    class VerifierKeyRemove {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(VerifierKeyRemove.prototype);
            obj.__wbg_ptr = ptr;
            VerifierKeyRemoveFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            VerifierKeyRemoveFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_verifierkeyremove_free(ptr, 0);
        }
        constructor(operation, version){
            _assertClass$2(version, ContractOperationVersion);
            const ret = wasm$5.verifierkeyremove_new(operation, version.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            VerifierKeyRemoveFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get operation() {
            const ret = wasm$5.verifierkeyremove_operation(this.__wbg_ptr);
            return ret;
        }
        get version() {
            const ret = wasm$5.verifierkeyremove_version(this.__wbg_ptr);
            return ContractOperationVersion.__wrap(ret);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.verifierkeyremove_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$5.__wbg_vmresults_free(ptr >>> 0, 1));
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$5.__wbg_vmstack_free(ptr >>> 0, 1));
    const WellFormedStrictnessFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_wellformedstrictness_free(ptr >>> 0, 1));
    class WellFormedStrictness {
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            WellFormedStrictnessFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_wellformedstrictness_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.wellformedstrictness_new();
            this.__wbg_ptr = ret >>> 0;
            WellFormedStrictnessFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get enforceBalancing() {
            const ret = wasm$5.wellformedstrictness_enforce_balancing(this.__wbg_ptr);
            return ret !== 0;
        }
        get verifyNativeProofs() {
            const ret = wasm$5.wellformedstrictness_verify_native_proofs(this.__wbg_ptr);
            return ret !== 0;
        }
        get verifyContractProofs() {
            const ret = wasm$5.wellformedstrictness_verify_contract_proofs(this.__wbg_ptr);
            return ret !== 0;
        }
        get enforceLimits() {
            const ret = wasm$5.wellformedstrictness_enforce_limits(this.__wbg_ptr);
            return ret !== 0;
        }
        set enforceBalancing(value) {
            wasm$5.wellformedstrictness_set_enforce_balancing(this.__wbg_ptr, value);
        }
        set verifyNativeProofs(value) {
            wasm$5.wellformedstrictness_set_verify_native_proofs(this.__wbg_ptr, value);
        }
        set verifyContractProofs(value) {
            wasm$5.wellformedstrictness_set_verify_contract_proofs(this.__wbg_ptr, value);
        }
        set enforceLimits(value) {
            wasm$5.wellformedstrictness_set_enforce_limits(this.__wbg_ptr, value);
        }
    }
    const ZswapChainStateFinalization$2 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$5.__wbg_zswapchainstate_free(ptr >>> 0, 1));
    let ZswapChainState$2 = class ZswapChainState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ZswapChainState.prototype);
            obj.__wbg_ptr = ptr;
            ZswapChainStateFinalization$2.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ZswapChainStateFinalization$2.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$5.__wbg_zswapchainstate_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$5.zswapchainstate_new();
            this.__wbg_ptr = ret >>> 0;
            ZswapChainStateFinalization$2.register(this, this.__wbg_ptr, this);
            return this;
        }
        get firstFree() {
            const ret = wasm$5.zswapchainstate_firstFree(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        serialize_raw(netid) {
            const ret = wasm$5.zswapchainstate_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        filter(contract_address) {
            _assertClass$2(contract_address, ContractAddress$2);
            var ptr0 = contract_address.__destroy_into_raw();
            const ret = wasm$5.zswapchainstate_filter(this.__wbg_ptr, ptr0);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        merkle_tree_root() {
            const ret = wasm$5.zswapchainstate_merkle_tree_root(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$2(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$2(ret[0], ret[1]).slice();
            wasm$5.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        serialize(netid) {
            const ret = wasm$5.zswapchainstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$5.zswapchainstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$2(raw, wasm$5.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$2;
            const ret = wasm$5.zswapchainstate_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        static deserializeFromLedgerState(raw, netid) {
            const ret = wasm$5.zswapchainstate_deserializeFromLedgerState(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        tryApply(offer, whitelist) {
            _assertClass$2(offer, Offer$2);
            const ret = wasm$5.zswapchainstate_tryApply(this.__wbg_ptr, offer.__wbg_ptr, whitelist);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        tryApplyWithoutWhitelist(offer) {
            _assertClass$2(offer, Offer$2);
            const ret = wasm$5.zswapchainstate_tryApplyWithoutWhitelist(this.__wbg_ptr, offer.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        tryApplyProofErased(offer, whitelist) {
            _assertClass$2(offer, ProofErasedOffer$2);
            const ret = wasm$5.zswapchainstate_tryApplyProofErased(this.__wbg_ptr, offer.__wbg_ptr, whitelist);
            if (ret[2]) {
                throw takeFromExternrefTable0$2(ret[1]);
            }
            return takeFromExternrefTable0$2(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$5.zswapchainstate_toString(this.__wbg_ptr, isLikeNone$2(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$2(ret[0], ret[1]);
            } finally{
                wasm$5.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    function __wbg_BigInt_470dd987b8190f8e(arg0) {
        const ret = BigInt(arg0);
        return ret;
    }
    function __wbg_BigInt_ddea6d2f55558acb() {
        return handleError$3(function(arg0) {
            const ret = BigInt(arg0);
            return ret;
        }, arguments);
    }
    function __wbg_String_fed4d24b68977888$2(arg0, arg1) {
        const ret = String(arg1);
        const ptr1 = passStringToWasm0$2(ret, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN$2;
        getDataViewMemory0$2().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$2().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbg_add_883d9432f9188ef2$2(arg0, arg1) {
        const ret = arg0.add(arg1);
        return ret;
    }
    function __wbg_apply_36be6a55257c99bf$2() {
        return handleError$3(function(arg0, arg1, arg2) {
            const ret = arg0.apply(arg1, arg2);
            return ret;
        }, arguments);
    }
    function __wbg_buffer_09165b52af8c5237$2(arg0) {
        const ret = arg0.buffer;
        return ret;
    }
    function __wbg_buffer_609cc3eee51ed158$2(arg0) {
        const ret = arg0.buffer;
        return ret;
    }
    function __wbg_byobRequest_77d9adf63337edfb$2(arg0) {
        const ret = arg0.byobRequest;
        return isLikeNone$2(ret) ? 0 : addToExternrefTable0$2(ret);
    }
    function __wbg_byteLength_e674b853d9c77e1d$2(arg0) {
        const ret = arg0.byteLength;
        return ret;
    }
    function __wbg_byteOffset_fd862df290ef848d$2(arg0) {
        const ret = arg0.byteOffset;
        return ret;
    }
    function __wbg_call_672a4d21634d4a24$2() {
        return handleError$3(function(arg0, arg1) {
            const ret = arg0.call(arg1);
            return ret;
        }, arguments);
    }
    function __wbg_call_7cccdd69e0791ae2$2() {
        return handleError$3(function(arg0, arg1, arg2) {
            const ret = arg0.call(arg1, arg2);
            return ret;
        }, arguments);
    }
    function __wbg_close_304cc1fef3466669$2() {
        return handleError$3(function(arg0) {
            arg0.close();
        }, arguments);
    }
    function __wbg_close_5ce03e29be453811$2() {
        return handleError$3(function(arg0) {
            arg0.close();
        }, arguments);
    }
    function __wbg_contractcall_new(arg0) {
        const ret = ContractCall.__wrap(arg0);
        return ret;
    }
    function __wbg_contractdeploy_new(arg0) {
        const ret = ContractDeploy.__wrap(arg0);
        return ret;
    }
    function __wbg_contractstate_new(arg0) {
        const ret = ContractState.__wrap(arg0);
        return ret;
    }
    function __wbg_crypto_574e78ad8b13b65f$2(arg0) {
        const ret = arg0.crypto;
        return ret;
    }
    function __wbg_done_769e5ede4b31c67b(arg0) {
        const ret = arg0.done;
        return ret;
    }
    function __wbg_enqueue_bb16ba72f537dc9e$2() {
        return handleError$3(function(arg0, arg1) {
            arg0.enqueue(arg1);
        }, arguments);
    }
    function __wbg_entries_3265d4158b33e5dc(arg0) {
        const ret = Object.entries(arg0);
        return ret;
    }
    function __wbg_forEach_432d981ecbee7d69$2(arg0, arg1, arg2) {
        try {
            var state0 = {
                a: arg1,
                b: arg2
            };
            var cb0 = (arg0, arg1, arg2)=>{
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_657(a, state0.b, arg0, arg1, arg2);
                } finally{
                    state0.a = a;
                }
            };
            arg0.forEach(cb0);
        } finally{
            state0.a = state0.b = 0;
        }
    }
    function __wbg_getPrototypeOf_08aaacea7e300a38$2() {
        return handleError$3(function(arg0) {
            const ret = Reflect.getPrototypeOf(arg0);
            return ret;
        }, arguments);
    }
    function __wbg_getRandomValues_b8f5dbd5f3995a9e$2() {
        return handleError$3(function(arg0, arg1) {
            arg0.getRandomValues(arg1);
        }, arguments);
    }
    function __wbg_get_67b2ba62fc30de12$2() {
        return handleError$3(function(arg0, arg1) {
            const ret = Reflect.get(arg0, arg1);
            return ret;
        }, arguments);
    }
    function __wbg_get_b9b93047fe3cf45b(arg0, arg1) {
        const ret = arg0[arg1 >>> 0];
        return ret;
    }
    function __wbg_getwithrefkey_bb8f74a92cb2e784$2(arg0, arg1) {
        const ret = arg0[arg1];
        return ret;
    }
    function __wbg_input_new$2(arg0) {
        const ret = Input$2.__wrap(arg0);
        return ret;
    }
    function __wbg_instanceof_ArrayBuffer_e14585432e3737fc$2(arg0) {
        let result;
        try {
            result = arg0 instanceof ArrayBuffer;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_instanceof_Set_f48781e4bf8ffb09$2(arg0) {
        let result;
        try {
            result = arg0 instanceof Set;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_instanceof_Uint8Array_17156bcf118086a9$2(arg0) {
        let result;
        try {
            result = arg0 instanceof Uint8Array;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_isArray_a1eab7e0d067391b(arg0) {
        const ret = Array.isArray(arg0);
        return ret;
    }
    function __wbg_isSafeInteger_343e2beeeece1bb0$2(arg0) {
        const ret = Number.isSafeInteger(arg0);
        return ret;
    }
    function __wbg_iterator_9a24c88df860dc65() {
        const ret = Symbol.iterator;
        return ret;
    }
    function __wbg_ledgerstate_new(arg0) {
        const ret = LedgerState.__wrap(arg0);
        return ret;
    }
    function __wbg_length_a446193dc22c12f8$2(arg0) {
        const ret = arg0.length;
        return ret;
    }
    function __wbg_length_e2d2a49132c1b256(arg0) {
        const ret = arg0.length;
        return ret;
    }
    function __wbg_localstate_new$2(arg0) {
        const ret = LocalState$2.__wrap(arg0);
        return ret;
    }
    function __wbg_maintenanceupdate_new(arg0) {
        const ret = MaintenanceUpdate.__wrap(arg0);
        return ret;
    }
    function __wbg_msCrypto_a61aeb35a24c1329$2(arg0) {
        const ret = arg0.msCrypto;
        return ret;
    }
    function __wbg_new_23a2665fac83c611$2(arg0, arg1) {
        try {
            var state0 = {
                a: arg0,
                b: arg1
            };
            var cb0 = (arg0, arg1)=>{
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_664(a, state0.b, arg0, arg1);
                } finally{
                    state0.a = a;
                }
            };
            const ret = new Promise(cb0);
            return ret;
        } finally{
            state0.a = state0.b = 0;
        }
    }
    function __wbg_new_405e22f390576ce2$2() {
        const ret = new Object();
        return ret;
    }
    function __wbg_new_5e0be73521bc8c17$2() {
        const ret = new Map();
        return ret;
    }
    function __wbg_new_78feb108b6472713$2() {
        const ret = new Array();
        return ret;
    }
    function __wbg_new_a12002a7f91c75be$2(arg0) {
        const ret = new Uint8Array(arg0);
        return ret;
    }
    function __wbg_new_a239edaa1dc2968f$2(arg0) {
        const ret = new Set(arg0);
        return ret;
    }
    function __wbg_new_c68d7209be747379$2(arg0, arg1) {
        const ret = new Error(getStringFromWasm0$2(arg0, arg1));
        return ret;
    }
    function __wbg_newnoargs_105ed471475aaf50$2(arg0, arg1) {
        const ret = new Function(getStringFromWasm0$2(arg0, arg1));
        return ret;
    }
    function __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a$2(arg0, arg1, arg2) {
        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
        return ret;
    }
    function __wbg_newwithlength_a381634e90c276d4$2(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return ret;
    }
    function __wbg_next_25feadfc0913fea9(arg0) {
        const ret = arg0.next;
        return ret;
    }
    function __wbg_next_6574e1a8a62d1055() {
        return handleError$3(function(arg0) {
            const ret = arg0.next();
            return ret;
        }, arguments);
    }
    function __wbg_node_905d3e251edff8a2$2(arg0) {
        const ret = arg0.node;
        return ret;
    }
    function __wbg_output_new$2(arg0) {
        const ret = Output$2.__wrap(arg0);
        return ret;
    }
    function __wbg_process_dc0fbacc7c1c06f7$2(arg0) {
        const ret = arg0.process;
        return ret;
    }
    function __wbg_prooferasedinput_new$2(arg0) {
        const ret = ProofErasedInput$2.__wrap(arg0);
        return ret;
    }
    function __wbg_prooferasedoutput_new$2(arg0) {
        const ret = ProofErasedOutput$2.__wrap(arg0);
        return ret;
    }
    function __wbg_prooferasedtransient_new$2(arg0) {
        const ret = ProofErasedTransient$2.__wrap(arg0);
        return ret;
    }
    function __wbg_push_737cfc8c1432c2c6$2(arg0, arg1) {
        const ret = arg0.push(arg1);
        return ret;
    }
    function __wbg_queueMicrotask_97d92b4fcc8a61c5$2(arg0) {
        queueMicrotask(arg0);
    }
    function __wbg_queueMicrotask_d3219def82552485$2(arg0) {
        const ret = arg0.queueMicrotask;
        return ret;
    }
    function __wbg_randomFillSync_ac0988aba3254290$2() {
        return handleError$3(function(arg0, arg1) {
            arg0.randomFillSync(arg1);
        }, arguments);
    }
    function __wbg_replaceauthority_new(arg0) {
        const ret = ReplaceAuthority.__wrap(arg0);
        return ret;
    }
    function __wbg_require_60cc747a6bc5215a$2() {
        return handleError$3(function() {
            const ret = commonjsRequire;
            return ret;
        }, arguments);
    }
    function __wbg_resolve_4851785c9c5f573d$2(arg0) {
        const ret = Promise.resolve(arg0);
        return ret;
    }
    function __wbg_respond_1f279fa9f8edcb1c$2() {
        return handleError$3(function(arg0, arg1) {
            arg0.respond(arg1 >>> 0);
        }, arguments);
    }
    function __wbg_set_37837023f3d740e8(arg0, arg1, arg2) {
        arg0[arg1 >>> 0] = arg2;
    }
    function __wbg_set_3fda3bac07393de4$2(arg0, arg1, arg2) {
        arg0[arg1] = arg2;
    }
    function __wbg_set_65595bdd868b3009$2(arg0, arg1, arg2) {
        arg0.set(arg1, arg2 >>> 0);
    }
    function __wbg_set_8fc6bf8a5b1071d1$2(arg0, arg1, arg2) {
        const ret = arg0.set(arg1, arg2);
        return ret;
    }
    function __wbg_statevalue_new(arg0) {
        const ret = StateValue.__wrap(arg0);
        return ret;
    }
    function __wbg_static_accessor_GLOBAL_88a902d13a557d07$2() {
        const ret = typeof global === 'undefined' ? null : global;
        return isLikeNone$2(ret) ? 0 : addToExternrefTable0$2(ret);
    }
    function __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0$2() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone$2(ret) ? 0 : addToExternrefTable0$2(ret);
    }
    function __wbg_static_accessor_SELF_37c5d418e4bf5819$2() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone$2(ret) ? 0 : addToExternrefTable0$2(ret);
    }
    function __wbg_static_accessor_WINDOW_5de37043a91a9c40$2() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone$2(ret) ? 0 : addToExternrefTable0$2(ret);
    }
    function __wbg_subarray_aa9065fa9dc5df96$2(arg0, arg1, arg2) {
        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
        return ret;
    }
    function __wbg_then_44b73946d2fb3e7d$2(arg0, arg1) {
        const ret = arg0.then(arg1);
        return ret;
    }
    function __wbg_toString_b5d4438bc26b267c() {
        return handleError$3(function(arg0, arg1) {
            const ret = arg0.toString(arg1);
            return ret;
        }, arguments);
    }
    function __wbg_toString_c813bbd34d063839(arg0) {
        const ret = arg0.toString();
        return ret;
    }
    function __wbg_transactionresult_new(arg0) {
        const ret = TransactionResult.__wrap(arg0);
        return ret;
    }
    function __wbg_transient_new$2(arg0) {
        const ret = Transient$2.__wrap(arg0);
        return ret;
    }
    function __wbg_unproveninput_new$2(arg0) {
        const ret = UnprovenInput$2.__wrap(arg0);
        return ret;
    }
    function __wbg_unprovenoutput_new$2(arg0) {
        const ret = UnprovenOutput$2.__wrap(arg0);
        return ret;
    }
    function __wbg_unproventransaction_new$2(arg0) {
        const ret = UnprovenTransaction$2.__wrap(arg0);
        return ret;
    }
    function __wbg_unproventransient_new$2(arg0) {
        const ret = UnprovenTransient$2.__wrap(arg0);
        return ret;
    }
    function __wbg_value_cd1ffa7b1ab794f1(arg0) {
        const ret = arg0.value;
        return ret;
    }
    function __wbg_verifierkeyinsert_new(arg0) {
        const ret = VerifierKeyInsert.__wrap(arg0);
        return ret;
    }
    function __wbg_verifierkeyremove_new(arg0) {
        const ret = VerifierKeyRemove.__wrap(arg0);
        return ret;
    }
    function __wbg_versions_c01dfd4722a88165$2(arg0) {
        const ret = arg0.versions;
        return ret;
    }
    function __wbg_view_fd8a56e8983f448d$2(arg0) {
        const ret = arg0.view;
        return isLikeNone$2(ret) ? 0 : addToExternrefTable0$2(ret);
    }
    function __wbg_zswapchainstate_new$2(arg0) {
        const ret = ZswapChainState$2.__wrap(arg0);
        return ret;
    }
    function __wbindgen_bigint_from_i128$2(arg0, arg1) {
        const ret = arg0 << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    }
    function __wbindgen_bigint_from_i64(arg0) {
        const ret = arg0;
        return ret;
    }
    function __wbindgen_bigint_from_u128$2(arg0, arg1) {
        const ret = BigInt.asUintN(64, arg0) << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    }
    function __wbindgen_bigint_from_u64$2(arg0) {
        const ret = BigInt.asUintN(64, arg0);
        return ret;
    }
    function __wbindgen_bigint_get_as_i64$2(arg0, arg1) {
        const v = arg1;
        const ret = typeof (v) === 'bigint' ? v : undefined;
        getDataViewMemory0$2().setBigInt64(arg0 + 8 * 1, isLikeNone$2(ret) ? BigInt(0) : ret, true);
        getDataViewMemory0$2().setInt32(arg0 + 4 * 0, !isLikeNone$2(ret), true);
    }
    function __wbindgen_boolean_get$2(arg0) {
        const v = arg0;
        const ret = typeof (v) === 'boolean' ? (v ? 1 : 0) : 2;
        return ret;
    }
    function __wbindgen_cb_drop$2(arg0) {
        const obj = arg0.original;
        if (obj.cnt-- == 1) {
            obj.a = 0;
            return true;
        }
        const ret = false;
        return ret;
    }
    function __wbindgen_closure_wrapper8113(arg0, arg1, arg2) {
        const ret = makeMutClosure$2(arg0, arg1, 1594, __wbg_adapter_58);
        return ret;
    }
    function __wbindgen_debug_string$2(arg0, arg1) {
        const ret = debugString$2(arg1);
        const ptr1 = passStringToWasm0$2(ret, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN$2;
        getDataViewMemory0$2().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$2().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbindgen_error_new$2(arg0, arg1) {
        const ret = new Error(getStringFromWasm0$2(arg0, arg1));
        return ret;
    }
    function __wbindgen_in$2(arg0, arg1) {
        const ret = arg0 in arg1;
        return ret;
    }
    function __wbindgen_init_externref_table$2() {
        const table = wasm$5.__wbindgen_export_2;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
    }
    function __wbindgen_is_bigint$2(arg0) {
        const ret = typeof (arg0) === 'bigint';
        return ret;
    }
    function __wbindgen_is_function$2(arg0) {
        const ret = typeof (arg0) === 'function';
        return ret;
    }
    function __wbindgen_is_null$2(arg0) {
        const ret = arg0 === null;
        return ret;
    }
    function __wbindgen_is_object$2(arg0) {
        const val = arg0;
        const ret = typeof (val) === 'object' && val !== null;
        return ret;
    }
    function __wbindgen_is_string$2(arg0) {
        const ret = typeof (arg0) === 'string';
        return ret;
    }
    function __wbindgen_is_undefined$2(arg0) {
        const ret = arg0 === undefined;
        return ret;
    }
    function __wbindgen_jsval_eq$2(arg0, arg1) {
        const ret = arg0 === arg1;
        return ret;
    }
    function __wbindgen_jsval_loose_eq$2(arg0, arg1) {
        const ret = arg0 == arg1;
        return ret;
    }
    function __wbindgen_memory$2() {
        const ret = wasm$5.memory;
        return ret;
    }
    function __wbindgen_number_get$2(arg0, arg1) {
        const obj = arg1;
        const ret = typeof (obj) === 'number' ? obj : undefined;
        getDataViewMemory0$2().setFloat64(arg0 + 8 * 1, isLikeNone$2(ret) ? 0 : ret, true);
        getDataViewMemory0$2().setInt32(arg0 + 4 * 0, !isLikeNone$2(ret), true);
    }
    function __wbindgen_number_new$2(arg0) {
        const ret = arg0;
        return ret;
    }
    function __wbindgen_shr$2(arg0, arg1) {
        const ret = arg0 >> arg1;
        return ret;
    }
    function __wbindgen_string_get$2(arg0, arg1) {
        const obj = arg1;
        const ret = typeof (obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone$2(ret) ? 0 : passStringToWasm0$2(ret, wasm$5.__wbindgen_malloc, wasm$5.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN$2;
        getDataViewMemory0$2().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$2().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbindgen_string_new$2(arg0, arg1) {
        const ret = getStringFromWasm0$2(arg0, arg1);
        return ret;
    }
    function __wbindgen_throw$2(arg0, arg1) {
        throw new Error(getStringFromWasm0$2(arg0, arg1));
    }
    function ReplaceAuthority_() {
        return ReplaceAuthority;
    }
    function VerifierKeyRemove_() {
        return VerifierKeyRemove;
    }
    function VerifierKeyInsert_() {
        return VerifierKeyInsert;
    }
    function ContractCallsPrototype_() {
        return ContractCallsPrototype;
    }
    function PreTranscript_() {
        return PreTranscript;
    }
    function UnprovenOffer_$2() {
        return UnprovenOffer$2;
    }
    URL = globalThis.URL;
    const __vite__wasmModule$2 = await __vite__initWasm({
        "./midnight_ledger_wasm_bg.js": {
            "__wbg_unproventransaction_new": __wbg_unproventransaction_new$2,
            "__wbg_ledgerstate_new": __wbg_ledgerstate_new,
            "__wbg_contractcall_new": __wbg_contractcall_new,
            "__wbg_transactionresult_new": __wbg_transactionresult_new,
            "__wbg_localstate_new": __wbg_localstate_new$2,
            "__wbindgen_error_new": __wbindgen_error_new$2,
            "__wbindgen_is_string": __wbindgen_is_string$2,
            "__wbg_maintenanceupdate_new": __wbg_maintenanceupdate_new,
            "__wbg_contractdeploy_new": __wbg_contractdeploy_new,
            "__wbindgen_string_get": __wbindgen_string_get$2,
            "__wbg_replaceauthority_new": __wbg_replaceauthority_new,
            "__wbg_verifierkeyremove_new": __wbg_verifierkeyremove_new,
            "__wbg_verifierkeyinsert_new": __wbg_verifierkeyinsert_new,
            "__wbindgen_bigint_from_u64": __wbindgen_bigint_from_u64$2,
            "__wbindgen_shr": __wbindgen_shr$2,
            "__wbindgen_jsval_eq": __wbindgen_jsval_eq$2,
            "__wbindgen_boolean_get": __wbindgen_boolean_get$2,
            "__wbindgen_bigint_from_u128": __wbindgen_bigint_from_u128$2,
            "__wbindgen_is_null": __wbindgen_is_null$2,
            "__wbindgen_is_undefined": __wbindgen_is_undefined$2,
            "__wbindgen_string_new": __wbindgen_string_new$2,
            "__wbindgen_number_get": __wbindgen_number_get$2,
            "__wbindgen_number_new": __wbindgen_number_new$2,
            "__wbindgen_is_object": __wbindgen_is_object$2,
            "__wbindgen_is_bigint": __wbindgen_is_bigint$2,
            "__wbindgen_in": __wbindgen_in$2,
            "__wbindgen_bigint_from_i64": __wbindgen_bigint_from_i64,
            "__wbg_prooferasedoutput_new": __wbg_prooferasedoutput_new$2,
            "__wbg_zswapchainstate_new": __wbg_zswapchainstate_new$2,
            "__wbg_output_new": __wbg_output_new$2,
            "__wbg_unproventransient_new": __wbg_unproventransient_new$2,
            "__wbg_unprovenoutput_new": __wbg_unprovenoutput_new$2,
            "__wbg_unproveninput_new": __wbg_unproveninput_new$2,
            "__wbg_input_new": __wbg_input_new$2,
            "__wbg_transient_new": __wbg_transient_new$2,
            "__wbg_prooferasedtransient_new": __wbg_prooferasedtransient_new$2,
            "__wbg_prooferasedinput_new": __wbg_prooferasedinput_new$2,
            "__wbg_statevalue_new": __wbg_statevalue_new,
            "__wbg_contractstate_new": __wbg_contractstate_new,
            "__wbindgen_jsval_loose_eq": __wbindgen_jsval_loose_eq$2,
            "__wbg_String_fed4d24b68977888": __wbg_String_fed4d24b68977888$2,
            "__wbindgen_bigint_from_i128": __wbindgen_bigint_from_i128$2,
            "__wbg_getwithrefkey_bb8f74a92cb2e784": __wbg_getwithrefkey_bb8f74a92cb2e784$2,
            "__wbg_set_3fda3bac07393de4": __wbg_set_3fda3bac07393de4$2,
            "__wbindgen_cb_drop": __wbindgen_cb_drop$2,
            "__wbg_queueMicrotask_d3219def82552485": __wbg_queueMicrotask_d3219def82552485$2,
            "__wbindgen_is_function": __wbindgen_is_function$2,
            "__wbg_queueMicrotask_97d92b4fcc8a61c5": __wbg_queueMicrotask_97d92b4fcc8a61c5$2,
            "__wbg_view_fd8a56e8983f448d": __wbg_view_fd8a56e8983f448d$2,
            "__wbg_respond_1f279fa9f8edcb1c": __wbg_respond_1f279fa9f8edcb1c$2,
            "__wbg_close_304cc1fef3466669": __wbg_close_304cc1fef3466669$2,
            "__wbg_enqueue_bb16ba72f537dc9e": __wbg_enqueue_bb16ba72f537dc9e$2,
            "__wbg_byobRequest_77d9adf63337edfb": __wbg_byobRequest_77d9adf63337edfb$2,
            "__wbg_close_5ce03e29be453811": __wbg_close_5ce03e29be453811$2,
            "__wbg_crypto_574e78ad8b13b65f": __wbg_crypto_574e78ad8b13b65f$2,
            "__wbg_process_dc0fbacc7c1c06f7": __wbg_process_dc0fbacc7c1c06f7$2,
            "__wbg_versions_c01dfd4722a88165": __wbg_versions_c01dfd4722a88165$2,
            "__wbg_node_905d3e251edff8a2": __wbg_node_905d3e251edff8a2$2,
            "__wbg_require_60cc747a6bc5215a": __wbg_require_60cc747a6bc5215a$2,
            "__wbg_msCrypto_a61aeb35a24c1329": __wbg_msCrypto_a61aeb35a24c1329$2,
            "__wbg_randomFillSync_ac0988aba3254290": __wbg_randomFillSync_ac0988aba3254290$2,
            "__wbg_getRandomValues_b8f5dbd5f3995a9e": __wbg_getRandomValues_b8f5dbd5f3995a9e$2,
            "__wbg_get_b9b93047fe3cf45b": __wbg_get_b9b93047fe3cf45b,
            "__wbg_length_e2d2a49132c1b256": __wbg_length_e2d2a49132c1b256,
            "__wbg_new_78feb108b6472713": __wbg_new_78feb108b6472713$2,
            "__wbg_BigInt_470dd987b8190f8e": __wbg_BigInt_470dd987b8190f8e,
            "__wbg_newnoargs_105ed471475aaf50": __wbg_newnoargs_105ed471475aaf50$2,
            "__wbg_new_5e0be73521bc8c17": __wbg_new_5e0be73521bc8c17$2,
            "__wbg_next_25feadfc0913fea9": __wbg_next_25feadfc0913fea9,
            "__wbg_next_6574e1a8a62d1055": __wbg_next_6574e1a8a62d1055,
            "__wbg_done_769e5ede4b31c67b": __wbg_done_769e5ede4b31c67b,
            "__wbg_value_cd1ffa7b1ab794f1": __wbg_value_cd1ffa7b1ab794f1,
            "__wbg_iterator_9a24c88df860dc65": __wbg_iterator_9a24c88df860dc65,
            "__wbg_get_67b2ba62fc30de12": __wbg_get_67b2ba62fc30de12$2,
            "__wbg_call_672a4d21634d4a24": __wbg_call_672a4d21634d4a24$2,
            "__wbg_new_405e22f390576ce2": __wbg_new_405e22f390576ce2$2,
            "__wbg_new_a239edaa1dc2968f": __wbg_new_a239edaa1dc2968f$2,
            "__wbg_set_37837023f3d740e8": __wbg_set_37837023f3d740e8,
            "__wbg_isArray_a1eab7e0d067391b": __wbg_isArray_a1eab7e0d067391b,
            "__wbg_push_737cfc8c1432c2c6": __wbg_push_737cfc8c1432c2c6$2,
            "__wbg_instanceof_ArrayBuffer_e14585432e3737fc": __wbg_instanceof_ArrayBuffer_e14585432e3737fc$2,
            "__wbg_BigInt_ddea6d2f55558acb": __wbg_BigInt_ddea6d2f55558acb,
            "__wbg_toString_b5d4438bc26b267c": __wbg_toString_b5d4438bc26b267c,
            "__wbg_new_c68d7209be747379": __wbg_new_c68d7209be747379$2,
            "__wbg_toString_c813bbd34d063839": __wbg_toString_c813bbd34d063839,
            "__wbg_apply_36be6a55257c99bf": __wbg_apply_36be6a55257c99bf$2,
            "__wbg_call_7cccdd69e0791ae2": __wbg_call_7cccdd69e0791ae2$2,
            "__wbg_set_8fc6bf8a5b1071d1": __wbg_set_8fc6bf8a5b1071d1$2,
            "__wbg_isSafeInteger_343e2beeeece1bb0": __wbg_isSafeInteger_343e2beeeece1bb0$2,
            "__wbg_entries_3265d4158b33e5dc": __wbg_entries_3265d4158b33e5dc,
            "__wbg_instanceof_Set_f48781e4bf8ffb09": __wbg_instanceof_Set_f48781e4bf8ffb09$2,
            "__wbg_add_883d9432f9188ef2": __wbg_add_883d9432f9188ef2$2,
            "__wbg_forEach_432d981ecbee7d69": __wbg_forEach_432d981ecbee7d69$2,
            "__wbg_new_23a2665fac83c611": __wbg_new_23a2665fac83c611$2,
            "__wbg_resolve_4851785c9c5f573d": __wbg_resolve_4851785c9c5f573d$2,
            "__wbg_then_44b73946d2fb3e7d": __wbg_then_44b73946d2fb3e7d$2,
            "__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0": __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0$2,
            "__wbg_static_accessor_SELF_37c5d418e4bf5819": __wbg_static_accessor_SELF_37c5d418e4bf5819$2,
            "__wbg_static_accessor_WINDOW_5de37043a91a9c40": __wbg_static_accessor_WINDOW_5de37043a91a9c40$2,
            "__wbg_static_accessor_GLOBAL_88a902d13a557d07": __wbg_static_accessor_GLOBAL_88a902d13a557d07$2,
            "__wbg_buffer_609cc3eee51ed158": __wbg_buffer_609cc3eee51ed158$2,
            "__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a": __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a$2,
            "__wbg_new_a12002a7f91c75be": __wbg_new_a12002a7f91c75be$2,
            "__wbg_set_65595bdd868b3009": __wbg_set_65595bdd868b3009$2,
            "__wbg_length_a446193dc22c12f8": __wbg_length_a446193dc22c12f8$2,
            "__wbg_instanceof_Uint8Array_17156bcf118086a9": __wbg_instanceof_Uint8Array_17156bcf118086a9$2,
            "__wbg_newwithlength_a381634e90c276d4": __wbg_newwithlength_a381634e90c276d4$2,
            "__wbg_buffer_09165b52af8c5237": __wbg_buffer_09165b52af8c5237$2,
            "__wbg_subarray_aa9065fa9dc5df96": __wbg_subarray_aa9065fa9dc5df96$2,
            "__wbg_byteLength_e674b853d9c77e1d": __wbg_byteLength_e674b853d9c77e1d$2,
            "__wbg_byteOffset_fd862df290ef848d": __wbg_byteOffset_fd862df290ef848d$2,
            "__wbg_getPrototypeOf_08aaacea7e300a38": __wbg_getPrototypeOf_08aaacea7e300a38$2,
            "__wbindgen_bigint_get_as_i64": __wbindgen_bigint_get_as_i64$2,
            "__wbindgen_debug_string": __wbindgen_debug_string$2,
            "__wbindgen_throw": __wbindgen_throw$2,
            "__wbindgen_memory": __wbindgen_memory$2,
            "__wbindgen_closure_wrapper8113": __wbindgen_closure_wrapper8113,
            "__wbindgen_init_externref_table": __wbindgen_init_externref_table$2
        },
        "./snippets/midnight-ledger-wasm-c311d63f8bcc3530/inline0.js": {
            "ReplaceAuthority_": ReplaceAuthority_
        },
        "./snippets/midnight-ledger-wasm-c311d63f8bcc3530/inline1.js": {
            "VerifierKeyRemove_": VerifierKeyRemove_
        },
        "./snippets/midnight-ledger-wasm-c311d63f8bcc3530/inline2.js": {
            "VerifierKeyInsert_": VerifierKeyInsert_
        },
        "./snippets/midnight-ledger-wasm-c311d63f8bcc3530/inline3.js": {
            "ContractCallsPrototype_": ContractCallsPrototype_
        },
        "./snippets/midnight-ledger-wasm-c311d63f8bcc3530/inline4.js": {
            "PreTranscript_": PreTranscript_
        },
        "./snippets/midnight-zswap-wasm-41bcd0561f7a9007/inline0.js": {
            "UnprovenOffer_": UnprovenOffer_$2
        }
    }, __vite__wasmUrl$2);
    const memory$2 = __vite__wasmModule$2.memory;
    const __wbg_wellformedstrictness_free = __vite__wasmModule$2.__wbg_wellformedstrictness_free;
    const wellformedstrictness_new = __vite__wasmModule$2.wellformedstrictness_new;
    const wellformedstrictness_enforce_balancing = __vite__wasmModule$2.wellformedstrictness_enforce_balancing;
    const wellformedstrictness_verify_native_proofs = __vite__wasmModule$2.wellformedstrictness_verify_native_proofs;
    const wellformedstrictness_verify_contract_proofs = __vite__wasmModule$2.wellformedstrictness_verify_contract_proofs;
    const wellformedstrictness_enforce_limits = __vite__wasmModule$2.wellformedstrictness_enforce_limits;
    const wellformedstrictness_set_enforce_balancing = __vite__wasmModule$2.wellformedstrictness_set_enforce_balancing;
    const wellformedstrictness_set_verify_native_proofs = __vite__wasmModule$2.wellformedstrictness_set_verify_native_proofs;
    const wellformedstrictness_set_verify_contract_proofs = __vite__wasmModule$2.wellformedstrictness_set_verify_contract_proofs;
    const wellformedstrictness_set_enforce_limits = __vite__wasmModule$2.wellformedstrictness_set_enforce_limits;
    const __wbg_transaction_free$2 = __vite__wasmModule$2.__wbg_transaction_free;
    const transaction_new$2 = __vite__wasmModule$2.transaction_new;
    const transaction_mint$2 = __vite__wasmModule$2.transaction_mint;
    const transaction_fromUnproven$2 = __vite__wasmModule$2.transaction_fromUnproven;
    const transaction_eraseProofs$2 = __vite__wasmModule$2.transaction_eraseProofs;
    const transaction_guaranteedCoins$2 = __vite__wasmModule$2.transaction_guaranteedCoins;
    const transaction_fallibleCoins$2 = __vite__wasmModule$2.transaction_fallibleCoins;
    const transaction_wellFormed = __vite__wasmModule$2.transaction_wellFormed;
    const transaction_transactionHash$2 = __vite__wasmModule$2.transaction_transactionHash;
    const transaction_identifiers$2 = __vite__wasmModule$2.transaction_identifiers;
    const transaction_merge$2 = __vite__wasmModule$2.transaction_merge;
    const transaction_serialize$2 = __vite__wasmModule$2.transaction_serialize;
    const transaction_deserialize$2 = __vite__wasmModule$2.transaction_deserialize;
    const transaction_imbalances$2 = __vite__wasmModule$2.transaction_imbalances;
    const transaction_fees$2 = __vite__wasmModule$2.transaction_fees;
    const transaction_contractCalls = __vite__wasmModule$2.transaction_contractCalls;
    const transaction_toString$2 = __vite__wasmModule$2.transaction_toString;
    const __wbg_unproventransaction_free$2 = __vite__wasmModule$2.__wbg_unproventransaction_free;
    const unproventransaction_fromMint$2 = __vite__wasmModule$2.unproventransaction_fromMint;
    const unproventransaction_mint$2 = __vite__wasmModule$2.unproventransaction_mint;
    const unproventransaction_new$2 = __vite__wasmModule$2.unproventransaction_new;
    const unproventransaction_eraseProofs$2 = __vite__wasmModule$2.unproventransaction_eraseProofs;
    const unproventransaction_guaranteedCoins$2 = __vite__wasmModule$2.unproventransaction_guaranteedCoins;
    const unproventransaction_fallibleCoins$2 = __vite__wasmModule$2.unproventransaction_fallibleCoins;
    const unproventransaction_identifiers$2 = __vite__wasmModule$2.unproventransaction_identifiers;
    const unproventransaction_merge$2 = __vite__wasmModule$2.unproventransaction_merge;
    const unproventransaction_serialize$2 = __vite__wasmModule$2.unproventransaction_serialize;
    const unproventransaction_deserialize$2 = __vite__wasmModule$2.unproventransaction_deserialize;
    const unproventransaction_imbalances = __vite__wasmModule$2.unproventransaction_imbalances;
    const unproventransaction_contractCalls = __vite__wasmModule$2.unproventransaction_contractCalls;
    const unproventransaction_toString$2 = __vite__wasmModule$2.unproventransaction_toString;
    const __wbg_prooferasedtransaction_free$2 = __vite__wasmModule$2.__wbg_prooferasedtransaction_free;
    const prooferasedtransaction_new$2 = __vite__wasmModule$2.prooferasedtransaction_new;
    const prooferasedtransaction_mint$2 = __vite__wasmModule$2.prooferasedtransaction_mint;
    const prooferasedtransaction_guaranteedCoins$2 = __vite__wasmModule$2.prooferasedtransaction_guaranteedCoins;
    const prooferasedtransaction_fallibleCoins$2 = __vite__wasmModule$2.prooferasedtransaction_fallibleCoins;
    const prooferasedtransaction_wellFormed = __vite__wasmModule$2.prooferasedtransaction_wellFormed;
    const prooferasedtransaction_identifiers$2 = __vite__wasmModule$2.prooferasedtransaction_identifiers;
    const prooferasedtransaction_merge$2 = __vite__wasmModule$2.prooferasedtransaction_merge;
    const prooferasedtransaction_serialize$2 = __vite__wasmModule$2.prooferasedtransaction_serialize;
    const prooferasedtransaction_deserialize$2 = __vite__wasmModule$2.prooferasedtransaction_deserialize;
    const prooferasedtransaction_imbalances$2 = __vite__wasmModule$2.prooferasedtransaction_imbalances;
    const prooferasedtransaction_fees$2 = __vite__wasmModule$2.prooferasedtransaction_fees;
    const prooferasedtransaction_contractCalls = __vite__wasmModule$2.prooferasedtransaction_contractCalls;
    const prooferasedtransaction_toString$2 = __vite__wasmModule$2.prooferasedtransaction_toString;
    const __wbg_contractdeploy_free = __vite__wasmModule$2.__wbg_contractdeploy_free;
    const contractdeploy_new = __vite__wasmModule$2.contractdeploy_new;
    const contractdeploy_initialState = __vite__wasmModule$2.contractdeploy_initialState;
    const contractdeploy_address = __vite__wasmModule$2.contractdeploy_address;
    const contractdeploy_toString = __vite__wasmModule$2.contractdeploy_toString;
    const __wbg_contractcall_free = __vite__wasmModule$2.__wbg_contractcall_free;
    const contractcall_new = __vite__wasmModule$2.contractcall_new;
    const contractcall_address = __vite__wasmModule$2.contractcall_address;
    const contractcall_entryPoint = __vite__wasmModule$2.contractcall_entryPoint;
    const contractcall_guaranteedTranscript = __vite__wasmModule$2.contractcall_guaranteedTranscript;
    const contractcall_fallibleTranscript = __vite__wasmModule$2.contractcall_fallibleTranscript;
    const contractcall_communicationCommitment = __vite__wasmModule$2.contractcall_communicationCommitment;
    const contractcall_toString = __vite__wasmModule$2.contractcall_toString;
    const __wbg_replaceauthority_free = __vite__wasmModule$2.__wbg_replaceauthority_free;
    const replaceauthority_new = __vite__wasmModule$2.replaceauthority_new;
    const replaceauthority_authority = __vite__wasmModule$2.replaceauthority_authority;
    const replaceauthority_toString = __vite__wasmModule$2.replaceauthority_toString;
    const __wbg_contractoperationversion_free = __vite__wasmModule$2.__wbg_contractoperationversion_free;
    const contractoperationversion_new = __vite__wasmModule$2.contractoperationversion_new;
    const contractoperationversion_version = __vite__wasmModule$2.contractoperationversion_version;
    const contractoperationversion_toString = __vite__wasmModule$2.contractoperationversion_toString;
    const __wbg_contractoperationversionedverifierkey_free = __vite__wasmModule$2.__wbg_contractoperationversionedverifierkey_free;
    const contractoperationversionedverifierkey_new = __vite__wasmModule$2.contractoperationversionedverifierkey_new;
    const contractoperationversionedverifierkey_version = __vite__wasmModule$2.contractoperationversionedverifierkey_version;
    const contractoperationversionedverifierkey_raw_vk = __vite__wasmModule$2.contractoperationversionedverifierkey_raw_vk;
    const contractoperationversionedverifierkey_toString = __vite__wasmModule$2.contractoperationversionedverifierkey_toString;
    const __wbg_verifierkeyremove_free = __vite__wasmModule$2.__wbg_verifierkeyremove_free;
    const verifierkeyinsert_new = __vite__wasmModule$2.verifierkeyinsert_new;
    const verifierkeyinsert_operation = __vite__wasmModule$2.verifierkeyinsert_operation;
    const verifierkeyinsert_vk = __vite__wasmModule$2.verifierkeyinsert_vk;
    const verifierkeyinsert_toString = __vite__wasmModule$2.verifierkeyinsert_toString;
    const __wbg_verifierkeyinsert_free = __vite__wasmModule$2.__wbg_verifierkeyinsert_free;
    const verifierkeyremove_new = __vite__wasmModule$2.verifierkeyremove_new;
    const verifierkeyremove_operation = __vite__wasmModule$2.verifierkeyremove_operation;
    const verifierkeyremove_version = __vite__wasmModule$2.verifierkeyremove_version;
    const verifierkeyremove_toString = __vite__wasmModule$2.verifierkeyremove_toString;
    const __wbg_maintenanceupdate_free = __vite__wasmModule$2.__wbg_maintenanceupdate_free;
    const maintenanceupdate_new = __vite__wasmModule$2.maintenanceupdate_new;
    const maintenanceupdate_addSignature = __vite__wasmModule$2.maintenanceupdate_addSignature;
    const maintenanceupdate_toString = __vite__wasmModule$2.maintenanceupdate_toString;
    const maintenanceupdate_data_to_sign = __vite__wasmModule$2.maintenanceupdate_data_to_sign;
    const maintenanceupdate_address = __vite__wasmModule$2.maintenanceupdate_address;
    const maintenanceupdate_updates = __vite__wasmModule$2.maintenanceupdate_updates;
    const maintenanceupdate_counter = __vite__wasmModule$2.maintenanceupdate_counter;
    const maintenanceupdate_signatures = __vite__wasmModule$2.maintenanceupdate_signatures;
    const __wbg_contractcallsprototype_free = __vite__wasmModule$2.__wbg_contractcallsprototype_free;
    const contractcallsprototype_new = __vite__wasmModule$2.contractcallsprototype_new;
    const contractcallsprototype_addCall = __vite__wasmModule$2.contractcallsprototype_addCall;
    const contractcallsprototype_addDeploy = __vite__wasmModule$2.contractcallsprototype_addDeploy;
    const contractcallsprototype_addMaintenanceUpdate = __vite__wasmModule$2.contractcallsprototype_addMaintenanceUpdate;
    const contractcallsprototype_toString = __vite__wasmModule$2.contractcallsprototype_toString;
    const __wbg_contractcallprototype_free = __vite__wasmModule$2.__wbg_contractcallprototype_free;
    const contractcallprototype_new = __vite__wasmModule$2.contractcallprototype_new;
    const contractcallprototype_toString = __vite__wasmModule$2.contractcallprototype_toString;
    const __wbg_pretranscript_free = __vite__wasmModule$2.__wbg_pretranscript_free;
    const pretranscript_new = __vite__wasmModule$2.pretranscript_new;
    const pretranscript_toString = __vite__wasmModule$2.pretranscript_toString;
    const partitionTranscripts = __vite__wasmModule$2.partitionTranscripts;
    const __wbg_transactioncontext_free = __vite__wasmModule$2.__wbg_transactioncontext_free;
    const transactioncontext_new = __vite__wasmModule$2.transactioncontext_new;
    const transactioncontext_toString = __vite__wasmModule$2.transactioncontext_toString;
    const __wbg_transactionresult_free = __vite__wasmModule$2.__wbg_transactionresult_free;
    const transactionresult_new = __vite__wasmModule$2.transactionresult_new;
    const transactionresult_type_ = __vite__wasmModule$2.transactionresult_type_;
    const transactionresult_error = __vite__wasmModule$2.transactionresult_error;
    const transactionresult_toString = __vite__wasmModule$2.transactionresult_toString;
    const __wbg_ledgerstate_free = __vite__wasmModule$2.__wbg_ledgerstate_free;
    const ledgerstate_new = __vite__wasmModule$2.ledgerstate_new;
    const ledgerstate_blank = __vite__wasmModule$2.ledgerstate_blank;
    const ledgerstate_parameters = __vite__wasmModule$2.ledgerstate_parameters;
    const ledgerstate_set_parameters = __vite__wasmModule$2.ledgerstate_set_parameters;
    const ledgerstate_treasuryBalance = __vite__wasmModule$2.ledgerstate_treasuryBalance;
    const ledgerstate_unclaimedMints = __vite__wasmModule$2.ledgerstate_unclaimedMints;
    const ledgerstate_unminted_native_token_supply = __vite__wasmModule$2.ledgerstate_unminted_native_token_supply;
    const ledgerstate_zswap = __vite__wasmModule$2.ledgerstate_zswap;
    const ledgerstate_apply = __vite__wasmModule$2.ledgerstate_apply;
    const ledgerstate_applySystemTx = __vite__wasmModule$2.ledgerstate_applySystemTx;
    const ledgerstate_index = __vite__wasmModule$2.ledgerstate_index;
    const ledgerstate_updateIndex = __vite__wasmModule$2.ledgerstate_updateIndex;
    const ledgerstate_serialize = __vite__wasmModule$2.ledgerstate_serialize;
    const ledgerstate_deserialize = __vite__wasmModule$2.ledgerstate_deserialize;
    const ledgerstate_toString = __vite__wasmModule$2.ledgerstate_toString;
    const __wbg_localstate_free$2 = __vite__wasmModule$2.__wbg_localstate_free;
    const localstate_new$2 = __vite__wasmModule$2.localstate_new;
    const localstate_authorizeMint$2 = __vite__wasmModule$2.localstate_authorizeMint;
    const localstate_firstFree$2 = __vite__wasmModule$2.localstate_firstFree;
    const localstate_coins$2 = __vite__wasmModule$2.localstate_coins;
    const localstate_pendingSpends$2 = __vite__wasmModule$2.localstate_pendingSpends;
    const localstate_pendingOutputs$2 = __vite__wasmModule$2.localstate_pendingOutputs;
    const localstate_applyMint$2 = __vite__wasmModule$2.localstate_applyMint;
    const localstate_applyProofErasedMint$2 = __vite__wasmModule$2.localstate_applyProofErasedMint;
    const localstate_applyFailed$2 = __vite__wasmModule$2.localstate_applyFailed;
    const localstate_applyFailedProofErased$2 = __vite__wasmModule$2.localstate_applyFailedProofErased;
    const localstate_apply$2 = __vite__wasmModule$2.localstate_apply;
    const localstate_applyProofErased$2 = __vite__wasmModule$2.localstate_applyProofErased;
    const localstate_applyTx$2 = __vite__wasmModule$2.localstate_applyTx;
    const localstate_applyProofErasedTx$2 = __vite__wasmModule$2.localstate_applyProofErasedTx;
    const localstate_applySystemTx$2 = __vite__wasmModule$2.localstate_applySystemTx;
    const localstate_applyCollapsedUpdate$2 = __vite__wasmModule$2.localstate_applyCollapsedUpdate;
    const localstate_spend$2 = __vite__wasmModule$2.localstate_spend;
    const localstate_spendFromOutput$2 = __vite__wasmModule$2.localstate_spendFromOutput;
    const localstate_watchFor$2 = __vite__wasmModule$2.localstate_watchFor;
    const localstate_serialize$2 = __vite__wasmModule$2.localstate_serialize;
    const localstate_deserialize$2 = __vite__wasmModule$2.localstate_deserialize;
    const localstate_toString$2 = __vite__wasmModule$2.localstate_toString;
    const createCoinInfo$2 = __vite__wasmModule$2.createCoinInfo;
    const nativeToken$2 = __vite__wasmModule$2.nativeToken;
    const __wbg_merkletreecollapsedupdate_free$2 = __vite__wasmModule$2.__wbg_merkletreecollapsedupdate_free;
    const merkletreecollapsedupdate_new$2 = __vite__wasmModule$2.merkletreecollapsedupdate_new;
    const merkletreecollapsedupdate_new_raw$2 = __vite__wasmModule$2.merkletreecollapsedupdate_new_raw;
    const merkletreecollapsedupdate_serialize$2 = __vite__wasmModule$2.merkletreecollapsedupdate_serialize;
    const merkletreecollapsedupdate_serialize_raw$2 = __vite__wasmModule$2.merkletreecollapsedupdate_serialize_raw;
    const merkletreecollapsedupdate_deserialize$2 = __vite__wasmModule$2.merkletreecollapsedupdate_deserialize;
    const merkletreecollapsedupdate_toString$2 = __vite__wasmModule$2.merkletreecollapsedupdate_toString;
    const __wbg_zswapchainstate_free$2 = __vite__wasmModule$2.__wbg_zswapchainstate_free;
    const __wbg_contractaddress_free$2 = __vite__wasmModule$2.__wbg_contractaddress_free;
    const contractaddress_deserialize_raw$2 = __vite__wasmModule$2.contractaddress_deserialize_raw;
    const zswapchainstate_new$2 = __vite__wasmModule$2.zswapchainstate_new;
    const zswapchainstate_firstFree$2 = __vite__wasmModule$2.zswapchainstate_firstFree;
    const zswapchainstate_serialize_raw$2 = __vite__wasmModule$2.zswapchainstate_serialize_raw;
    const zswapchainstate_filter$2 = __vite__wasmModule$2.zswapchainstate_filter;
    const zswapchainstate_merkle_tree_root$2 = __vite__wasmModule$2.zswapchainstate_merkle_tree_root;
    const zswapchainstate_serialize$2 = __vite__wasmModule$2.zswapchainstate_serialize;
    const zswapchainstate_deserialize$2 = __vite__wasmModule$2.zswapchainstate_deserialize;
    const zswapchainstate_deserialize_raw$2 = __vite__wasmModule$2.zswapchainstate_deserialize_raw;
    const zswapchainstate_deserializeFromLedgerState$2 = __vite__wasmModule$2.zswapchainstate_deserializeFromLedgerState;
    const zswapchainstate_tryApply$2 = __vite__wasmModule$2.zswapchainstate_tryApply;
    const zswapchainstate_tryApplyWithoutWhitelist$2 = __vite__wasmModule$2.zswapchainstate_tryApplyWithoutWhitelist;
    const zswapchainstate_tryApplyProofErased$2 = __vite__wasmModule$2.zswapchainstate_tryApplyProofErased;
    const zswapchainstate_toString$2 = __vite__wasmModule$2.zswapchainstate_toString;
    const sampleCoinPublicKey$2 = __vite__wasmModule$2.sampleCoinPublicKey;
    const sampleEncryptionPublicKey$2 = __vite__wasmModule$2.sampleEncryptionPublicKey;
    const coin_nullifier$2 = __vite__wasmModule$2.coin_nullifier;
    const coin_commitment$2 = __vite__wasmModule$2.coin_commitment;
    const __wbg_systemtransaction_free$2 = __vite__wasmModule$2.__wbg_systemtransaction_free;
    const systemtransaction_new$2 = __vite__wasmModule$2.systemtransaction_new;
    const systemtransaction_serialize$2 = __vite__wasmModule$2.systemtransaction_serialize;
    const systemtransaction_deserialize$2 = __vite__wasmModule$2.systemtransaction_deserialize;
    const systemtransaction_toString$2 = __vite__wasmModule$2.systemtransaction_toString;
    const __wbg_ledgerparameters_free$2 = __vite__wasmModule$2.__wbg_ledgerparameters_free;
    const ledgerparameters_new$2 = __vite__wasmModule$2.ledgerparameters_new;
    const ledgerparameters_dummyParameters$2 = __vite__wasmModule$2.ledgerparameters_dummyParameters;
    const ledgerparameters_transactionCostModel$2 = __vite__wasmModule$2.ledgerparameters_transactionCostModel;
    const ledgerparameters_serialize$2 = __vite__wasmModule$2.ledgerparameters_serialize;
    const ledgerparameters_deserialize$2 = __vite__wasmModule$2.ledgerparameters_deserialize;
    const ledgerparameters_toString$2 = __vite__wasmModule$2.ledgerparameters_toString;
    const __wbg_authorizedmint_free$2 = __vite__wasmModule$2.__wbg_authorizedmint_free;
    const authorizedmint_new$2 = __vite__wasmModule$2.authorizedmint_new;
    const authorizedmint_serialize$2 = __vite__wasmModule$2.authorizedmint_serialize;
    const authorizedmint_deserialize$2 = __vite__wasmModule$2.authorizedmint_deserialize;
    const authorizedmint_eraseProof$2 = __vite__wasmModule$2.authorizedmint_eraseProof;
    const authorizedmint_coin$2 = __vite__wasmModule$2.authorizedmint_coin;
    const authorizedmint_recipient$2 = __vite__wasmModule$2.authorizedmint_recipient;
    const authorizedmint_toString$2 = __vite__wasmModule$2.authorizedmint_toString;
    const __wbg_unprovenauthorizedmint_free$2 = __vite__wasmModule$2.__wbg_unprovenauthorizedmint_free;
    const unprovenauthorizedmint_new$2 = __vite__wasmModule$2.unprovenauthorizedmint_new;
    const unprovenauthorizedmint_serialize$2 = __vite__wasmModule$2.unprovenauthorizedmint_serialize;
    const unprovenauthorizedmint_deserialize$2 = __vite__wasmModule$2.unprovenauthorizedmint_deserialize;
    const unprovenauthorizedmint_coin$2 = __vite__wasmModule$2.unprovenauthorizedmint_coin;
    const unprovenauthorizedmint_recipient$2 = __vite__wasmModule$2.unprovenauthorizedmint_recipient;
    const unprovenauthorizedmint_toString$2 = __vite__wasmModule$2.unprovenauthorizedmint_toString;
    const __wbg_prooferasedauthorizedmint_free$2 = __vite__wasmModule$2.__wbg_prooferasedauthorizedmint_free;
    const prooferasedauthorizedmint_new$2 = __vite__wasmModule$2.prooferasedauthorizedmint_new;
    const prooferasedauthorizedmint_serialize$2 = __vite__wasmModule$2.prooferasedauthorizedmint_serialize;
    const prooferasedauthorizedmint_deserialize$2 = __vite__wasmModule$2.prooferasedauthorizedmint_deserialize;
    const prooferasedauthorizedmint_coin$2 = __vite__wasmModule$2.prooferasedauthorizedmint_coin;
    const prooferasedauthorizedmint_recipient$2 = __vite__wasmModule$2.prooferasedauthorizedmint_recipient;
    const prooferasedauthorizedmint_toString$2 = __vite__wasmModule$2.prooferasedauthorizedmint_toString;
    const __wbg_offer_free$2 = __vite__wasmModule$2.__wbg_offer_free;
    const offer_new$2 = __vite__wasmModule$2.offer_new;
    const offer_merge$2 = __vite__wasmModule$2.offer_merge;
    const offer_serialize$2 = __vite__wasmModule$2.offer_serialize;
    const offer_serialize_raw$2 = __vite__wasmModule$2.offer_serialize_raw;
    const offer_deserialize$2 = __vite__wasmModule$2.offer_deserialize;
    const offer_deserialize_raw$2 = __vite__wasmModule$2.offer_deserialize_raw;
    const offer_inputs$2 = __vite__wasmModule$2.offer_inputs;
    const offer_outputs$2 = __vite__wasmModule$2.offer_outputs;
    const offer_transient$2 = __vite__wasmModule$2.offer_transient;
    const offer_deltas$2 = __vite__wasmModule$2.offer_deltas;
    const offer_toString$2 = __vite__wasmModule$2.offer_toString;
    const __wbg_prooferasedoffer_free$2 = __vite__wasmModule$2.__wbg_prooferasedoffer_free;
    const prooferasedoffer_new$2 = __vite__wasmModule$2.prooferasedoffer_new;
    const prooferasedoffer_merge$2 = __vite__wasmModule$2.prooferasedoffer_merge;
    const prooferasedoffer_serialize$2 = __vite__wasmModule$2.prooferasedoffer_serialize;
    const prooferasedoffer_deserialize$2 = __vite__wasmModule$2.prooferasedoffer_deserialize;
    const prooferasedoffer_inputs$2 = __vite__wasmModule$2.prooferasedoffer_inputs;
    const prooferasedoffer_outputs$2 = __vite__wasmModule$2.prooferasedoffer_outputs;
    const prooferasedoffer_transient$2 = __vite__wasmModule$2.prooferasedoffer_transient;
    const prooferasedoffer_deltas$2 = __vite__wasmModule$2.prooferasedoffer_deltas;
    const prooferasedoffer_toString$2 = __vite__wasmModule$2.prooferasedoffer_toString;
    const __wbg_unprovenoffer_free$2 = __vite__wasmModule$2.__wbg_unprovenoffer_free;
    const unprovenoffer_new$2 = __vite__wasmModule$2.unprovenoffer_new;
    const unprovenoffer_fromInput$2 = __vite__wasmModule$2.unprovenoffer_fromInput;
    const unprovenoffer_fromOutput$2 = __vite__wasmModule$2.unprovenoffer_fromOutput;
    const unprovenoffer_fromTransient$2 = __vite__wasmModule$2.unprovenoffer_fromTransient;
    const unprovenoffer_merge$2 = __vite__wasmModule$2.unprovenoffer_merge;
    const unprovenoffer_serialize$2 = __vite__wasmModule$2.unprovenoffer_serialize;
    const unprovenoffer_deserialize$2 = __vite__wasmModule$2.unprovenoffer_deserialize;
    const unprovenoffer_inputs$2 = __vite__wasmModule$2.unprovenoffer_inputs;
    const unprovenoffer_outputs$2 = __vite__wasmModule$2.unprovenoffer_outputs;
    const unprovenoffer_transient$2 = __vite__wasmModule$2.unprovenoffer_transient;
    const unprovenoffer_deltas$2 = __vite__wasmModule$2.unprovenoffer_deltas;
    const unprovenoffer_toString$2 = __vite__wasmModule$2.unprovenoffer_toString;
    const __wbg_input_free$2 = __vite__wasmModule$2.__wbg_input_free;
    const input_new$2 = __vite__wasmModule$2.input_new;
    const input_serialize$2 = __vite__wasmModule$2.input_serialize;
    const input_deserialize$2 = __vite__wasmModule$2.input_deserialize;
    const input_nullifier$2 = __vite__wasmModule$2.input_nullifier;
    const input_contractAddress$2 = __vite__wasmModule$2.input_contractAddress;
    const input_toString$2 = __vite__wasmModule$2.input_toString;
    const __wbg_prooferasedinput_free$2 = __vite__wasmModule$2.__wbg_prooferasedinput_free;
    const prooferasedinput_new$2 = __vite__wasmModule$2.prooferasedinput_new;
    const prooferasedinput_serialize$2 = __vite__wasmModule$2.prooferasedinput_serialize;
    const prooferasedinput_deserialize$2 = __vite__wasmModule$2.prooferasedinput_deserialize;
    const prooferasedinput_nullifier$2 = __vite__wasmModule$2.prooferasedinput_nullifier;
    const prooferasedinput_contractAddress$2 = __vite__wasmModule$2.prooferasedinput_contractAddress;
    const prooferasedinput_toString$2 = __vite__wasmModule$2.prooferasedinput_toString;
    const __wbg_unproveninput_free$2 = __vite__wasmModule$2.__wbg_unproveninput_free;
    const unproveninput_new$2 = __vite__wasmModule$2.unproveninput_new;
    const unproveninput_newContractOwned$2 = __vite__wasmModule$2.unproveninput_newContractOwned;
    const unproveninput_serialize$2 = __vite__wasmModule$2.unproveninput_serialize;
    const unproveninput_deserialize$2 = __vite__wasmModule$2.unproveninput_deserialize;
    const unproveninput_nullifier$2 = __vite__wasmModule$2.unproveninput_nullifier;
    const unproveninput_contractAddress$2 = __vite__wasmModule$2.unproveninput_contractAddress;
    const unproveninput_toString$2 = __vite__wasmModule$2.unproveninput_toString;
    const __wbg_output_free$2 = __vite__wasmModule$2.__wbg_output_free;
    const output_new$2 = __vite__wasmModule$2.output_new;
    const output_serialize$2 = __vite__wasmModule$2.output_serialize;
    const output_deserialize$2 = __vite__wasmModule$2.output_deserialize;
    const output_commitment$2 = __vite__wasmModule$2.output_commitment;
    const output_contractAddress$2 = __vite__wasmModule$2.output_contractAddress;
    const output_toString$2 = __vite__wasmModule$2.output_toString;
    const __wbg_prooferasedoutput_free$2 = __vite__wasmModule$2.__wbg_prooferasedoutput_free;
    const prooferasedoutput_new$2 = __vite__wasmModule$2.prooferasedoutput_new;
    const prooferasedoutput_serialize$2 = __vite__wasmModule$2.prooferasedoutput_serialize;
    const prooferasedoutput_deserialize$2 = __vite__wasmModule$2.prooferasedoutput_deserialize;
    const prooferasedoutput_commitment$2 = __vite__wasmModule$2.prooferasedoutput_commitment;
    const prooferasedoutput_contractAddress$2 = __vite__wasmModule$2.prooferasedoutput_contractAddress;
    const prooferasedoutput_toString$2 = __vite__wasmModule$2.prooferasedoutput_toString;
    const __wbg_unprovenoutput_free$2 = __vite__wasmModule$2.__wbg_unprovenoutput_free;
    const unprovenoutput_construct$2 = __vite__wasmModule$2.unprovenoutput_construct;
    const unprovenoutput_new$2 = __vite__wasmModule$2.unprovenoutput_new;
    const unprovenoutput_newContractOwned$2 = __vite__wasmModule$2.unprovenoutput_newContractOwned;
    const unprovenoutput_serialize$2 = __vite__wasmModule$2.unprovenoutput_serialize;
    const unprovenoutput_deserialize$2 = __vite__wasmModule$2.unprovenoutput_deserialize;
    const unprovenoutput_commitment$2 = __vite__wasmModule$2.unprovenoutput_commitment;
    const unprovenoutput_contractAddress$2 = __vite__wasmModule$2.unprovenoutput_contractAddress;
    const unprovenoutput_toString$2 = __vite__wasmModule$2.unprovenoutput_toString;
    const __wbg_transient_free$2 = __vite__wasmModule$2.__wbg_transient_free;
    const transient_new$2 = __vite__wasmModule$2.transient_new;
    const transient_serialize$2 = __vite__wasmModule$2.transient_serialize;
    const transient_deserialize$2 = __vite__wasmModule$2.transient_deserialize;
    const transient_commitment$2 = __vite__wasmModule$2.transient_commitment;
    const transient_nullifier$2 = __vite__wasmModule$2.transient_nullifier;
    const transient_contractAddress$2 = __vite__wasmModule$2.transient_contractAddress;
    const transient_toString$2 = __vite__wasmModule$2.transient_toString;
    const __wbg_prooferasedtransient_free$2 = __vite__wasmModule$2.__wbg_prooferasedtransient_free;
    const prooferasedtransient_new$2 = __vite__wasmModule$2.prooferasedtransient_new;
    const prooferasedtransient_serialize$2 = __vite__wasmModule$2.prooferasedtransient_serialize;
    const prooferasedtransient_deserialize$2 = __vite__wasmModule$2.prooferasedtransient_deserialize;
    const prooferasedtransient_commitment$2 = __vite__wasmModule$2.prooferasedtransient_commitment;
    const prooferasedtransient_nullifier$2 = __vite__wasmModule$2.prooferasedtransient_nullifier;
    const prooferasedtransient_contractAddress$2 = __vite__wasmModule$2.prooferasedtransient_contractAddress;
    const prooferasedtransient_toString$2 = __vite__wasmModule$2.prooferasedtransient_toString;
    const __wbg_unproventransient_free$2 = __vite__wasmModule$2.__wbg_unproventransient_free;
    const unproventransient_new$2 = __vite__wasmModule$2.unproventransient_new;
    const unproventransient_newFromContractOwnedOutput$2 = __vite__wasmModule$2.unproventransient_newFromContractOwnedOutput;
    const unproventransient_serialize$2 = __vite__wasmModule$2.unproventransient_serialize;
    const unproventransient_deserialize$2 = __vite__wasmModule$2.unproventransient_deserialize;
    const unproventransient_commitment$2 = __vite__wasmModule$2.unproventransient_commitment;
    const unproventransient_nullifier$2 = __vite__wasmModule$2.unproventransient_nullifier;
    const unproventransient_contractAddress$2 = __vite__wasmModule$2.unproventransient_contractAddress;
    const unproventransient_toString$2 = __vite__wasmModule$2.unproventransient_toString;
    const __wbg_transactioncostmodel_free$2 = __vite__wasmModule$2.__wbg_transactioncostmodel_free;
    const transactioncostmodel_new$2 = __vite__wasmModule$2.transactioncostmodel_new;
    const transactioncostmodel_dummyTransactionCostModel$2 = __vite__wasmModule$2.transactioncostmodel_dummyTransactionCostModel;
    const transactioncostmodel_inputFeeOverhead$2 = __vite__wasmModule$2.transactioncostmodel_inputFeeOverhead;
    const transactioncostmodel_outputFeeOverhead$2 = __vite__wasmModule$2.transactioncostmodel_outputFeeOverhead;
    const transactioncostmodel_serialize$2 = __vite__wasmModule$2.transactioncostmodel_serialize;
    const transactioncostmodel_deserialize$2 = __vite__wasmModule$2.transactioncostmodel_deserialize;
    const transactioncostmodel_toString$2 = __vite__wasmModule$2.transactioncostmodel_toString;
    const unprovenauthorizedmint_eraseProof$2 = __vite__wasmModule$2.unprovenauthorizedmint_eraseProof;
    const __wbg_secretkeys_free$2 = __vite__wasmModule$2.__wbg_secretkeys_free;
    const secretkeys_new$2 = __vite__wasmModule$2.secretkeys_new;
    const secretkeys_fromSeed$2 = __vite__wasmModule$2.secretkeys_fromSeed;
    const secretkeys_fromSeedRng$2 = __vite__wasmModule$2.secretkeys_fromSeedRng;
    const secretkeys_coinPublicKey$2 = __vite__wasmModule$2.secretkeys_coinPublicKey;
    const secretkeys_encryptionPublicKey$2 = __vite__wasmModule$2.secretkeys_encryptionPublicKey;
    const secretkeys_encryptionSecretKey$2 = __vite__wasmModule$2.secretkeys_encryptionSecretKey;
    const secretkeys_coinSecretKey$2 = __vite__wasmModule$2.secretkeys_coinSecretKey;
    const __wbg_coinsecretkey_free$2 = __vite__wasmModule$2.__wbg_coinsecretkey_free;
    const coinsecretkey_new$2 = __vite__wasmModule$2.coinsecretkey_new;
    const coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$2 = __vite__wasmModule$2.coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize;
    const __wbg_encryptionsecretkey_free$2 = __vite__wasmModule$2.__wbg_encryptionsecretkey_free;
    const encryptionsecretkey_new$2 = __vite__wasmModule$2.encryptionsecretkey_new;
    const encryptionsecretkey_test$2 = __vite__wasmModule$2.encryptionsecretkey_test;
    const encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$2 = __vite__wasmModule$2.encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize;
    const encryptionsecretkey_deserialize$2 = __vite__wasmModule$2.encryptionsecretkey_deserialize;
    const encryptionsecretkey_deserialize_raw$2 = __vite__wasmModule$2.encryptionsecretkey_deserialize_raw;
    const __wbg_queryresults_free = __vite__wasmModule$2.__wbg_queryresults_free;
    const queryresults_new = __vite__wasmModule$2.queryresults_new;
    const queryresults_context = __vite__wasmModule$2.queryresults_context;
    const queryresults_events = __vite__wasmModule$2.queryresults_events;
    const queryresults_gas_cost = __vite__wasmModule$2.queryresults_gas_cost;
    const queryresults_toString = __vite__wasmModule$2.queryresults_toString;
    const __wbg_querycontext_free = __vite__wasmModule$2.__wbg_querycontext_free;
    const __wbg_costmodel_free = __vite__wasmModule$2.__wbg_costmodel_free;
    const costmodel_new = __vite__wasmModule$2.costmodel_new;
    const costmodel_dummyCostModel = __vite__wasmModule$2.costmodel_dummyCostModel;
    const costmodel_toString = __vite__wasmModule$2.costmodel_toString;
    const querycontext_new = __vite__wasmModule$2.querycontext_new;
    const querycontext_state = __vite__wasmModule$2.querycontext_state;
    const querycontext_address = __vite__wasmModule$2.querycontext_address;
    const querycontext_effects = __vite__wasmModule$2.querycontext_effects;
    const querycontext_set_effects = __vite__wasmModule$2.querycontext_set_effects;
    const querycontext_block = __vite__wasmModule$2.querycontext_block;
    const querycontext_set_block = __vite__wasmModule$2.querycontext_set_block;
    const querycontext_com_indicies = __vite__wasmModule$2.querycontext_com_indicies;
    const querycontext_insertCommitment = __vite__wasmModule$2.querycontext_insertCommitment;
    const querycontext_qualify = __vite__wasmModule$2.querycontext_qualify;
    const querycontext_runTranscript = __vite__wasmModule$2.querycontext_runTranscript;
    const querycontext_query = __vite__wasmModule$2.querycontext_query;
    const querycontext_intoTranscript = __vite__wasmModule$2.querycontext_intoTranscript;
    const querycontext_toString = __vite__wasmModule$2.querycontext_toString;
    const encodeCoinInfo = __vite__wasmModule$2.encodeCoinInfo;
    const encodeQualifiedCoinInfo = __vite__wasmModule$2.encodeQualifiedCoinInfo;
    const decodeCoinInfo = __vite__wasmModule$2.decodeCoinInfo;
    const decodeQualifiedCoinInfo = __vite__wasmModule$2.decodeQualifiedCoinInfo;
    const encodeTokenType = __vite__wasmModule$2.encodeTokenType;
    const decodeTokenType = __vite__wasmModule$2.decodeTokenType;
    const encodeContractAddress = __vite__wasmModule$2.encodeContractAddress;
    const decodeContractAddress = __vite__wasmModule$2.decodeContractAddress;
    const encodeCoinPublicKey = __vite__wasmModule$2.encodeCoinPublicKey;
    const decodeCoinPublicKey = __vite__wasmModule$2.decodeCoinPublicKey;
    const entryPointHash = __vite__wasmModule$2.entryPointHash;
    const communicationCommitmentRandomness = __vite__wasmModule$2.communicationCommitmentRandomness;
    const communicationCommitment = __vite__wasmModule$2.communicationCommitment;
    const sampleSigningKey = __vite__wasmModule$2.sampleSigningKey;
    const signData = __vite__wasmModule$2.signData;
    const signatureVerifyingKey = __vite__wasmModule$2.signatureVerifyingKey;
    const verifySignature = __vite__wasmModule$2.verifySignature;
    const tokenType = __vite__wasmModule$2.tokenType;
    const sampleContractAddress$2 = __vite__wasmModule$2.sampleContractAddress;
    const sampleTokenType$2 = __vite__wasmModule$2.sampleTokenType;
    const dummyContractAddress = __vite__wasmModule$2.dummyContractAddress;
    const coinCommitment = __vite__wasmModule$2.coinCommitment;
    const leafHash = __vite__wasmModule$2.leafHash;
    const maxAlignedSize = __vite__wasmModule$2.maxAlignedSize;
    const maxField = __vite__wasmModule$2.maxField;
    const checkProofData = __vite__wasmModule$2.checkProofData;
    const bigIntModFr = __vite__wasmModule$2.bigIntModFr;
    const valueToBigInt = __vite__wasmModule$2.valueToBigInt;
    const bigIntToValue = __vite__wasmModule$2.bigIntToValue;
    const transientHash = __vite__wasmModule$2.transientHash;
    const transientCommit = __vite__wasmModule$2.transientCommit;
    const persistentHash = __vite__wasmModule$2.persistentHash;
    const persistentCommit = __vite__wasmModule$2.persistentCommit;
    const degradeToTransient = __vite__wasmModule$2.degradeToTransient;
    const upgradeFromTransient = __vite__wasmModule$2.upgradeFromTransient;
    const hashToCurve = __vite__wasmModule$2.hashToCurve;
    const ecAdd = __vite__wasmModule$2.ecAdd;
    const ecMul = __vite__wasmModule$2.ecMul;
    const ecMulGenerator = __vite__wasmModule$2.ecMulGenerator;
    const __wbg_statemap_free = __vite__wasmModule$2.__wbg_statemap_free;
    const statemap_new = __vite__wasmModule$2.statemap_new;
    const statemap_keys = __vite__wasmModule$2.statemap_keys;
    const statemap_get = __vite__wasmModule$2.statemap_get;
    const statemap_insert = __vite__wasmModule$2.statemap_insert;
    const statemap_remove = __vite__wasmModule$2.statemap_remove;
    const statemap_toString = __vite__wasmModule$2.statemap_toString;
    const __wbg_stateboundedmerkletree_free = __vite__wasmModule$2.__wbg_stateboundedmerkletree_free;
    const stateboundedmerkletree_blank = __vite__wasmModule$2.stateboundedmerkletree_blank;
    const stateboundedmerkletree_height = __vite__wasmModule$2.stateboundedmerkletree_height;
    const stateboundedmerkletree_root = __vite__wasmModule$2.stateboundedmerkletree_root;
    const stateboundedmerkletree_findPathForLeaf = __vite__wasmModule$2.stateboundedmerkletree_findPathForLeaf;
    const stateboundedmerkletree_pathForLeaf = __vite__wasmModule$2.stateboundedmerkletree_pathForLeaf;
    const stateboundedmerkletree_update = __vite__wasmModule$2.stateboundedmerkletree_update;
    const stateboundedmerkletree_collapse = __vite__wasmModule$2.stateboundedmerkletree_collapse;
    const stateboundedmerkletree_toString = __vite__wasmModule$2.stateboundedmerkletree_toString;
    const __wbg_statevalue_free = __vite__wasmModule$2.__wbg_statevalue_free;
    const statevalue_new = __vite__wasmModule$2.statevalue_new;
    const statevalue_type = __vite__wasmModule$2.statevalue_type;
    const statevalue_newNull = __vite__wasmModule$2.statevalue_newNull;
    const statevalue_newCell = __vite__wasmModule$2.statevalue_newCell;
    const statevalue_newMap = __vite__wasmModule$2.statevalue_newMap;
    const statevalue_newBoundedMerkleTree = __vite__wasmModule$2.statevalue_newBoundedMerkleTree;
    const statevalue_newArray = __vite__wasmModule$2.statevalue_newArray;
    const statevalue_arrayPush = __vite__wasmModule$2.statevalue_arrayPush;
    const statevalue_asCell = __vite__wasmModule$2.statevalue_asCell;
    const statevalue_asMap = __vite__wasmModule$2.statevalue_asMap;
    const statevalue_asBoundedMerkleTree = __vite__wasmModule$2.statevalue_asBoundedMerkleTree;
    const statevalue_asArray = __vite__wasmModule$2.statevalue_asArray;
    const statevalue_logSize = __vite__wasmModule$2.statevalue_logSize;
    const statevalue_encode = __vite__wasmModule$2.statevalue_encode;
    const statevalue_decode = __vite__wasmModule$2.statevalue_decode;
    const statevalue_toString = __vite__wasmModule$2.statevalue_toString;
    const __wbg_contractstate_free = __vite__wasmModule$2.__wbg_contractstate_free;
    const contractstate_new = __vite__wasmModule$2.contractstate_new;
    const contractstate_data = __vite__wasmModule$2.contractstate_data;
    const contractstate_set_data = __vite__wasmModule$2.contractstate_set_data;
    const contractstate_maintenance_authority = __vite__wasmModule$2.contractstate_maintenance_authority;
    const contractstate_set_maintenance_authority = __vite__wasmModule$2.contractstate_set_maintenance_authority;
    const contractstate_operations = __vite__wasmModule$2.contractstate_operations;
    const contractstate_operation = __vite__wasmModule$2.contractstate_operation;
    const contractstate_setOperation = __vite__wasmModule$2.contractstate_setOperation;
    const contractstate_query = __vite__wasmModule$2.contractstate_query;
    const contractstate_serialize = __vite__wasmModule$2.contractstate_serialize;
    const contractstate_deserialize = __vite__wasmModule$2.contractstate_deserialize;
    const contractstate_toString = __vite__wasmModule$2.contractstate_toString;
    const __wbg_contractoperation_free = __vite__wasmModule$2.__wbg_contractoperation_free;
    const contractoperation_new = __vite__wasmModule$2.contractoperation_new;
    const contractoperation_verifier_key = __vite__wasmModule$2.contractoperation_verifier_key;
    const contractoperation_set_verifier_key = __vite__wasmModule$2.contractoperation_set_verifier_key;
    const contractoperation_serialize = __vite__wasmModule$2.contractoperation_serialize;
    const contractoperation_deserialize = __vite__wasmModule$2.contractoperation_deserialize;
    const contractoperation_toString = __vite__wasmModule$2.contractoperation_toString;
    const __wbg_contractmaintenanceauthority_free = __vite__wasmModule$2.__wbg_contractmaintenanceauthority_free;
    const contractmaintenanceauthority_new = __vite__wasmModule$2.contractmaintenanceauthority_new;
    const contractmaintenanceauthority_committee = __vite__wasmModule$2.contractmaintenanceauthority_committee;
    const contractmaintenanceauthority_threshold = __vite__wasmModule$2.contractmaintenanceauthority_threshold;
    const contractmaintenanceauthority_counter = __vite__wasmModule$2.contractmaintenanceauthority_counter;
    const contractmaintenanceauthority_serialize = __vite__wasmModule$2.contractmaintenanceauthority_serialize;
    const contractmaintenanceauthority_deserialize = __vite__wasmModule$2.contractmaintenanceauthority_deserialize;
    const contractmaintenanceauthority_toString = __vite__wasmModule$2.contractmaintenanceauthority_toString;
    const __wbg_vmresults_free = __vite__wasmModule$2.__wbg_vmresults_free;
    const vmresults_new = __vite__wasmModule$2.vmresults_new;
    const vmresults_stack = __vite__wasmModule$2.vmresults_stack;
    const vmresults_events = __vite__wasmModule$2.vmresults_events;
    const vmresults_gas_cost = __vite__wasmModule$2.vmresults_gas_cost;
    const vmresults_toString = __vite__wasmModule$2.vmresults_toString;
    const __wbg_vmstack_free = __vite__wasmModule$2.__wbg_vmstack_free;
    const vmstack_new = __vite__wasmModule$2.vmstack_new;
    const vmstack_push = __vite__wasmModule$2.vmstack_push;
    const vmstack_removeLast = __vite__wasmModule$2.vmstack_removeLast;
    const vmstack_length = __vite__wasmModule$2.vmstack_length;
    const vmstack_get = __vite__wasmModule$2.vmstack_get;
    const vmstack_isStrong = __vite__wasmModule$2.vmstack_isStrong;
    const vmstack_toString = __vite__wasmModule$2.vmstack_toString;
    const runProgram = __vite__wasmModule$2.runProgram;
    const __wbg_intounderlyingbytesource_free$2 = __vite__wasmModule$2.__wbg_intounderlyingbytesource_free;
    const intounderlyingbytesource_type$2 = __vite__wasmModule$2.intounderlyingbytesource_type;
    const intounderlyingbytesource_autoAllocateChunkSize$2 = __vite__wasmModule$2.intounderlyingbytesource_autoAllocateChunkSize;
    const intounderlyingbytesource_start$2 = __vite__wasmModule$2.intounderlyingbytesource_start;
    const intounderlyingbytesource_pull$2 = __vite__wasmModule$2.intounderlyingbytesource_pull;
    const intounderlyingbytesource_cancel$2 = __vite__wasmModule$2.intounderlyingbytesource_cancel;
    const __wbg_intounderlyingsource_free$2 = __vite__wasmModule$2.__wbg_intounderlyingsource_free;
    const intounderlyingsource_pull$2 = __vite__wasmModule$2.intounderlyingsource_pull;
    const intounderlyingsource_cancel$2 = __vite__wasmModule$2.intounderlyingsource_cancel;
    const __wbg_intounderlyingsink_free$2 = __vite__wasmModule$2.__wbg_intounderlyingsink_free;
    const intounderlyingsink_write$2 = __vite__wasmModule$2.intounderlyingsink_write;
    const intounderlyingsink_close$2 = __vite__wasmModule$2.intounderlyingsink_close;
    const intounderlyingsink_abort$2 = __vite__wasmModule$2.intounderlyingsink_abort;
    const __wbindgen_exn_store$2 = __vite__wasmModule$2.__wbindgen_exn_store;
    const __externref_table_alloc$2 = __vite__wasmModule$2.__externref_table_alloc;
    const __wbindgen_export_2 = __vite__wasmModule$2.__wbindgen_export_2;
    const __wbindgen_malloc$2 = __vite__wasmModule$2.__wbindgen_malloc;
    const __wbindgen_realloc$2 = __vite__wasmModule$2.__wbindgen_realloc;
    const __wbindgen_export_5$2 = __vite__wasmModule$2.__wbindgen_export_5;
    const __externref_table_dealloc$2 = __vite__wasmModule$2.__externref_table_dealloc;
    const __wbindgen_free$2 = __vite__wasmModule$2.__wbindgen_free;
    const __externref_drop_slice$2 = __vite__wasmModule$2.__externref_drop_slice;
    const closure1593_externref_shim = __vite__wasmModule$2.closure1593_externref_shim;
    const closure1651_externref_shim = __vite__wasmModule$2.closure1651_externref_shim;
    const closure1655_externref_shim = __vite__wasmModule$2.closure1655_externref_shim;
    const __wbindgen_start$2 = __vite__wasmModule$2.__wbindgen_start;
    const wasm$4 = Object.freeze(Object.defineProperty({
        __proto__: null,
        __externref_drop_slice: __externref_drop_slice$2,
        __externref_table_alloc: __externref_table_alloc$2,
        __externref_table_dealloc: __externref_table_dealloc$2,
        __wbg_authorizedmint_free: __wbg_authorizedmint_free$2,
        __wbg_coinsecretkey_free: __wbg_coinsecretkey_free$2,
        __wbg_contractaddress_free: __wbg_contractaddress_free$2,
        __wbg_contractcall_free,
        __wbg_contractcallprototype_free,
        __wbg_contractcallsprototype_free,
        __wbg_contractdeploy_free,
        __wbg_contractmaintenanceauthority_free,
        __wbg_contractoperation_free,
        __wbg_contractoperationversion_free,
        __wbg_contractoperationversionedverifierkey_free,
        __wbg_contractstate_free,
        __wbg_costmodel_free,
        __wbg_encryptionsecretkey_free: __wbg_encryptionsecretkey_free$2,
        __wbg_input_free: __wbg_input_free$2,
        __wbg_intounderlyingbytesource_free: __wbg_intounderlyingbytesource_free$2,
        __wbg_intounderlyingsink_free: __wbg_intounderlyingsink_free$2,
        __wbg_intounderlyingsource_free: __wbg_intounderlyingsource_free$2,
        __wbg_ledgerparameters_free: __wbg_ledgerparameters_free$2,
        __wbg_ledgerstate_free,
        __wbg_localstate_free: __wbg_localstate_free$2,
        __wbg_maintenanceupdate_free,
        __wbg_merkletreecollapsedupdate_free: __wbg_merkletreecollapsedupdate_free$2,
        __wbg_offer_free: __wbg_offer_free$2,
        __wbg_output_free: __wbg_output_free$2,
        __wbg_pretranscript_free,
        __wbg_prooferasedauthorizedmint_free: __wbg_prooferasedauthorizedmint_free$2,
        __wbg_prooferasedinput_free: __wbg_prooferasedinput_free$2,
        __wbg_prooferasedoffer_free: __wbg_prooferasedoffer_free$2,
        __wbg_prooferasedoutput_free: __wbg_prooferasedoutput_free$2,
        __wbg_prooferasedtransaction_free: __wbg_prooferasedtransaction_free$2,
        __wbg_prooferasedtransient_free: __wbg_prooferasedtransient_free$2,
        __wbg_querycontext_free,
        __wbg_queryresults_free,
        __wbg_replaceauthority_free,
        __wbg_secretkeys_free: __wbg_secretkeys_free$2,
        __wbg_stateboundedmerkletree_free,
        __wbg_statemap_free,
        __wbg_statevalue_free,
        __wbg_systemtransaction_free: __wbg_systemtransaction_free$2,
        __wbg_transaction_free: __wbg_transaction_free$2,
        __wbg_transactioncontext_free,
        __wbg_transactioncostmodel_free: __wbg_transactioncostmodel_free$2,
        __wbg_transactionresult_free,
        __wbg_transient_free: __wbg_transient_free$2,
        __wbg_unprovenauthorizedmint_free: __wbg_unprovenauthorizedmint_free$2,
        __wbg_unproveninput_free: __wbg_unproveninput_free$2,
        __wbg_unprovenoffer_free: __wbg_unprovenoffer_free$2,
        __wbg_unprovenoutput_free: __wbg_unprovenoutput_free$2,
        __wbg_unproventransaction_free: __wbg_unproventransaction_free$2,
        __wbg_unproventransient_free: __wbg_unproventransient_free$2,
        __wbg_verifierkeyinsert_free,
        __wbg_verifierkeyremove_free,
        __wbg_vmresults_free,
        __wbg_vmstack_free,
        __wbg_wellformedstrictness_free,
        __wbg_zswapchainstate_free: __wbg_zswapchainstate_free$2,
        __wbindgen_exn_store: __wbindgen_exn_store$2,
        __wbindgen_export_2,
        __wbindgen_export_5: __wbindgen_export_5$2,
        __wbindgen_free: __wbindgen_free$2,
        __wbindgen_malloc: __wbindgen_malloc$2,
        __wbindgen_realloc: __wbindgen_realloc$2,
        __wbindgen_start: __wbindgen_start$2,
        authorizedmint_coin: authorizedmint_coin$2,
        authorizedmint_deserialize: authorizedmint_deserialize$2,
        authorizedmint_eraseProof: authorizedmint_eraseProof$2,
        authorizedmint_new: authorizedmint_new$2,
        authorizedmint_recipient: authorizedmint_recipient$2,
        authorizedmint_serialize: authorizedmint_serialize$2,
        authorizedmint_toString: authorizedmint_toString$2,
        bigIntModFr,
        bigIntToValue,
        checkProofData,
        closure1593_externref_shim,
        closure1651_externref_shim,
        closure1655_externref_shim,
        coinCommitment,
        coin_commitment: coin_commitment$2,
        coin_nullifier: coin_nullifier$2,
        coinsecretkey_new: coinsecretkey_new$2,
        coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize: coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$2,
        communicationCommitment,
        communicationCommitmentRandomness,
        contractaddress_deserialize_raw: contractaddress_deserialize_raw$2,
        contractcall_address,
        contractcall_communicationCommitment,
        contractcall_entryPoint,
        contractcall_fallibleTranscript,
        contractcall_guaranteedTranscript,
        contractcall_new,
        contractcall_toString,
        contractcallprototype_new,
        contractcallprototype_toString,
        contractcallsprototype_addCall,
        contractcallsprototype_addDeploy,
        contractcallsprototype_addMaintenanceUpdate,
        contractcallsprototype_new,
        contractcallsprototype_toString,
        contractdeploy_address,
        contractdeploy_initialState,
        contractdeploy_new,
        contractdeploy_toString,
        contractmaintenanceauthority_committee,
        contractmaintenanceauthority_counter,
        contractmaintenanceauthority_deserialize,
        contractmaintenanceauthority_new,
        contractmaintenanceauthority_serialize,
        contractmaintenanceauthority_threshold,
        contractmaintenanceauthority_toString,
        contractoperation_deserialize,
        contractoperation_new,
        contractoperation_serialize,
        contractoperation_set_verifier_key,
        contractoperation_toString,
        contractoperation_verifier_key,
        contractoperationversion_new,
        contractoperationversion_toString,
        contractoperationversion_version,
        contractoperationversionedverifierkey_new,
        contractoperationversionedverifierkey_raw_vk,
        contractoperationversionedverifierkey_toString,
        contractoperationversionedverifierkey_version,
        contractstate_data,
        contractstate_deserialize,
        contractstate_maintenance_authority,
        contractstate_new,
        contractstate_operation,
        contractstate_operations,
        contractstate_query,
        contractstate_serialize,
        contractstate_setOperation,
        contractstate_set_data,
        contractstate_set_maintenance_authority,
        contractstate_toString,
        costmodel_dummyCostModel,
        costmodel_new,
        costmodel_toString,
        createCoinInfo: createCoinInfo$2,
        decodeCoinInfo,
        decodeCoinPublicKey,
        decodeContractAddress,
        decodeQualifiedCoinInfo,
        decodeTokenType,
        degradeToTransient,
        dummyContractAddress,
        ecAdd,
        ecMul,
        ecMulGenerator,
        encodeCoinInfo,
        encodeCoinPublicKey,
        encodeContractAddress,
        encodeQualifiedCoinInfo,
        encodeTokenType,
        encryptionsecretkey_deserialize: encryptionsecretkey_deserialize$2,
        encryptionsecretkey_deserialize_raw: encryptionsecretkey_deserialize_raw$2,
        encryptionsecretkey_new: encryptionsecretkey_new$2,
        encryptionsecretkey_test: encryptionsecretkey_test$2,
        encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize: encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$2,
        entryPointHash,
        hashToCurve,
        input_contractAddress: input_contractAddress$2,
        input_deserialize: input_deserialize$2,
        input_new: input_new$2,
        input_nullifier: input_nullifier$2,
        input_serialize: input_serialize$2,
        input_toString: input_toString$2,
        intounderlyingbytesource_autoAllocateChunkSize: intounderlyingbytesource_autoAllocateChunkSize$2,
        intounderlyingbytesource_cancel: intounderlyingbytesource_cancel$2,
        intounderlyingbytesource_pull: intounderlyingbytesource_pull$2,
        intounderlyingbytesource_start: intounderlyingbytesource_start$2,
        intounderlyingbytesource_type: intounderlyingbytesource_type$2,
        intounderlyingsink_abort: intounderlyingsink_abort$2,
        intounderlyingsink_close: intounderlyingsink_close$2,
        intounderlyingsink_write: intounderlyingsink_write$2,
        intounderlyingsource_cancel: intounderlyingsource_cancel$2,
        intounderlyingsource_pull: intounderlyingsource_pull$2,
        leafHash,
        ledgerparameters_deserialize: ledgerparameters_deserialize$2,
        ledgerparameters_dummyParameters: ledgerparameters_dummyParameters$2,
        ledgerparameters_new: ledgerparameters_new$2,
        ledgerparameters_serialize: ledgerparameters_serialize$2,
        ledgerparameters_toString: ledgerparameters_toString$2,
        ledgerparameters_transactionCostModel: ledgerparameters_transactionCostModel$2,
        ledgerstate_apply,
        ledgerstate_applySystemTx,
        ledgerstate_blank,
        ledgerstate_deserialize,
        ledgerstate_index,
        ledgerstate_new,
        ledgerstate_parameters,
        ledgerstate_serialize,
        ledgerstate_set_parameters,
        ledgerstate_toString,
        ledgerstate_treasuryBalance,
        ledgerstate_unclaimedMints,
        ledgerstate_unminted_native_token_supply,
        ledgerstate_updateIndex,
        ledgerstate_zswap,
        localstate_apply: localstate_apply$2,
        localstate_applyCollapsedUpdate: localstate_applyCollapsedUpdate$2,
        localstate_applyFailed: localstate_applyFailed$2,
        localstate_applyFailedProofErased: localstate_applyFailedProofErased$2,
        localstate_applyMint: localstate_applyMint$2,
        localstate_applyProofErased: localstate_applyProofErased$2,
        localstate_applyProofErasedMint: localstate_applyProofErasedMint$2,
        localstate_applyProofErasedTx: localstate_applyProofErasedTx$2,
        localstate_applySystemTx: localstate_applySystemTx$2,
        localstate_applyTx: localstate_applyTx$2,
        localstate_authorizeMint: localstate_authorizeMint$2,
        localstate_coins: localstate_coins$2,
        localstate_deserialize: localstate_deserialize$2,
        localstate_firstFree: localstate_firstFree$2,
        localstate_new: localstate_new$2,
        localstate_pendingOutputs: localstate_pendingOutputs$2,
        localstate_pendingSpends: localstate_pendingSpends$2,
        localstate_serialize: localstate_serialize$2,
        localstate_spend: localstate_spend$2,
        localstate_spendFromOutput: localstate_spendFromOutput$2,
        localstate_toString: localstate_toString$2,
        localstate_watchFor: localstate_watchFor$2,
        maintenanceupdate_addSignature,
        maintenanceupdate_address,
        maintenanceupdate_counter,
        maintenanceupdate_data_to_sign,
        maintenanceupdate_new,
        maintenanceupdate_signatures,
        maintenanceupdate_toString,
        maintenanceupdate_updates,
        maxAlignedSize,
        maxField,
        memory: memory$2,
        merkletreecollapsedupdate_deserialize: merkletreecollapsedupdate_deserialize$2,
        merkletreecollapsedupdate_new: merkletreecollapsedupdate_new$2,
        merkletreecollapsedupdate_new_raw: merkletreecollapsedupdate_new_raw$2,
        merkletreecollapsedupdate_serialize: merkletreecollapsedupdate_serialize$2,
        merkletreecollapsedupdate_serialize_raw: merkletreecollapsedupdate_serialize_raw$2,
        merkletreecollapsedupdate_toString: merkletreecollapsedupdate_toString$2,
        nativeToken: nativeToken$2,
        offer_deltas: offer_deltas$2,
        offer_deserialize: offer_deserialize$2,
        offer_deserialize_raw: offer_deserialize_raw$2,
        offer_inputs: offer_inputs$2,
        offer_merge: offer_merge$2,
        offer_new: offer_new$2,
        offer_outputs: offer_outputs$2,
        offer_serialize: offer_serialize$2,
        offer_serialize_raw: offer_serialize_raw$2,
        offer_toString: offer_toString$2,
        offer_transient: offer_transient$2,
        output_commitment: output_commitment$2,
        output_contractAddress: output_contractAddress$2,
        output_deserialize: output_deserialize$2,
        output_new: output_new$2,
        output_serialize: output_serialize$2,
        output_toString: output_toString$2,
        partitionTranscripts,
        persistentCommit,
        persistentHash,
        pretranscript_new,
        pretranscript_toString,
        prooferasedauthorizedmint_coin: prooferasedauthorizedmint_coin$2,
        prooferasedauthorizedmint_deserialize: prooferasedauthorizedmint_deserialize$2,
        prooferasedauthorizedmint_new: prooferasedauthorizedmint_new$2,
        prooferasedauthorizedmint_recipient: prooferasedauthorizedmint_recipient$2,
        prooferasedauthorizedmint_serialize: prooferasedauthorizedmint_serialize$2,
        prooferasedauthorizedmint_toString: prooferasedauthorizedmint_toString$2,
        prooferasedinput_contractAddress: prooferasedinput_contractAddress$2,
        prooferasedinput_deserialize: prooferasedinput_deserialize$2,
        prooferasedinput_new: prooferasedinput_new$2,
        prooferasedinput_nullifier: prooferasedinput_nullifier$2,
        prooferasedinput_serialize: prooferasedinput_serialize$2,
        prooferasedinput_toString: prooferasedinput_toString$2,
        prooferasedoffer_deltas: prooferasedoffer_deltas$2,
        prooferasedoffer_deserialize: prooferasedoffer_deserialize$2,
        prooferasedoffer_inputs: prooferasedoffer_inputs$2,
        prooferasedoffer_merge: prooferasedoffer_merge$2,
        prooferasedoffer_new: prooferasedoffer_new$2,
        prooferasedoffer_outputs: prooferasedoffer_outputs$2,
        prooferasedoffer_serialize: prooferasedoffer_serialize$2,
        prooferasedoffer_toString: prooferasedoffer_toString$2,
        prooferasedoffer_transient: prooferasedoffer_transient$2,
        prooferasedoutput_commitment: prooferasedoutput_commitment$2,
        prooferasedoutput_contractAddress: prooferasedoutput_contractAddress$2,
        prooferasedoutput_deserialize: prooferasedoutput_deserialize$2,
        prooferasedoutput_new: prooferasedoutput_new$2,
        prooferasedoutput_serialize: prooferasedoutput_serialize$2,
        prooferasedoutput_toString: prooferasedoutput_toString$2,
        prooferasedtransaction_contractCalls,
        prooferasedtransaction_deserialize: prooferasedtransaction_deserialize$2,
        prooferasedtransaction_fallibleCoins: prooferasedtransaction_fallibleCoins$2,
        prooferasedtransaction_fees: prooferasedtransaction_fees$2,
        prooferasedtransaction_guaranteedCoins: prooferasedtransaction_guaranteedCoins$2,
        prooferasedtransaction_identifiers: prooferasedtransaction_identifiers$2,
        prooferasedtransaction_imbalances: prooferasedtransaction_imbalances$2,
        prooferasedtransaction_merge: prooferasedtransaction_merge$2,
        prooferasedtransaction_mint: prooferasedtransaction_mint$2,
        prooferasedtransaction_new: prooferasedtransaction_new$2,
        prooferasedtransaction_serialize: prooferasedtransaction_serialize$2,
        prooferasedtransaction_toString: prooferasedtransaction_toString$2,
        prooferasedtransaction_wellFormed,
        prooferasedtransient_commitment: prooferasedtransient_commitment$2,
        prooferasedtransient_contractAddress: prooferasedtransient_contractAddress$2,
        prooferasedtransient_deserialize: prooferasedtransient_deserialize$2,
        prooferasedtransient_new: prooferasedtransient_new$2,
        prooferasedtransient_nullifier: prooferasedtransient_nullifier$2,
        prooferasedtransient_serialize: prooferasedtransient_serialize$2,
        prooferasedtransient_toString: prooferasedtransient_toString$2,
        querycontext_address,
        querycontext_block,
        querycontext_com_indicies,
        querycontext_effects,
        querycontext_insertCommitment,
        querycontext_intoTranscript,
        querycontext_new,
        querycontext_qualify,
        querycontext_query,
        querycontext_runTranscript,
        querycontext_set_block,
        querycontext_set_effects,
        querycontext_state,
        querycontext_toString,
        queryresults_context,
        queryresults_events,
        queryresults_gas_cost,
        queryresults_new,
        queryresults_toString,
        replaceauthority_authority,
        replaceauthority_new,
        replaceauthority_toString,
        runProgram,
        sampleCoinPublicKey: sampleCoinPublicKey$2,
        sampleContractAddress: sampleContractAddress$2,
        sampleEncryptionPublicKey: sampleEncryptionPublicKey$2,
        sampleSigningKey,
        sampleTokenType: sampleTokenType$2,
        secretkeys_coinPublicKey: secretkeys_coinPublicKey$2,
        secretkeys_coinSecretKey: secretkeys_coinSecretKey$2,
        secretkeys_encryptionPublicKey: secretkeys_encryptionPublicKey$2,
        secretkeys_encryptionSecretKey: secretkeys_encryptionSecretKey$2,
        secretkeys_fromSeed: secretkeys_fromSeed$2,
        secretkeys_fromSeedRng: secretkeys_fromSeedRng$2,
        secretkeys_new: secretkeys_new$2,
        signData,
        signatureVerifyingKey,
        stateboundedmerkletree_blank,
        stateboundedmerkletree_collapse,
        stateboundedmerkletree_findPathForLeaf,
        stateboundedmerkletree_height,
        stateboundedmerkletree_pathForLeaf,
        stateboundedmerkletree_root,
        stateboundedmerkletree_toString,
        stateboundedmerkletree_update,
        statemap_get,
        statemap_insert,
        statemap_keys,
        statemap_new,
        statemap_remove,
        statemap_toString,
        statevalue_arrayPush,
        statevalue_asArray,
        statevalue_asBoundedMerkleTree,
        statevalue_asCell,
        statevalue_asMap,
        statevalue_decode,
        statevalue_encode,
        statevalue_logSize,
        statevalue_new,
        statevalue_newArray,
        statevalue_newBoundedMerkleTree,
        statevalue_newCell,
        statevalue_newMap,
        statevalue_newNull,
        statevalue_toString,
        statevalue_type,
        systemtransaction_deserialize: systemtransaction_deserialize$2,
        systemtransaction_new: systemtransaction_new$2,
        systemtransaction_serialize: systemtransaction_serialize$2,
        systemtransaction_toString: systemtransaction_toString$2,
        tokenType,
        transaction_contractCalls,
        transaction_deserialize: transaction_deserialize$2,
        transaction_eraseProofs: transaction_eraseProofs$2,
        transaction_fallibleCoins: transaction_fallibleCoins$2,
        transaction_fees: transaction_fees$2,
        transaction_fromUnproven: transaction_fromUnproven$2,
        transaction_guaranteedCoins: transaction_guaranteedCoins$2,
        transaction_identifiers: transaction_identifiers$2,
        transaction_imbalances: transaction_imbalances$2,
        transaction_merge: transaction_merge$2,
        transaction_mint: transaction_mint$2,
        transaction_new: transaction_new$2,
        transaction_serialize: transaction_serialize$2,
        transaction_toString: transaction_toString$2,
        transaction_transactionHash: transaction_transactionHash$2,
        transaction_wellFormed,
        transactioncontext_new,
        transactioncontext_toString,
        transactioncostmodel_deserialize: transactioncostmodel_deserialize$2,
        transactioncostmodel_dummyTransactionCostModel: transactioncostmodel_dummyTransactionCostModel$2,
        transactioncostmodel_inputFeeOverhead: transactioncostmodel_inputFeeOverhead$2,
        transactioncostmodel_new: transactioncostmodel_new$2,
        transactioncostmodel_outputFeeOverhead: transactioncostmodel_outputFeeOverhead$2,
        transactioncostmodel_serialize: transactioncostmodel_serialize$2,
        transactioncostmodel_toString: transactioncostmodel_toString$2,
        transactionresult_error,
        transactionresult_new,
        transactionresult_toString,
        transactionresult_type_,
        transientCommit,
        transientHash,
        transient_commitment: transient_commitment$2,
        transient_contractAddress: transient_contractAddress$2,
        transient_deserialize: transient_deserialize$2,
        transient_new: transient_new$2,
        transient_nullifier: transient_nullifier$2,
        transient_serialize: transient_serialize$2,
        transient_toString: transient_toString$2,
        unprovenauthorizedmint_coin: unprovenauthorizedmint_coin$2,
        unprovenauthorizedmint_deserialize: unprovenauthorizedmint_deserialize$2,
        unprovenauthorizedmint_eraseProof: unprovenauthorizedmint_eraseProof$2,
        unprovenauthorizedmint_new: unprovenauthorizedmint_new$2,
        unprovenauthorizedmint_recipient: unprovenauthorizedmint_recipient$2,
        unprovenauthorizedmint_serialize: unprovenauthorizedmint_serialize$2,
        unprovenauthorizedmint_toString: unprovenauthorizedmint_toString$2,
        unproveninput_contractAddress: unproveninput_contractAddress$2,
        unproveninput_deserialize: unproveninput_deserialize$2,
        unproveninput_new: unproveninput_new$2,
        unproveninput_newContractOwned: unproveninput_newContractOwned$2,
        unproveninput_nullifier: unproveninput_nullifier$2,
        unproveninput_serialize: unproveninput_serialize$2,
        unproveninput_toString: unproveninput_toString$2,
        unprovenoffer_deltas: unprovenoffer_deltas$2,
        unprovenoffer_deserialize: unprovenoffer_deserialize$2,
        unprovenoffer_fromInput: unprovenoffer_fromInput$2,
        unprovenoffer_fromOutput: unprovenoffer_fromOutput$2,
        unprovenoffer_fromTransient: unprovenoffer_fromTransient$2,
        unprovenoffer_inputs: unprovenoffer_inputs$2,
        unprovenoffer_merge: unprovenoffer_merge$2,
        unprovenoffer_new: unprovenoffer_new$2,
        unprovenoffer_outputs: unprovenoffer_outputs$2,
        unprovenoffer_serialize: unprovenoffer_serialize$2,
        unprovenoffer_toString: unprovenoffer_toString$2,
        unprovenoffer_transient: unprovenoffer_transient$2,
        unprovenoutput_commitment: unprovenoutput_commitment$2,
        unprovenoutput_construct: unprovenoutput_construct$2,
        unprovenoutput_contractAddress: unprovenoutput_contractAddress$2,
        unprovenoutput_deserialize: unprovenoutput_deserialize$2,
        unprovenoutput_new: unprovenoutput_new$2,
        unprovenoutput_newContractOwned: unprovenoutput_newContractOwned$2,
        unprovenoutput_serialize: unprovenoutput_serialize$2,
        unprovenoutput_toString: unprovenoutput_toString$2,
        unproventransaction_contractCalls,
        unproventransaction_deserialize: unproventransaction_deserialize$2,
        unproventransaction_eraseProofs: unproventransaction_eraseProofs$2,
        unproventransaction_fallibleCoins: unproventransaction_fallibleCoins$2,
        unproventransaction_fromMint: unproventransaction_fromMint$2,
        unproventransaction_guaranteedCoins: unproventransaction_guaranteedCoins$2,
        unproventransaction_identifiers: unproventransaction_identifiers$2,
        unproventransaction_imbalances,
        unproventransaction_merge: unproventransaction_merge$2,
        unproventransaction_mint: unproventransaction_mint$2,
        unproventransaction_new: unproventransaction_new$2,
        unproventransaction_serialize: unproventransaction_serialize$2,
        unproventransaction_toString: unproventransaction_toString$2,
        unproventransient_commitment: unproventransient_commitment$2,
        unproventransient_contractAddress: unproventransient_contractAddress$2,
        unproventransient_deserialize: unproventransient_deserialize$2,
        unproventransient_new: unproventransient_new$2,
        unproventransient_newFromContractOwnedOutput: unproventransient_newFromContractOwnedOutput$2,
        unproventransient_nullifier: unproventransient_nullifier$2,
        unproventransient_serialize: unproventransient_serialize$2,
        unproventransient_toString: unproventransient_toString$2,
        upgradeFromTransient,
        valueToBigInt,
        verifierkeyinsert_new,
        verifierkeyinsert_operation,
        verifierkeyinsert_toString,
        verifierkeyinsert_vk,
        verifierkeyremove_new,
        verifierkeyremove_operation,
        verifierkeyremove_toString,
        verifierkeyremove_version,
        verifySignature,
        vmresults_events,
        vmresults_gas_cost,
        vmresults_new,
        vmresults_stack,
        vmresults_toString,
        vmstack_get,
        vmstack_isStrong,
        vmstack_length,
        vmstack_new,
        vmstack_push,
        vmstack_removeLast,
        vmstack_toString,
        wellformedstrictness_enforce_balancing,
        wellformedstrictness_enforce_limits,
        wellformedstrictness_new,
        wellformedstrictness_set_enforce_balancing,
        wellformedstrictness_set_enforce_limits,
        wellformedstrictness_set_verify_contract_proofs,
        wellformedstrictness_set_verify_native_proofs,
        wellformedstrictness_verify_contract_proofs,
        wellformedstrictness_verify_native_proofs,
        zswapchainstate_deserialize: zswapchainstate_deserialize$2,
        zswapchainstate_deserializeFromLedgerState: zswapchainstate_deserializeFromLedgerState$2,
        zswapchainstate_deserialize_raw: zswapchainstate_deserialize_raw$2,
        zswapchainstate_filter: zswapchainstate_filter$2,
        zswapchainstate_firstFree: zswapchainstate_firstFree$2,
        zswapchainstate_merkle_tree_root: zswapchainstate_merkle_tree_root$2,
        zswapchainstate_new: zswapchainstate_new$2,
        zswapchainstate_serialize: zswapchainstate_serialize$2,
        zswapchainstate_serialize_raw: zswapchainstate_serialize_raw$2,
        zswapchainstate_toString: zswapchainstate_toString$2,
        zswapchainstate_tryApply: zswapchainstate_tryApply$2,
        zswapchainstate_tryApplyProofErased: zswapchainstate_tryApplyProofErased$2,
        zswapchainstate_tryApplyWithoutWhitelist: zswapchainstate_tryApplyWithoutWhitelist$2
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    __wbg_set_wasm$2(wasm$4);
    __wbindgen_start$2();
    const createProverKey = (uint8Array)=>{
        return uint8Array;
    };
    const createVerifierKey = (uint8Array)=>{
        return uint8Array;
    };
    const createZKIR = (uint8Array)=>{
        return uint8Array;
    };
    const createUnbalancedTx = (tx)=>{
        return tx;
    };
    const createBalancedTx = (tx)=>{
        return tx;
    };
    const FailEntirely = 'FailEntirely';
    const FailFallible = 'FailFallible';
    const SucceedEntirely = 'SucceedEntirely';
    class ZKConfigProvider {
        async getVerifierKeys(circuitIds) {
            return Promise.all(circuitIds.map(async (id)=>{
                const key = await this.getVerifierKey(id);
                return [
                    id,
                    key
                ];
            }));
        }
        async get(circuitId) {
            return {
                circuitId,
                proverKey: await this.getProverKey(circuitId),
                verifierKey: await this.getVerifierKey(circuitId),
                zkir: await this.getZKIR(circuitId)
            };
        }
    }
    class InvalidProtocolSchemeError extends Error {
        invalidScheme;
        allowableSchemes;
        constructor(invalidScheme, allowableSchemes){
            super(`Invalid protocol scheme: '${invalidScheme}'. Allowable schemes are one of: ${allowableSchemes.join(',')}`);
            this.invalidScheme = invalidScheme;
            this.allowableSchemes = allowableSchemes;
        }
    }
    var LogLevel;
    (function(LogLevel) {
        LogLevel["INFO"] = "info";
        LogLevel["WARN"] = "warn";
        LogLevel["ERROR"] = "error";
        LogLevel["FATAL"] = "fatal";
        LogLevel["DEBUG"] = "debug";
        LogLevel["TRACE"] = "trace";
    })(LogLevel || (LogLevel = {}));
    var browserPonyfill = {
        exports: {}
    };
    var hasRequiredBrowserPonyfill;
    function requireBrowserPonyfill() {
        if (hasRequiredBrowserPonyfill) return browserPonyfill.exports;
        hasRequiredBrowserPonyfill = 1;
        (function(module, exports) {
            var __global__ = (typeof globalThis !== 'undefined' && globalThis) || (typeof self !== 'undefined' && self) || (typeof commonjsGlobal !== 'undefined' && commonjsGlobal);
            var __globalThis__ = (function() {
                function F() {
                    this.fetch = false;
                    this.DOMException = __global__.DOMException;
                }
                F.prototype = __global__;
                return new F();
            })();
            (function(globalThis) {
                ((function(exports) {
                    var g = (typeof globalThis !== 'undefined' && globalThis) || (typeof self !== 'undefined' && self) || (typeof commonjsGlobal !== 'undefined' && commonjsGlobal) || {};
                    var support = {
                        searchParams: 'URLSearchParams' in g,
                        iterable: 'Symbol' in g && 'iterator' in Symbol,
                        blob: 'FileReader' in g && 'Blob' in g && (function() {
                            try {
                                new Blob();
                                return true;
                            } catch (e) {
                                return false;
                            }
                        })(),
                        formData: 'FormData' in g,
                        arrayBuffer: 'ArrayBuffer' in g
                    };
                    function isDataView(obj) {
                        return obj && DataView.prototype.isPrototypeOf(obj);
                    }
                    if (support.arrayBuffer) {
                        var viewClasses = [
                            '[object Int8Array]',
                            '[object Uint8Array]',
                            '[object Uint8ClampedArray]',
                            '[object Int16Array]',
                            '[object Uint16Array]',
                            '[object Int32Array]',
                            '[object Uint32Array]',
                            '[object Float32Array]',
                            '[object Float64Array]'
                        ];
                        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
                        };
                    }
                    function normalizeName(name) {
                        if (typeof name !== 'string') {
                            name = String(name);
                        }
                        if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
                            throw new TypeError('Invalid character in header field name: "' + name + '"');
                        }
                        return name.toLowerCase();
                    }
                    function normalizeValue(value) {
                        if (typeof value !== 'string') {
                            value = String(value);
                        }
                        return value;
                    }
                    function iteratorFor(items) {
                        var iterator = {
                            next: function() {
                                var value = items.shift();
                                return {
                                    done: value === undefined,
                                    value: value
                                };
                            }
                        };
                        if (support.iterable) {
                            iterator[Symbol.iterator] = function() {
                                return iterator;
                            };
                        }
                        return iterator;
                    }
                    function Headers(headers) {
                        this.map = {};
                        if (headers instanceof Headers) {
                            headers.forEach(function(value, name) {
                                this.append(name, value);
                            }, this);
                        } else if (Array.isArray(headers)) {
                            headers.forEach(function(header) {
                                if (header.length != 2) {
                                    throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
                                }
                                this.append(header[0], header[1]);
                            }, this);
                        } else if (headers) {
                            Object.getOwnPropertyNames(headers).forEach(function(name) {
                                this.append(name, headers[name]);
                            }, this);
                        }
                    }
                    Headers.prototype.append = function(name, value) {
                        name = normalizeName(name);
                        value = normalizeValue(value);
                        var oldValue = this.map[name];
                        this.map[name] = oldValue ? oldValue + ', ' + value : value;
                    };
                    Headers.prototype['delete'] = function(name) {
                        delete this.map[normalizeName(name)];
                    };
                    Headers.prototype.get = function(name) {
                        name = normalizeName(name);
                        return this.has(name) ? this.map[name] : null;
                    };
                    Headers.prototype.has = function(name) {
                        return this.map.hasOwnProperty(normalizeName(name));
                    };
                    Headers.prototype.set = function(name, value) {
                        this.map[normalizeName(name)] = normalizeValue(value);
                    };
                    Headers.prototype.forEach = function(callback, thisArg) {
                        for(var name in this.map){
                            if (this.map.hasOwnProperty(name)) {
                                callback.call(thisArg, this.map[name], name, this);
                            }
                        }
                    };
                    Headers.prototype.keys = function() {
                        var items = [];
                        this.forEach(function(value, name) {
                            items.push(name);
                        });
                        return iteratorFor(items);
                    };
                    Headers.prototype.values = function() {
                        var items = [];
                        this.forEach(function(value) {
                            items.push(value);
                        });
                        return iteratorFor(items);
                    };
                    Headers.prototype.entries = function() {
                        var items = [];
                        this.forEach(function(value, name) {
                            items.push([
                                name,
                                value
                            ]);
                        });
                        return iteratorFor(items);
                    };
                    if (support.iterable) {
                        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
                    }
                    function consumed(body) {
                        if (body._noBody) return;
                        if (body.bodyUsed) {
                            return Promise.reject(new TypeError('Already read'));
                        }
                        body.bodyUsed = true;
                    }
                    function fileReaderReady(reader) {
                        return new Promise(function(resolve, reject) {
                            reader.onload = function() {
                                resolve(reader.result);
                            };
                            reader.onerror = function() {
                                reject(reader.error);
                            };
                        });
                    }
                    function readBlobAsArrayBuffer(blob) {
                        var reader = new FileReader();
                        var promise = fileReaderReady(reader);
                        reader.readAsArrayBuffer(blob);
                        return promise;
                    }
                    function readBlobAsText(blob) {
                        var reader = new FileReader();
                        var promise = fileReaderReady(reader);
                        var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
                        var encoding = match ? match[1] : 'utf-8';
                        reader.readAsText(blob, encoding);
                        return promise;
                    }
                    function readArrayBufferAsText(buf) {
                        var view = new Uint8Array(buf);
                        var chars = new Array(view.length);
                        for(var i = 0; i < view.length; i++){
                            chars[i] = String.fromCharCode(view[i]);
                        }
                        return chars.join('');
                    }
                    function bufferClone(buf) {
                        if (buf.slice) {
                            return buf.slice(0);
                        } else {
                            var view = new Uint8Array(buf.byteLength);
                            view.set(new Uint8Array(buf));
                            return view.buffer;
                        }
                    }
                    function Body() {
                        this.bodyUsed = false;
                        this._initBody = function(body) {
                            this.bodyUsed = this.bodyUsed;
                            this._bodyInit = body;
                            if (!body) {
                                this._noBody = true;
                                this._bodyText = '';
                            } else if (typeof body === 'string') {
                                this._bodyText = body;
                            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                                this._bodyBlob = body;
                            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                                this._bodyFormData = body;
                            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                                this._bodyText = body.toString();
                            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                                this._bodyArrayBuffer = bufferClone(body.buffer);
                                this._bodyInit = new Blob([
                                    this._bodyArrayBuffer
                                ]);
                            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                                this._bodyArrayBuffer = bufferClone(body);
                            } else {
                                this._bodyText = body = Object.prototype.toString.call(body);
                            }
                            if (!this.headers.get('content-type')) {
                                if (typeof body === 'string') {
                                    this.headers.set('content-type', 'text/plain;charset=UTF-8');
                                } else if (this._bodyBlob && this._bodyBlob.type) {
                                    this.headers.set('content-type', this._bodyBlob.type);
                                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                                    this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                                }
                            }
                        };
                        if (support.blob) {
                            this.blob = function() {
                                var rejected = consumed(this);
                                if (rejected) {
                                    return rejected;
                                }
                                if (this._bodyBlob) {
                                    return Promise.resolve(this._bodyBlob);
                                } else if (this._bodyArrayBuffer) {
                                    return Promise.resolve(new Blob([
                                        this._bodyArrayBuffer
                                    ]));
                                } else if (this._bodyFormData) {
                                    throw new Error('could not read FormData body as blob');
                                } else {
                                    return Promise.resolve(new Blob([
                                        this._bodyText
                                    ]));
                                }
                            };
                        }
                        this.arrayBuffer = function() {
                            if (this._bodyArrayBuffer) {
                                var isConsumed = consumed(this);
                                if (isConsumed) {
                                    return isConsumed;
                                } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                                    return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                                } else {
                                    return Promise.resolve(this._bodyArrayBuffer);
                                }
                            } else if (support.blob) {
                                return this.blob().then(readBlobAsArrayBuffer);
                            } else {
                                throw new Error('could not read as ArrayBuffer');
                            }
                        };
                        this.text = function() {
                            var rejected = consumed(this);
                            if (rejected) {
                                return rejected;
                            }
                            if (this._bodyBlob) {
                                return readBlobAsText(this._bodyBlob);
                            } else if (this._bodyArrayBuffer) {
                                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                            } else if (this._bodyFormData) {
                                throw new Error('could not read FormData body as text');
                            } else {
                                return Promise.resolve(this._bodyText);
                            }
                        };
                        if (support.formData) {
                            this.formData = function() {
                                return this.text().then(decode);
                            };
                        }
                        this.json = function() {
                            return this.text().then(JSON.parse);
                        };
                        return this;
                    }
                    var methods = [
                        'CONNECT',
                        'DELETE',
                        'GET',
                        'HEAD',
                        'OPTIONS',
                        'PATCH',
                        'POST',
                        'PUT',
                        'TRACE'
                    ];
                    function normalizeMethod(method) {
                        var upcased = method.toUpperCase();
                        return methods.indexOf(upcased) > -1 ? upcased : method;
                    }
                    function Request(input, options) {
                        if (!(this instanceof Request)) {
                            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                        }
                        options = options || {};
                        var body = options.body;
                        if (input instanceof Request) {
                            if (input.bodyUsed) {
                                throw new TypeError('Already read');
                            }
                            this.url = input.url;
                            this.credentials = input.credentials;
                            if (!options.headers) {
                                this.headers = new Headers(input.headers);
                            }
                            this.method = input.method;
                            this.mode = input.mode;
                            this.signal = input.signal;
                            if (!body && input._bodyInit != null) {
                                body = input._bodyInit;
                                input.bodyUsed = true;
                            }
                        } else {
                            this.url = String(input);
                        }
                        this.credentials = options.credentials || this.credentials || 'same-origin';
                        if (options.headers || !this.headers) {
                            this.headers = new Headers(options.headers);
                        }
                        this.method = normalizeMethod(options.method || this.method || 'GET');
                        this.mode = options.mode || this.mode || null;
                        this.signal = options.signal || this.signal || (function() {
                            if ('AbortController' in g) {
                                var ctrl = new AbortController();
                                return ctrl.signal;
                            }
                        }());
                        this.referrer = null;
                        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                            throw new TypeError('Body not allowed for GET or HEAD requests');
                        }
                        this._initBody(body);
                        if (this.method === 'GET' || this.method === 'HEAD') {
                            if (options.cache === 'no-store' || options.cache === 'no-cache') {
                                var reParamSearch = /([?&])_=[^&]*/;
                                if (reParamSearch.test(this.url)) {
                                    this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
                                } else {
                                    var reQueryString = /\?/;
                                    this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
                                }
                            }
                        }
                    }
                    Request.prototype.clone = function() {
                        return new Request(this, {
                            body: this._bodyInit
                        });
                    };
                    function decode(body) {
                        var form = new FormData();
                        body.trim().split('&').forEach(function(bytes) {
                            if (bytes) {
                                var split = bytes.split('=');
                                var name = split.shift().replace(/\+/g, ' ');
                                var value = split.join('=').replace(/\+/g, ' ');
                                form.append(decodeURIComponent(name), decodeURIComponent(value));
                            }
                        });
                        return form;
                    }
                    function parseHeaders(rawHeaders) {
                        var headers = new Headers();
                        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
                        preProcessedHeaders.split('\r').map(function(header) {
                            return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
                        }).forEach(function(line) {
                            var parts = line.split(':');
                            var key = parts.shift().trim();
                            if (key) {
                                var value = parts.join(':').trim();
                                try {
                                    headers.append(key, value);
                                } catch (error) {
                                    console.warn('Response ' + error.message);
                                }
                            }
                        });
                        return headers;
                    }
                    Body.call(Request.prototype);
                    function Response(bodyInit, options) {
                        if (!(this instanceof Response)) {
                            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                        }
                        if (!options) {
                            options = {};
                        }
                        this.type = 'default';
                        this.status = options.status === undefined ? 200 : options.status;
                        if (this.status < 200 || this.status > 599) {
                            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                        }
                        this.ok = this.status >= 200 && this.status < 300;
                        this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
                        this.headers = new Headers(options.headers);
                        this.url = options.url || '';
                        this._initBody(bodyInit);
                    }
                    Body.call(Response.prototype);
                    Response.prototype.clone = function() {
                        return new Response(this._bodyInit, {
                            status: this.status,
                            statusText: this.statusText,
                            headers: new Headers(this.headers),
                            url: this.url
                        });
                    };
                    Response.error = function() {
                        var response = new Response(null, {
                            status: 200,
                            statusText: ''
                        });
                        response.ok = false;
                        response.status = 0;
                        response.type = 'error';
                        return response;
                    };
                    var redirectStatuses = [
                        301,
                        302,
                        303,
                        307,
                        308
                    ];
                    Response.redirect = function(url, status) {
                        if (redirectStatuses.indexOf(status) === -1) {
                            throw new RangeError('Invalid status code');
                        }
                        return new Response(null, {
                            status: status,
                            headers: {
                                location: url
                            }
                        });
                    };
                    exports.DOMException = g.DOMException;
                    try {
                        new exports.DOMException();
                    } catch (err) {
                        exports.DOMException = function(message, name) {
                            this.message = message;
                            this.name = name;
                            var error = Error(message);
                            this.stack = error.stack;
                        };
                        exports.DOMException.prototype = Object.create(Error.prototype);
                        exports.DOMException.prototype.constructor = exports.DOMException;
                    }
                    function fetch(input, init) {
                        return new Promise(function(resolve, reject) {
                            var request = new Request(input, init);
                            if (request.signal && request.signal.aborted) {
                                return reject(new exports.DOMException('Aborted', 'AbortError'));
                            }
                            var xhr = new XMLHttpRequest();
                            function abortXhr() {
                                xhr.abort();
                            }
                            xhr.onload = function() {
                                var options = {
                                    statusText: xhr.statusText,
                                    headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                                };
                                if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
                                    options.status = 200;
                                } else {
                                    options.status = xhr.status;
                                }
                                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                                setTimeout(function() {
                                    resolve(new Response(body, options));
                                }, 0);
                            };
                            xhr.onerror = function() {
                                setTimeout(function() {
                                    reject(new TypeError('Network request failed'));
                                }, 0);
                            };
                            xhr.ontimeout = function() {
                                setTimeout(function() {
                                    reject(new TypeError('Network request timed out'));
                                }, 0);
                            };
                            xhr.onabort = function() {
                                setTimeout(function() {
                                    reject(new exports.DOMException('Aborted', 'AbortError'));
                                }, 0);
                            };
                            function fixUrl(url) {
                                try {
                                    return url === '' && g.location.href ? g.location.href : url;
                                } catch (e) {
                                    return url;
                                }
                            }
                            xhr.open(request.method, fixUrl(request.url), true);
                            if (request.credentials === 'include') {
                                xhr.withCredentials = true;
                            } else if (request.credentials === 'omit') {
                                xhr.withCredentials = false;
                            }
                            if ('responseType' in xhr) {
                                if (support.blob) {
                                    xhr.responseType = 'blob';
                                } else if (support.arrayBuffer) {
                                    xhr.responseType = 'arraybuffer';
                                }
                            }
                            if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {
                                var names = [];
                                Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                                    names.push(normalizeName(name));
                                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                                });
                                request.headers.forEach(function(value, name) {
                                    if (names.indexOf(name) === -1) {
                                        xhr.setRequestHeader(name, value);
                                    }
                                });
                            } else {
                                request.headers.forEach(function(value, name) {
                                    xhr.setRequestHeader(name, value);
                                });
                            }
                            if (request.signal) {
                                request.signal.addEventListener('abort', abortXhr);
                                xhr.onreadystatechange = function() {
                                    if (xhr.readyState === 4) {
                                        request.signal.removeEventListener('abort', abortXhr);
                                    }
                                };
                            }
                            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
                        });
                    }
                    fetch.polyfill = true;
                    if (!g.fetch) {
                        g.fetch = fetch;
                        g.Headers = Headers;
                        g.Request = Request;
                        g.Response = Response;
                    }
                    exports.Headers = Headers;
                    exports.Request = Request;
                    exports.Response = Response;
                    exports.fetch = fetch;
                    return exports;
                }))({});
            })(__globalThis__);
            __globalThis__.fetch.ponyfill = true;
            delete __globalThis__.fetch.polyfill;
            var ctx = __global__.fetch ? __global__ : __globalThis__;
            exports = ctx.fetch;
            exports.default = ctx.fetch;
            exports.fetch = ctx.fetch;
            exports.Headers = ctx.Headers;
            exports.Request = ctx.Request;
            exports.Response = ctx.Response;
            module.exports = exports;
        }(browserPonyfill, browserPonyfill.exports));
        return browserPonyfill.exports;
    }
    var browserPonyfillExports = requireBrowserPonyfill();
    const fetch$1 = getDefaultExportFromCjs(browserPonyfillExports);
    const KEY_PATH = 'keys';
    const PROVER_EXT = '.prover';
    const VERIFIER_EXT = '.verifier';
    const ZKIR_PATH = 'zkir';
    const ZKIR_EXT = '.bzkir';
    class FetchZkConfigProvider extends ZKConfigProvider {
        baseURL;
        fetchFunc;
        constructor(baseURL, fetchFunc = browserPonyfillExports.fetch){
            super();
            this.baseURL = baseURL;
            this.fetchFunc = fetchFunc;
            const urlObject = new URL(baseURL);
            if (urlObject.protocol !== 'http:' && urlObject.protocol !== 'https:') {
                throw new InvalidProtocolSchemeError(urlObject.protocol, [
                    'http:',
                    'https:'
                ]);
            }
        }
        async sendRequest(url, circuitId, ext, responseType) {
            const response = await this.fetchFunc(`${this.baseURL}/${url}/${circuitId}${ext}`, {
                method: 'GET'
            });
            if (response.ok) {
                return responseType === 'text' ? (await response.text()) : (await response.arrayBuffer().then((arrayBuffer)=>new Uint8Array(arrayBuffer)));
            }
            throw new Error(response.statusText);
        }
        getProverKey(circuitId) {
            return this.sendRequest(KEY_PATH, circuitId, PROVER_EXT, 'arraybuffer').then(createProverKey);
        }
        getVerifierKey(circuitId) {
            return this.sendRequest(KEY_PATH, circuitId, VERIFIER_EXT, 'arraybuffer').then(createVerifierKey);
        }
        getZKIR(circuitId) {
            return this.sendRequest(ZKIR_PATH, circuitId, ZKIR_EXT, 'arraybuffer').then(createZKIR);
        }
    }
    var fetchRetry_umd$1 = {
        exports: {}
    };
    var fetchRetry_umd = fetchRetry_umd$1.exports;
    var hasRequiredFetchRetry_umd;
    function requireFetchRetry_umd() {
        if (hasRequiredFetchRetry_umd) return fetchRetry_umd$1.exports;
        hasRequiredFetchRetry_umd = 1;
        (function(module, exports) {
            (function(global, factory) {
                module.exports = factory();
            })(fetchRetry_umd, (function() {
                var fetchRetry = function(fetch, defaults) {
                    defaults = defaults || {};
                    if (typeof fetch !== 'function') {
                        throw new ArgumentError('fetch must be a function');
                    }
                    if (typeof defaults !== 'object') {
                        throw new ArgumentError('defaults must be an object');
                    }
                    if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) {
                        throw new ArgumentError('retries must be a positive integer');
                    }
                    if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') {
                        throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');
                    }
                    if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') {
                        throw new ArgumentError('retryOn property expects an array or function');
                    }
                    var baseDefaults = {
                        retries: 3,
                        retryDelay: 1000,
                        retryOn: []
                    };
                    defaults = Object.assign(baseDefaults, defaults);
                    return function fetchRetry(input, init) {
                        var retries = defaults.retries;
                        var retryDelay = defaults.retryDelay;
                        var retryOn = defaults.retryOn;
                        if (init && init.retries !== undefined) {
                            if (isPositiveInteger(init.retries)) {
                                retries = init.retries;
                            } else {
                                throw new ArgumentError('retries must be a positive integer');
                            }
                        }
                        if (init && init.retryDelay !== undefined) {
                            if (isPositiveInteger(init.retryDelay) || (typeof init.retryDelay === 'function')) {
                                retryDelay = init.retryDelay;
                            } else {
                                throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');
                            }
                        }
                        if (init && init.retryOn) {
                            if (Array.isArray(init.retryOn) || (typeof init.retryOn === 'function')) {
                                retryOn = init.retryOn;
                            } else {
                                throw new ArgumentError('retryOn property expects an array or function');
                            }
                        }
                        return new Promise(function(resolve, reject) {
                            var wrappedFetch = function(attempt) {
                                var _input = typeof Request !== 'undefined' && input instanceof Request ? input.clone() : input;
                                fetch(_input, init).then(function(response) {
                                    if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {
                                        resolve(response);
                                    } else if (typeof retryOn === 'function') {
                                        try {
                                            return Promise.resolve(retryOn(attempt, null, response)).then(function(retryOnResponse) {
                                                if (retryOnResponse) {
                                                    retry(attempt, null, response);
                                                } else {
                                                    resolve(response);
                                                }
                                            }).catch(reject);
                                        } catch (error) {
                                            reject(error);
                                        }
                                    } else {
                                        if (attempt < retries) {
                                            retry(attempt, null, response);
                                        } else {
                                            resolve(response);
                                        }
                                    }
                                }).catch(function(error) {
                                    if (typeof retryOn === 'function') {
                                        try {
                                            Promise.resolve(retryOn(attempt, error, null)).then(function(retryOnResponse) {
                                                if (retryOnResponse) {
                                                    retry(attempt, error, null);
                                                } else {
                                                    reject(error);
                                                }
                                            }).catch(function(error) {
                                                reject(error);
                                            });
                                        } catch (error) {
                                            reject(error);
                                        }
                                    } else if (attempt < retries) {
                                        retry(attempt, error, null);
                                    } else {
                                        reject(error);
                                    }
                                });
                            };
                            function retry(attempt, error, response) {
                                var delay = (typeof retryDelay === 'function') ? retryDelay(attempt, error, response) : retryDelay;
                                setTimeout(function() {
                                    wrappedFetch(++attempt);
                                }, delay);
                            }
                            wrappedFetch(0);
                        });
                    };
                };
                function isPositiveInteger(value) {
                    return Number.isInteger(value) && value >= 0;
                }
                function ArgumentError(message) {
                    this.name = 'ArgumentError';
                    this.message = message;
                }
                return fetchRetry;
            }));
        }(fetchRetry_umd$1));
        return fetchRetry_umd$1.exports;
    }
    var fetchRetry_umdExports = requireFetchRetry_umd();
    const fetchBuilder = getDefaultExportFromCjs(fetchRetry_umdExports);
    class BorshError extends Error {
        constructor(message){
            super(message);
            this.fieldPath = [];
            this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
            this.fieldPath.splice(0, 0, fieldName);
            this.message = this.originalMessage + ". Error originated at field path: " + this.fieldPath.join(".");
        }
    }
    function writeBufferLEBigInt(num, width, buffer, offset) {
        const hex = num.toString(16);
        const padded = hex.padStart(width * 2, '0').slice(0, width * 2);
        for (const [ix, value] of padded.match(/.{1,2}/g).map((byte)=>parseInt(byte, 16)).entries()){
            buffer[offset + width - 1 - ix] = value;
        }
    }
    function writeUInt32LE(value, buf, offset) {
        checkInt(value, 0, 0xffffffff, 3);
        buf[offset] = value;
        buf[offset + 1] = value >>> 8;
        buf[offset + 2] = value >>> 16;
        buf[offset + 3] = value >>> 24;
    }
    function writeUInt16LE(value, buf, offset) {
        checkInt(value, 0, 0xffff, 1);
        buf[offset] = value;
        buf[offset + 1] = (value >>> 8);
    }
    const writeBigUint64Le = (bigIntOrNumber, buf, offset)=>{
        let lo, hi;
        if (typeof bigIntOrNumber === 'bigint') {
            if (bigIntOrNumber <= Number.MAX_SAFE_INTEGER) {
                if (bigIntOrNumber < 0) {
                    throw new Error("u64 value can not negative, got " + bigIntOrNumber);
                }
                bigIntOrNumber = Number(bigIntOrNumber);
                lo = bigIntOrNumber >>> 0;
                hi = (bigIntOrNumber - lo) / 4294967296;
            } else {
                if (bigIntOrNumber > 18446744073709551615n) {
                    throw new Error("u64 value can exceed mav value got " + bigIntOrNumber);
                }
                lo = Number(bigIntOrNumber & 4294967295n);
                hi = Number(bigIntOrNumber >> 32n & 4294967295n);
            }
        } else {
            if (bigIntOrNumber < 0 || bigIntOrNumber > 18446744073709551615n) {
                throw new Error("u64 value can not negative, got " + bigIntOrNumber);
            }
            lo = bigIntOrNumber >>> 0;
            hi = (bigIntOrNumber - lo) / 4294967296;
        }
        buf[offset] = lo;
        buf[offset + 1] = lo >>> 8;
        buf[offset + 2] = lo >>> 16;
        buf[offset + 3] = lo >>> 24;
        buf[offset + 4] = hi;
        buf[offset + 5] = hi >>> 8;
        buf[offset + 6] = hi >>> 16;
        buf[offset + 7] = hi >>> 24;
    };
    const checkInt = (value, min, max, byteLength)=>{
        if (value > max || value < min) {
            const n = '';
            let range;
            if (byteLength > 3) {
                {
                    range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
                }
            } else {
                range = `>= ${min}${n} and <= ${max}${n}`;
            }
            throw new Error("Out of range value: " + range + ", " + value);
        }
    };
    var utf8$1 = {};
    var hasRequiredUtf8;
    function requireUtf8() {
        if (hasRequiredUtf8) return utf8$1;
        hasRequiredUtf8 = 1;
        (function(exports) {
            var utf8 = exports;
            utf8.length = function utf8_length(string) {
                var len = 0, c = 0;
                for(var i = 0; i < string.length; ++i){
                    c = string.charCodeAt(i);
                    if (c < 128) len += 1;
                    else if (c < 2048) len += 2;
                    else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
                        ++i;
                        len += 4;
                    } else len += 3;
                }
                return len;
            };
            utf8.read = function utf8_read(buffer, start, end) {
                var len = end - start;
                if (len < 1) return "";
                var parts = null, chunk = [], i = 0, t;
                while(start < end){
                    t = buffer[start++];
                    if (t < 128) chunk[i++] = t;
                    else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
                    else if (t > 239 && t < 365) {
                        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
                        chunk[i++] = 0xD800 + (t >> 10);
                        chunk[i++] = 0xDC00 + (t & 1023);
                    } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
                    if (i > 8191) {
                        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                        i = 0;
                    }
                }
                if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("");
                }
                return String.fromCharCode.apply(String, chunk.slice(0, i));
            };
            utf8.write = function utf8_write(string, buffer, offset) {
                var start = offset, c1, c2;
                for(var i = 0; i < string.length; ++i){
                    c1 = string.charCodeAt(i);
                    if (c1 < 128) {
                        buffer[offset++] = c1;
                    } else if (c1 < 2048) {
                        buffer[offset++] = c1 >> 6 | 192;
                        buffer[offset++] = c1 & 63 | 128;
                    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
                        c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
                        ++i;
                        buffer[offset++] = c1 >> 18 | 240;
                        buffer[offset++] = c1 >> 12 & 63 | 128;
                        buffer[offset++] = c1 >> 6 & 63 | 128;
                        buffer[offset++] = c1 & 63 | 128;
                    } else {
                        buffer[offset++] = c1 >> 12 | 224;
                        buffer[offset++] = c1 >> 6 & 63 | 128;
                        buffer[offset++] = c1 & 63 | 128;
                    }
                }
                return offset - start;
            };
        }(utf8$1));
        return utf8$1;
    }
    var utf8Exports = requireUtf8();
    const utf8 = getDefaultExportFromCjs(utf8Exports);
    var float;
    var hasRequiredFloat;
    function requireFloat() {
        if (hasRequiredFloat) return float;
        hasRequiredFloat = 1;
        float = factory(factory);
        function factory(exports) {
            if (typeof Float32Array !== "undefined") (function() {
                var f32 = new Float32Array([
                    -0
                ]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
                function writeFloat_f32_cpy(val, buf, pos) {
                    f32[0] = val;
                    buf[pos] = f8b[0];
                    buf[pos + 1] = f8b[1];
                    buf[pos + 2] = f8b[2];
                    buf[pos + 3] = f8b[3];
                }
                function writeFloat_f32_rev(val, buf, pos) {
                    f32[0] = val;
                    buf[pos] = f8b[3];
                    buf[pos + 1] = f8b[2];
                    buf[pos + 2] = f8b[1];
                    buf[pos + 3] = f8b[0];
                }
                exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
                exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
                function readFloat_f32_cpy(buf, pos) {
                    f8b[0] = buf[pos];
                    f8b[1] = buf[pos + 1];
                    f8b[2] = buf[pos + 2];
                    f8b[3] = buf[pos + 3];
                    return f32[0];
                }
                function readFloat_f32_rev(buf, pos) {
                    f8b[3] = buf[pos];
                    f8b[2] = buf[pos + 1];
                    f8b[1] = buf[pos + 2];
                    f8b[0] = buf[pos + 3];
                    return f32[0];
                }
                exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
                exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
            })();
            else (function() {
                function writeFloat_ieee754(writeUint, val, buf, pos) {
                    var sign = val < 0 ? 1 : 0;
                    if (sign) val = -val;
                    if (val === 0) writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
                    else if (isNaN(val)) writeUint(2143289344, buf, pos);
                    else if (val > 3.4028234663852886e+38) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
                    else if (val < 1.1754943508222875e-38) writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
                    else {
                        var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                        writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
                    }
                }
                exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
                exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
                function readFloat_ieee754(readUint, buf, pos) {
                    var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
                    return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
                }
                exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
                exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
            })();
            if (typeof Float64Array !== "undefined") (function() {
                var f64 = new Float64Array([
                    -0
                ]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
                function writeDouble_f64_cpy(val, buf, pos) {
                    f64[0] = val;
                    buf[pos] = f8b[0];
                    buf[pos + 1] = f8b[1];
                    buf[pos + 2] = f8b[2];
                    buf[pos + 3] = f8b[3];
                    buf[pos + 4] = f8b[4];
                    buf[pos + 5] = f8b[5];
                    buf[pos + 6] = f8b[6];
                    buf[pos + 7] = f8b[7];
                }
                function writeDouble_f64_rev(val, buf, pos) {
                    f64[0] = val;
                    buf[pos] = f8b[7];
                    buf[pos + 1] = f8b[6];
                    buf[pos + 2] = f8b[5];
                    buf[pos + 3] = f8b[4];
                    buf[pos + 4] = f8b[3];
                    buf[pos + 5] = f8b[2];
                    buf[pos + 6] = f8b[1];
                    buf[pos + 7] = f8b[0];
                }
                exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
                exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
                function readDouble_f64_cpy(buf, pos) {
                    f8b[0] = buf[pos];
                    f8b[1] = buf[pos + 1];
                    f8b[2] = buf[pos + 2];
                    f8b[3] = buf[pos + 3];
                    f8b[4] = buf[pos + 4];
                    f8b[5] = buf[pos + 5];
                    f8b[6] = buf[pos + 6];
                    f8b[7] = buf[pos + 7];
                    return f64[0];
                }
                function readDouble_f64_rev(buf, pos) {
                    f8b[7] = buf[pos];
                    f8b[6] = buf[pos + 1];
                    f8b[5] = buf[pos + 2];
                    f8b[4] = buf[pos + 3];
                    f8b[3] = buf[pos + 4];
                    f8b[2] = buf[pos + 5];
                    f8b[1] = buf[pos + 6];
                    f8b[0] = buf[pos + 7];
                    return f64[0];
                }
                exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
                exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
            })();
            else (function() {
                function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
                    var sign = val < 0 ? 1 : 0;
                    if (sign) val = -val;
                    if (val === 0) {
                        writeUint(0, buf, pos + off0);
                        writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
                    } else if (isNaN(val)) {
                        writeUint(0, buf, pos + off0);
                        writeUint(2146959360, buf, pos + off1);
                    } else if (val > 1.7976931348623157e+308) {
                        writeUint(0, buf, pos + off0);
                        writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
                    } else {
                        var mantissa;
                        if (val < 2.2250738585072014e-308) {
                            mantissa = val / 5e-324;
                            writeUint(mantissa >>> 0, buf, pos + off0);
                            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                        } else {
                            var exponent = Math.floor(Math.log(val) / Math.LN2);
                            if (exponent === 1024) exponent = 1023;
                            mantissa = val * Math.pow(2, -exponent);
                            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                        }
                    }
                }
                exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
                exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
                function readDouble_ieee754(readUint, off0, off1, buf, pos) {
                    var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
                    var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
                    return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
                }
                exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
                exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
            })();
            return exports;
        }
        function writeUintLE(val, buf, pos) {
            buf[pos] = val & 255;
            buf[pos + 1] = val >>> 8 & 255;
            buf[pos + 2] = val >>> 16 & 255;
            buf[pos + 3] = val >>> 24;
        }
        function writeUintBE(val, buf, pos) {
            buf[pos] = val >>> 24;
            buf[pos + 1] = val >>> 16 & 255;
            buf[pos + 2] = val >>> 8 & 255;
            buf[pos + 3] = val & 255;
        }
        function readUintLE(buf, pos) {
            return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
        }
        function readUintBE(buf, pos) {
            return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
        }
        return float;
    }
    var floatExports = requireFloat();
    const allocUnsafeFn = ()=>{
        if (globalThis.Buffer) {
            return globalThis.Buffer.allocUnsafe;
        }
        return (len)=>new Uint8Array(len);
    };
    const allocUnsafe = allocUnsafeFn();
    const writeStringBufferFnFn = ()=>{
        if (globalThis.Buffer) {
            return (length)=>{
                if (length < 48) return utf8.write;
                return (string, buf, offset)=>buf.write(string, offset);
            };
        }
        return ()=>utf8.write;
    };
    const writeStringBufferFn = writeStringBufferFnFn();
    const stringLengthFn = ()=>{
        if (globalThis.Buffer) {
            return (globalThis.Buffer).byteLength;
        }
        return utf8.length;
    };
    class BinaryWriter {
        constructor(){
            this.totalSize = 0;
            this._writes = ()=>this._buf = allocUnsafe(this.totalSize);
            this._writesTail = this._writes;
        }
        bool(value) {
            return BinaryWriter.bool(value, this);
        }
        static bool(value, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writer._buf[offset] = value ? 1 : 0;
            writer.totalSize += 1;
        }
        u8(value) {
            return BinaryWriter.u8(value, this);
        }
        static u8(value, writer) {
            checkInt(value, 0, 0xff, 1);
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writer._buf[offset] = value;
            writer.totalSize += 1;
        }
        u16(value) {
            return BinaryWriter.u16(value, this);
        }
        static u16(value, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writeUInt16LE(value, writer._buf, offset);
            writer.totalSize += 2;
        }
        u32(value) {
            return BinaryWriter.u32(value, this);
        }
        static u32(value, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writeUInt32LE(value, writer._buf, offset);
            writer.totalSize += 4;
        }
        u64(value) {
            return BinaryWriter.u64(value, this);
        }
        static u64(value, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writeBigUint64Le(value, writer._buf, offset);
            writer.totalSize += 8;
        }
        u128(value) {
            return BinaryWriter.u128(value, this);
        }
        static u128(value, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writeBufferLEBigInt(value, 16, writer._buf, offset);
            writer.totalSize += 16;
        }
        u256(value) {
            return BinaryWriter.u256(value, this);
        }
        static u256(value, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writeBufferLEBigInt(value, 32, writer._buf, offset);
            writer.totalSize += 32;
        }
        u512(value) {
            return BinaryWriter.u512(value, this);
        }
        static u512(value, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>writeBufferLEBigInt(value, 64, writer._buf, offset);
            writer.totalSize += 64;
        }
        f32(value) {
            return BinaryWriter.f32(value, this);
        }
        static f32(value, writer) {
            if (Number.isNaN(value)) {
                throw new BorshError("NaN is not supported for f32");
            }
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>floatExports.writeFloatLE(value, writer._buf, offset);
            writer.totalSize += 4;
        }
        f64(value) {
            return BinaryWriter.f64(value, this);
        }
        static f64(value, writer) {
            if (Number.isNaN(value)) {
                throw new BorshError("NaN is not supported for f64");
            }
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>floatExports.writeDoubleLE(value, writer._buf, offset);
            writer.totalSize += 8;
        }
        string(str) {
            return BinaryWriter.string(str, this);
        }
        static string(str, writer) {
            const len = stringLengthFn()(str);
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>{
                writeUInt32LE(len, writer._buf, offset);
                writeStringBufferFn(len)(str, writer._buf, offset + 4);
            };
            writer.totalSize += 4 + len;
        }
        static stringCustom(str, writer, lengthWriter = writeUInt32LE, lengthSize = 4) {
            const len = utf8.length(str);
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>{
                lengthWriter(len, writer._buf, offset);
                writeStringBufferFn(len)(str, writer._buf, offset + lengthSize);
            };
            writer.totalSize += lengthSize + len;
        }
        set(array) {
            let offset = this.totalSize;
            this._writes = this._writes.next = ()=>{
                this._buf.set(array, offset);
            };
            this.totalSize += array.length;
        }
        uint8Array(array) {
            return BinaryWriter.uint8Array(array, this);
        }
        static uint8Array(array, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>{
                writeUInt32LE(array.length, writer._buf, offset);
                writer._buf.set(array, offset + 4);
            };
            writer.totalSize += array.length + 4;
        }
        static uint8ArrayCustom(array, writer, lengthWriter = writeUInt32LE, lengthSize = 4) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>{
                lengthWriter(array.length, writer._buf, offset);
                writer._buf.set(array, offset + lengthSize);
            };
            writer.totalSize += array.length + lengthSize;
        }
        static uint8ArrayFixed(array, writer) {
            let offset = writer.totalSize;
            writer._writes = writer._writes.next = ()=>{
                writer._buf.set(array, offset);
            };
            writer.totalSize += array.length;
        }
        static smallNumberEncoding(encoding) {
            if (encoding === 'u8') {
                return [
                    (value, buf, offset)=>buf[offset] = value,
                    1
                ];
            } else if (encoding === 'u16') {
                return [
                    writeUInt16LE,
                    2
                ];
            } else if (encoding === 'u32') {
                return [
                    writeUInt32LE,
                    4
                ];
            } else {
                throw new Error("Unsupported encoding: " + encoding);
            }
        }
        static write(encoding) {
            if (encoding === 'u8') {
                return BinaryWriter.u8;
            } else if (encoding === 'u16') {
                return BinaryWriter.u16;
            } else if (encoding === 'u32') {
                return BinaryWriter.u32;
            } else if (encoding === 'u64') {
                return BinaryWriter.u64;
            } else if (encoding === 'u128') {
                return BinaryWriter.u128;
            } else if (encoding === 'u256') {
                return BinaryWriter.u256;
            } else if (encoding === 'u512') {
                return BinaryWriter.u512;
            } else if (encoding === 'bool') {
                return BinaryWriter.bool;
            } else if (encoding === 'f32') {
                return BinaryWriter.f32;
            } else if (encoding === 'f64') {
                return BinaryWriter.f64;
            } else if (encoding === 'string') {
                return BinaryWriter.string;
            } else {
                throw new Error("Unsupported encoding: " + encoding);
            }
        }
        finalize() {
            let current = this._writesTail;
            while(current != null){
                current();
                current = current.next;
            }
            return this._buf;
        }
    }
    var runtime = {};
    const __viteBrowserExternal = {};
    const __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: __viteBrowserExternal
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    const require$$0$2 = getAugmentedNamespace(__viteBrowserExternal$1);
    var objectInspect;
    var hasRequiredObjectInspect;
    function requireObjectInspect() {
        if (hasRequiredObjectInspect) return objectInspect;
        hasRequiredObjectInspect = 1;
        var hasMap = typeof Map === 'function' && Map.prototype;
        var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
        var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
        var mapForEach = hasMap && Map.prototype.forEach;
        var hasSet = typeof Set === 'function' && Set.prototype;
        var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
        var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
        var setForEach = hasSet && Set.prototype.forEach;
        var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
        var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
        var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
        var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
        var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
        var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
        var booleanValueOf = Boolean.prototype.valueOf;
        var objectToString = Object.prototype.toString;
        var functionToString = Function.prototype.toString;
        var $match = String.prototype.match;
        var $slice = String.prototype.slice;
        var $replace = String.prototype.replace;
        var $toUpperCase = String.prototype.toUpperCase;
        var $toLowerCase = String.prototype.toLowerCase;
        var $test = RegExp.prototype.test;
        var $concat = Array.prototype.concat;
        var $join = Array.prototype.join;
        var $arrSlice = Array.prototype.slice;
        var $floor = Math.floor;
        var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
        var gOPS = Object.getOwnPropertySymbols;
        var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
        var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
        var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
        var isEnumerable = Object.prototype.propertyIsEnumerable;
        var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
            return O.__proto__;
        } : null);
        function addNumericSeparator(num, str) {
            if (num === Infinity || num === -Infinity || num !== num || (num && num > -1e3 && num < 1000) || $test.call(/e/, str)) {
                return str;
            }
            var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
            if (typeof num === 'number') {
                var int = num < 0 ? -$floor(-num) : $floor(num);
                if (int !== num) {
                    var intStr = String(int);
                    var dec = $slice.call(str, intStr.length + 1);
                    return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
                }
            }
            return $replace.call(str, sepRegex, '$&_');
        }
        var utilInspect = require$$0$2;
        var inspectCustom = utilInspect.custom;
        var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
        var quotes = {
            __proto__: null,
            'double': '"',
            single: "'"
        };
        var quoteREs = {
            __proto__: null,
            'double': /(["\\])/g,
            single: /(['\\])/g
        };
        objectInspect = function inspect_(obj, options, depth, seen) {
            var opts = options || {};
            if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
                throw new TypeError('option "quoteStyle" must be "single" or "double"');
            }
            if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
                throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            }
            var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
            if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
                throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
            }
            if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
                throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            }
            if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
                throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            }
            var numericSeparator = opts.numericSeparator;
            if (typeof obj === 'undefined') {
                return 'undefined';
            }
            if (obj === null) {
                return 'null';
            }
            if (typeof obj === 'boolean') {
                return obj ? 'true' : 'false';
            }
            if (typeof obj === 'string') {
                return inspectString(obj, opts);
            }
            if (typeof obj === 'number') {
                if (obj === 0) {
                    return Infinity / obj > 0 ? '0' : '-0';
                }
                var str = String(obj);
                return numericSeparator ? addNumericSeparator(obj, str) : str;
            }
            if (typeof obj === 'bigint') {
                var bigIntStr = String(obj) + 'n';
                return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
            }
            var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
            if (typeof depth === 'undefined') {
                depth = 0;
            }
            if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
                return isArray(obj) ? '[Array]' : '[Object]';
            }
            var indent = getIndent(opts, depth);
            if (typeof seen === 'undefined') {
                seen = [];
            } else if (indexOf(seen, obj) >= 0) {
                return '[Circular]';
            }
            function inspect(value, from, noIndent) {
                if (from) {
                    seen = $arrSlice.call(seen);
                    seen.push(from);
                }
                if (noIndent) {
                    var newOpts = {
                        depth: opts.depth
                    };
                    if (has(opts, 'quoteStyle')) {
                        newOpts.quoteStyle = opts.quoteStyle;
                    }
                    return inspect_(value, newOpts, depth + 1, seen);
                }
                return inspect_(value, opts, depth + 1, seen);
            }
            if (typeof obj === 'function' && !isRegExp(obj)) {
                var name = nameOf(obj);
                var keys = arrObjKeys(obj, inspect);
                return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
            }
            if (isSymbol(obj)) {
                var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
                return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
            }
            if (isElement(obj)) {
                var s = '<' + $toLowerCase.call(String(obj.nodeName));
                var attrs = obj.attributes || [];
                for(var i = 0; i < attrs.length; i++){
                    s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
                }
                s += '>';
                if (obj.childNodes && obj.childNodes.length) {
                    s += '...';
                }
                s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
                return s;
            }
            if (isArray(obj)) {
                if (obj.length === 0) {
                    return '[]';
                }
                var xs = arrObjKeys(obj, inspect);
                if (indent && !singleLineValues(xs)) {
                    return '[' + indentedJoin(xs, indent) + ']';
                }
                return '[ ' + $join.call(xs, ', ') + ' ]';
            }
            if (isError(obj)) {
                var parts = arrObjKeys(obj, inspect);
                if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
                    return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
                }
                if (parts.length === 0) {
                    return '[' + String(obj) + ']';
                }
                return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
            }
            if (typeof obj === 'object' && customInspect) {
                if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
                    return utilInspect(obj, {
                        depth: maxDepth - depth
                    });
                } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
                    return obj.inspect();
                }
            }
            if (isMap(obj)) {
                var mapParts = [];
                if (mapForEach) {
                    mapForEach.call(obj, function(value, key) {
                        mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
                    });
                }
                return collectionOf('Map', mapSize.call(obj), mapParts, indent);
            }
            if (isSet(obj)) {
                var setParts = [];
                if (setForEach) {
                    setForEach.call(obj, function(value) {
                        setParts.push(inspect(value, obj));
                    });
                }
                return collectionOf('Set', setSize.call(obj), setParts, indent);
            }
            if (isWeakMap(obj)) {
                return weakCollectionOf('WeakMap');
            }
            if (isWeakSet(obj)) {
                return weakCollectionOf('WeakSet');
            }
            if (isWeakRef(obj)) {
                return weakCollectionOf('WeakRef');
            }
            if (isNumber(obj)) {
                return markBoxed(inspect(Number(obj)));
            }
            if (isBigInt(obj)) {
                return markBoxed(inspect(bigIntValueOf.call(obj)));
            }
            if (isBoolean(obj)) {
                return markBoxed(booleanValueOf.call(obj));
            }
            if (isString(obj)) {
                return markBoxed(inspect(String(obj)));
            }
            if (typeof window !== 'undefined' && obj === window) {
                return '{ [object Window] }';
            }
            if ((typeof globalThis !== 'undefined' && obj === globalThis) || (typeof commonjsGlobal !== 'undefined' && obj === commonjsGlobal)) {
                return '{ [object globalThis] }';
            }
            if (!isDate(obj) && !isRegExp(obj)) {
                var ys = arrObjKeys(obj, inspect);
                var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
                var protoTag = obj instanceof Object ? '' : 'null prototype';
                var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
                var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
                var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
                if (ys.length === 0) {
                    return tag + '{}';
                }
                if (indent) {
                    return tag + '{' + indentedJoin(ys, indent) + '}';
                }
                return tag + '{ ' + $join.call(ys, ', ') + ' }';
            }
            return String(obj);
        };
        function wrapQuotes(s, defaultStyle, opts) {
            var style = opts.quoteStyle || defaultStyle;
            var quoteChar = quotes[style];
            return quoteChar + s + quoteChar;
        }
        function quote(s) {
            return $replace.call(String(s), /"/g, '&quot;');
        }
        function canTrustToString(obj) {
            return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
        }
        function isArray(obj) {
            return toStr(obj) === '[object Array]' && canTrustToString(obj);
        }
        function isDate(obj) {
            return toStr(obj) === '[object Date]' && canTrustToString(obj);
        }
        function isRegExp(obj) {
            return toStr(obj) === '[object RegExp]' && canTrustToString(obj);
        }
        function isError(obj) {
            return toStr(obj) === '[object Error]' && canTrustToString(obj);
        }
        function isString(obj) {
            return toStr(obj) === '[object String]' && canTrustToString(obj);
        }
        function isNumber(obj) {
            return toStr(obj) === '[object Number]' && canTrustToString(obj);
        }
        function isBoolean(obj) {
            return toStr(obj) === '[object Boolean]' && canTrustToString(obj);
        }
        function isSymbol(obj) {
            if (hasShammedSymbols) {
                return obj && typeof obj === 'object' && obj instanceof Symbol;
            }
            if (typeof obj === 'symbol') {
                return true;
            }
            if (!obj || typeof obj !== 'object' || !symToString) {
                return false;
            }
            try {
                symToString.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        function isBigInt(obj) {
            if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
                return false;
            }
            try {
                bigIntValueOf.call(obj);
                return true;
            } catch (e) {}
            return false;
        }
        var hasOwn = Object.prototype.hasOwnProperty || function(key) {
            return key in this;
        };
        function has(obj, key) {
            return hasOwn.call(obj, key);
        }
        function toStr(obj) {
            return objectToString.call(obj);
        }
        function nameOf(f) {
            if (f.name) {
                return f.name;
            }
            var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
            if (m) {
                return m[1];
            }
            return null;
        }
        function indexOf(xs, x) {
            if (xs.indexOf) {
                return xs.indexOf(x);
            }
            for(var i = 0, l = xs.length; i < l; i++){
                if (xs[i] === x) {
                    return i;
                }
            }
            return -1;
        }
        function isMap(x) {
            if (!mapSize || !x || typeof x !== 'object') {
                return false;
            }
            try {
                mapSize.call(x);
                try {
                    setSize.call(x);
                } catch (s) {
                    return true;
                }
                return x instanceof Map;
            } catch (e) {}
            return false;
        }
        function isWeakMap(x) {
            if (!weakMapHas || !x || typeof x !== 'object') {
                return false;
            }
            try {
                weakMapHas.call(x, weakMapHas);
                try {
                    weakSetHas.call(x, weakSetHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakMap;
            } catch (e) {}
            return false;
        }
        function isWeakRef(x) {
            if (!weakRefDeref || !x || typeof x !== 'object') {
                return false;
            }
            try {
                weakRefDeref.call(x);
                return true;
            } catch (e) {}
            return false;
        }
        function isSet(x) {
            if (!setSize || !x || typeof x !== 'object') {
                return false;
            }
            try {
                setSize.call(x);
                try {
                    mapSize.call(x);
                } catch (m) {
                    return true;
                }
                return x instanceof Set;
            } catch (e) {}
            return false;
        }
        function isWeakSet(x) {
            if (!weakSetHas || !x || typeof x !== 'object') {
                return false;
            }
            try {
                weakSetHas.call(x, weakSetHas);
                try {
                    weakMapHas.call(x, weakMapHas);
                } catch (s) {
                    return true;
                }
                return x instanceof WeakSet;
            } catch (e) {}
            return false;
        }
        function isElement(x) {
            if (!x || typeof x !== 'object') {
                return false;
            }
            if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
                return true;
            }
            return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
        }
        function inspectString(str, opts) {
            if (str.length > opts.maxStringLength) {
                var remaining = str.length - opts.maxStringLength;
                var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
                return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
            }
            var quoteRE = quoteREs[opts.quoteStyle || 'single'];
            quoteRE.lastIndex = 0;
            var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
            return wrapQuotes(s, 'single', opts);
        }
        function lowbyte(c) {
            var n = c.charCodeAt(0);
            var x = {
                8: 'b',
                9: 't',
                10: 'n',
                12: 'f',
                13: 'r'
            }[n];
            if (x) {
                return '\\' + x;
            }
            return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
        }
        function markBoxed(str) {
            return 'Object(' + str + ')';
        }
        function weakCollectionOf(type) {
            return type + ' { ? }';
        }
        function collectionOf(type, size, entries, indent) {
            var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
            return type + ' (' + size + ') {' + joinedEntries + '}';
        }
        function singleLineValues(xs) {
            for(var i = 0; i < xs.length; i++){
                if (indexOf(xs[i], '\n') >= 0) {
                    return false;
                }
            }
            return true;
        }
        function getIndent(opts, depth) {
            var baseIndent;
            if (opts.indent === '\t') {
                baseIndent = '\t';
            } else if (typeof opts.indent === 'number' && opts.indent > 0) {
                baseIndent = $join.call(Array(opts.indent + 1), ' ');
            } else {
                return null;
            }
            return {
                base: baseIndent,
                prev: $join.call(Array(depth + 1), baseIndent)
            };
        }
        function indentedJoin(xs, indent) {
            if (xs.length === 0) {
                return '';
            }
            var lineJoiner = '\n' + indent.prev + indent.base;
            return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
        }
        function arrObjKeys(obj, inspect) {
            var isArr = isArray(obj);
            var xs = [];
            if (isArr) {
                xs.length = obj.length;
                for(var i = 0; i < obj.length; i++){
                    xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
                }
            }
            var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
            var symMap;
            if (hasShammedSymbols) {
                symMap = {};
                for(var k = 0; k < syms.length; k++){
                    symMap['$' + syms[k]] = syms[k];
                }
            }
            for(var key in obj){
                if (!has(obj, key)) {
                    continue;
                }
                if (isArr && String(Number(key)) === key && key < obj.length) {
                    continue;
                }
                if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
                    continue;
                } else if ($test.call(/[^\w$]/, key)) {
                    xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
                } else {
                    xs.push(key + ': ' + inspect(obj[key], obj));
                }
            }
            if (typeof gOPS === 'function') {
                for(var j = 0; j < syms.length; j++){
                    if (isEnumerable.call(obj, syms[j])) {
                        xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
                    }
                }
            }
            return xs;
        }
        return objectInspect;
    }
    const require$$1$2 = getAugmentedNamespace(midnight_onchain_runtime_wasm);
    var version$2 = {};
    var hasRequiredVersion;
    function requireVersion() {
        if (hasRequiredVersion) return version$2;
        hasRequiredVersion = 1;
        Object.defineProperty(version$2, "__esModule", {
            value: true
        });
        version$2.versionString = void 0;
        version$2.versionString = "0.8.1";
        return version$2;
    }
    var contractDependencies = {};
    var utils$1 = {};
    var hasRequiredUtils;
    function requireUtils() {
        if (hasRequiredUtils) return utils$1;
        hasRequiredUtils = 1;
        (function(exports) {
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CONTRACT_ADDRESS_BYTE_LENGTH = exports.HEX_REGEX_NO_PREFIX = void 0;
            exports.isContractAddress = isContractAddress;
            exports.HEX_REGEX_NO_PREFIX = /^([0-9A-Fa-f]{2})*$/;
            exports.CONTRACT_ADDRESS_BYTE_LENGTH = 35;
            function isContractAddress(x) {
                return typeof x === 'string' && x.length === exports.CONTRACT_ADDRESS_BYTE_LENGTH * 2 && exports.HEX_REGEX_NO_PREFIX.test(x);
            }
        }(utils$1));
        return utils$1;
    }
    var hasRequiredContractDependencies;
    function requireContractDependencies() {
        if (hasRequiredContractDependencies) return contractDependencies;
        hasRequiredContractDependencies = 1;
        Object.defineProperty(contractDependencies, "__esModule", {
            value: true
        });
        contractDependencies.contractDependencies = void 0;
        const runtime_1 = requireRuntime();
        const utils_1 = requireUtils();
        function isCompactVector(x) {
            return Array.isArray(x) && x.every((element)=>isCompactValue(element));
        }
        function isCompactStruct(x) {
            return (typeof x === 'object' && x !== null && x !== undefined && Object.entries(x).every(([key, value])=>typeof key === 'string' && isCompactValue(value)));
        }
        function isCompactValue(x) {
            return (0, utils_1.isContractAddress)(x) || isCompactVector(x) || isCompactStruct(x);
        }
        const expectedValueError = (expected, actual)=>{
            throw new runtime_1.CompactError(`Expected ${expected} but received ${JSON.stringify(actual)}`);
        };
        function assertIsContractAddress(value) {
            if (!(0, utils_1.isContractAddress)(value)) {
                expectedValueError('contract address', value);
            }
        }
        function assertIsCompactVector(value) {
            if (!isCompactVector(value)) {
                expectedValueError('vector', value);
            }
        }
        function assertIsCompactStruct(value) {
            if (!isCompactStruct(value)) {
                expectedValueError('struct', value);
            }
        }
        function assertIsCompactValue(x) {
            if (!isCompactValue(x)) {
                expectedValueError('Compact value', x);
            }
        }
        function toCompactValue(x) {
            assertIsCompactValue(x);
            return x;
        }
        const compactValueDependencies = (sparseCompactType, compactValue, dependencies)=>{
            if (sparseCompactType.tag == 'contractAddress') {
                assertIsContractAddress(compactValue);
                dependencies.add(compactValue);
            } else if (sparseCompactType.tag == 'struct') {
                assertIsCompactStruct(compactValue);
                Object.keys(compactValue).forEach((structElementId)=>compactValueDependencies(sparseCompactType.elements[structElementId], compactValue[structElementId], dependencies));
            } else {
                assertIsCompactVector(compactValue);
                compactValue.forEach((vectorElement)=>compactValueDependencies(sparseCompactType.sparseType, vectorElement, dependencies));
            }
        };
        const alignedValueToCompactValue = (descriptor, { value })=>toCompactValue(descriptor.fromValue(value));
        const stateValueToCompactValue = (descriptor, stateValue)=>alignedValueToCompactValue(descriptor, stateValue.asCell());
        const compactCellDependencies = (sparseCompactCellADT, state, dependencies)=>{
            const { sparseType, descriptor } = sparseCompactCellADT.valueType;
            compactValueDependencies(sparseType, stateValueToCompactValue(descriptor, state), dependencies);
        };
        const compactArrayLikeADTDependencies = (sparseCompactArrayLikeADT, states, dependencies)=>{
            const { sparseType, descriptor } = sparseCompactArrayLikeADT.valueType;
            states.forEach((state)=>compactValueDependencies(sparseType, stateValueToCompactValue(descriptor, state), dependencies));
        };
        const compactMapADTDependencies = (sparseCompactMapADT, stateMap, dependencies)=>{
            const { keyType, valueType } = sparseCompactMapADT;
            stateMap.keys().forEach((key)=>{
                if (keyType) {
                    compactValueDependencies(keyType.sparseType, alignedValueToCompactValue(keyType.descriptor, key), dependencies);
                }
                if (valueType) {
                    const value = stateMap.get(key);
                    if (!value) {
                        throw new runtime_1.CompactError(`State map ${stateMap.toString(false)} contains key without corresponding value`);
                    }
                    if (valueType.tag == 'compactValue') {
                        compactValueDependencies(valueType.sparseType, stateValueToCompactValue(valueType.descriptor, value), dependencies);
                    } else {
                        compactADTDependencies(valueType, value, dependencies);
                    }
                }
            });
        };
        function assertCastSucceeded(s, stateValue, expectedCastOutput) {
            if (!s) {
                throw new runtime_1.CompactError(`State ${stateValue.toString(false)} cannot be cast to a ${expectedCastOutput}`);
            }
        }
        const compactADTDependencies = (sparseCompactADT, stateValue, dependencies)=>{
            if (sparseCompactADT.tag == 'cell') {
                compactCellDependencies(sparseCompactADT, stateValue, dependencies);
            } else if (sparseCompactADT.tag == 'map') {
                const stateMap = stateValue.asMap();
                assertCastSucceeded(stateMap, stateValue, 'map');
                compactMapADTDependencies(sparseCompactADT, stateMap, dependencies);
            } else if (sparseCompactADT.tag == 'list' || sparseCompactADT.tag == 'set') {
                const states = stateValue.asArray();
                assertCastSucceeded(states, stateValue, 'array');
                compactArrayLikeADTDependencies(sparseCompactADT, states, dependencies);
            }
        };
        const castToStateArray = (state)=>{
            const ledgerState = state.asArray();
            assertCastSucceeded(ledgerState, state, 'array');
            return ledgerState;
        };
        const publicLedgerSegmentsDependencies = (publicLedgerSegments, state, dependencies)=>{
            const ledgerState = castToStateArray(state);
            Object.keys(publicLedgerSegments).map(parseInt).forEach((idx)=>{
                const referenceLocations = publicLedgerSegments.indices[idx];
                if ('tag' in referenceLocations && referenceLocations['tag'] === 'publicLedgerArray') {
                    publicLedgerSegmentsDependencies(referenceLocations, ledgerState[idx], dependencies);
                } else {
                    compactADTDependencies(referenceLocations, ledgerState[idx], dependencies);
                }
            });
        };
        const contractDependencies$1 = (contractReferenceLocations, state)=>{
            const dependencies = new Set();
            if (contractReferenceLocations.indices) {
                publicLedgerSegmentsDependencies(contractReferenceLocations, state, dependencies);
            }
            return [
                ...dependencies
            ];
        };
        contractDependencies.contractDependencies = contractDependencies$1;
        return contractDependencies;
    }
    var hasRequiredRuntime;
    function requireRuntime() {
        if (hasRequiredRuntime) return runtime;
        hasRequiredRuntime = 1;
        (function(exports) {
            var __createBinding = (runtime && runtime.__createBinding) || (Object.create ? (function(o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                    desc = {
                        enumerable: true,
                        get: function() {
                            return m[k];
                        }
                    };
                }
                Object.defineProperty(o, k2, desc);
            }) : (function(o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));
            var __exportStar = (runtime && runtime.__exportStar) || function(m, exports) {
                for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
            };
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CompactTypeField = exports.CompactTypeMerkleTreePath = exports.CompactTypeMerkleTreePathEntry = exports.CompactTypeMerkleTreeDigest = exports.CompactTypeCurvePoint = exports.constructorContext = exports.decodeZswapLocalState = exports.decodeRecipient = exports.encodeZswapLocalState = exports.encodeRecipient = exports.emptyZswapLocalState = exports.DUMMY_ADDRESS = exports.MAX_FIELD = exports.contractDependencies = exports.tokenType = exports.dummyContractAddress = exports.decodeQualifiedCoinInfo = exports.decodeCoinInfo = exports.encodeQualifiedCoinInfo = exports.encodeCoinInfo = exports.decodeCoinPublicKey = exports.encodeCoinPublicKey = exports.decodeContractAddress = exports.encodeContractAddress = exports.decodeTokenType = exports.encodeTokenType = exports.verifySignature = exports.signatureVerifyingKey = exports.signData = exports.sampleSigningKey = exports.sampleTokenType = exports.sampleContractAddress = exports.NetworkId = exports.leafHash = exports.coinCommitment = exports.maxAlignedSize = exports.bigIntToValue = exports.valueToBigInt = exports.VmStack = exports.VmResults = exports.StateValue = exports.StateMap = exports.StateBoundedMerkleTree = exports.QueryResults = exports.QueryContext = exports.ContractMaintenanceAuthority = exports.ContractState = exports.ContractOperation = exports.runProgram = exports.CostModel = void 0;
            exports.CompactError = exports.CompactTypeOpaqueString = exports.CompactTypeOpaqueUint8Array = exports.CompactTypeBytes = exports.CompactTypeBoolean = exports.CompactTypeVector = exports.CompactTypeUnsignedInteger = exports.CompactTypeEnum = void 0;
            exports.alignedConcat = alignedConcat;
            exports.transientHash = transientHash;
            exports.transientCommit = transientCommit;
            exports.persistentHash = persistentHash;
            exports.persistentCommit = persistentCommit;
            exports.degradeToTransient = degradeToTransient;
            exports.upgradeFromTransient = upgradeFromTransient;
            exports.hashToCurve = hashToCurve;
            exports.ecAdd = ecAdd;
            exports.ecMul = ecMul;
            exports.ecMulGenerator = ecMulGenerator;
            exports.createZswapInput = createZswapInput;
            exports.createZswapOutput = createZswapOutput;
            exports.ownPublicKey = ownPublicKey;
            exports.witnessContext = witnessContext;
            exports.checkProofData = checkProofData;
            exports.assert = assert;
            exports.type_error = type_error;
            exports.convert_bigint_to_Uint8Array = convert_bigint_to_Uint8Array;
            exports.convert_Uint8Array_to_bigint = convert_Uint8Array_to_bigint;
            exports.addField = addField;
            exports.subField = subField;
            exports.mulField = mulField;
            const inspect = requireObjectInspect();
            const ocrt = require$$1$2;
            __exportStar(requireVersion(), exports);
            var onchain_runtime_1 = require$$1$2;
            Object.defineProperty(exports, "CostModel", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.CostModel;
                }
            });
            Object.defineProperty(exports, "runProgram", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.runProgram;
                }
            });
            Object.defineProperty(exports, "ContractOperation", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.ContractOperation;
                }
            });
            Object.defineProperty(exports, "ContractState", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.ContractState;
                }
            });
            Object.defineProperty(exports, "ContractMaintenanceAuthority", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.ContractMaintenanceAuthority;
                }
            });
            Object.defineProperty(exports, "QueryContext", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.QueryContext;
                }
            });
            Object.defineProperty(exports, "QueryResults", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.QueryResults;
                }
            });
            Object.defineProperty(exports, "StateBoundedMerkleTree", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.StateBoundedMerkleTree;
                }
            });
            Object.defineProperty(exports, "StateMap", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.StateMap;
                }
            });
            Object.defineProperty(exports, "StateValue", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.StateValue;
                }
            });
            Object.defineProperty(exports, "VmResults", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.VmResults;
                }
            });
            Object.defineProperty(exports, "VmStack", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.VmStack;
                }
            });
            Object.defineProperty(exports, "valueToBigInt", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.valueToBigInt;
                }
            });
            Object.defineProperty(exports, "bigIntToValue", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.bigIntToValue;
                }
            });
            Object.defineProperty(exports, "maxAlignedSize", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.maxAlignedSize;
                }
            });
            Object.defineProperty(exports, "coinCommitment", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.coinCommitment;
                }
            });
            Object.defineProperty(exports, "leafHash", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.leafHash;
                }
            });
            Object.defineProperty(exports, "NetworkId", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.NetworkId;
                }
            });
            Object.defineProperty(exports, "sampleContractAddress", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.sampleContractAddress;
                }
            });
            Object.defineProperty(exports, "sampleTokenType", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.sampleTokenType;
                }
            });
            Object.defineProperty(exports, "sampleSigningKey", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.sampleSigningKey;
                }
            });
            Object.defineProperty(exports, "signData", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.signData;
                }
            });
            Object.defineProperty(exports, "signatureVerifyingKey", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.signatureVerifyingKey;
                }
            });
            Object.defineProperty(exports, "verifySignature", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.verifySignature;
                }
            });
            Object.defineProperty(exports, "encodeTokenType", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.encodeTokenType;
                }
            });
            Object.defineProperty(exports, "decodeTokenType", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.decodeTokenType;
                }
            });
            Object.defineProperty(exports, "encodeContractAddress", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.encodeContractAddress;
                }
            });
            Object.defineProperty(exports, "decodeContractAddress", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.decodeContractAddress;
                }
            });
            Object.defineProperty(exports, "encodeCoinPublicKey", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.encodeCoinPublicKey;
                }
            });
            Object.defineProperty(exports, "decodeCoinPublicKey", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.decodeCoinPublicKey;
                }
            });
            Object.defineProperty(exports, "encodeCoinInfo", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.encodeCoinInfo;
                }
            });
            Object.defineProperty(exports, "encodeQualifiedCoinInfo", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.encodeQualifiedCoinInfo;
                }
            });
            Object.defineProperty(exports, "decodeCoinInfo", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.decodeCoinInfo;
                }
            });
            Object.defineProperty(exports, "decodeQualifiedCoinInfo", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.decodeQualifiedCoinInfo;
                }
            });
            Object.defineProperty(exports, "dummyContractAddress", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.dummyContractAddress;
                }
            });
            Object.defineProperty(exports, "tokenType", {
                enumerable: true,
                get: function() {
                    return onchain_runtime_1.tokenType;
                }
            });
            var contract_dependencies_1 = requireContractDependencies();
            Object.defineProperty(exports, "contractDependencies", {
                enumerable: true,
                get: function() {
                    return contract_dependencies_1.contractDependencies;
                }
            });
            exports.MAX_FIELD = ocrt.maxField();
            const FIELD_MODULUS = exports.MAX_FIELD + 1n;
            exports.DUMMY_ADDRESS = ocrt.dummyContractAddress();
            function alignedConcat(...values) {
                const res = {
                    value: [],
                    alignment: []
                };
                for (const value of values){
                    res.value = res.value.concat(value.value);
                    res.alignment = res.alignment.concat(value.alignment);
                }
                return res;
            }
            function transientHash(rt_type, value) {
                return ocrt.valueToBigInt(ocrt.transientHash(rt_type.alignment(), rt_type.toValue(value)));
            }
            function transientCommit(rt_type, value, opening) {
                return ocrt.valueToBigInt(ocrt.transientCommit(rt_type.alignment(), rt_type.toValue(value), ocrt.bigIntToValue(opening)));
            }
            function persistentHash(rt_type, value) {
                const wrapped = ocrt.persistentHash(rt_type.alignment(), rt_type.toValue(value))[0];
                const res = new Uint8Array(32);
                res.set(wrapped, 0);
                return res;
            }
            function persistentCommit(rt_type, value, opening) {
                if (opening.length != 32) {
                    throw new CompactError('Expected 32-byte string');
                }
                const wrapped = ocrt.persistentCommit(rt_type.alignment(), rt_type.toValue(value), [
                    opening
                ])[0];
                const res = new Uint8Array(32);
                res.set(wrapped, 0);
                return res;
            }
            function degradeToTransient(x) {
                if (x.length != 32) {
                    throw new CompactError('Expected 32-byte string');
                }
                return ocrt.valueToBigInt(ocrt.degradeToTransient([
                    x
                ]));
            }
            function upgradeFromTransient(x) {
                const wrapped = ocrt.upgradeFromTransient(ocrt.bigIntToValue(x))[0];
                const res = new Uint8Array(32);
                res.set(wrapped, 0);
                return res;
            }
            function hashToCurve(rt_type, x) {
                return new CompactTypeCurvePoint().fromValue(ocrt.hashToCurve(rt_type.alignment(), rt_type.toValue(x)));
            }
            function ecAdd(a, b) {
                const rt_type = new CompactTypeCurvePoint();
                return rt_type.fromValue(ocrt.ecAdd(rt_type.toValue(a), rt_type.toValue(b)));
            }
            function ecMul(a, b) {
                const rt_type = new CompactTypeCurvePoint();
                return rt_type.fromValue(ocrt.ecMul(rt_type.toValue(a), ocrt.bigIntToValue(b)));
            }
            function ecMulGenerator(b) {
                return new CompactTypeCurvePoint().fromValue(ocrt.ecMulGenerator(ocrt.bigIntToValue(b)));
            }
            const emptyZswapLocalState = (coinPublicKey)=>({
                    coinPublicKey: {
                        bytes: ocrt.encodeCoinPublicKey(coinPublicKey)
                    },
                    currentIndex: 0n,
                    inputs: [],
                    outputs: []
                });
            exports.emptyZswapLocalState = emptyZswapLocalState;
            const encodeRecipient = ({ is_left, left, right })=>({
                    is_left,
                    left: {
                        bytes: ocrt.encodeCoinPublicKey(left)
                    },
                    right: {
                        bytes: ocrt.encodeContractAddress(right)
                    }
                });
            exports.encodeRecipient = encodeRecipient;
            const encodeZswapLocalState = (state)=>({
                    coinPublicKey: {
                        bytes: ocrt.encodeCoinPublicKey(state.coinPublicKey)
                    },
                    currentIndex: state.currentIndex,
                    inputs: state.inputs.map(ocrt.encodeQualifiedCoinInfo),
                    outputs: state.outputs.map(({ coinInfo, recipient })=>({
                            coinInfo: ocrt.encodeCoinInfo(coinInfo),
                            recipient: (0, exports.encodeRecipient)(recipient)
                        }))
                });
            exports.encodeZswapLocalState = encodeZswapLocalState;
            const decodeRecipient = ({ is_left, left, right })=>({
                    is_left,
                    left: ocrt.decodeCoinPublicKey(left.bytes),
                    right: ocrt.decodeContractAddress(right.bytes)
                });
            exports.decodeRecipient = decodeRecipient;
            const decodeZswapLocalState = (state)=>({
                    coinPublicKey: ocrt.decodeCoinPublicKey(state.coinPublicKey.bytes),
                    currentIndex: state.currentIndex,
                    inputs: state.inputs.map(ocrt.decodeQualifiedCoinInfo),
                    outputs: state.outputs.map(({ coinInfo, recipient })=>({
                            coinInfo: ocrt.decodeCoinInfo(coinInfo),
                            recipient: (0, exports.decodeRecipient)(recipient)
                        }))
                });
            exports.decodeZswapLocalState = decodeZswapLocalState;
            function createZswapInput(circuitContext, qualifiedCoinInfo) {
                circuitContext.currentZswapLocalState = {
                    ...circuitContext.currentZswapLocalState,
                    inputs: circuitContext.currentZswapLocalState.inputs.concat(qualifiedCoinInfo)
                };
            }
            function createCoinCommitment(coinInfo, recipient) {
                return ocrt.coinCommitment({
                    value: coinInfoDescriptor.toValue(coinInfo),
                    alignment: coinInfoDescriptor.alignment()
                }, {
                    value: eitherDescriptor.toValue(recipient),
                    alignment: eitherDescriptor.alignment()
                });
            }
            function createZswapOutput(circuitContext, coinInfo, recipient) {
                circuitContext.transactionContext = circuitContext.transactionContext.insertCommitment(Buffer.from(bytesDescriptor.fromValue(createCoinCommitment(coinInfo, recipient).value)).toString('hex'), circuitContext.currentZswapLocalState.currentIndex);
                circuitContext.currentZswapLocalState = {
                    ...circuitContext.currentZswapLocalState,
                    currentIndex: circuitContext.currentZswapLocalState.currentIndex + 1n,
                    outputs: circuitContext.currentZswapLocalState.outputs.concat({
                        coinInfo,
                        recipient
                    })
                };
            }
            function ownPublicKey(circuitContext) {
                return circuitContext.currentZswapLocalState.coinPublicKey;
            }
            function witnessContext(ledger, privateState, contractAddress) {
                return {
                    ledger,
                    privateState,
                    contractAddress
                };
            }
            function checkProofData(zkir, proofData) {
                return ocrt.checkProofData(zkir, proofData.input, proofData.output, proofData.publicTranscript, proofData.privateTranscriptOutputs);
            }
            const constructorContext = (initialPrivateState, coinPublicKey)=>({
                    initialPrivateState,
                    initialZswapLocalState: (0, exports.emptyZswapLocalState)(coinPublicKey)
                });
            exports.constructorContext = constructorContext;
            class CompactTypeCurvePoint {
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'field'
                            }
                        },
                        {
                            tag: 'atom',
                            value: {
                                tag: 'field'
                            }
                        }
                    ];
                }
                fromValue(value) {
                    const x = value.shift();
                    const y = value.shift();
                    if (x == undefined || y == undefined) {
                        throw new CompactError('expected CurvePoint');
                    } else {
                        return {
                            x: ocrt.valueToBigInt([
                                x
                            ]),
                            y: ocrt.valueToBigInt([
                                y
                            ])
                        };
                    }
                }
                toValue(value) {
                    return ocrt.bigIntToValue(value.x).concat(ocrt.bigIntToValue(value.y));
                }
            }
            exports.CompactTypeCurvePoint = CompactTypeCurvePoint;
            class CompactTypeMerkleTreeDigest {
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'field'
                            }
                        }
                    ];
                }
                fromValue(value) {
                    const val = value.shift();
                    if (val == undefined) {
                        throw new CompactError('expected MerkleTreeDigest');
                    } else {
                        return {
                            field: ocrt.valueToBigInt([
                                val
                            ])
                        };
                    }
                }
                toValue(value) {
                    return ocrt.bigIntToValue(value.field);
                }
            }
            exports.CompactTypeMerkleTreeDigest = CompactTypeMerkleTreeDigest;
            class CompactTypeMerkleTreePathEntry {
                constructor(){
                    this.digest = new CompactTypeMerkleTreeDigest();
                    this.bool = new CompactTypeBoolean();
                }
                alignment() {
                    return this.digest.alignment().concat(this.bool.alignment());
                }
                fromValue(value) {
                    const sibling = this.digest.fromValue(value);
                    const goes_left = this.bool.fromValue(value);
                    return {
                        sibling: sibling,
                        goes_left: goes_left
                    };
                }
                toValue(value) {
                    return this.digest.toValue(value.sibling).concat(this.bool.toValue(value.goes_left));
                }
            }
            exports.CompactTypeMerkleTreePathEntry = CompactTypeMerkleTreePathEntry;
            class CompactTypeMerkleTreePath {
                constructor(n, leaf){
                    this.leaf = leaf;
                    this.path = new CompactTypeVector(n, new CompactTypeMerkleTreePathEntry());
                }
                alignment() {
                    return this.leaf.alignment().concat(this.path.alignment());
                }
                fromValue(value) {
                    const leaf = this.leaf.fromValue(value);
                    const path = this.path.fromValue(value);
                    return {
                        leaf: leaf,
                        path: path
                    };
                }
                toValue(value) {
                    return this.leaf.toValue(value.leaf).concat(this.path.toValue(value.path));
                }
            }
            exports.CompactTypeMerkleTreePath = CompactTypeMerkleTreePath;
            class CompactTypeField {
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'field'
                            }
                        }
                    ];
                }
                fromValue(value) {
                    const val = value.shift();
                    if (val == undefined) {
                        throw new CompactError('expected Field');
                    } else {
                        return ocrt.valueToBigInt([
                            val
                        ]);
                    }
                }
                toValue(value) {
                    return ocrt.bigIntToValue(value);
                }
            }
            exports.CompactTypeField = CompactTypeField;
            class CompactTypeEnum {
                constructor(maxValue, length){
                    this.maxValue = maxValue;
                    this.length = length;
                }
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'bytes',
                                length: this.length
                            }
                        }
                    ];
                }
                fromValue(value) {
                    const val = value.shift();
                    if (val == undefined) {
                        throw new CompactError(`expected Enum[<=${this.maxValue}]`);
                    } else {
                        let res = 0;
                        for(let i = 0; i < val.length; i++){
                            res += (1 << (8 * i)) * val[i];
                        }
                        if (res > this.maxValue) {
                            throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
                        }
                        return res;
                    }
                }
                toValue(value) {
                    return new CompactTypeField().toValue(BigInt(value));
                }
            }
            exports.CompactTypeEnum = CompactTypeEnum;
            class CompactTypeUnsignedInteger {
                constructor(maxValue, length){
                    this.maxValue = maxValue;
                    this.length = length;
                }
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'bytes',
                                length: this.length
                            }
                        }
                    ];
                }
                fromValue(value) {
                    const val = value.shift();
                    if (val == undefined) {
                        throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
                    } else {
                        let res = 0n;
                        for(let i = 0; i < val.length; i++){
                            res += (1n << (8n * BigInt(i))) * BigInt(val[i]);
                        }
                        if (res > this.maxValue) {
                            throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
                        }
                        return res;
                    }
                }
                toValue(value) {
                    return new CompactTypeField().toValue(value);
                }
            }
            exports.CompactTypeUnsignedInteger = CompactTypeUnsignedInteger;
            class CompactTypeVector {
                constructor(length, type){
                    this.length = length;
                    this.type = type;
                }
                alignment() {
                    const inner = this.type.alignment();
                    let res = [];
                    for(let i = 0; i < this.length; i++){
                        res = res.concat(inner);
                    }
                    return res;
                }
                fromValue(value) {
                    const res = [];
                    for(let i = 0; i < this.length; i++){
                        res.push(this.type.fromValue(value));
                    }
                    return res;
                }
                toValue(value) {
                    if (value.length != this.length) {
                        throw new CompactError(`expected ${this.length}-element array`);
                    }
                    let res = [];
                    for(let i = 0; i < this.length; i++){
                        res = res.concat(this.type.toValue(value[i]));
                    }
                    return res;
                }
            }
            exports.CompactTypeVector = CompactTypeVector;
            class CompactTypeBoolean {
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'bytes',
                                length: 1
                            }
                        }
                    ];
                }
                fromValue(value) {
                    const val = value.shift();
                    if (val == undefined || val.length > 1 || (val.length == 1 && val[0] != 1)) {
                        throw new CompactError('expected Boolean');
                    }
                    return val.length == 1;
                }
                toValue(value) {
                    if (value) {
                        return [
                            new Uint8Array([
                                1
                            ])
                        ];
                    } else {
                        return [
                            new Uint8Array(0)
                        ];
                    }
                }
            }
            exports.CompactTypeBoolean = CompactTypeBoolean;
            class CompactTypeBytes {
                constructor(length){
                    this.length = length;
                }
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'bytes',
                                length: this.length
                            }
                        }
                    ];
                }
                fromValue(value) {
                    const val = value.shift();
                    if (val == undefined || val.length > this.length) {
                        throw new CompactError(`expected Bytes[${this.length}]`);
                    }
                    if (val.length == this.length) {
                        return val;
                    }
                    const res = new Uint8Array(this.length);
                    res.set(val, 0);
                    return res;
                }
                toValue(value) {
                    let end = value.length;
                    while(end > 0 && value[end - 1] == 0){
                        end -= 1;
                    }
                    return [
                        value.slice(0, end)
                    ];
                }
            }
            exports.CompactTypeBytes = CompactTypeBytes;
            class CompactTypeOpaqueUint8Array {
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'compress'
                            }
                        }
                    ];
                }
                fromValue(value) {
                    return value.shift();
                }
                toValue(value) {
                    return [
                        value
                    ];
                }
            }
            exports.CompactTypeOpaqueUint8Array = CompactTypeOpaqueUint8Array;
            class CompactTypeOpaqueString {
                alignment() {
                    return [
                        {
                            tag: 'atom',
                            value: {
                                tag: 'compress'
                            }
                        }
                    ];
                }
                fromValue(value) {
                    return new TextDecoder('utf-8').decode(value.shift());
                }
                toValue(value) {
                    return [
                        new TextEncoder().encode(value)
                    ];
                }
            }
            exports.CompactTypeOpaqueString = CompactTypeOpaqueString;
            class CompactError extends Error {
                constructor(msg){
                    super(msg);
                    this.name = 'CompactError';
                }
            }
            exports.CompactError = CompactError;
            function assert(b, s) {
                if (!b) {
                    const msg = `failed assert: ${s}`;
                    throw new CompactError(msg);
                }
            }
            function type_error(who, what, where, type, x) {
                const msg = `type error: ${who} ${what} at ${where}; expected value of type ${type} but received ${inspect(x)}`;
                throw new CompactError(msg);
            }
            function convert_bigint_to_Uint8Array(n, x) {
                const x_0 = x;
                const a = new Uint8Array(n);
                for(let i = 0; i < n; i++){
                    a[i] = Number(x & 0xffn);
                    x = x / 0x100n;
                    if (x == 0n) return a;
                }
                const msg = `range error: ${x_0} cannot be decomposed into ${n} bytes`;
                throw new CompactError(msg);
            }
            function convert_Uint8Array_to_bigint(n, a) {
                let x = 0n;
                for(let i = n - 1; i >= 0; i -= 1){
                    x = x * 0x100n + BigInt(a[i]);
                }
                if (x > exports.MAX_FIELD) {
                    const msg = `range error: ${x} is greater than maximum for the field ${exports.MAX_FIELD}`;
                    throw new CompactError(msg);
                }
                return x;
            }
            function addField(x, y) {
                const t = x + y;
                return t < FIELD_MODULUS ? t : t - FIELD_MODULUS;
            }
            function subField(x, y) {
                const t = x - y;
                return t >= 0 ? t : t + FIELD_MODULUS;
            }
            function mulField(x, y) {
                return (x * y) % FIELD_MODULUS;
            }
            const bytesDescriptor = new CompactTypeBytes(32);
            const uintDescriptor = new CompactTypeUnsignedInteger(18446744073709551615n, 8);
            class CoinInfoDescriptor {
                alignment() {
                    return bytesDescriptor.alignment().concat(bytesDescriptor.alignment().concat(uintDescriptor.alignment()));
                }
                fromValue(value) {
                    return {
                        nonce: bytesDescriptor.fromValue(value),
                        color: bytesDescriptor.fromValue(value),
                        value: uintDescriptor.fromValue(value)
                    };
                }
                toValue(value) {
                    return bytesDescriptor.toValue(value.nonce).concat(bytesDescriptor.toValue(value.color).concat(uintDescriptor.toValue(value.value)));
                }
            }
            const coinInfoDescriptor = new CoinInfoDescriptor();
            class ZswapCoinPublicKeyDescriptor {
                alignment() {
                    return bytesDescriptor.alignment();
                }
                fromValue(value) {
                    return {
                        bytes: bytesDescriptor.fromValue(value)
                    };
                }
                toValue(value) {
                    return bytesDescriptor.toValue(value.bytes);
                }
            }
            class ContractAddressDescriptor {
                alignment() {
                    return bytesDescriptor.alignment();
                }
                fromValue(value) {
                    return {
                        bytes: bytesDescriptor.fromValue(value)
                    };
                }
                toValue(value) {
                    return bytesDescriptor.toValue(value.bytes);
                }
            }
            const contractAddressDescriptor = new ContractAddressDescriptor();
            const zswapCoinPublicKeyDescriptor = new ZswapCoinPublicKeyDescriptor();
            const booleanDescriptor = new CompactTypeBoolean();
            class EitherDescriptor {
                alignment() {
                    return booleanDescriptor.alignment().concat(zswapCoinPublicKeyDescriptor.alignment().concat(contractAddressDescriptor.alignment()));
                }
                fromValue(value) {
                    return {
                        is_left: booleanDescriptor.fromValue(value),
                        left: zswapCoinPublicKeyDescriptor.fromValue(value),
                        right: contractAddressDescriptor.fromValue(value)
                    };
                }
                toValue(value) {
                    return booleanDescriptor.toValue(value.is_left).concat(zswapCoinPublicKeyDescriptor.toValue(value.left).concat(contractAddressDescriptor.toValue(value.right)));
                }
            }
            const eitherDescriptor = new EitherDescriptor();
        }(runtime));
        return runtime;
    }
    var runtimeExports = requireRuntime();
    const __vite__wasmUrl$1 = "/assets/midnight_zswap_wasm_bg-B513wwf3.wasm";
    let wasm$3;
    function __wbg_set_wasm$1(val) {
        wasm$3 = val;
    }
    let WASM_VECTOR_LEN$1 = 0;
    let cachedUint8ArrayMemory0$1 = null;
    function getUint8ArrayMemory0$1() {
        if (cachedUint8ArrayMemory0$1 === null || cachedUint8ArrayMemory0$1.byteLength === 0) {
            cachedUint8ArrayMemory0$1 = new Uint8Array(wasm$3.memory.buffer);
        }
        return cachedUint8ArrayMemory0$1;
    }
    const lTextEncoder$1 = typeof TextEncoder === 'undefined' ? (commonjsRequire)('util').TextEncoder : TextEncoder;
    let cachedTextEncoder$1 = new lTextEncoder$1('utf-8');
    const encodeString$1 = (typeof cachedTextEncoder$1.encodeInto === 'function' ? function(arg, view) {
        return cachedTextEncoder$1.encodeInto(arg, view);
    } : function(arg, view) {
        const buf = cachedTextEncoder$1.encode(arg);
        view.set(buf);
        return {
            read: arg.length,
            written: buf.length
        };
    });
    function passStringToWasm0$1(arg, malloc, realloc) {
        if (realloc === undefined) {
            const buf = cachedTextEncoder$1.encode(arg);
            const ptr = malloc(buf.length, 1) >>> 0;
            getUint8ArrayMemory0$1().subarray(ptr, ptr + buf.length).set(buf);
            WASM_VECTOR_LEN$1 = buf.length;
            return ptr;
        }
        let len = arg.length;
        let ptr = malloc(len, 1) >>> 0;
        const mem = getUint8ArrayMemory0$1();
        let offset = 0;
        for(; offset < len; offset++){
            const code = arg.charCodeAt(offset);
            if (code > 0x7F) break;
            mem[ptr + offset] = code;
        }
        if (offset !== len) {
            if (offset !== 0) {
                arg = arg.slice(offset);
            }
            ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
            const view = getUint8ArrayMemory0$1().subarray(ptr + offset, ptr + len);
            const ret = encodeString$1(arg, view);
            offset += ret.written;
            ptr = realloc(ptr, len, offset, 1) >>> 0;
        }
        WASM_VECTOR_LEN$1 = offset;
        return ptr;
    }
    let cachedDataViewMemory0$1 = null;
    function getDataViewMemory0$1() {
        if (cachedDataViewMemory0$1 === null || cachedDataViewMemory0$1.buffer.detached === true || (cachedDataViewMemory0$1.buffer.detached === undefined && cachedDataViewMemory0$1.buffer !== wasm$3.memory.buffer)) {
            cachedDataViewMemory0$1 = new DataView(wasm$3.memory.buffer);
        }
        return cachedDataViewMemory0$1;
    }
    function addToExternrefTable0$1(obj) {
        const idx = wasm$3.__externref_table_alloc();
        wasm$3.__wbindgen_export_4.set(idx, obj);
        return idx;
    }
    function handleError$2(f, args) {
        try {
            return f.apply(this, args);
        } catch (e) {
            const idx = addToExternrefTable0$1(e);
            wasm$3.__wbindgen_exn_store(idx);
        }
    }
    function isLikeNone$1(x) {
        return x === undefined || x === null;
    }
    const lTextDecoder$1 = typeof TextDecoder === 'undefined' ? (commonjsRequire)('util').TextDecoder : TextDecoder;
    let cachedTextDecoder$1 = new lTextDecoder$1('utf-8', {
        ignoreBOM: true,
        fatal: true
    });
    cachedTextDecoder$1.decode();
    function getStringFromWasm0$1(ptr, len) {
        ptr = ptr >>> 0;
        return cachedTextDecoder$1.decode(getUint8ArrayMemory0$1().subarray(ptr, ptr + len));
    }
    const CLOSURE_DTORS$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((state)=>{
        wasm$3.__wbindgen_export_5.get(state.dtor)(state.a, state.b);
    });
    function makeMutClosure$1(arg0, arg1, dtor, f) {
        const state = {
            a: arg0,
            b: arg1,
            cnt: 1,
            dtor
        };
        const real = (...args)=>{
            state.cnt++;
            const a = state.a;
            state.a = 0;
            try {
                return f(a, state.b, ...args);
            } finally{
                if (--state.cnt === 0) {
                    wasm$3.__wbindgen_export_5.get(state.dtor)(a, state.b);
                    CLOSURE_DTORS$1.unregister(state);
                } else {
                    state.a = a;
                }
            }
        };
        real.original = state;
        CLOSURE_DTORS$1.register(real, state, state);
        return real;
    }
    function debugString$1(val) {
        const type = typeof val;
        if (type == 'number' || type == 'boolean' || val == null) {
            return `${val}`;
        }
        if (type == 'string') {
            return `"${val}"`;
        }
        if (type == 'symbol') {
            const description = val.description;
            if (description == null) {
                return 'Symbol';
            } else {
                return `Symbol(${description})`;
            }
        }
        if (type == 'function') {
            const name = val.name;
            if (typeof name == 'string' && name.length > 0) {
                return `Function(${name})`;
            } else {
                return 'Function';
            }
        }
        if (Array.isArray(val)) {
            const length = val.length;
            let debug = '[';
            if (length > 0) {
                debug += debugString$1(val[0]);
            }
            for(let i = 1; i < length; i++){
                debug += ', ' + debugString$1(val[i]);
            }
            debug += ']';
            return debug;
        }
        const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
        let className;
        if (builtInMatches && builtInMatches.length > 1) {
            className = builtInMatches[1];
        } else {
            return toString.call(val);
        }
        if (className == 'Object') {
            try {
                return 'Object(' + JSON.stringify(val) + ')';
            } catch (_) {
                return 'Object';
            }
        }
        if (val instanceof Error) {
            return `${val.name}: ${val.message}\n${val.stack}`;
        }
        return className;
    }
    function takeFromExternrefTable0$1(idx) {
        const value = wasm$3.__wbindgen_export_4.get(idx);
        wasm$3.__externref_table_dealloc(idx);
        return value;
    }
    function _assertClass$1(instance, klass) {
        if (!(instance instanceof klass)) {
            throw new Error(`expected instance of ${klass.name}`);
        }
    }
    function getArrayU8FromWasm0$1(ptr, len) {
        ptr = ptr >>> 0;
        return getUint8ArrayMemory0$1().subarray(ptr / 1, ptr / 1 + len);
    }
    function passArray8ToWasm0$1(arg, malloc) {
        const ptr = malloc(arg.length * 1, 1) >>> 0;
        getUint8ArrayMemory0$1().set(arg, ptr / 1);
        WASM_VECTOR_LEN$1 = arg.length;
        return ptr;
    }
    function getArrayJsValueFromWasm0$1(ptr, len) {
        ptr = ptr >>> 0;
        const mem = getDataViewMemory0$1();
        const result = [];
        for(let i = ptr; i < ptr + 4 * len; i += 4){
            result.push(wasm$3.__wbindgen_export_4.get(mem.getUint32(i, true)));
        }
        wasm$3.__externref_drop_slice(ptr, len);
        return result;
    }
    function __wbg_adapter_56$1(arg0, arg1, arg2) {
        wasm$3.closure648_externref_shim(arg0, arg1, arg2);
    }
    function __wbg_adapter_389$1(arg0, arg1, arg2, arg3, arg4) {
        wasm$3.closure684_externref_shim(arg0, arg1, arg2, arg3, arg4);
    }
    function __wbg_adapter_394$1(arg0, arg1, arg2, arg3) {
        wasm$3.closure688_externref_shim(arg0, arg1, arg2, arg3);
    }
    const NetworkId$1 = Object.freeze({
        Undeployed: 0,
        "0": "Undeployed",
        DevNet: 1,
        "1": "DevNet",
        TestNet: 2,
        "2": "TestNet",
        MainNet: 3,
        "3": "MainNet"
    });
    const AuthorizedMintFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_authorizedmint_free(ptr >>> 0, 1));
    let AuthorizedMint$1 = class AuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(AuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            AuthorizedMintFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            AuthorizedMintFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_authorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.authorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            AuthorizedMintFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.authorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.authorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return AuthorizedMint.__wrap(ret[0]);
        }
        eraseProof() {
            const ret = wasm$3.authorizedmint_eraseProof(this.__wbg_ptr);
            return ProofErasedAuthorizedMint$1.__wrap(ret);
        }
        get coin() {
            const ret = wasm$3.authorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.authorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.authorizedmint_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const CoinSecretKeyFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_coinsecretkey_free(ptr >>> 0, 1));
    let CoinSecretKey$1 = class CoinSecretKey {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(CoinSecretKey.prototype);
            obj.__wbg_ptr = ptr;
            CoinSecretKeyFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            CoinSecretKeyFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_coinsecretkey_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.coinsecretkey_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            CoinSecretKeyFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        yesIKnowTheSecurityImplicationsOfThis_serialize(netid) {
            const ret = wasm$3.coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
    };
    const ContractAddressFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_contractaddress_free(ptr >>> 0, 1));
    let ContractAddress$1 = class ContractAddress {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractAddress.prototype);
            obj.__wbg_ptr = ptr;
            ContractAddressFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractAddressFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_contractaddress_free(ptr, 0);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$1(raw, wasm$3.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.contractaddress_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ContractAddress.__wrap(ret[0]);
        }
    };
    const EncryptionSecretKeyFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_encryptionsecretkey_free(ptr >>> 0, 1));
    let EncryptionSecretKey$1 = class EncryptionSecretKey {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(EncryptionSecretKey.prototype);
            obj.__wbg_ptr = ptr;
            EncryptionSecretKeyFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            EncryptionSecretKeyFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_encryptionsecretkey_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.encryptionsecretkey_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            EncryptionSecretKeyFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        test(offer) {
            _assertClass$1(offer, Offer$1);
            const ret = wasm$3.encryptionsecretkey_test(this.__wbg_ptr, offer.__wbg_ptr);
            return ret !== 0;
        }
        yesIKnowTheSecurityImplicationsOfThis_serialize(netid) {
            const ret = wasm$3.encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.encryptionsecretkey_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return EncryptionSecretKey.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$1(raw, wasm$3.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.encryptionsecretkey_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return EncryptionSecretKey.__wrap(ret[0]);
        }
    };
    const InputFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_input_free(ptr >>> 0, 1));
    let Input$1 = class Input {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Input.prototype);
            obj.__wbg_ptr = ptr;
            InputFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            InputFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_input_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.input_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            InputFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.input_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.input_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Input.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.input_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.input_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.input_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$3.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$3.__wbg_intounderlyingsink_free(ptr >>> 0, 1));
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$3.__wbg_intounderlyingsource_free(ptr >>> 0, 1));
    const LedgerParametersFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_ledgerparameters_free(ptr >>> 0, 1));
    let LedgerParameters$1 = class LedgerParameters {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(LedgerParameters.prototype);
            obj.__wbg_ptr = ptr;
            LedgerParametersFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            LedgerParametersFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_ledgerparameters_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.ledgerparameters_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            LedgerParametersFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static dummyParameters() {
            const ret = wasm$3.ledgerparameters_dummyParameters();
            return LedgerParameters.__wrap(ret);
        }
        get transactionCostModel() {
            const ret = wasm$3.ledgerparameters_transactionCostModel(this.__wbg_ptr);
            return TransactionCostModel$1.__wrap(ret);
        }
        serialize(netid) {
            const ret = wasm$3.ledgerparameters_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.ledgerparameters_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return LedgerParameters.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.ledgerparameters_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const LocalStateFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_localstate_free(ptr >>> 0, 1));
    let LocalState$1 = class LocalState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(LocalState.prototype);
            obj.__wbg_ptr = ptr;
            LocalStateFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            LocalStateFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_localstate_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.localstate_new();
            this.__wbg_ptr = ret >>> 0;
            LocalStateFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        authorizeMint(secret_keys, coin) {
            _assertClass$1(secret_keys, SecretKeys$1);
            const ret = wasm$3.localstate_authorizeMint(this.__wbg_ptr, secret_keys.__wbg_ptr, coin);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenAuthorizedMint$1.__wrap(ret[0]);
        }
        get firstFree() {
            const ret = wasm$3.localstate_firstFree(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        get coins() {
            const ret = wasm$3.localstate_coins(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        get pendingSpends() {
            const ret = wasm$3.localstate_pendingSpends(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        get pendingOutputs() {
            const ret = wasm$3.localstate_pendingOutputs(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        applyMint(secret_keys, mint) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(mint, AuthorizedMint$1);
            const ret = wasm$3.localstate_applyMint(this.__wbg_ptr, secret_keys.__wbg_ptr, mint.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyProofErasedMint(secret_keys, mint) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(mint, ProofErasedAuthorizedMint$1);
            const ret = wasm$3.localstate_applyProofErasedMint(this.__wbg_ptr, secret_keys.__wbg_ptr, mint.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyFailed(offer) {
            _assertClass$1(offer, Offer$1);
            const ret = wasm$3.localstate_applyFailed(this.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyFailedProofErased(offer) {
            _assertClass$1(offer, ProofErasedOffer$1);
            const ret = wasm$3.localstate_applyFailedProofErased(this.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        apply(secret_keys, offer) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(offer, Offer$1);
            const ret = wasm$3.localstate_apply(this.__wbg_ptr, secret_keys.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyProofErased(secret_keys, offer) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(offer, ProofErasedOffer$1);
            const ret = wasm$3.localstate_applyProofErased(this.__wbg_ptr, secret_keys.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyTx(secret_keys, tx, res) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(tx, Transaction$1);
            const ptr0 = passStringToWasm0$1(res, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.localstate_applyTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        applyProofErasedTx(secret_keys, tx, res) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(tx, ProofErasedTransaction$1);
            const ptr0 = passStringToWasm0$1(res, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.localstate_applyProofErasedTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        applySystemTx(secret_keys, tx) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(tx, SystemTransaction$1);
            const ret = wasm$3.localstate_applySystemTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyCollapsedUpdate(update) {
            _assertClass$1(update, MerkleTreeCollapsedUpdate$1);
            const ret = wasm$3.localstate_applyCollapsedUpdate(this.__wbg_ptr, update.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        spend(secret_keys, coin, segment) {
            _assertClass$1(secret_keys, SecretKeys$1);
            const ret = wasm$3.localstate_spend(this.__wbg_ptr, secret_keys.__wbg_ptr, coin, segment);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        spendFromOutput(secret_keys, coin, segment, output) {
            _assertClass$1(secret_keys, SecretKeys$1);
            _assertClass$1(output, UnprovenOutput$1);
            const ret = wasm$3.localstate_spendFromOutput(this.__wbg_ptr, secret_keys.__wbg_ptr, coin, segment, output.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        watchFor(coin_public_key, coin) {
            const ptr0 = passStringToWasm0$1(coin_public_key, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.localstate_watchFor(this.__wbg_ptr, ptr0, len0, coin);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.localstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.localstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.localstate_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const MerkleTreeCollapsedUpdateFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_merkletreecollapsedupdate_free(ptr >>> 0, 1));
    let MerkleTreeCollapsedUpdate$1 = class MerkleTreeCollapsedUpdate {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(MerkleTreeCollapsedUpdate.prototype);
            obj.__wbg_ptr = ptr;
            MerkleTreeCollapsedUpdateFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            MerkleTreeCollapsedUpdateFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_merkletreecollapsedupdate_free(ptr, 0);
        }
        constructor(state, start, end){
            _assertClass$1(state, ZswapChainState$1);
            const ret = wasm$3.merkletreecollapsedupdate_new(state.__wbg_ptr, start, end);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            MerkleTreeCollapsedUpdateFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static new_raw(state, start, end) {
            _assertClass$1(state, ZswapChainState$1);
            const ret = wasm$3.merkletreecollapsedupdate_new_raw(state.__wbg_ptr, start, end);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return MerkleTreeCollapsedUpdate.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.merkletreecollapsedupdate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        serialize_raw(netid) {
            const ret = wasm$3.merkletreecollapsedupdate_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.merkletreecollapsedupdate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return MerkleTreeCollapsedUpdate.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.merkletreecollapsedupdate_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const OfferFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_offer_free(ptr >>> 0, 1));
    let Offer$1 = class Offer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Offer.prototype);
            obj.__wbg_ptr = ptr;
            OfferFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            OfferFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_offer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.offer_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            OfferFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        merge(other) {
            _assertClass$1(other, Offer);
            const ret = wasm$3.offer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.offer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        serialize_raw(netid) {
            const ret = wasm$3.offer_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.offer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$1(raw, wasm$3.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.offer_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$3.offer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$3.offer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$3.offer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$3.offer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.offer_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const OutputFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_output_free(ptr >>> 0, 1));
    let Output$1 = class Output {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Output.prototype);
            obj.__wbg_ptr = ptr;
            OutputFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            OutputFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_output_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.output_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            OutputFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.output_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.output_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Output.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.output_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.output_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.output_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedAuthorizedMintFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_prooferasedauthorizedmint_free(ptr >>> 0, 1));
    let ProofErasedAuthorizedMint$1 = class ProofErasedAuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedAuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedAuthorizedMintFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedAuthorizedMintFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_prooferasedauthorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.prooferasedauthorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedAuthorizedMintFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.prooferasedauthorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.prooferasedauthorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedAuthorizedMint.__wrap(ret[0]);
        }
        get coin() {
            const ret = wasm$3.prooferasedauthorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.prooferasedauthorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.prooferasedauthorizedmint_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedInputFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_prooferasedinput_free(ptr >>> 0, 1));
    let ProofErasedInput$1 = class ProofErasedInput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedInput.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedInputFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedInputFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_prooferasedinput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.prooferasedinput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedInputFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.prooferasedinput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.prooferasedinput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedInput.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.prooferasedinput_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.prooferasedinput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.prooferasedinput_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedOfferFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_prooferasedoffer_free(ptr >>> 0, 1));
    let ProofErasedOffer$1 = class ProofErasedOffer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedOffer.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedOfferFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedOfferFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_prooferasedoffer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.prooferasedoffer_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedOfferFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        merge(other) {
            _assertClass$1(other, ProofErasedOffer);
            const ret = wasm$3.prooferasedoffer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedOffer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.prooferasedoffer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.prooferasedoffer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedOffer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$3.prooferasedoffer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$3.prooferasedoffer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$3.prooferasedoffer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$3.prooferasedoffer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.prooferasedoffer_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedOutputFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_prooferasedoutput_free(ptr >>> 0, 1));
    let ProofErasedOutput$1 = class ProofErasedOutput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedOutput.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedOutputFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedOutputFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_prooferasedoutput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.prooferasedoutput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedOutputFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.prooferasedoutput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.prooferasedoutput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedOutput.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.prooferasedoutput_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.prooferasedoutput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.prooferasedoutput_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedTransactionFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_prooferasedtransaction_free(ptr >>> 0, 1));
    let ProofErasedTransaction$1 = class ProofErasedTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedTransaction.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedTransactionFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedTransactionFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_prooferasedtransaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.prooferasedtransaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedTransactionFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        get mint() {
            const ret = wasm$3.prooferasedtransaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedAuthorizedMint$1.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$3.prooferasedtransaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedOffer$1.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$3.prooferasedtransaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedOffer$1.__wrap(ret);
        }
        identifiers() {
            const ret = wasm$3.prooferasedtransaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass$1(other, ProofErasedTransaction);
            const ret = wasm$3.prooferasedtransaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedTransaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.prooferasedtransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.prooferasedtransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedTransaction.__wrap(ret[0]);
        }
        imbalances(guaranteed, fees) {
            const ret = wasm$3.prooferasedtransaction_imbalances(this.__wbg_ptr, guaranteed, !isLikeNone$1(fees), isLikeNone$1(fees) ? BigInt(0) : fees);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        fees(params) {
            _assertClass$1(params, LedgerParameters$1);
            const ret = wasm$3.prooferasedtransaction_fees(this.__wbg_ptr, params.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.prooferasedtransaction_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ProofErasedTransientFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_prooferasedtransient_free(ptr >>> 0, 1));
    let ProofErasedTransient$1 = class ProofErasedTransient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedTransient.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedTransientFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedTransientFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_prooferasedtransient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.prooferasedtransient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedTransientFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.prooferasedtransient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.prooferasedtransient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ProofErasedTransient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.prooferasedtransient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.prooferasedtransient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.prooferasedtransient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.prooferasedtransient_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const SecretKeysFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_secretkeys_free(ptr >>> 0, 1));
    let SecretKeys$1 = class SecretKeys {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(SecretKeys.prototype);
            obj.__wbg_ptr = ptr;
            SecretKeysFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            SecretKeysFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_secretkeys_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.secretkeys_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            SecretKeysFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromSeed(seed) {
            const ret = wasm$3.secretkeys_fromSeed(seed);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return SecretKeys.__wrap(ret[0]);
        }
        static fromSeedRng(seed) {
            const ret = wasm$3.secretkeys_fromSeedRng(seed);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return SecretKeys.__wrap(ret[0]);
        }
        get coinPublicKey() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.secretkeys_coinPublicKey(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get encryptionPublicKey() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.secretkeys_encryptionPublicKey(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get encryptionSecretKey() {
            const ret = wasm$3.secretkeys_encryptionSecretKey(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return EncryptionSecretKey$1.__wrap(ret[0]);
        }
        get coinSecretKey() {
            const ret = wasm$3.secretkeys_coinSecretKey(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return CoinSecretKey$1.__wrap(ret[0]);
        }
    };
    const SystemTransactionFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_systemtransaction_free(ptr >>> 0, 1));
    let SystemTransaction$1 = class SystemTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(SystemTransaction.prototype);
            obj.__wbg_ptr = ptr;
            SystemTransactionFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            SystemTransactionFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_systemtransaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.systemtransaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            SystemTransactionFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.systemtransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.systemtransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return SystemTransaction.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.systemtransaction_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const TransactionFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_transaction_free(ptr >>> 0, 1));
    let Transaction$1 = class Transaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Transaction.prototype);
            obj.__wbg_ptr = ptr;
            TransactionFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_transaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.transaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromUnproven(prove, unproven) {
            _assertClass$1(unproven, UnprovenTransaction$1);
            const ret = wasm$3.transaction_fromUnproven(prove, unproven.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        eraseProofs() {
            const ret = wasm$3.transaction_eraseProofs(this.__wbg_ptr);
            return ProofErasedTransaction$1.__wrap(ret);
        }
        get mint() {
            const ret = wasm$3.transaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : AuthorizedMint$1.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$3.transaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : Offer$1.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$3.transaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : Offer$1.__wrap(ret);
        }
        transactionHash() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.transaction_transactionHash(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        identifiers() {
            const ret = wasm$3.transaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass$1(other, Transaction);
            const ret = wasm$3.transaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Transaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.transaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.transaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Transaction.__wrap(ret[0]);
        }
        imbalances(guaranteed, fees) {
            const ret = wasm$3.transaction_imbalances(this.__wbg_ptr, guaranteed, isLikeNone$1(fees) ? 0 : addToExternrefTable0$1(fees));
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        fees(params) {
            _assertClass$1(params, LedgerParameters$1);
            const ret = wasm$3.transaction_fees(this.__wbg_ptr, params.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.transaction_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const TransactionCostModelFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_transactioncostmodel_free(ptr >>> 0, 1));
    let TransactionCostModel$1 = class TransactionCostModel {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(TransactionCostModel.prototype);
            obj.__wbg_ptr = ptr;
            TransactionCostModelFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionCostModelFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_transactioncostmodel_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.transactioncostmodel_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionCostModelFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static dummyTransactionCostModel() {
            const ret = wasm$3.transactioncostmodel_dummyTransactionCostModel();
            return TransactionCostModel.__wrap(ret);
        }
        get inputFeeOverhead() {
            const ret = wasm$3.transactioncostmodel_inputFeeOverhead(this.__wbg_ptr);
            return ret;
        }
        get outputFeeOverhead() {
            const ret = wasm$3.transactioncostmodel_outputFeeOverhead(this.__wbg_ptr);
            return ret;
        }
        serialize(netid) {
            const ret = wasm$3.transactioncostmodel_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.transactioncostmodel_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return TransactionCostModel.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.transactioncostmodel_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const TransientFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_transient_free(ptr >>> 0, 1));
    let Transient$1 = class Transient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Transient.prototype);
            obj.__wbg_ptr = ptr;
            TransientFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransientFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_transient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.transient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransientFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.transient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.transient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return Transient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.transient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.transient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.transient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.transient_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenAuthorizedMintFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_unprovenauthorizedmint_free(ptr >>> 0, 1));
    let UnprovenAuthorizedMint$1 = class UnprovenAuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenAuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenAuthorizedMintFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenAuthorizedMintFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_unprovenauthorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.unprovenauthorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenAuthorizedMintFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$3.unprovenauthorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.unprovenauthorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenAuthorizedMint.__wrap(ret[0]);
        }
        eraseProof() {
            const ret = wasm$3.authorizedmint_eraseProof(this.__wbg_ptr);
            return ProofErasedAuthorizedMint$1.__wrap(ret);
        }
        get coin() {
            const ret = wasm$3.unprovenauthorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.unprovenauthorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.unprovenauthorizedmint_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenInputFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_unproveninput_free(ptr >>> 0, 1));
    let UnprovenInput$1 = class UnprovenInput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenInput.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenInputFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenInputFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_unproveninput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.unproveninput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenInputFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static newContractOwned(coin, segment, contract, state) {
            const ptr0 = passStringToWasm0$1(contract, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            _assertClass$1(state, ZswapChainState$1);
            const ret = wasm$3.unproveninput_newContractOwned(coin, segment, ptr0, len0, state.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenInput.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.unproveninput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.unproveninput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenInput.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.unproveninput_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.unproveninput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.unproveninput_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenOfferFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_unprovenoffer_free(ptr >>> 0, 1));
    let UnprovenOffer$1 = class UnprovenOffer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenOffer.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenOfferFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenOfferFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_unprovenoffer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.unprovenoffer_new();
            this.__wbg_ptr = ret >>> 0;
            UnprovenOfferFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromInput(input, type_, value) {
            _assertClass$1(input, UnprovenInput$1);
            const ptr0 = passStringToWasm0$1(type_, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.unprovenoffer_fromInput(input.__wbg_ptr, ptr0, len0, value);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        static fromOutput(output, type_, value) {
            _assertClass$1(output, UnprovenOutput$1);
            const ptr0 = passStringToWasm0$1(type_, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.unprovenoffer_fromOutput(output.__wbg_ptr, ptr0, len0, value);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        static fromTransient(transient) {
            _assertClass$1(transient, UnprovenTransient$1);
            const ret = wasm$3.unprovenoffer_fromTransient(transient.__wbg_ptr);
            return UnprovenOffer.__wrap(ret);
        }
        merge(other) {
            _assertClass$1(other, UnprovenOffer);
            const ret = wasm$3.unprovenoffer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.unprovenoffer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.unprovenoffer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$3.unprovenoffer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$3.unprovenoffer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$3.unprovenoffer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$3.unprovenoffer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.unprovenoffer_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenOutputFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_unprovenoutput_free(ptr >>> 0, 1));
    let UnprovenOutput$1 = class UnprovenOutput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenOutput.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenOutputFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenOutputFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_unprovenoutput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.unprovenoutput_construct();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenOutputFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static new(coin, segment, target_cpk, target_epk) {
            const ptr0 = passStringToWasm0$1(target_cpk, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ptr1 = passStringToWasm0$1(target_epk, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.unprovenoutput_new(coin, segment, ptr0, len0, ptr1, len1);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        static newContractOwned(coin, segment, contract) {
            const ptr0 = passStringToWasm0$1(contract, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.unprovenoutput_newContractOwned(coin, segment, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.unprovenoutput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.unprovenoutput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.unprovenoutput_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.unprovenoutput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.unprovenoutput_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenTransactionFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_unproventransaction_free(ptr >>> 0, 1));
    let UnprovenTransaction$1 = class UnprovenTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenTransaction.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenTransactionFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenTransactionFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_unproventransaction_free(ptr, 0);
        }
        constructor(guaranteed, fallible){
            _assertClass$1(guaranteed, UnprovenOffer$1);
            const ret = wasm$3.unproventransaction_new(guaranteed.__wbg_ptr, fallible);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenTransactionFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromMint(mint) {
            _assertClass$1(mint, UnprovenAuthorizedMint$1);
            const ret = wasm$3.unproventransaction_fromMint(mint.__wbg_ptr);
            return UnprovenTransaction.__wrap(ret);
        }
        eraseProofs() {
            const ret = wasm$3.unproventransaction_eraseProofs(this.__wbg_ptr);
            return ProofErasedTransaction$1.__wrap(ret);
        }
        get mint() {
            const ret = wasm$3.unproventransaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenAuthorizedMint$1.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$3.unproventransaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenOffer$1.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$3.unproventransaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenOffer$1.__wrap(ret);
        }
        identifiers() {
            const ret = wasm$3.unproventransaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass$1(other, UnprovenTransaction);
            const ret = wasm$3.unproventransaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenTransaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.unproventransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.unproventransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenTransaction.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.unproventransaction_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const UnprovenTransientFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_unproventransient_free(ptr >>> 0, 1));
    let UnprovenTransient$1 = class UnprovenTransient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenTransient.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenTransientFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenTransientFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_unproventransient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.unproventransient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenTransientFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        static newFromContractOwnedOutput(coin, segment, output) {
            _assertClass$1(output, UnprovenOutput$1);
            const ret = wasm$3.unproventransient_newFromContractOwnedOutput(coin, segment, output.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenTransient.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$3.unproventransient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.unproventransient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return UnprovenTransient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.unproventransient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$3.unproventransient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0$1(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0$1(ptr1, len1);
            } finally{
                wasm$3.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$3.unproventransient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0$1(ret[0], ret[1]).slice();
                wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.unproventransient_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    const ZswapChainStateFinalization$1 = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$3.__wbg_zswapchainstate_free(ptr >>> 0, 1));
    let ZswapChainState$1 = class ZswapChainState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ZswapChainState.prototype);
            obj.__wbg_ptr = ptr;
            ZswapChainStateFinalization$1.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ZswapChainStateFinalization$1.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$3.__wbg_zswapchainstate_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$3.zswapchainstate_new();
            this.__wbg_ptr = ret >>> 0;
            ZswapChainStateFinalization$1.register(this, this.__wbg_ptr, this);
            return this;
        }
        get firstFree() {
            const ret = wasm$3.localstate_firstFree(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        serialize_raw(netid) {
            const ret = wasm$3.zswapchainstate_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        filter(contract_address) {
            _assertClass$1(contract_address, ContractAddress$1);
            var ptr0 = contract_address.__destroy_into_raw();
            const ret = wasm$3.zswapchainstate_filter(this.__wbg_ptr, ptr0);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        merkle_tree_root() {
            const ret = wasm$3.zswapchainstate_merkle_tree_root(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0$1(ret[2]);
            }
            var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
            wasm$3.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        serialize(netid) {
            const ret = wasm$3.zswapchainstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$3.zswapchainstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0$1(raw, wasm$3.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN$1;
            const ret = wasm$3.zswapchainstate_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        static deserializeFromLedgerState(raw, netid) {
            const ret = wasm$3.zswapchainstate_deserializeFromLedgerState(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        tryApply(offer, whitelist) {
            _assertClass$1(offer, Offer$1);
            const ret = wasm$3.zswapchainstate_tryApply(this.__wbg_ptr, offer.__wbg_ptr, whitelist);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        tryApplyWithoutWhitelist(offer) {
            _assertClass$1(offer, Offer$1);
            const ret = wasm$3.zswapchainstate_tryApplyWithoutWhitelist(this.__wbg_ptr, offer.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        tryApplyProofErased(offer, whitelist) {
            _assertClass$1(offer, ProofErasedOffer$1);
            const ret = wasm$3.zswapchainstate_tryApplyProofErased(this.__wbg_ptr, offer.__wbg_ptr, whitelist);
            if (ret[2]) {
                throw takeFromExternrefTable0$1(ret[1]);
            }
            return takeFromExternrefTable0$1(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$3.zswapchainstate_toString(this.__wbg_ptr, isLikeNone$1(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0$1(ret[0], ret[1]);
            } finally{
                wasm$3.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    };
    function __wbg_String_fed4d24b68977888$1(arg0, arg1) {
        const ret = String(arg1);
        const ptr1 = passStringToWasm0$1(ret, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN$1;
        getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbg_add_883d9432f9188ef2$1(arg0, arg1) {
        const ret = arg0.add(arg1);
        return ret;
    }
    function __wbg_apply_36be6a55257c99bf$1() {
        return handleError$2(function(arg0, arg1, arg2) {
            const ret = arg0.apply(arg1, arg2);
            return ret;
        }, arguments);
    }
    function __wbg_buffer_09165b52af8c5237$1(arg0) {
        const ret = arg0.buffer;
        return ret;
    }
    function __wbg_buffer_609cc3eee51ed158$1(arg0) {
        const ret = arg0.buffer;
        return ret;
    }
    function __wbg_byobRequest_77d9adf63337edfb$1(arg0) {
        const ret = arg0.byobRequest;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    }
    function __wbg_byteLength_e674b853d9c77e1d$1(arg0) {
        const ret = arg0.byteLength;
        return ret;
    }
    function __wbg_byteOffset_fd862df290ef848d$1(arg0) {
        const ret = arg0.byteOffset;
        return ret;
    }
    function __wbg_call_672a4d21634d4a24$1() {
        return handleError$2(function(arg0, arg1) {
            const ret = arg0.call(arg1);
            return ret;
        }, arguments);
    }
    function __wbg_call_7cccdd69e0791ae2$1() {
        return handleError$2(function(arg0, arg1, arg2) {
            const ret = arg0.call(arg1, arg2);
            return ret;
        }, arguments);
    }
    function __wbg_close_304cc1fef3466669$1() {
        return handleError$2(function(arg0) {
            arg0.close();
        }, arguments);
    }
    function __wbg_close_5ce03e29be453811$1() {
        return handleError$2(function(arg0) {
            arg0.close();
        }, arguments);
    }
    function __wbg_crypto_574e78ad8b13b65f$1(arg0) {
        const ret = arg0.crypto;
        return ret;
    }
    function __wbg_enqueue_bb16ba72f537dc9e$1() {
        return handleError$2(function(arg0, arg1) {
            arg0.enqueue(arg1);
        }, arguments);
    }
    function __wbg_forEach_432d981ecbee7d69$1(arg0, arg1, arg2) {
        try {
            var state0 = {
                a: arg1,
                b: arg2
            };
            var cb0 = (arg0, arg1, arg2)=>{
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_389$1(a, state0.b, arg0, arg1, arg2);
                } finally{
                    state0.a = a;
                }
            };
            arg0.forEach(cb0);
        } finally{
            state0.a = state0.b = 0;
        }
    }
    function __wbg_getPrototypeOf_08aaacea7e300a38$1() {
        return handleError$2(function(arg0) {
            const ret = Reflect.getPrototypeOf(arg0);
            return ret;
        }, arguments);
    }
    function __wbg_getRandomValues_b8f5dbd5f3995a9e$1() {
        return handleError$2(function(arg0, arg1) {
            arg0.getRandomValues(arg1);
        }, arguments);
    }
    function __wbg_get_67b2ba62fc30de12$1() {
        return handleError$2(function(arg0, arg1) {
            const ret = Reflect.get(arg0, arg1);
            return ret;
        }, arguments);
    }
    function __wbg_getwithrefkey_bb8f74a92cb2e784$1(arg0, arg1) {
        const ret = arg0[arg1];
        return ret;
    }
    function __wbg_input_new$1(arg0) {
        const ret = Input$1.__wrap(arg0);
        return ret;
    }
    function __wbg_instanceof_ArrayBuffer_e14585432e3737fc$1(arg0) {
        let result;
        try {
            result = arg0 instanceof ArrayBuffer;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_instanceof_Set_f48781e4bf8ffb09$1(arg0) {
        let result;
        try {
            result = arg0 instanceof Set;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_instanceof_Uint8Array_17156bcf118086a9$1(arg0) {
        let result;
        try {
            result = arg0 instanceof Uint8Array;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_isSafeInteger_343e2beeeece1bb0$1(arg0) {
        const ret = Number.isSafeInteger(arg0);
        return ret;
    }
    function __wbg_length_a446193dc22c12f8$1(arg0) {
        const ret = arg0.length;
        return ret;
    }
    function __wbg_localstate_new$1(arg0) {
        const ret = LocalState$1.__wrap(arg0);
        return ret;
    }
    function __wbg_msCrypto_a61aeb35a24c1329$1(arg0) {
        const ret = arg0.msCrypto;
        return ret;
    }
    function __wbg_new_23a2665fac83c611$1(arg0, arg1) {
        try {
            var state0 = {
                a: arg0,
                b: arg1
            };
            var cb0 = (arg0, arg1)=>{
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_394$1(a, state0.b, arg0, arg1);
                } finally{
                    state0.a = a;
                }
            };
            const ret = new Promise(cb0);
            return ret;
        } finally{
            state0.a = state0.b = 0;
        }
    }
    function __wbg_new_405e22f390576ce2$1() {
        const ret = new Object();
        return ret;
    }
    function __wbg_new_5e0be73521bc8c17$1() {
        const ret = new Map();
        return ret;
    }
    function __wbg_new_78feb108b6472713$1() {
        const ret = new Array();
        return ret;
    }
    function __wbg_new_a12002a7f91c75be$1(arg0) {
        const ret = new Uint8Array(arg0);
        return ret;
    }
    function __wbg_new_a239edaa1dc2968f$1(arg0) {
        const ret = new Set(arg0);
        return ret;
    }
    function __wbg_new_c68d7209be747379$1(arg0, arg1) {
        const ret = new Error(getStringFromWasm0$1(arg0, arg1));
        return ret;
    }
    function __wbg_newnoargs_105ed471475aaf50$1(arg0, arg1) {
        const ret = new Function(getStringFromWasm0$1(arg0, arg1));
        return ret;
    }
    function __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a$1(arg0, arg1, arg2) {
        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
        return ret;
    }
    function __wbg_newwithlength_a381634e90c276d4$1(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return ret;
    }
    function __wbg_node_905d3e251edff8a2$1(arg0) {
        const ret = arg0.node;
        return ret;
    }
    function __wbg_output_new$1(arg0) {
        const ret = Output$1.__wrap(arg0);
        return ret;
    }
    function __wbg_process_dc0fbacc7c1c06f7$1(arg0) {
        const ret = arg0.process;
        return ret;
    }
    function __wbg_prooferasedinput_new$1(arg0) {
        const ret = ProofErasedInput$1.__wrap(arg0);
        return ret;
    }
    function __wbg_prooferasedoutput_new$1(arg0) {
        const ret = ProofErasedOutput$1.__wrap(arg0);
        return ret;
    }
    function __wbg_prooferasedtransient_new$1(arg0) {
        const ret = ProofErasedTransient$1.__wrap(arg0);
        return ret;
    }
    function __wbg_push_737cfc8c1432c2c6$1(arg0, arg1) {
        const ret = arg0.push(arg1);
        return ret;
    }
    function __wbg_queueMicrotask_97d92b4fcc8a61c5$1(arg0) {
        queueMicrotask(arg0);
    }
    function __wbg_queueMicrotask_d3219def82552485$1(arg0) {
        const ret = arg0.queueMicrotask;
        return ret;
    }
    function __wbg_randomFillSync_ac0988aba3254290$1() {
        return handleError$2(function(arg0, arg1) {
            arg0.randomFillSync(arg1);
        }, arguments);
    }
    function __wbg_require_60cc747a6bc5215a$1() {
        return handleError$2(function() {
            const ret = commonjsRequire;
            return ret;
        }, arguments);
    }
    function __wbg_resolve_4851785c9c5f573d$1(arg0) {
        const ret = Promise.resolve(arg0);
        return ret;
    }
    function __wbg_respond_1f279fa9f8edcb1c$1() {
        return handleError$2(function(arg0, arg1) {
            arg0.respond(arg1 >>> 0);
        }, arguments);
    }
    function __wbg_set_3fda3bac07393de4$1(arg0, arg1, arg2) {
        arg0[arg1] = arg2;
    }
    function __wbg_set_65595bdd868b3009$1(arg0, arg1, arg2) {
        arg0.set(arg1, arg2 >>> 0);
    }
    function __wbg_set_8fc6bf8a5b1071d1$1(arg0, arg1, arg2) {
        const ret = arg0.set(arg1, arg2);
        return ret;
    }
    function __wbg_static_accessor_GLOBAL_88a902d13a557d07$1() {
        const ret = typeof global === 'undefined' ? null : global;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    }
    function __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0$1() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    }
    function __wbg_static_accessor_SELF_37c5d418e4bf5819$1() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    }
    function __wbg_static_accessor_WINDOW_5de37043a91a9c40$1() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    }
    function __wbg_subarray_aa9065fa9dc5df96$1(arg0, arg1, arg2) {
        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
        return ret;
    }
    function __wbg_then_44b73946d2fb3e7d$1(arg0, arg1) {
        const ret = arg0.then(arg1);
        return ret;
    }
    function __wbg_transient_new$1(arg0) {
        const ret = Transient$1.__wrap(arg0);
        return ret;
    }
    function __wbg_unproveninput_new$1(arg0) {
        const ret = UnprovenInput$1.__wrap(arg0);
        return ret;
    }
    function __wbg_unprovenoutput_new$1(arg0) {
        const ret = UnprovenOutput$1.__wrap(arg0);
        return ret;
    }
    function __wbg_unproventransaction_new$1(arg0) {
        const ret = UnprovenTransaction$1.__wrap(arg0);
        return ret;
    }
    function __wbg_unproventransient_new$1(arg0) {
        const ret = UnprovenTransient$1.__wrap(arg0);
        return ret;
    }
    function __wbg_versions_c01dfd4722a88165$1(arg0) {
        const ret = arg0.versions;
        return ret;
    }
    function __wbg_view_fd8a56e8983f448d$1(arg0) {
        const ret = arg0.view;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    }
    function __wbg_zswapchainstate_new$1(arg0) {
        const ret = ZswapChainState$1.__wrap(arg0);
        return ret;
    }
    function __wbindgen_bigint_from_i128$1(arg0, arg1) {
        const ret = arg0 << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    }
    function __wbindgen_bigint_from_u128$1(arg0, arg1) {
        const ret = BigInt.asUintN(64, arg0) << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    }
    function __wbindgen_bigint_from_u64$1(arg0) {
        const ret = BigInt.asUintN(64, arg0);
        return ret;
    }
    function __wbindgen_bigint_get_as_i64$1(arg0, arg1) {
        const v = arg1;
        const ret = typeof (v) === 'bigint' ? v : undefined;
        getDataViewMemory0$1().setBigInt64(arg0 + 8 * 1, isLikeNone$1(ret) ? BigInt(0) : ret, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, !isLikeNone$1(ret), true);
    }
    function __wbindgen_boolean_get$1(arg0) {
        const v = arg0;
        const ret = typeof (v) === 'boolean' ? (v ? 1 : 0) : 2;
        return ret;
    }
    function __wbindgen_cb_drop$1(arg0) {
        const obj = arg0.original;
        if (obj.cnt-- == 1) {
            obj.a = 0;
            return true;
        }
        const ret = false;
        return ret;
    }
    function __wbindgen_closure_wrapper3626$1(arg0, arg1, arg2) {
        const ret = makeMutClosure$1(arg0, arg1, 649, __wbg_adapter_56$1);
        return ret;
    }
    function __wbindgen_debug_string$1(arg0, arg1) {
        const ret = debugString$1(arg1);
        const ptr1 = passStringToWasm0$1(ret, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN$1;
        getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbindgen_error_new$1(arg0, arg1) {
        const ret = new Error(getStringFromWasm0$1(arg0, arg1));
        return ret;
    }
    function __wbindgen_in$1(arg0, arg1) {
        const ret = arg0 in arg1;
        return ret;
    }
    function __wbindgen_init_externref_table$1() {
        const table = wasm$3.__wbindgen_export_4;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
    }
    function __wbindgen_is_bigint$1(arg0) {
        const ret = typeof (arg0) === 'bigint';
        return ret;
    }
    function __wbindgen_is_function$1(arg0) {
        const ret = typeof (arg0) === 'function';
        return ret;
    }
    function __wbindgen_is_null$1(arg0) {
        const ret = arg0 === null;
        return ret;
    }
    function __wbindgen_is_object$1(arg0) {
        const val = arg0;
        const ret = typeof (val) === 'object' && val !== null;
        return ret;
    }
    function __wbindgen_is_string$1(arg0) {
        const ret = typeof (arg0) === 'string';
        return ret;
    }
    function __wbindgen_is_undefined$1(arg0) {
        const ret = arg0 === undefined;
        return ret;
    }
    function __wbindgen_jsval_eq$1(arg0, arg1) {
        const ret = arg0 === arg1;
        return ret;
    }
    function __wbindgen_jsval_loose_eq$1(arg0, arg1) {
        const ret = arg0 == arg1;
        return ret;
    }
    function __wbindgen_memory$1() {
        const ret = wasm$3.memory;
        return ret;
    }
    function __wbindgen_number_get$1(arg0, arg1) {
        const obj = arg1;
        const ret = typeof (obj) === 'number' ? obj : undefined;
        getDataViewMemory0$1().setFloat64(arg0 + 8 * 1, isLikeNone$1(ret) ? 0 : ret, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, !isLikeNone$1(ret), true);
    }
    function __wbindgen_number_new$1(arg0) {
        const ret = arg0;
        return ret;
    }
    function __wbindgen_shr$1(arg0, arg1) {
        const ret = arg0 >> arg1;
        return ret;
    }
    function __wbindgen_string_get$1(arg0, arg1) {
        const obj = arg1;
        const ret = typeof (obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone$1(ret) ? 0 : passStringToWasm0$1(ret, wasm$3.__wbindgen_malloc, wasm$3.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN$1;
        getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbindgen_string_new$1(arg0, arg1) {
        const ret = getStringFromWasm0$1(arg0, arg1);
        return ret;
    }
    function __wbindgen_throw$1(arg0, arg1) {
        throw new Error(getStringFromWasm0$1(arg0, arg1));
    }
    function UnprovenOffer_$1() {
        return UnprovenOffer$1;
    }
    URL = globalThis.URL;
    const __vite__wasmModule$1 = await __vite__initWasm({
        "./midnight_zswap_wasm_bg.js": {
            "__wbg_unprovenoutput_new": __wbg_unprovenoutput_new$1,
            "__wbg_unproveninput_new": __wbg_unproveninput_new$1,
            "__wbg_unproventransient_new": __wbg_unproventransient_new$1,
            "__wbindgen_number_new": __wbindgen_number_new$1,
            "__wbg_localstate_new": __wbg_localstate_new$1,
            "__wbg_input_new": __wbg_input_new$1,
            "__wbg_prooferasedtransient_new": __wbg_prooferasedtransient_new$1,
            "__wbg_unproventransaction_new": __wbg_unproventransaction_new$1,
            "__wbg_prooferasedoutput_new": __wbg_prooferasedoutput_new$1,
            "__wbg_zswapchainstate_new": __wbg_zswapchainstate_new$1,
            "__wbg_output_new": __wbg_output_new$1,
            "__wbg_prooferasedinput_new": __wbg_prooferasedinput_new$1,
            "__wbg_transient_new": __wbg_transient_new$1,
            "__wbindgen_bigint_from_u64": __wbindgen_bigint_from_u64$1,
            "__wbindgen_shr": __wbindgen_shr$1,
            "__wbindgen_jsval_eq": __wbindgen_jsval_eq$1,
            "__wbindgen_is_bigint": __wbindgen_is_bigint$1,
            "__wbindgen_error_new": __wbindgen_error_new$1,
            "__wbindgen_is_object": __wbindgen_is_object$1,
            "__wbindgen_is_undefined": __wbindgen_is_undefined$1,
            "__wbindgen_in": __wbindgen_in$1,
            "__wbindgen_string_get": __wbindgen_string_get$1,
            "__wbindgen_string_new": __wbindgen_string_new$1,
            "__wbindgen_number_get": __wbindgen_number_get$1,
            "__wbindgen_bigint_from_u128": __wbindgen_bigint_from_u128$1,
            "__wbindgen_is_null": __wbindgen_is_null$1,
            "__wbindgen_is_string": __wbindgen_is_string$1,
            "__wbindgen_jsval_loose_eq": __wbindgen_jsval_loose_eq$1,
            "__wbindgen_boolean_get": __wbindgen_boolean_get$1,
            "__wbg_String_fed4d24b68977888": __wbg_String_fed4d24b68977888$1,
            "__wbindgen_bigint_from_i128": __wbindgen_bigint_from_i128$1,
            "__wbg_getwithrefkey_bb8f74a92cb2e784": __wbg_getwithrefkey_bb8f74a92cb2e784$1,
            "__wbg_set_3fda3bac07393de4": __wbg_set_3fda3bac07393de4$1,
            "__wbindgen_cb_drop": __wbindgen_cb_drop$1,
            "__wbg_queueMicrotask_d3219def82552485": __wbg_queueMicrotask_d3219def82552485$1,
            "__wbindgen_is_function": __wbindgen_is_function$1,
            "__wbg_queueMicrotask_97d92b4fcc8a61c5": __wbg_queueMicrotask_97d92b4fcc8a61c5$1,
            "__wbg_view_fd8a56e8983f448d": __wbg_view_fd8a56e8983f448d$1,
            "__wbg_respond_1f279fa9f8edcb1c": __wbg_respond_1f279fa9f8edcb1c$1,
            "__wbg_close_304cc1fef3466669": __wbg_close_304cc1fef3466669$1,
            "__wbg_enqueue_bb16ba72f537dc9e": __wbg_enqueue_bb16ba72f537dc9e$1,
            "__wbg_byobRequest_77d9adf63337edfb": __wbg_byobRequest_77d9adf63337edfb$1,
            "__wbg_close_5ce03e29be453811": __wbg_close_5ce03e29be453811$1,
            "__wbg_crypto_574e78ad8b13b65f": __wbg_crypto_574e78ad8b13b65f$1,
            "__wbg_process_dc0fbacc7c1c06f7": __wbg_process_dc0fbacc7c1c06f7$1,
            "__wbg_versions_c01dfd4722a88165": __wbg_versions_c01dfd4722a88165$1,
            "__wbg_node_905d3e251edff8a2": __wbg_node_905d3e251edff8a2$1,
            "__wbg_require_60cc747a6bc5215a": __wbg_require_60cc747a6bc5215a$1,
            "__wbg_msCrypto_a61aeb35a24c1329": __wbg_msCrypto_a61aeb35a24c1329$1,
            "__wbg_randomFillSync_ac0988aba3254290": __wbg_randomFillSync_ac0988aba3254290$1,
            "__wbg_getRandomValues_b8f5dbd5f3995a9e": __wbg_getRandomValues_b8f5dbd5f3995a9e$1,
            "__wbg_new_78feb108b6472713": __wbg_new_78feb108b6472713$1,
            "__wbg_newnoargs_105ed471475aaf50": __wbg_newnoargs_105ed471475aaf50$1,
            "__wbg_new_5e0be73521bc8c17": __wbg_new_5e0be73521bc8c17$1,
            "__wbg_get_67b2ba62fc30de12": __wbg_get_67b2ba62fc30de12$1,
            "__wbg_call_672a4d21634d4a24": __wbg_call_672a4d21634d4a24$1,
            "__wbg_new_405e22f390576ce2": __wbg_new_405e22f390576ce2$1,
            "__wbg_new_a239edaa1dc2968f": __wbg_new_a239edaa1dc2968f$1,
            "__wbg_push_737cfc8c1432c2c6": __wbg_push_737cfc8c1432c2c6$1,
            "__wbg_instanceof_ArrayBuffer_e14585432e3737fc": __wbg_instanceof_ArrayBuffer_e14585432e3737fc$1,
            "__wbg_new_c68d7209be747379": __wbg_new_c68d7209be747379$1,
            "__wbg_apply_36be6a55257c99bf": __wbg_apply_36be6a55257c99bf$1,
            "__wbg_call_7cccdd69e0791ae2": __wbg_call_7cccdd69e0791ae2$1,
            "__wbg_set_8fc6bf8a5b1071d1": __wbg_set_8fc6bf8a5b1071d1$1,
            "__wbg_isSafeInteger_343e2beeeece1bb0": __wbg_isSafeInteger_343e2beeeece1bb0$1,
            "__wbg_instanceof_Set_f48781e4bf8ffb09": __wbg_instanceof_Set_f48781e4bf8ffb09$1,
            "__wbg_add_883d9432f9188ef2": __wbg_add_883d9432f9188ef2$1,
            "__wbg_forEach_432d981ecbee7d69": __wbg_forEach_432d981ecbee7d69$1,
            "__wbg_new_23a2665fac83c611": __wbg_new_23a2665fac83c611$1,
            "__wbg_resolve_4851785c9c5f573d": __wbg_resolve_4851785c9c5f573d$1,
            "__wbg_then_44b73946d2fb3e7d": __wbg_then_44b73946d2fb3e7d$1,
            "__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0": __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0$1,
            "__wbg_static_accessor_SELF_37c5d418e4bf5819": __wbg_static_accessor_SELF_37c5d418e4bf5819$1,
            "__wbg_static_accessor_WINDOW_5de37043a91a9c40": __wbg_static_accessor_WINDOW_5de37043a91a9c40$1,
            "__wbg_static_accessor_GLOBAL_88a902d13a557d07": __wbg_static_accessor_GLOBAL_88a902d13a557d07$1,
            "__wbg_buffer_609cc3eee51ed158": __wbg_buffer_609cc3eee51ed158$1,
            "__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a": __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a$1,
            "__wbg_new_a12002a7f91c75be": __wbg_new_a12002a7f91c75be$1,
            "__wbg_set_65595bdd868b3009": __wbg_set_65595bdd868b3009$1,
            "__wbg_length_a446193dc22c12f8": __wbg_length_a446193dc22c12f8$1,
            "__wbg_instanceof_Uint8Array_17156bcf118086a9": __wbg_instanceof_Uint8Array_17156bcf118086a9$1,
            "__wbg_newwithlength_a381634e90c276d4": __wbg_newwithlength_a381634e90c276d4$1,
            "__wbg_buffer_09165b52af8c5237": __wbg_buffer_09165b52af8c5237$1,
            "__wbg_subarray_aa9065fa9dc5df96": __wbg_subarray_aa9065fa9dc5df96$1,
            "__wbg_byteLength_e674b853d9c77e1d": __wbg_byteLength_e674b853d9c77e1d$1,
            "__wbg_byteOffset_fd862df290ef848d": __wbg_byteOffset_fd862df290ef848d$1,
            "__wbg_getPrototypeOf_08aaacea7e300a38": __wbg_getPrototypeOf_08aaacea7e300a38$1,
            "__wbindgen_bigint_get_as_i64": __wbindgen_bigint_get_as_i64$1,
            "__wbindgen_debug_string": __wbindgen_debug_string$1,
            "__wbindgen_throw": __wbindgen_throw$1,
            "__wbindgen_memory": __wbindgen_memory$1,
            "__wbindgen_closure_wrapper3626": __wbindgen_closure_wrapper3626$1,
            "__wbindgen_init_externref_table": __wbindgen_init_externref_table$1
        },
        "./snippets/midnight-zswap-wasm-41bcd0561f7a9007/inline0.js": {
            "UnprovenOffer_": UnprovenOffer_$1
        }
    }, __vite__wasmUrl$1);
    const memory$1 = __vite__wasmModule$1.memory;
    const __wbg_systemtransaction_free$1 = __vite__wasmModule$1.__wbg_systemtransaction_free;
    const systemtransaction_new$1 = __vite__wasmModule$1.systemtransaction_new;
    const systemtransaction_serialize$1 = __vite__wasmModule$1.systemtransaction_serialize;
    const systemtransaction_deserialize$1 = __vite__wasmModule$1.systemtransaction_deserialize;
    const systemtransaction_toString$1 = __vite__wasmModule$1.systemtransaction_toString;
    const __wbg_ledgerparameters_free$1 = __vite__wasmModule$1.__wbg_ledgerparameters_free;
    const ledgerparameters_new$1 = __vite__wasmModule$1.ledgerparameters_new;
    const ledgerparameters_dummyParameters$1 = __vite__wasmModule$1.ledgerparameters_dummyParameters;
    const ledgerparameters_transactionCostModel$1 = __vite__wasmModule$1.ledgerparameters_transactionCostModel;
    const ledgerparameters_serialize$1 = __vite__wasmModule$1.ledgerparameters_serialize;
    const ledgerparameters_deserialize$1 = __vite__wasmModule$1.ledgerparameters_deserialize;
    const ledgerparameters_toString$1 = __vite__wasmModule$1.ledgerparameters_toString;
    const __wbg_authorizedmint_free$1 = __vite__wasmModule$1.__wbg_authorizedmint_free;
    const authorizedmint_new$1 = __vite__wasmModule$1.authorizedmint_new;
    const authorizedmint_serialize$1 = __vite__wasmModule$1.authorizedmint_serialize;
    const authorizedmint_deserialize$1 = __vite__wasmModule$1.authorizedmint_deserialize;
    const authorizedmint_eraseProof$1 = __vite__wasmModule$1.authorizedmint_eraseProof;
    const authorizedmint_coin$1 = __vite__wasmModule$1.authorizedmint_coin;
    const authorizedmint_recipient$1 = __vite__wasmModule$1.authorizedmint_recipient;
    const authorizedmint_toString$1 = __vite__wasmModule$1.authorizedmint_toString;
    const __wbg_unprovenauthorizedmint_free$1 = __vite__wasmModule$1.__wbg_unprovenauthorizedmint_free;
    const unprovenauthorizedmint_new$1 = __vite__wasmModule$1.unprovenauthorizedmint_new;
    const unprovenauthorizedmint_serialize$1 = __vite__wasmModule$1.unprovenauthorizedmint_serialize;
    const unprovenauthorizedmint_deserialize$1 = __vite__wasmModule$1.unprovenauthorizedmint_deserialize;
    const unprovenauthorizedmint_coin$1 = __vite__wasmModule$1.unprovenauthorizedmint_coin;
    const unprovenauthorizedmint_recipient$1 = __vite__wasmModule$1.unprovenauthorizedmint_recipient;
    const unprovenauthorizedmint_toString$1 = __vite__wasmModule$1.unprovenauthorizedmint_toString;
    const __wbg_prooferasedauthorizedmint_free$1 = __vite__wasmModule$1.__wbg_prooferasedauthorizedmint_free;
    const prooferasedauthorizedmint_new$1 = __vite__wasmModule$1.prooferasedauthorizedmint_new;
    const prooferasedauthorizedmint_serialize$1 = __vite__wasmModule$1.prooferasedauthorizedmint_serialize;
    const prooferasedauthorizedmint_deserialize$1 = __vite__wasmModule$1.prooferasedauthorizedmint_deserialize;
    const prooferasedauthorizedmint_coin$1 = __vite__wasmModule$1.prooferasedauthorizedmint_coin;
    const prooferasedauthorizedmint_recipient$1 = __vite__wasmModule$1.prooferasedauthorizedmint_recipient;
    const prooferasedauthorizedmint_toString$1 = __vite__wasmModule$1.prooferasedauthorizedmint_toString;
    const __wbg_offer_free$1 = __vite__wasmModule$1.__wbg_offer_free;
    const offer_new$1 = __vite__wasmModule$1.offer_new;
    const offer_merge$1 = __vite__wasmModule$1.offer_merge;
    const offer_serialize$1 = __vite__wasmModule$1.offer_serialize;
    const offer_serialize_raw$1 = __vite__wasmModule$1.offer_serialize_raw;
    const offer_deserialize$1 = __vite__wasmModule$1.offer_deserialize;
    const offer_deserialize_raw$1 = __vite__wasmModule$1.offer_deserialize_raw;
    const offer_inputs$1 = __vite__wasmModule$1.offer_inputs;
    const offer_outputs$1 = __vite__wasmModule$1.offer_outputs;
    const offer_transient$1 = __vite__wasmModule$1.offer_transient;
    const offer_deltas$1 = __vite__wasmModule$1.offer_deltas;
    const offer_toString$1 = __vite__wasmModule$1.offer_toString;
    const __wbg_prooferasedoffer_free$1 = __vite__wasmModule$1.__wbg_prooferasedoffer_free;
    const prooferasedoffer_new$1 = __vite__wasmModule$1.prooferasedoffer_new;
    const prooferasedoffer_merge$1 = __vite__wasmModule$1.prooferasedoffer_merge;
    const prooferasedoffer_serialize$1 = __vite__wasmModule$1.prooferasedoffer_serialize;
    const prooferasedoffer_deserialize$1 = __vite__wasmModule$1.prooferasedoffer_deserialize;
    const prooferasedoffer_inputs$1 = __vite__wasmModule$1.prooferasedoffer_inputs;
    const prooferasedoffer_outputs$1 = __vite__wasmModule$1.prooferasedoffer_outputs;
    const prooferasedoffer_transient$1 = __vite__wasmModule$1.prooferasedoffer_transient;
    const prooferasedoffer_deltas$1 = __vite__wasmModule$1.prooferasedoffer_deltas;
    const prooferasedoffer_toString$1 = __vite__wasmModule$1.prooferasedoffer_toString;
    const __wbg_unprovenoffer_free$1 = __vite__wasmModule$1.__wbg_unprovenoffer_free;
    const unprovenoffer_new$1 = __vite__wasmModule$1.unprovenoffer_new;
    const unprovenoffer_fromInput$1 = __vite__wasmModule$1.unprovenoffer_fromInput;
    const unprovenoffer_fromOutput$1 = __vite__wasmModule$1.unprovenoffer_fromOutput;
    const unprovenoffer_fromTransient$1 = __vite__wasmModule$1.unprovenoffer_fromTransient;
    const unprovenoffer_merge$1 = __vite__wasmModule$1.unprovenoffer_merge;
    const unprovenoffer_serialize$1 = __vite__wasmModule$1.unprovenoffer_serialize;
    const unprovenoffer_deserialize$1 = __vite__wasmModule$1.unprovenoffer_deserialize;
    const unprovenoffer_inputs$1 = __vite__wasmModule$1.unprovenoffer_inputs;
    const unprovenoffer_outputs$1 = __vite__wasmModule$1.unprovenoffer_outputs;
    const unprovenoffer_transient$1 = __vite__wasmModule$1.unprovenoffer_transient;
    const unprovenoffer_deltas$1 = __vite__wasmModule$1.unprovenoffer_deltas;
    const unprovenoffer_toString$1 = __vite__wasmModule$1.unprovenoffer_toString;
    const __wbg_input_free$1 = __vite__wasmModule$1.__wbg_input_free;
    const input_new$1 = __vite__wasmModule$1.input_new;
    const input_serialize$1 = __vite__wasmModule$1.input_serialize;
    const input_deserialize$1 = __vite__wasmModule$1.input_deserialize;
    const input_nullifier$1 = __vite__wasmModule$1.input_nullifier;
    const input_contractAddress$1 = __vite__wasmModule$1.input_contractAddress;
    const input_toString$1 = __vite__wasmModule$1.input_toString;
    const __wbg_prooferasedinput_free$1 = __vite__wasmModule$1.__wbg_prooferasedinput_free;
    const prooferasedinput_new$1 = __vite__wasmModule$1.prooferasedinput_new;
    const prooferasedinput_serialize$1 = __vite__wasmModule$1.prooferasedinput_serialize;
    const prooferasedinput_deserialize$1 = __vite__wasmModule$1.prooferasedinput_deserialize;
    const prooferasedinput_nullifier$1 = __vite__wasmModule$1.prooferasedinput_nullifier;
    const prooferasedinput_contractAddress$1 = __vite__wasmModule$1.prooferasedinput_contractAddress;
    const prooferasedinput_toString$1 = __vite__wasmModule$1.prooferasedinput_toString;
    const __wbg_unproveninput_free$1 = __vite__wasmModule$1.__wbg_unproveninput_free;
    const unproveninput_new$1 = __vite__wasmModule$1.unproveninput_new;
    const unproveninput_newContractOwned$1 = __vite__wasmModule$1.unproveninput_newContractOwned;
    const unproveninput_serialize$1 = __vite__wasmModule$1.unproveninput_serialize;
    const unproveninput_deserialize$1 = __vite__wasmModule$1.unproveninput_deserialize;
    const unproveninput_nullifier$1 = __vite__wasmModule$1.unproveninput_nullifier;
    const unproveninput_contractAddress$1 = __vite__wasmModule$1.unproveninput_contractAddress;
    const unproveninput_toString$1 = __vite__wasmModule$1.unproveninput_toString;
    const __wbg_output_free$1 = __vite__wasmModule$1.__wbg_output_free;
    const output_new$1 = __vite__wasmModule$1.output_new;
    const output_serialize$1 = __vite__wasmModule$1.output_serialize;
    const output_deserialize$1 = __vite__wasmModule$1.output_deserialize;
    const output_commitment$1 = __vite__wasmModule$1.output_commitment;
    const output_contractAddress$1 = __vite__wasmModule$1.output_contractAddress;
    const output_toString$1 = __vite__wasmModule$1.output_toString;
    const __wbg_prooferasedoutput_free$1 = __vite__wasmModule$1.__wbg_prooferasedoutput_free;
    const prooferasedoutput_new$1 = __vite__wasmModule$1.prooferasedoutput_new;
    const prooferasedoutput_serialize$1 = __vite__wasmModule$1.prooferasedoutput_serialize;
    const prooferasedoutput_deserialize$1 = __vite__wasmModule$1.prooferasedoutput_deserialize;
    const prooferasedoutput_commitment$1 = __vite__wasmModule$1.prooferasedoutput_commitment;
    const prooferasedoutput_contractAddress$1 = __vite__wasmModule$1.prooferasedoutput_contractAddress;
    const prooferasedoutput_toString$1 = __vite__wasmModule$1.prooferasedoutput_toString;
    const __wbg_unprovenoutput_free$1 = __vite__wasmModule$1.__wbg_unprovenoutput_free;
    const unprovenoutput_construct$1 = __vite__wasmModule$1.unprovenoutput_construct;
    const unprovenoutput_new$1 = __vite__wasmModule$1.unprovenoutput_new;
    const unprovenoutput_newContractOwned$1 = __vite__wasmModule$1.unprovenoutput_newContractOwned;
    const unprovenoutput_serialize$1 = __vite__wasmModule$1.unprovenoutput_serialize;
    const unprovenoutput_deserialize$1 = __vite__wasmModule$1.unprovenoutput_deserialize;
    const unprovenoutput_commitment$1 = __vite__wasmModule$1.unprovenoutput_commitment;
    const unprovenoutput_contractAddress$1 = __vite__wasmModule$1.unprovenoutput_contractAddress;
    const unprovenoutput_toString$1 = __vite__wasmModule$1.unprovenoutput_toString;
    const __wbg_transient_free$1 = __vite__wasmModule$1.__wbg_transient_free;
    const transient_new$1 = __vite__wasmModule$1.transient_new;
    const transient_serialize$1 = __vite__wasmModule$1.transient_serialize;
    const transient_deserialize$1 = __vite__wasmModule$1.transient_deserialize;
    const transient_commitment$1 = __vite__wasmModule$1.transient_commitment;
    const transient_nullifier$1 = __vite__wasmModule$1.transient_nullifier;
    const transient_contractAddress$1 = __vite__wasmModule$1.transient_contractAddress;
    const transient_toString$1 = __vite__wasmModule$1.transient_toString;
    const __wbg_prooferasedtransient_free$1 = __vite__wasmModule$1.__wbg_prooferasedtransient_free;
    const prooferasedtransient_new$1 = __vite__wasmModule$1.prooferasedtransient_new;
    const prooferasedtransient_serialize$1 = __vite__wasmModule$1.prooferasedtransient_serialize;
    const prooferasedtransient_deserialize$1 = __vite__wasmModule$1.prooferasedtransient_deserialize;
    const prooferasedtransient_commitment$1 = __vite__wasmModule$1.prooferasedtransient_commitment;
    const prooferasedtransient_nullifier$1 = __vite__wasmModule$1.prooferasedtransient_nullifier;
    const prooferasedtransient_contractAddress$1 = __vite__wasmModule$1.prooferasedtransient_contractAddress;
    const prooferasedtransient_toString$1 = __vite__wasmModule$1.prooferasedtransient_toString;
    const __wbg_unproventransient_free$1 = __vite__wasmModule$1.__wbg_unproventransient_free;
    const unproventransient_new$1 = __vite__wasmModule$1.unproventransient_new;
    const unproventransient_newFromContractOwnedOutput$1 = __vite__wasmModule$1.unproventransient_newFromContractOwnedOutput;
    const unproventransient_serialize$1 = __vite__wasmModule$1.unproventransient_serialize;
    const unproventransient_deserialize$1 = __vite__wasmModule$1.unproventransient_deserialize;
    const unproventransient_commitment$1 = __vite__wasmModule$1.unproventransient_commitment;
    const unproventransient_nullifier$1 = __vite__wasmModule$1.unproventransient_nullifier;
    const unproventransient_contractAddress$1 = __vite__wasmModule$1.unproventransient_contractAddress;
    const unproventransient_toString$1 = __vite__wasmModule$1.unproventransient_toString;
    const __wbg_transaction_free$1 = __vite__wasmModule$1.__wbg_transaction_free;
    const transaction_new$1 = __vite__wasmModule$1.transaction_new;
    const transaction_fromUnproven$1 = __vite__wasmModule$1.transaction_fromUnproven;
    const transaction_eraseProofs$1 = __vite__wasmModule$1.transaction_eraseProofs;
    const transaction_mint$1 = __vite__wasmModule$1.transaction_mint;
    const transaction_guaranteedCoins$1 = __vite__wasmModule$1.transaction_guaranteedCoins;
    const transaction_fallibleCoins$1 = __vite__wasmModule$1.transaction_fallibleCoins;
    const transaction_transactionHash$1 = __vite__wasmModule$1.transaction_transactionHash;
    const transaction_identifiers$1 = __vite__wasmModule$1.transaction_identifiers;
    const transaction_merge$1 = __vite__wasmModule$1.transaction_merge;
    const transaction_serialize$1 = __vite__wasmModule$1.transaction_serialize;
    const transaction_deserialize$1 = __vite__wasmModule$1.transaction_deserialize;
    const transaction_imbalances$1 = __vite__wasmModule$1.transaction_imbalances;
    const transaction_fees$1 = __vite__wasmModule$1.transaction_fees;
    const transaction_toString$1 = __vite__wasmModule$1.transaction_toString;
    const __wbg_prooferasedtransaction_free$1 = __vite__wasmModule$1.__wbg_prooferasedtransaction_free;
    const prooferasedtransaction_new$1 = __vite__wasmModule$1.prooferasedtransaction_new;
    const prooferasedtransaction_mint$1 = __vite__wasmModule$1.prooferasedtransaction_mint;
    const prooferasedtransaction_guaranteedCoins$1 = __vite__wasmModule$1.prooferasedtransaction_guaranteedCoins;
    const prooferasedtransaction_fallibleCoins$1 = __vite__wasmModule$1.prooferasedtransaction_fallibleCoins;
    const prooferasedtransaction_identifiers$1 = __vite__wasmModule$1.prooferasedtransaction_identifiers;
    const prooferasedtransaction_merge$1 = __vite__wasmModule$1.prooferasedtransaction_merge;
    const prooferasedtransaction_serialize$1 = __vite__wasmModule$1.prooferasedtransaction_serialize;
    const prooferasedtransaction_deserialize$1 = __vite__wasmModule$1.prooferasedtransaction_deserialize;
    const prooferasedtransaction_imbalances$1 = __vite__wasmModule$1.prooferasedtransaction_imbalances;
    const prooferasedtransaction_fees$1 = __vite__wasmModule$1.prooferasedtransaction_fees;
    const prooferasedtransaction_toString$1 = __vite__wasmModule$1.prooferasedtransaction_toString;
    const __wbg_unproventransaction_free$1 = __vite__wasmModule$1.__wbg_unproventransaction_free;
    const unproventransaction_new$1 = __vite__wasmModule$1.unproventransaction_new;
    const unproventransaction_fromMint$1 = __vite__wasmModule$1.unproventransaction_fromMint;
    const unproventransaction_eraseProofs$1 = __vite__wasmModule$1.unproventransaction_eraseProofs;
    const unproventransaction_mint$1 = __vite__wasmModule$1.unproventransaction_mint;
    const unproventransaction_guaranteedCoins$1 = __vite__wasmModule$1.unproventransaction_guaranteedCoins;
    const unproventransaction_fallibleCoins$1 = __vite__wasmModule$1.unproventransaction_fallibleCoins;
    const unproventransaction_identifiers$1 = __vite__wasmModule$1.unproventransaction_identifiers;
    const unproventransaction_merge$1 = __vite__wasmModule$1.unproventransaction_merge;
    const unproventransaction_serialize$1 = __vite__wasmModule$1.unproventransaction_serialize;
    const unproventransaction_deserialize$1 = __vite__wasmModule$1.unproventransaction_deserialize;
    const unproventransaction_toString$1 = __vite__wasmModule$1.unproventransaction_toString;
    const __wbg_transactioncostmodel_free$1 = __vite__wasmModule$1.__wbg_transactioncostmodel_free;
    const transactioncostmodel_new$1 = __vite__wasmModule$1.transactioncostmodel_new;
    const transactioncostmodel_dummyTransactionCostModel$1 = __vite__wasmModule$1.transactioncostmodel_dummyTransactionCostModel;
    const transactioncostmodel_inputFeeOverhead$1 = __vite__wasmModule$1.transactioncostmodel_inputFeeOverhead;
    const transactioncostmodel_outputFeeOverhead$1 = __vite__wasmModule$1.transactioncostmodel_outputFeeOverhead;
    const transactioncostmodel_serialize$1 = __vite__wasmModule$1.transactioncostmodel_serialize;
    const transactioncostmodel_deserialize$1 = __vite__wasmModule$1.transactioncostmodel_deserialize;
    const transactioncostmodel_toString$1 = __vite__wasmModule$1.transactioncostmodel_toString;
    const unprovenauthorizedmint_eraseProof$1 = __vite__wasmModule$1.unprovenauthorizedmint_eraseProof;
    const __wbg_secretkeys_free$1 = __vite__wasmModule$1.__wbg_secretkeys_free;
    const secretkeys_new$1 = __vite__wasmModule$1.secretkeys_new;
    const secretkeys_fromSeed$1 = __vite__wasmModule$1.secretkeys_fromSeed;
    const secretkeys_fromSeedRng$1 = __vite__wasmModule$1.secretkeys_fromSeedRng;
    const secretkeys_coinPublicKey$1 = __vite__wasmModule$1.secretkeys_coinPublicKey;
    const secretkeys_encryptionPublicKey$1 = __vite__wasmModule$1.secretkeys_encryptionPublicKey;
    const secretkeys_encryptionSecretKey$1 = __vite__wasmModule$1.secretkeys_encryptionSecretKey;
    const secretkeys_coinSecretKey$1 = __vite__wasmModule$1.secretkeys_coinSecretKey;
    const __wbg_coinsecretkey_free$1 = __vite__wasmModule$1.__wbg_coinsecretkey_free;
    const coinsecretkey_new$1 = __vite__wasmModule$1.coinsecretkey_new;
    const coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$1 = __vite__wasmModule$1.coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize;
    const __wbg_encryptionsecretkey_free$1 = __vite__wasmModule$1.__wbg_encryptionsecretkey_free;
    const encryptionsecretkey_new$1 = __vite__wasmModule$1.encryptionsecretkey_new;
    const encryptionsecretkey_test$1 = __vite__wasmModule$1.encryptionsecretkey_test;
    const encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$1 = __vite__wasmModule$1.encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize;
    const encryptionsecretkey_deserialize$1 = __vite__wasmModule$1.encryptionsecretkey_deserialize;
    const encryptionsecretkey_deserialize_raw$1 = __vite__wasmModule$1.encryptionsecretkey_deserialize_raw;
    const createCoinInfo$1 = __vite__wasmModule$1.createCoinInfo;
    const nativeToken$1 = __vite__wasmModule$1.nativeToken;
    const __wbg_merkletreecollapsedupdate_free$1 = __vite__wasmModule$1.__wbg_merkletreecollapsedupdate_free;
    const merkletreecollapsedupdate_new$1 = __vite__wasmModule$1.merkletreecollapsedupdate_new;
    const merkletreecollapsedupdate_new_raw$1 = __vite__wasmModule$1.merkletreecollapsedupdate_new_raw;
    const merkletreecollapsedupdate_serialize$1 = __vite__wasmModule$1.merkletreecollapsedupdate_serialize;
    const merkletreecollapsedupdate_serialize_raw$1 = __vite__wasmModule$1.merkletreecollapsedupdate_serialize_raw;
    const merkletreecollapsedupdate_deserialize$1 = __vite__wasmModule$1.merkletreecollapsedupdate_deserialize;
    const merkletreecollapsedupdate_toString$1 = __vite__wasmModule$1.merkletreecollapsedupdate_toString;
    const __wbg_localstate_free$1 = __vite__wasmModule$1.__wbg_localstate_free;
    const localstate_new$1 = __vite__wasmModule$1.localstate_new;
    const localstate_authorizeMint$1 = __vite__wasmModule$1.localstate_authorizeMint;
    const localstate_firstFree$1 = __vite__wasmModule$1.localstate_firstFree;
    const localstate_coins$1 = __vite__wasmModule$1.localstate_coins;
    const localstate_pendingSpends$1 = __vite__wasmModule$1.localstate_pendingSpends;
    const localstate_pendingOutputs$1 = __vite__wasmModule$1.localstate_pendingOutputs;
    const localstate_applyMint$1 = __vite__wasmModule$1.localstate_applyMint;
    const localstate_applyProofErasedMint$1 = __vite__wasmModule$1.localstate_applyProofErasedMint;
    const localstate_applyFailed$1 = __vite__wasmModule$1.localstate_applyFailed;
    const localstate_applyFailedProofErased$1 = __vite__wasmModule$1.localstate_applyFailedProofErased;
    const localstate_apply$1 = __vite__wasmModule$1.localstate_apply;
    const localstate_applyProofErased$1 = __vite__wasmModule$1.localstate_applyProofErased;
    const localstate_applyTx$1 = __vite__wasmModule$1.localstate_applyTx;
    const localstate_applyProofErasedTx$1 = __vite__wasmModule$1.localstate_applyProofErasedTx;
    const localstate_applySystemTx$1 = __vite__wasmModule$1.localstate_applySystemTx;
    const localstate_applyCollapsedUpdate$1 = __vite__wasmModule$1.localstate_applyCollapsedUpdate;
    const localstate_spend$1 = __vite__wasmModule$1.localstate_spend;
    const localstate_spendFromOutput$1 = __vite__wasmModule$1.localstate_spendFromOutput;
    const localstate_watchFor$1 = __vite__wasmModule$1.localstate_watchFor;
    const localstate_serialize$1 = __vite__wasmModule$1.localstate_serialize;
    const localstate_deserialize$1 = __vite__wasmModule$1.localstate_deserialize;
    const localstate_toString$1 = __vite__wasmModule$1.localstate_toString;
    const __wbg_zswapchainstate_free$1 = __vite__wasmModule$1.__wbg_zswapchainstate_free;
    const __wbg_contractaddress_free$1 = __vite__wasmModule$1.__wbg_contractaddress_free;
    const contractaddress_deserialize_raw$1 = __vite__wasmModule$1.contractaddress_deserialize_raw;
    const zswapchainstate_new$1 = __vite__wasmModule$1.zswapchainstate_new;
    const zswapchainstate_serialize_raw$1 = __vite__wasmModule$1.zswapchainstate_serialize_raw;
    const zswapchainstate_filter$1 = __vite__wasmModule$1.zswapchainstate_filter;
    const zswapchainstate_merkle_tree_root$1 = __vite__wasmModule$1.zswapchainstate_merkle_tree_root;
    const zswapchainstate_serialize$1 = __vite__wasmModule$1.zswapchainstate_serialize;
    const zswapchainstate_deserialize$1 = __vite__wasmModule$1.zswapchainstate_deserialize;
    const zswapchainstate_deserialize_raw$1 = __vite__wasmModule$1.zswapchainstate_deserialize_raw;
    const zswapchainstate_deserializeFromLedgerState$1 = __vite__wasmModule$1.zswapchainstate_deserializeFromLedgerState;
    const zswapchainstate_tryApply$1 = __vite__wasmModule$1.zswapchainstate_tryApply;
    const zswapchainstate_tryApplyWithoutWhitelist$1 = __vite__wasmModule$1.zswapchainstate_tryApplyWithoutWhitelist;
    const zswapchainstate_tryApplyProofErased$1 = __vite__wasmModule$1.zswapchainstate_tryApplyProofErased;
    const zswapchainstate_toString$1 = __vite__wasmModule$1.zswapchainstate_toString;
    const sampleContractAddress$1 = __vite__wasmModule$1.sampleContractAddress;
    const sampleTokenType$1 = __vite__wasmModule$1.sampleTokenType;
    const sampleCoinPublicKey$1 = __vite__wasmModule$1.sampleCoinPublicKey;
    const sampleEncryptionPublicKey$1 = __vite__wasmModule$1.sampleEncryptionPublicKey;
    const coin_nullifier$1 = __vite__wasmModule$1.coin_nullifier;
    const coin_commitment$1 = __vite__wasmModule$1.coin_commitment;
    const zswapchainstate_firstFree$1 = __vite__wasmModule$1.zswapchainstate_firstFree;
    const __wbg_intounderlyingbytesource_free$1 = __vite__wasmModule$1.__wbg_intounderlyingbytesource_free;
    const intounderlyingbytesource_type$1 = __vite__wasmModule$1.intounderlyingbytesource_type;
    const intounderlyingbytesource_autoAllocateChunkSize$1 = __vite__wasmModule$1.intounderlyingbytesource_autoAllocateChunkSize;
    const intounderlyingbytesource_start$1 = __vite__wasmModule$1.intounderlyingbytesource_start;
    const intounderlyingbytesource_pull$1 = __vite__wasmModule$1.intounderlyingbytesource_pull;
    const intounderlyingbytesource_cancel$1 = __vite__wasmModule$1.intounderlyingbytesource_cancel;
    const __wbg_intounderlyingsource_free$1 = __vite__wasmModule$1.__wbg_intounderlyingsource_free;
    const intounderlyingsource_pull$1 = __vite__wasmModule$1.intounderlyingsource_pull;
    const intounderlyingsource_cancel$1 = __vite__wasmModule$1.intounderlyingsource_cancel;
    const __wbg_intounderlyingsink_free$1 = __vite__wasmModule$1.__wbg_intounderlyingsink_free;
    const intounderlyingsink_write$1 = __vite__wasmModule$1.intounderlyingsink_write;
    const intounderlyingsink_close$1 = __vite__wasmModule$1.intounderlyingsink_close;
    const intounderlyingsink_abort$1 = __vite__wasmModule$1.intounderlyingsink_abort;
    const __wbindgen_malloc$1 = __vite__wasmModule$1.__wbindgen_malloc;
    const __wbindgen_realloc$1 = __vite__wasmModule$1.__wbindgen_realloc;
    const __wbindgen_exn_store$1 = __vite__wasmModule$1.__wbindgen_exn_store;
    const __externref_table_alloc$1 = __vite__wasmModule$1.__externref_table_alloc;
    const __wbindgen_export_4$1 = __vite__wasmModule$1.__wbindgen_export_4;
    const __wbindgen_export_5$1 = __vite__wasmModule$1.__wbindgen_export_5;
    const __externref_table_dealloc$1 = __vite__wasmModule$1.__externref_table_dealloc;
    const __wbindgen_free$1 = __vite__wasmModule$1.__wbindgen_free;
    const __externref_drop_slice$1 = __vite__wasmModule$1.__externref_drop_slice;
    const closure648_externref_shim$1 = __vite__wasmModule$1.closure648_externref_shim;
    const closure684_externref_shim$1 = __vite__wasmModule$1.closure684_externref_shim;
    const closure688_externref_shim$1 = __vite__wasmModule$1.closure688_externref_shim;
    const __wbindgen_start$1 = __vite__wasmModule$1.__wbindgen_start;
    const wasm$2 = Object.freeze(Object.defineProperty({
        __proto__: null,
        __externref_drop_slice: __externref_drop_slice$1,
        __externref_table_alloc: __externref_table_alloc$1,
        __externref_table_dealloc: __externref_table_dealloc$1,
        __wbg_authorizedmint_free: __wbg_authorizedmint_free$1,
        __wbg_coinsecretkey_free: __wbg_coinsecretkey_free$1,
        __wbg_contractaddress_free: __wbg_contractaddress_free$1,
        __wbg_encryptionsecretkey_free: __wbg_encryptionsecretkey_free$1,
        __wbg_input_free: __wbg_input_free$1,
        __wbg_intounderlyingbytesource_free: __wbg_intounderlyingbytesource_free$1,
        __wbg_intounderlyingsink_free: __wbg_intounderlyingsink_free$1,
        __wbg_intounderlyingsource_free: __wbg_intounderlyingsource_free$1,
        __wbg_ledgerparameters_free: __wbg_ledgerparameters_free$1,
        __wbg_localstate_free: __wbg_localstate_free$1,
        __wbg_merkletreecollapsedupdate_free: __wbg_merkletreecollapsedupdate_free$1,
        __wbg_offer_free: __wbg_offer_free$1,
        __wbg_output_free: __wbg_output_free$1,
        __wbg_prooferasedauthorizedmint_free: __wbg_prooferasedauthorizedmint_free$1,
        __wbg_prooferasedinput_free: __wbg_prooferasedinput_free$1,
        __wbg_prooferasedoffer_free: __wbg_prooferasedoffer_free$1,
        __wbg_prooferasedoutput_free: __wbg_prooferasedoutput_free$1,
        __wbg_prooferasedtransaction_free: __wbg_prooferasedtransaction_free$1,
        __wbg_prooferasedtransient_free: __wbg_prooferasedtransient_free$1,
        __wbg_secretkeys_free: __wbg_secretkeys_free$1,
        __wbg_systemtransaction_free: __wbg_systemtransaction_free$1,
        __wbg_transaction_free: __wbg_transaction_free$1,
        __wbg_transactioncostmodel_free: __wbg_transactioncostmodel_free$1,
        __wbg_transient_free: __wbg_transient_free$1,
        __wbg_unprovenauthorizedmint_free: __wbg_unprovenauthorizedmint_free$1,
        __wbg_unproveninput_free: __wbg_unproveninput_free$1,
        __wbg_unprovenoffer_free: __wbg_unprovenoffer_free$1,
        __wbg_unprovenoutput_free: __wbg_unprovenoutput_free$1,
        __wbg_unproventransaction_free: __wbg_unproventransaction_free$1,
        __wbg_unproventransient_free: __wbg_unproventransient_free$1,
        __wbg_zswapchainstate_free: __wbg_zswapchainstate_free$1,
        __wbindgen_exn_store: __wbindgen_exn_store$1,
        __wbindgen_export_4: __wbindgen_export_4$1,
        __wbindgen_export_5: __wbindgen_export_5$1,
        __wbindgen_free: __wbindgen_free$1,
        __wbindgen_malloc: __wbindgen_malloc$1,
        __wbindgen_realloc: __wbindgen_realloc$1,
        __wbindgen_start: __wbindgen_start$1,
        authorizedmint_coin: authorizedmint_coin$1,
        authorizedmint_deserialize: authorizedmint_deserialize$1,
        authorizedmint_eraseProof: authorizedmint_eraseProof$1,
        authorizedmint_new: authorizedmint_new$1,
        authorizedmint_recipient: authorizedmint_recipient$1,
        authorizedmint_serialize: authorizedmint_serialize$1,
        authorizedmint_toString: authorizedmint_toString$1,
        closure648_externref_shim: closure648_externref_shim$1,
        closure684_externref_shim: closure684_externref_shim$1,
        closure688_externref_shim: closure688_externref_shim$1,
        coin_commitment: coin_commitment$1,
        coin_nullifier: coin_nullifier$1,
        coinsecretkey_new: coinsecretkey_new$1,
        coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize: coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$1,
        contractaddress_deserialize_raw: contractaddress_deserialize_raw$1,
        createCoinInfo: createCoinInfo$1,
        encryptionsecretkey_deserialize: encryptionsecretkey_deserialize$1,
        encryptionsecretkey_deserialize_raw: encryptionsecretkey_deserialize_raw$1,
        encryptionsecretkey_new: encryptionsecretkey_new$1,
        encryptionsecretkey_test: encryptionsecretkey_test$1,
        encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize: encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize$1,
        input_contractAddress: input_contractAddress$1,
        input_deserialize: input_deserialize$1,
        input_new: input_new$1,
        input_nullifier: input_nullifier$1,
        input_serialize: input_serialize$1,
        input_toString: input_toString$1,
        intounderlyingbytesource_autoAllocateChunkSize: intounderlyingbytesource_autoAllocateChunkSize$1,
        intounderlyingbytesource_cancel: intounderlyingbytesource_cancel$1,
        intounderlyingbytesource_pull: intounderlyingbytesource_pull$1,
        intounderlyingbytesource_start: intounderlyingbytesource_start$1,
        intounderlyingbytesource_type: intounderlyingbytesource_type$1,
        intounderlyingsink_abort: intounderlyingsink_abort$1,
        intounderlyingsink_close: intounderlyingsink_close$1,
        intounderlyingsink_write: intounderlyingsink_write$1,
        intounderlyingsource_cancel: intounderlyingsource_cancel$1,
        intounderlyingsource_pull: intounderlyingsource_pull$1,
        ledgerparameters_deserialize: ledgerparameters_deserialize$1,
        ledgerparameters_dummyParameters: ledgerparameters_dummyParameters$1,
        ledgerparameters_new: ledgerparameters_new$1,
        ledgerparameters_serialize: ledgerparameters_serialize$1,
        ledgerparameters_toString: ledgerparameters_toString$1,
        ledgerparameters_transactionCostModel: ledgerparameters_transactionCostModel$1,
        localstate_apply: localstate_apply$1,
        localstate_applyCollapsedUpdate: localstate_applyCollapsedUpdate$1,
        localstate_applyFailed: localstate_applyFailed$1,
        localstate_applyFailedProofErased: localstate_applyFailedProofErased$1,
        localstate_applyMint: localstate_applyMint$1,
        localstate_applyProofErased: localstate_applyProofErased$1,
        localstate_applyProofErasedMint: localstate_applyProofErasedMint$1,
        localstate_applyProofErasedTx: localstate_applyProofErasedTx$1,
        localstate_applySystemTx: localstate_applySystemTx$1,
        localstate_applyTx: localstate_applyTx$1,
        localstate_authorizeMint: localstate_authorizeMint$1,
        localstate_coins: localstate_coins$1,
        localstate_deserialize: localstate_deserialize$1,
        localstate_firstFree: localstate_firstFree$1,
        localstate_new: localstate_new$1,
        localstate_pendingOutputs: localstate_pendingOutputs$1,
        localstate_pendingSpends: localstate_pendingSpends$1,
        localstate_serialize: localstate_serialize$1,
        localstate_spend: localstate_spend$1,
        localstate_spendFromOutput: localstate_spendFromOutput$1,
        localstate_toString: localstate_toString$1,
        localstate_watchFor: localstate_watchFor$1,
        memory: memory$1,
        merkletreecollapsedupdate_deserialize: merkletreecollapsedupdate_deserialize$1,
        merkletreecollapsedupdate_new: merkletreecollapsedupdate_new$1,
        merkletreecollapsedupdate_new_raw: merkletreecollapsedupdate_new_raw$1,
        merkletreecollapsedupdate_serialize: merkletreecollapsedupdate_serialize$1,
        merkletreecollapsedupdate_serialize_raw: merkletreecollapsedupdate_serialize_raw$1,
        merkletreecollapsedupdate_toString: merkletreecollapsedupdate_toString$1,
        nativeToken: nativeToken$1,
        offer_deltas: offer_deltas$1,
        offer_deserialize: offer_deserialize$1,
        offer_deserialize_raw: offer_deserialize_raw$1,
        offer_inputs: offer_inputs$1,
        offer_merge: offer_merge$1,
        offer_new: offer_new$1,
        offer_outputs: offer_outputs$1,
        offer_serialize: offer_serialize$1,
        offer_serialize_raw: offer_serialize_raw$1,
        offer_toString: offer_toString$1,
        offer_transient: offer_transient$1,
        output_commitment: output_commitment$1,
        output_contractAddress: output_contractAddress$1,
        output_deserialize: output_deserialize$1,
        output_new: output_new$1,
        output_serialize: output_serialize$1,
        output_toString: output_toString$1,
        prooferasedauthorizedmint_coin: prooferasedauthorizedmint_coin$1,
        prooferasedauthorizedmint_deserialize: prooferasedauthorizedmint_deserialize$1,
        prooferasedauthorizedmint_new: prooferasedauthorizedmint_new$1,
        prooferasedauthorizedmint_recipient: prooferasedauthorizedmint_recipient$1,
        prooferasedauthorizedmint_serialize: prooferasedauthorizedmint_serialize$1,
        prooferasedauthorizedmint_toString: prooferasedauthorizedmint_toString$1,
        prooferasedinput_contractAddress: prooferasedinput_contractAddress$1,
        prooferasedinput_deserialize: prooferasedinput_deserialize$1,
        prooferasedinput_new: prooferasedinput_new$1,
        prooferasedinput_nullifier: prooferasedinput_nullifier$1,
        prooferasedinput_serialize: prooferasedinput_serialize$1,
        prooferasedinput_toString: prooferasedinput_toString$1,
        prooferasedoffer_deltas: prooferasedoffer_deltas$1,
        prooferasedoffer_deserialize: prooferasedoffer_deserialize$1,
        prooferasedoffer_inputs: prooferasedoffer_inputs$1,
        prooferasedoffer_merge: prooferasedoffer_merge$1,
        prooferasedoffer_new: prooferasedoffer_new$1,
        prooferasedoffer_outputs: prooferasedoffer_outputs$1,
        prooferasedoffer_serialize: prooferasedoffer_serialize$1,
        prooferasedoffer_toString: prooferasedoffer_toString$1,
        prooferasedoffer_transient: prooferasedoffer_transient$1,
        prooferasedoutput_commitment: prooferasedoutput_commitment$1,
        prooferasedoutput_contractAddress: prooferasedoutput_contractAddress$1,
        prooferasedoutput_deserialize: prooferasedoutput_deserialize$1,
        prooferasedoutput_new: prooferasedoutput_new$1,
        prooferasedoutput_serialize: prooferasedoutput_serialize$1,
        prooferasedoutput_toString: prooferasedoutput_toString$1,
        prooferasedtransaction_deserialize: prooferasedtransaction_deserialize$1,
        prooferasedtransaction_fallibleCoins: prooferasedtransaction_fallibleCoins$1,
        prooferasedtransaction_fees: prooferasedtransaction_fees$1,
        prooferasedtransaction_guaranteedCoins: prooferasedtransaction_guaranteedCoins$1,
        prooferasedtransaction_identifiers: prooferasedtransaction_identifiers$1,
        prooferasedtransaction_imbalances: prooferasedtransaction_imbalances$1,
        prooferasedtransaction_merge: prooferasedtransaction_merge$1,
        prooferasedtransaction_mint: prooferasedtransaction_mint$1,
        prooferasedtransaction_new: prooferasedtransaction_new$1,
        prooferasedtransaction_serialize: prooferasedtransaction_serialize$1,
        prooferasedtransaction_toString: prooferasedtransaction_toString$1,
        prooferasedtransient_commitment: prooferasedtransient_commitment$1,
        prooferasedtransient_contractAddress: prooferasedtransient_contractAddress$1,
        prooferasedtransient_deserialize: prooferasedtransient_deserialize$1,
        prooferasedtransient_new: prooferasedtransient_new$1,
        prooferasedtransient_nullifier: prooferasedtransient_nullifier$1,
        prooferasedtransient_serialize: prooferasedtransient_serialize$1,
        prooferasedtransient_toString: prooferasedtransient_toString$1,
        sampleCoinPublicKey: sampleCoinPublicKey$1,
        sampleContractAddress: sampleContractAddress$1,
        sampleEncryptionPublicKey: sampleEncryptionPublicKey$1,
        sampleTokenType: sampleTokenType$1,
        secretkeys_coinPublicKey: secretkeys_coinPublicKey$1,
        secretkeys_coinSecretKey: secretkeys_coinSecretKey$1,
        secretkeys_encryptionPublicKey: secretkeys_encryptionPublicKey$1,
        secretkeys_encryptionSecretKey: secretkeys_encryptionSecretKey$1,
        secretkeys_fromSeed: secretkeys_fromSeed$1,
        secretkeys_fromSeedRng: secretkeys_fromSeedRng$1,
        secretkeys_new: secretkeys_new$1,
        systemtransaction_deserialize: systemtransaction_deserialize$1,
        systemtransaction_new: systemtransaction_new$1,
        systemtransaction_serialize: systemtransaction_serialize$1,
        systemtransaction_toString: systemtransaction_toString$1,
        transaction_deserialize: transaction_deserialize$1,
        transaction_eraseProofs: transaction_eraseProofs$1,
        transaction_fallibleCoins: transaction_fallibleCoins$1,
        transaction_fees: transaction_fees$1,
        transaction_fromUnproven: transaction_fromUnproven$1,
        transaction_guaranteedCoins: transaction_guaranteedCoins$1,
        transaction_identifiers: transaction_identifiers$1,
        transaction_imbalances: transaction_imbalances$1,
        transaction_merge: transaction_merge$1,
        transaction_mint: transaction_mint$1,
        transaction_new: transaction_new$1,
        transaction_serialize: transaction_serialize$1,
        transaction_toString: transaction_toString$1,
        transaction_transactionHash: transaction_transactionHash$1,
        transactioncostmodel_deserialize: transactioncostmodel_deserialize$1,
        transactioncostmodel_dummyTransactionCostModel: transactioncostmodel_dummyTransactionCostModel$1,
        transactioncostmodel_inputFeeOverhead: transactioncostmodel_inputFeeOverhead$1,
        transactioncostmodel_new: transactioncostmodel_new$1,
        transactioncostmodel_outputFeeOverhead: transactioncostmodel_outputFeeOverhead$1,
        transactioncostmodel_serialize: transactioncostmodel_serialize$1,
        transactioncostmodel_toString: transactioncostmodel_toString$1,
        transient_commitment: transient_commitment$1,
        transient_contractAddress: transient_contractAddress$1,
        transient_deserialize: transient_deserialize$1,
        transient_new: transient_new$1,
        transient_nullifier: transient_nullifier$1,
        transient_serialize: transient_serialize$1,
        transient_toString: transient_toString$1,
        unprovenauthorizedmint_coin: unprovenauthorizedmint_coin$1,
        unprovenauthorizedmint_deserialize: unprovenauthorizedmint_deserialize$1,
        unprovenauthorizedmint_eraseProof: unprovenauthorizedmint_eraseProof$1,
        unprovenauthorizedmint_new: unprovenauthorizedmint_new$1,
        unprovenauthorizedmint_recipient: unprovenauthorizedmint_recipient$1,
        unprovenauthorizedmint_serialize: unprovenauthorizedmint_serialize$1,
        unprovenauthorizedmint_toString: unprovenauthorizedmint_toString$1,
        unproveninput_contractAddress: unproveninput_contractAddress$1,
        unproveninput_deserialize: unproveninput_deserialize$1,
        unproveninput_new: unproveninput_new$1,
        unproveninput_newContractOwned: unproveninput_newContractOwned$1,
        unproveninput_nullifier: unproveninput_nullifier$1,
        unproveninput_serialize: unproveninput_serialize$1,
        unproveninput_toString: unproveninput_toString$1,
        unprovenoffer_deltas: unprovenoffer_deltas$1,
        unprovenoffer_deserialize: unprovenoffer_deserialize$1,
        unprovenoffer_fromInput: unprovenoffer_fromInput$1,
        unprovenoffer_fromOutput: unprovenoffer_fromOutput$1,
        unprovenoffer_fromTransient: unprovenoffer_fromTransient$1,
        unprovenoffer_inputs: unprovenoffer_inputs$1,
        unprovenoffer_merge: unprovenoffer_merge$1,
        unprovenoffer_new: unprovenoffer_new$1,
        unprovenoffer_outputs: unprovenoffer_outputs$1,
        unprovenoffer_serialize: unprovenoffer_serialize$1,
        unprovenoffer_toString: unprovenoffer_toString$1,
        unprovenoffer_transient: unprovenoffer_transient$1,
        unprovenoutput_commitment: unprovenoutput_commitment$1,
        unprovenoutput_construct: unprovenoutput_construct$1,
        unprovenoutput_contractAddress: unprovenoutput_contractAddress$1,
        unprovenoutput_deserialize: unprovenoutput_deserialize$1,
        unprovenoutput_new: unprovenoutput_new$1,
        unprovenoutput_newContractOwned: unprovenoutput_newContractOwned$1,
        unprovenoutput_serialize: unprovenoutput_serialize$1,
        unprovenoutput_toString: unprovenoutput_toString$1,
        unproventransaction_deserialize: unproventransaction_deserialize$1,
        unproventransaction_eraseProofs: unproventransaction_eraseProofs$1,
        unproventransaction_fallibleCoins: unproventransaction_fallibleCoins$1,
        unproventransaction_fromMint: unproventransaction_fromMint$1,
        unproventransaction_guaranteedCoins: unproventransaction_guaranteedCoins$1,
        unproventransaction_identifiers: unproventransaction_identifiers$1,
        unproventransaction_merge: unproventransaction_merge$1,
        unproventransaction_mint: unproventransaction_mint$1,
        unproventransaction_new: unproventransaction_new$1,
        unproventransaction_serialize: unproventransaction_serialize$1,
        unproventransaction_toString: unproventransaction_toString$1,
        unproventransient_commitment: unproventransient_commitment$1,
        unproventransient_contractAddress: unproventransient_contractAddress$1,
        unproventransient_deserialize: unproventransient_deserialize$1,
        unproventransient_new: unproventransient_new$1,
        unproventransient_newFromContractOwnedOutput: unproventransient_newFromContractOwnedOutput$1,
        unproventransient_nullifier: unproventransient_nullifier$1,
        unproventransient_serialize: unproventransient_serialize$1,
        unproventransient_toString: unproventransient_toString$1,
        zswapchainstate_deserialize: zswapchainstate_deserialize$1,
        zswapchainstate_deserializeFromLedgerState: zswapchainstate_deserializeFromLedgerState$1,
        zswapchainstate_deserialize_raw: zswapchainstate_deserialize_raw$1,
        zswapchainstate_filter: zswapchainstate_filter$1,
        zswapchainstate_firstFree: zswapchainstate_firstFree$1,
        zswapchainstate_merkle_tree_root: zswapchainstate_merkle_tree_root$1,
        zswapchainstate_new: zswapchainstate_new$1,
        zswapchainstate_serialize: zswapchainstate_serialize$1,
        zswapchainstate_serialize_raw: zswapchainstate_serialize_raw$1,
        zswapchainstate_toString: zswapchainstate_toString$1,
        zswapchainstate_tryApply: zswapchainstate_tryApply$1,
        zswapchainstate_tryApplyProofErased: zswapchainstate_tryApplyProofErased$1,
        zswapchainstate_tryApplyWithoutWhitelist: zswapchainstate_tryApplyWithoutWhitelist$1
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    __wbg_set_wasm$1(wasm$2);
    __wbindgen_start$1();
    var NetworkId;
    (function(NetworkId) {
        NetworkId["Undeployed"] = "Undeployed";
        NetworkId["DevNet"] = "DevNet";
        NetworkId["TestNet"] = "TestNet";
        NetworkId["MainNet"] = "MainNet";
    })(NetworkId || (NetworkId = {}));
    class NetworkIdTypeError extends TypeError {
        networkId;
        constructor(networkId){
            super(`Invalid network ID: '${networkId}'. Must be one of: ${Object.values(NetworkId).join(', ')}`);
            this.networkId = networkId;
        }
    }
    const toLedgerNetworkId = (id)=>{
        switch(id){
            case NetworkId.Undeployed:
                return NetworkId$2.Undeployed;
            case NetworkId.DevNet:
                return NetworkId$2.DevNet;
            case NetworkId.TestNet:
                return NetworkId$2.TestNet;
            case NetworkId.MainNet:
                return NetworkId$2.MainNet;
            default:
                throw new NetworkIdTypeError(String(id));
        }
    };
    const toRuntimeNetworkId = (id)=>{
        switch(id){
            case NetworkId.Undeployed:
                return runtimeExports.NetworkId.Undeployed;
            case NetworkId.DevNet:
                return runtimeExports.NetworkId.DevNet;
            case NetworkId.TestNet:
                return runtimeExports.NetworkId.TestNet;
            case NetworkId.MainNet:
                return runtimeExports.NetworkId.MainNet;
            default:
                throw new NetworkIdTypeError(String(id));
        }
    };
    const toZswapNetworkId = (id)=>{
        switch(id){
            case NetworkId.Undeployed:
                return NetworkId$1.Undeployed;
            case NetworkId.DevNet:
                return NetworkId$1.DevNet;
            case NetworkId.TestNet:
                return NetworkId$1.TestNet;
            case NetworkId.MainNet:
                return NetworkId$1.MainNet;
            default:
                throw new NetworkIdTypeError(String(id));
        }
    };
    let currentNetworkId = NetworkId.Undeployed;
    const getNetworkId = ()=>currentNetworkId;
    const getRuntimeNetworkId = ()=>toRuntimeNetworkId(getNetworkId());
    const getLedgerNetworkId = ()=>toLedgerNetworkId(getNetworkId());
    const getZswapNetworkId = ()=>toZswapNetworkId(getNetworkId());
    const networkIdToHex = (networkId)=>{
        switch(networkId){
            case NetworkId.Undeployed:
                return '00';
            case NetworkId.DevNet:
                return '01';
            case NetworkId.TestNet:
                return '02';
            case NetworkId.MainNet:
                return '04';
            default:
                throw new NetworkIdTypeError(String(networkId));
        }
    };
    const retryOptions = {
        retries: 3,
        retryDelay: (attempt)=>2 ** attempt * 1000,
        retryOn: [
            500,
            503
        ]
    };
    const fetchRetry = fetchBuilder(fetch$1, retryOptions);
    const serializeZKConfig = (zkConfig)=>{
        const binaryWriter = new BinaryWriter();
        if (zkConfig) {
            binaryWriter.u32(1);
            binaryWriter.string(zkConfig.circuitId);
            BinaryWriter.uint8ArrayFixed(zkConfig.proverKey, binaryWriter);
            BinaryWriter.uint8ArrayFixed(zkConfig.verifierKey, binaryWriter);
            BinaryWriter.uint8ArrayFixed(zkConfig.zkir, binaryWriter);
        } else {
            binaryWriter.u32(0);
        }
        return binaryWriter.finalize();
    };
    const serializePayload = (unprovenTx, zkConfig)=>new Blob([
            unprovenTx.serialize(getLedgerNetworkId()),
            serializeZKConfig(zkConfig)
        ]).arrayBuffer();
    const deserializePayload = (arrayBuffer)=>createUnbalancedTx(Transaction$2.deserialize(new Uint8Array(arrayBuffer), getLedgerNetworkId()));
    const PROVE_TX_PATH = '/prove-tx';
    const DEFAULT_CONFIG = {
        timeout: 300000,
        zkConfig: undefined
    };
    const httpClientProofProvider = (url)=>{
        const urlObject = new URL(PROVE_TX_PATH, url);
        if (urlObject.protocol !== 'http:' && urlObject.protocol !== 'https:') {
            throw new InvalidProtocolSchemeError(urlObject.protocol, [
                'http:',
                'https:'
            ]);
        }
        return {
            async proveTx (unprovenTx, partialProveTxConfig) {
                const config = _.defaults(partialProveTxConfig, DEFAULT_CONFIG);
                const response = await fetchRetry(urlObject, {
                    method: 'POST',
                    body: await serializePayload(unprovenTx, config.zkConfig),
                    signal: AbortSignal.timeout(config.timeout)
                });
                if (!response.ok) {
                    throw new Error(`Failed Proof Server response: url="${response.url}", code="${response.status}", status="${response.statusText}""`);
                }
                return deserializePayload(await response.arrayBuffer());
            }
        };
    };
    var core$2 = {};
    const require$$0$1 = getAugmentedNamespace(tslib_es6$1);
    var genericMessage = "Invariant Violation";
    var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function(obj, proto) {
        obj.__proto__ = proto;
        return obj;
    } : _a;
    var InvariantError = (function(_super) {
        __extends(InvariantError, _super);
        function InvariantError(message) {
            if (message === void 0) {
                message = genericMessage;
            }
            var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
            _this.framesToPop = 1;
            _this.name = genericMessage;
            setPrototypeOf(_this, InvariantError.prototype);
            return _this;
        }
        return InvariantError;
    }(Error));
    function invariant$2(condition, message) {
        if (!condition) {
            throw new InvariantError(message);
        }
    }
    var verbosityLevels = [
        "debug",
        "log",
        "warn",
        "error",
        "silent"
    ];
    var verbosityLevel = verbosityLevels.indexOf("log");
    function wrapConsoleMethod(name) {
        return function() {
            if (verbosityLevels.indexOf(name) >= verbosityLevel) {
                var method = console[name] || console.log;
                return method.apply(console, arguments);
            }
        };
    }
    (function(invariant) {
        invariant.debug = wrapConsoleMethod("debug");
        invariant.log = wrapConsoleMethod("log");
        invariant.warn = wrapConsoleMethod("warn");
        invariant.error = wrapConsoleMethod("error");
    })(invariant$2 || (invariant$2 = {}));
    function setVerbosity(level) {
        var old = verbosityLevels[verbosityLevel];
        verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
        return old;
    }
    const invariant$3 = invariant$2;
    const invariant$4 = Object.freeze(Object.defineProperty({
        __proto__: null,
        InvariantError,
        default: invariant$3,
        get invariant () {
            return invariant$2;
        },
        setVerbosity
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    var version$1 = "3.14.0";
    function maybe$1(thunk) {
        try {
            return thunk();
        } catch (_a) {}
    }
    const untypedGlobal = (maybe$1(function() {
        return globalThis;
    }) || maybe$1(function() {
        return window;
    }) || maybe$1(function() {
        return self;
    }) || maybe$1(function() {
        return global;
    }) || maybe$1(function() {
        return maybe$1.constructor("return this")();
    }));
    var prefixCounts = new Map();
    function makeUniqueId(prefix) {
        var count = prefixCounts.get(prefix) || 1;
        prefixCounts.set(prefix, count + 1);
        return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
    }
    function stringifyForDisplay(value, space) {
        if (space === void 0) {
            space = 0;
        }
        var undefId = makeUniqueId("stringifyForDisplay");
        return JSON.stringify(value, function(key, value) {
            return value === void 0 ? undefId : value;
        }, space).split(JSON.stringify(undefId)).join("<undefined>");
    }
    function wrap$2(fn) {
        return function(message) {
            var args = [];
            for(var _i = 1; _i < arguments.length; _i++){
                args[_i - 1] = arguments[_i];
            }
            if (typeof message === "number") {
                var arg0 = message;
                message = getHandledErrorMsg(arg0);
                if (!message) {
                    message = getFallbackErrorMsg(arg0, args);
                    args = [];
                }
            }
            fn.apply(void 0, [
                message
            ].concat(args));
        };
    }
    var invariant$1 = Object.assign(function invariant(condition, message) {
        var args = [];
        for(var _i = 2; _i < arguments.length; _i++){
            args[_i - 2] = arguments[_i];
        }
        if (!condition) {
            invariant$2(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
        }
    }, {
        debug: wrap$2(invariant$2.debug),
        log: wrap$2(invariant$2.log),
        warn: wrap$2(invariant$2.warn),
        error: wrap$2(invariant$2.error)
    });
    function newInvariantError(message) {
        var optionalParams = [];
        for(var _i = 1; _i < arguments.length; _i++){
            optionalParams[_i - 1] = arguments[_i];
        }
        return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
    }
    var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version$1);
    function stringify(arg) {
        if (typeof arg == "string") {
            return arg;
        }
        try {
            return stringifyForDisplay(arg, 2).slice(0, 1000);
        } catch (_a) {
            return "<non-serializable>";
        }
    }
    function getHandledErrorMsg(message, messageArgs) {
        if (messageArgs === void 0) {
            messageArgs = [];
        }
        if (!message) return;
        return (untypedGlobal[ApolloErrorMessageHandler] && untypedGlobal[ApolloErrorMessageHandler](message, messageArgs.map(stringify)));
    }
    function getFallbackErrorMsg(message, messageArgs) {
        if (messageArgs === void 0) {
            messageArgs = [];
        }
        if (!message) return;
        return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
            version: version$1,
            message: message,
            args: messageArgs.map(stringify)
        })));
    }
    var DEV = globalThis.__DEV__ !== false;
    const globals = Object.freeze(Object.defineProperty({
        __proto__: null,
        DEV,
        InvariantError,
        __DEV__: DEV,
        global: untypedGlobal,
        invariant: invariant$1,
        maybe: maybe$1,
        newInvariantError
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    const require$$0 = getAugmentedNamespace(globals);
    const version = '16.11.0';
    const versionInfo = Object.freeze({
        major: 16,
        minor: 11,
        patch: 0,
        preReleaseTag: null
    });
    function devAssert(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
            throw new Error(message);
        }
    }
    function isPromise(value) {
        return (typeof (value === null || value === void 0 ? void 0 : value.then) === 'function');
    }
    function isObjectLike(value) {
        return typeof value == 'object' && value !== null;
    }
    function invariant(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
            throw new Error(message != null ? message : 'Unexpected invariant triggered.');
        }
    }
    const LineRegExp = /\r\n|[\n\r]/g;
    function getLocation(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match of source.body.matchAll(LineRegExp)){
            typeof match.index === 'number' || invariant(false);
            if (match.index >= position) {
                break;
            }
            lastLineStart = match.index + match[0].length;
            line += 1;
        }
        return {
            line,
            column: position + 1 - lastLineStart
        };
    }
    function printLocation(location) {
        return printSourceLocation(location.source, getLocation(location.source, location.start));
    }
    function printSourceLocation(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = ''.padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
            const subLineIndex = Math.floor(columnNum / 80);
            const subLineColumnNum = columnNum % 80;
            const subLines = [];
            for(let i = 0; i < locationLine.length; i += 80){
                subLines.push(locationLine.slice(i, i + 80));
            }
            return (locationStr + printPrefixedLines([
                [
                    `${lineNum} |`,
                    subLines[0]
                ],
                ...subLines.slice(1, subLineIndex + 1).map((subLine)=>[
                        '|',
                        subLine
                    ]),
                [
                    '|',
                    '^'.padStart(subLineColumnNum)
                ],
                [
                    '|',
                    subLines[subLineIndex + 1]
                ]
            ]));
        }
        return (locationStr + printPrefixedLines([
            [
                `${lineNum - 1} |`,
                lines[lineIndex - 1]
            ],
            [
                `${lineNum} |`,
                locationLine
            ],
            [
                '|',
                '^'.padStart(columnNum)
            ],
            [
                `${lineNum + 1} |`,
                lines[lineIndex + 1]
            ]
        ]));
    }
    function printPrefixedLines(lines) {
        const existingLines = lines.filter(([_, line])=>line !== undefined);
        const padLen = Math.max(...existingLines.map(([prefix])=>prefix.length));
        return existingLines.map(([prefix, line])=>prefix.padStart(padLen) + (line ? ' ' + line : '')).join('\n');
    }
    function toNormalizedOptions(args) {
        const firstArg = args[0];
        if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {
            return {
                nodes: firstArg,
                source: args[1],
                positions: args[2],
                path: args[3],
                originalError: args[4],
                extensions: args[5]
            };
        }
        return firstArg;
    }
    class GraphQLError extends Error {
        constructor(message, ...rawArgs){
            var _this$nodes, _nodeLocations$, _ref;
            const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
            super(message);
            this.name = 'GraphQLError';
            this.path = path !== null && path !== void 0 ? path : undefined;
            this.originalError = originalError !== null && originalError !== void 0 ? originalError : undefined;
            this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [
                nodes
            ] : undefined);
            const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node)=>node.loc).filter((loc)=>loc != null));
            this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
            this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc)=>loc.start);
            this.locations = positions && source ? positions.map((pos)=>getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc)=>getLocation(loc.source, loc.start));
            const originalExtensions = isObjectLike(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : undefined;
            this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : Object.create(null);
            Object.defineProperties(this, {
                message: {
                    writable: true,
                    enumerable: true
                },
                name: {
                    enumerable: false
                },
                nodes: {
                    enumerable: false
                },
                source: {
                    enumerable: false
                },
                positions: {
                    enumerable: false
                },
                originalError: {
                    enumerable: false
                }
            });
            if (originalError !== null && originalError !== void 0 && originalError.stack) {
                Object.defineProperty(this, 'stack', {
                    value: originalError.stack,
                    writable: true,
                    configurable: true
                });
            } else if (Error.captureStackTrace) {
                Error.captureStackTrace(this, GraphQLError);
            } else {
                Object.defineProperty(this, 'stack', {
                    value: Error().stack,
                    writable: true,
                    configurable: true
                });
            }
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLError';
        }
        toString() {
            let output = this.message;
            if (this.nodes) {
                for (const node of this.nodes){
                    if (node.loc) {
                        output += '\n\n' + printLocation(node.loc);
                    }
                }
            } else if (this.source && this.locations) {
                for (const location of this.locations){
                    output += '\n\n' + printSourceLocation(this.source, location);
                }
            }
            return output;
        }
        toJSON() {
            const formattedError = {
                message: this.message
            };
            if (this.locations != null) {
                formattedError.locations = this.locations;
            }
            if (this.path != null) {
                formattedError.path = this.path;
            }
            if (this.extensions != null && Object.keys(this.extensions).length > 0) {
                formattedError.extensions = this.extensions;
            }
            return formattedError;
        }
    }
    function undefinedIfEmpty(array) {
        return array === undefined || array.length === 0 ? undefined : array;
    }
    function printError(error) {
        return error.toString();
    }
    function formatError(error) {
        return error.toJSON();
    }
    function syntaxError(source, position, description) {
        return new GraphQLError(`Syntax Error: ${description}`, {
            source,
            positions: [
                position
            ]
        });
    }
    class Location {
        constructor(startToken, endToken, source){
            this.start = startToken.start;
            this.end = endToken.end;
            this.startToken = startToken;
            this.endToken = endToken;
            this.source = source;
        }
        get [Symbol.toStringTag]() {
            return 'Location';
        }
        toJSON() {
            return {
                start: this.start,
                end: this.end
            };
        }
    }
    class Token {
        constructor(kind, start, end, line, column, value){
            this.kind = kind;
            this.start = start;
            this.end = end;
            this.line = line;
            this.column = column;
            this.value = value;
            this.prev = null;
            this.next = null;
        }
        get [Symbol.toStringTag]() {
            return 'Token';
        }
        toJSON() {
            return {
                kind: this.kind,
                value: this.value,
                line: this.line,
                column: this.column
            };
        }
    }
    const QueryDocumentKeys = {
        Name: [],
        Document: [
            'definitions'
        ],
        OperationDefinition: [
            'name',
            'variableDefinitions',
            'directives',
            'selectionSet'
        ],
        VariableDefinition: [
            'variable',
            'type',
            'defaultValue',
            'directives'
        ],
        Variable: [
            'name'
        ],
        SelectionSet: [
            'selections'
        ],
        Field: [
            'alias',
            'name',
            'arguments',
            'directives',
            'selectionSet'
        ],
        Argument: [
            'name',
            'value'
        ],
        FragmentSpread: [
            'name',
            'directives'
        ],
        InlineFragment: [
            'typeCondition',
            'directives',
            'selectionSet'
        ],
        FragmentDefinition: [
            'name',
            'variableDefinitions',
            'typeCondition',
            'directives',
            'selectionSet'
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: [
            'values'
        ],
        ObjectValue: [
            'fields'
        ],
        ObjectField: [
            'name',
            'value'
        ],
        Directive: [
            'name',
            'arguments'
        ],
        NamedType: [
            'name'
        ],
        ListType: [
            'type'
        ],
        NonNullType: [
            'type'
        ],
        SchemaDefinition: [
            'description',
            'directives',
            'operationTypes'
        ],
        OperationTypeDefinition: [
            'type'
        ],
        ScalarTypeDefinition: [
            'description',
            'name',
            'directives'
        ],
        ObjectTypeDefinition: [
            'description',
            'name',
            'interfaces',
            'directives',
            'fields'
        ],
        FieldDefinition: [
            'description',
            'name',
            'arguments',
            'type',
            'directives'
        ],
        InputValueDefinition: [
            'description',
            'name',
            'type',
            'defaultValue',
            'directives'
        ],
        InterfaceTypeDefinition: [
            'description',
            'name',
            'interfaces',
            'directives',
            'fields'
        ],
        UnionTypeDefinition: [
            'description',
            'name',
            'directives',
            'types'
        ],
        EnumTypeDefinition: [
            'description',
            'name',
            'directives',
            'values'
        ],
        EnumValueDefinition: [
            'description',
            'name',
            'directives'
        ],
        InputObjectTypeDefinition: [
            'description',
            'name',
            'directives',
            'fields'
        ],
        DirectiveDefinition: [
            'description',
            'name',
            'arguments',
            'locations'
        ],
        SchemaExtension: [
            'directives',
            'operationTypes'
        ],
        ScalarTypeExtension: [
            'name',
            'directives'
        ],
        ObjectTypeExtension: [
            'name',
            'interfaces',
            'directives',
            'fields'
        ],
        InterfaceTypeExtension: [
            'name',
            'interfaces',
            'directives',
            'fields'
        ],
        UnionTypeExtension: [
            'name',
            'directives',
            'types'
        ],
        EnumTypeExtension: [
            'name',
            'directives',
            'values'
        ],
        InputObjectTypeExtension: [
            'name',
            'directives',
            'fields'
        ]
    };
    const kindValues = new Set(Object.keys(QueryDocumentKeys));
    function isNode(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === 'string' && kindValues.has(maybeKind);
    }
    var OperationTypeNode;
    (function(OperationTypeNode) {
        OperationTypeNode['QUERY'] = 'query';
        OperationTypeNode['MUTATION'] = 'mutation';
        OperationTypeNode['SUBSCRIPTION'] = 'subscription';
    })(OperationTypeNode || (OperationTypeNode = {}));
    var DirectiveLocation;
    (function(DirectiveLocation) {
        DirectiveLocation['QUERY'] = 'QUERY';
        DirectiveLocation['MUTATION'] = 'MUTATION';
        DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';
        DirectiveLocation['FIELD'] = 'FIELD';
        DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';
        DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';
        DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';
        DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';
        DirectiveLocation['SCHEMA'] = 'SCHEMA';
        DirectiveLocation['SCALAR'] = 'SCALAR';
        DirectiveLocation['OBJECT'] = 'OBJECT';
        DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';
        DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';
        DirectiveLocation['INTERFACE'] = 'INTERFACE';
        DirectiveLocation['UNION'] = 'UNION';
        DirectiveLocation['ENUM'] = 'ENUM';
        DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';
        DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';
        DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';
    })(DirectiveLocation || (DirectiveLocation = {}));
    var Kind;
    (function(Kind) {
        Kind['NAME'] = 'Name';
        Kind['DOCUMENT'] = 'Document';
        Kind['OPERATION_DEFINITION'] = 'OperationDefinition';
        Kind['VARIABLE_DEFINITION'] = 'VariableDefinition';
        Kind['SELECTION_SET'] = 'SelectionSet';
        Kind['FIELD'] = 'Field';
        Kind['ARGUMENT'] = 'Argument';
        Kind['FRAGMENT_SPREAD'] = 'FragmentSpread';
        Kind['INLINE_FRAGMENT'] = 'InlineFragment';
        Kind['FRAGMENT_DEFINITION'] = 'FragmentDefinition';
        Kind['VARIABLE'] = 'Variable';
        Kind['INT'] = 'IntValue';
        Kind['FLOAT'] = 'FloatValue';
        Kind['STRING'] = 'StringValue';
        Kind['BOOLEAN'] = 'BooleanValue';
        Kind['NULL'] = 'NullValue';
        Kind['ENUM'] = 'EnumValue';
        Kind['LIST'] = 'ListValue';
        Kind['OBJECT'] = 'ObjectValue';
        Kind['OBJECT_FIELD'] = 'ObjectField';
        Kind['DIRECTIVE'] = 'Directive';
        Kind['NAMED_TYPE'] = 'NamedType';
        Kind['LIST_TYPE'] = 'ListType';
        Kind['NON_NULL_TYPE'] = 'NonNullType';
        Kind['SCHEMA_DEFINITION'] = 'SchemaDefinition';
        Kind['OPERATION_TYPE_DEFINITION'] = 'OperationTypeDefinition';
        Kind['SCALAR_TYPE_DEFINITION'] = 'ScalarTypeDefinition';
        Kind['OBJECT_TYPE_DEFINITION'] = 'ObjectTypeDefinition';
        Kind['FIELD_DEFINITION'] = 'FieldDefinition';
        Kind['INPUT_VALUE_DEFINITION'] = 'InputValueDefinition';
        Kind['INTERFACE_TYPE_DEFINITION'] = 'InterfaceTypeDefinition';
        Kind['UNION_TYPE_DEFINITION'] = 'UnionTypeDefinition';
        Kind['ENUM_TYPE_DEFINITION'] = 'EnumTypeDefinition';
        Kind['ENUM_VALUE_DEFINITION'] = 'EnumValueDefinition';
        Kind['INPUT_OBJECT_TYPE_DEFINITION'] = 'InputObjectTypeDefinition';
        Kind['DIRECTIVE_DEFINITION'] = 'DirectiveDefinition';
        Kind['SCHEMA_EXTENSION'] = 'SchemaExtension';
        Kind['SCALAR_TYPE_EXTENSION'] = 'ScalarTypeExtension';
        Kind['OBJECT_TYPE_EXTENSION'] = 'ObjectTypeExtension';
        Kind['INTERFACE_TYPE_EXTENSION'] = 'InterfaceTypeExtension';
        Kind['UNION_TYPE_EXTENSION'] = 'UnionTypeExtension';
        Kind['ENUM_TYPE_EXTENSION'] = 'EnumTypeExtension';
        Kind['INPUT_OBJECT_TYPE_EXTENSION'] = 'InputObjectTypeExtension';
    })(Kind || (Kind = {}));
    function isWhiteSpace(code) {
        return code === 0x0009 || code === 0x0020;
    }
    function isDigit$1(code) {
        return code >= 0x0030 && code <= 0x0039;
    }
    function isLetter(code) {
        return ((code >= 0x0061 && code <= 0x007a) || (code >= 0x0041 && code <= 0x005a));
    }
    function isNameStart(code) {
        return isLetter(code) || code === 0x005f;
    }
    function isNameContinue(code) {
        return isLetter(code) || isDigit$1(code) || code === 0x005f;
    }
    function dedentBlockStringLines(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for(let i = 0; i < lines.length; ++i){
            var _firstNonEmptyLine;
            const line = lines[i];
            const indent = leadingWhitespace(line);
            if (indent === line.length) {
                continue;
            }
            firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
            lastNonEmptyLine = i;
            if (i !== 0 && indent < commonIndent) {
                commonIndent = indent;
            }
        }
        return lines.map((line, i)=>(i === 0 ? line : line.slice(commonIndent))).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
    }
    function leadingWhitespace(str) {
        let i = 0;
        while(i < str.length && isWhiteSpace(str.charCodeAt(i))){
            ++i;
        }
        return i;
    }
    function isPrintableAsBlockString(value) {
        if (value === '') {
            return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for(let i = 0; i < value.length; ++i){
            switch(value.codePointAt(i)){
                case 0x0000:
                case 0x0001:
                case 0x0002:
                case 0x0003:
                case 0x0004:
                case 0x0005:
                case 0x0006:
                case 0x0007:
                case 0x0008:
                case 0x000b:
                case 0x000c:
                case 0x000e:
                case 0x000f:
                    return false;
                case 0x000d:
                    return false;
                case 10:
                    if (isEmptyLine && !seenNonEmptyLine) {
                        return false;
                    }
                    seenNonEmptyLine = true;
                    isEmptyLine = true;
                    hasIndent = false;
                    break;
                case 9:
                case 32:
                    hasIndent || (hasIndent = isEmptyLine);
                    break;
                default:
                    hasCommonIndent && (hasCommonIndent = hasIndent);
                    isEmptyLine = false;
            }
        }
        if (isEmptyLine) {
            return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
            return false;
        }
        return true;
    }
    function printBlockString(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line)=>line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith('\\');
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = '';
        const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
        if ((printAsMultipleLines && !skipLeadingNewLine) || forceLeadingNewLine) {
            result += '\n';
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
            result += '\n';
        }
        return '"""' + result + '"""';
    }
    var TokenKind;
    (function(TokenKind) {
        TokenKind['SOF'] = '<SOF>';
        TokenKind['EOF'] = '<EOF>';
        TokenKind['BANG'] = '!';
        TokenKind['DOLLAR'] = '$';
        TokenKind['AMP'] = '&';
        TokenKind['PAREN_L'] = '(';
        TokenKind['PAREN_R'] = ')';
        TokenKind['SPREAD'] = '...';
        TokenKind['COLON'] = ':';
        TokenKind['EQUALS'] = '=';
        TokenKind['AT'] = '@';
        TokenKind['BRACKET_L'] = '[';
        TokenKind['BRACKET_R'] = ']';
        TokenKind['BRACE_L'] = '{';
        TokenKind['PIPE'] = '|';
        TokenKind['BRACE_R'] = '}';
        TokenKind['NAME'] = 'Name';
        TokenKind['INT'] = 'Int';
        TokenKind['FLOAT'] = 'Float';
        TokenKind['STRING'] = 'String';
        TokenKind['BLOCK_STRING'] = 'BlockString';
        TokenKind['COMMENT'] = 'Comment';
    })(TokenKind || (TokenKind = {}));
    class Lexer {
        constructor(source){
            const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
            this.source = source;
            this.lastToken = startOfFileToken;
            this.token = startOfFileToken;
            this.line = 1;
            this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
            return 'Lexer';
        }
        advance() {
            this.lastToken = this.token;
            const token = (this.token = this.lookahead());
            return token;
        }
        lookahead() {
            let token = this.token;
            if (token.kind !== TokenKind.EOF) {
                do {
                    if (token.next) {
                        token = token.next;
                    } else {
                        const nextToken = readNextToken(this, token.end);
                        token.next = nextToken;
                        nextToken.prev = token;
                        token = nextToken;
                    }
                }while (token.kind === TokenKind.COMMENT);
            }
            return token;
        }
    }
    function isPunctuatorTokenKind(kind) {
        return (kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R);
    }
    function isUnicodeScalarValue(code) {
        return ((code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff));
    }
    function isSupplementaryCodePoint(body, location) {
        return (isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1)));
    }
    function isLeadingSurrogate(code) {
        return code >= 0xd800 && code <= 0xdbff;
    }
    function isTrailingSurrogate(code) {
        return code >= 0xdc00 && code <= 0xdfff;
    }
    function printCodePointAt(lexer, location) {
        const code = lexer.source.body.codePointAt(location);
        if (code === undefined) {
            return TokenKind.EOF;
        } else if (code >= 0x0020 && code <= 0x007e) {
            const char = String.fromCodePoint(code);
            return char === '"' ? "'\"'" : `"${char}"`;
        }
        return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');
    }
    function createToken(lexer, kind, start, end, value) {
        const line = lexer.line;
        const col = 1 + start - lexer.lineStart;
        return new Token(kind, start, end, line, col, value);
    }
    function readNextToken(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start;
        while(position < bodyLength){
            const code = body.charCodeAt(position);
            switch(code){
                case 0xfeff:
                case 0x0009:
                case 0x0020:
                case 0x002c:
                    ++position;
                    continue;
                case 0x000a:
                    ++position;
                    ++lexer.line;
                    lexer.lineStart = position;
                    continue;
                case 0x000d:
                    if (body.charCodeAt(position + 1) === 0x000a) {
                        position += 2;
                    } else {
                        ++position;
                    }
                    ++lexer.line;
                    lexer.lineStart = position;
                    continue;
                case 0x0023:
                    return readComment(lexer, position);
                case 0x0021:
                    return createToken(lexer, TokenKind.BANG, position, position + 1);
                case 0x0024:
                    return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
                case 0x0026:
                    return createToken(lexer, TokenKind.AMP, position, position + 1);
                case 0x0028:
                    return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
                case 0x0029:
                    return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
                case 0x002e:
                    if (body.charCodeAt(position + 1) === 0x002e && body.charCodeAt(position + 2) === 0x002e) {
                        return createToken(lexer, TokenKind.SPREAD, position, position + 3);
                    }
                    break;
                case 0x003a:
                    return createToken(lexer, TokenKind.COLON, position, position + 1);
                case 0x003d:
                    return createToken(lexer, TokenKind.EQUALS, position, position + 1);
                case 0x0040:
                    return createToken(lexer, TokenKind.AT, position, position + 1);
                case 0x005b:
                    return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
                case 0x005d:
                    return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
                case 0x007b:
                    return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
                case 0x007c:
                    return createToken(lexer, TokenKind.PIPE, position, position + 1);
                case 0x007d:
                    return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
                case 0x0022:
                    if (body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {
                        return readBlockString(lexer, position);
                    }
                    return readString(lexer, position);
            }
            if (isDigit$1(code) || code === 0x002d) {
                return readNumber(lexer, position, code);
            }
            if (isNameStart(code)) {
                return readName(lexer, position);
            }
            throw syntaxError(lexer.source, position, code === 0x0027 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
        }
        return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
    }
    function readComment(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while(position < bodyLength){
            const code = body.charCodeAt(position);
            if (code === 0x000a || code === 0x000d) {
                break;
            }
            if (isUnicodeScalarValue(code)) {
                ++position;
            } else if (isSupplementaryCodePoint(body, position)) {
                position += 2;
            } else {
                break;
            }
        }
        return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
    }
    function readNumber(lexer, start, firstCode) {
        const body = lexer.source.body;
        let position = start;
        let code = firstCode;
        let isFloat = false;
        if (code === 0x002d) {
            code = body.charCodeAt(++position);
        }
        if (code === 0x0030) {
            code = body.charCodeAt(++position);
            if (isDigit$1(code)) {
                throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
            }
        } else {
            position = readDigits(lexer, position, code);
            code = body.charCodeAt(position);
        }
        if (code === 0x002e) {
            isFloat = true;
            code = body.charCodeAt(++position);
            position = readDigits(lexer, position, code);
            code = body.charCodeAt(position);
        }
        if (code === 0x0045 || code === 0x0065) {
            isFloat = true;
            code = body.charCodeAt(++position);
            if (code === 0x002b || code === 0x002d) {
                code = body.charCodeAt(++position);
            }
            position = readDigits(lexer, position, code);
            code = body.charCodeAt(position);
        }
        if (code === 0x002e || isNameStart(code)) {
            throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
        }
        return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
    }
    function readDigits(lexer, start, firstCode) {
        if (!isDigit$1(firstCode)) {
            throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
        }
        const body = lexer.source.body;
        let position = start + 1;
        while(isDigit$1(body.charCodeAt(position))){
            ++position;
        }
        return position;
    }
    function readString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        let chunkStart = position;
        let value = '';
        while(position < bodyLength){
            const code = body.charCodeAt(position);
            if (code === 0x0022) {
                value += body.slice(chunkStart, position);
                return createToken(lexer, TokenKind.STRING, start, position + 1, value);
            }
            if (code === 0x005c) {
                value += body.slice(chunkStart, position);
                const escape = body.charCodeAt(position + 1) === 0x0075 ? body.charCodeAt(position + 2) === 0x007b ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
                value += escape.value;
                position += escape.size;
                chunkStart = position;
                continue;
            }
            if (code === 0x000a || code === 0x000d) {
                break;
            }
            if (isUnicodeScalarValue(code)) {
                ++position;
            } else if (isSupplementaryCodePoint(body, position)) {
                position += 2;
            } else {
                throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
            }
        }
        throw syntaxError(lexer.source, position, 'Unterminated string.');
    }
    function readEscapedUnicodeVariableWidth(lexer, position) {
        const body = lexer.source.body;
        let point = 0;
        let size = 3;
        while(size < 12){
            const code = body.charCodeAt(position + size++);
            if (code === 0x007d) {
                if (size < 5 || !isUnicodeScalarValue(point)) {
                    break;
                }
                return {
                    value: String.fromCodePoint(point),
                    size
                };
            }
            point = (point << 4) | readHexDigit(code);
            if (point < 0) {
                break;
            }
        }
        throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
    }
    function readEscapedUnicodeFixedWidth(lexer, position) {
        const body = lexer.source.body;
        const code = read16BitHexCode(body, position + 2);
        if (isUnicodeScalarValue(code)) {
            return {
                value: String.fromCodePoint(code),
                size: 6
            };
        }
        if (isLeadingSurrogate(code)) {
            if (body.charCodeAt(position + 6) === 0x005c && body.charCodeAt(position + 7) === 0x0075) {
                const trailingCode = read16BitHexCode(body, position + 8);
                if (isTrailingSurrogate(trailingCode)) {
                    return {
                        value: String.fromCodePoint(code, trailingCode),
                        size: 12
                    };
                }
            }
        }
        throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
    }
    function read16BitHexCode(body, position) {
        return ((readHexDigit(body.charCodeAt(position)) << 12) | (readHexDigit(body.charCodeAt(position + 1)) << 8) | (readHexDigit(body.charCodeAt(position + 2)) << 4) | readHexDigit(body.charCodeAt(position + 3)));
    }
    function readHexDigit(code) {
        return code >= 0x0030 && code <= 0x0039 ? code - 0x0030 : code >= 0x0041 && code <= 0x0046 ? code - 0x0037 : code >= 0x0061 && code <= 0x0066 ? code - 0x0057 : -1;
    }
    function readEscapedCharacter(lexer, position) {
        const body = lexer.source.body;
        const code = body.charCodeAt(position + 1);
        switch(code){
            case 0x0022:
                return {
                    value: '\u0022',
                    size: 2
                };
            case 0x005c:
                return {
                    value: '\u005c',
                    size: 2
                };
            case 0x002f:
                return {
                    value: '\u002f',
                    size: 2
                };
            case 0x0062:
                return {
                    value: '\u0008',
                    size: 2
                };
            case 0x0066:
                return {
                    value: '\u000c',
                    size: 2
                };
            case 0x006e:
                return {
                    value: '\u000a',
                    size: 2
                };
            case 0x0072:
                return {
                    value: '\u000d',
                    size: 2
                };
            case 0x0074:
                return {
                    value: '\u0009',
                    size: 2
                };
        }
        throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
    }
    function readBlockString(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let lineStart = lexer.lineStart;
        let position = start + 3;
        let chunkStart = position;
        let currentLine = '';
        const blockLines = [];
        while(position < bodyLength){
            const code = body.charCodeAt(position);
            if (code === 0x0022 && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {
                currentLine += body.slice(chunkStart, position);
                blockLines.push(currentLine);
                const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join('\n'));
                lexer.line += blockLines.length - 1;
                lexer.lineStart = lineStart;
                return token;
            }
            if (code === 0x005c && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022 && body.charCodeAt(position + 3) === 0x0022) {
                currentLine += body.slice(chunkStart, position);
                chunkStart = position + 1;
                position += 4;
                continue;
            }
            if (code === 0x000a || code === 0x000d) {
                currentLine += body.slice(chunkStart, position);
                blockLines.push(currentLine);
                if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {
                    position += 2;
                } else {
                    ++position;
                }
                currentLine = '';
                chunkStart = position;
                lineStart = position;
                continue;
            }
            if (isUnicodeScalarValue(code)) {
                ++position;
            } else if (isSupplementaryCodePoint(body, position)) {
                position += 2;
            } else {
                throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
            }
        }
        throw syntaxError(lexer.source, position, 'Unterminated string.');
    }
    function readName(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while(position < bodyLength){
            const code = body.charCodeAt(position);
            if (isNameContinue(code)) {
                ++position;
            } else {
                break;
            }
        }
        return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
    }
    const MAX_ARRAY_LENGTH = 10;
    const MAX_RECURSIVE_DEPTH = 2;
    function inspect(value) {
        return formatValue(value, []);
    }
    function formatValue(value, seenValues) {
        switch(typeof value){
            case 'string':
                return JSON.stringify(value);
            case 'function':
                return value.name ? `[function ${value.name}]` : '[function]';
            case 'object':
                return formatObjectValue(value, seenValues);
            default:
                return String(value);
        }
    }
    function formatObjectValue(value, previouslySeenValues) {
        if (value === null) {
            return 'null';
        }
        if (previouslySeenValues.includes(value)) {
            return '[Circular]';
        }
        const seenValues = [
            ...previouslySeenValues,
            value
        ];
        if (isJSONable(value)) {
            const jsonValue = value.toJSON();
            if (jsonValue !== value) {
                return typeof jsonValue === 'string' ? jsonValue : formatValue(jsonValue, seenValues);
            }
        } else if (Array.isArray(value)) {
            return formatArray(value, seenValues);
        }
        return formatObject(value, seenValues);
    }
    function isJSONable(value) {
        return typeof value.toJSON === 'function';
    }
    function formatObject(object, seenValues) {
        const entries = Object.entries(object);
        if (entries.length === 0) {
            return '{}';
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
            return '[' + getObjectTag(object) + ']';
        }
        const properties = entries.map(([key, value])=>key + ': ' + formatValue(value, seenValues));
        return '{ ' + properties.join(', ') + ' }';
    }
    function formatArray(array, seenValues) {
        if (array.length === 0) {
            return '[]';
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
            return '[Array]';
        }
        const len = Math.min(MAX_ARRAY_LENGTH, array.length);
        const remaining = array.length - len;
        const items = [];
        for(let i = 0; i < len; ++i){
            items.push(formatValue(array[i], seenValues));
        }
        if (remaining === 1) {
            items.push('... 1 more item');
        } else if (remaining > 1) {
            items.push(`... ${remaining} more items`);
        }
        return '[' + items.join(', ') + ']';
    }
    function getObjectTag(object) {
        const tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');
        if (tag === 'Object' && typeof object.constructor === 'function') {
            const name = object.constructor.name;
            if (typeof name === 'string' && name !== '') {
                return name;
            }
        }
        return tag;
    }
    const isProduction = globalThis.process && true;
    const instanceOf = (isProduction ? function instanceOf2(value, constructor) {
        return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
        if (value instanceof constructor) {
            return true;
        }
        if (typeof value === "object" && value !== null) {
            var _value$constructor;
            const className = constructor.prototype[Symbol.toStringTag];
            const valueClassName = (Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name);
            if (className === valueClassName) {
                const stringifiedValue = inspect(value);
                throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
            }
        }
        return false;
    });
    class Source {
        constructor(body, name = 'GraphQL request', locationOffset = {
            line: 1,
            column: 1
        }){
            typeof body === 'string' || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
            this.body = body;
            this.name = name;
            this.locationOffset = locationOffset;
            this.locationOffset.line > 0 || devAssert(false, 'line in locationOffset is 1-indexed and must be positive.');
            this.locationOffset.column > 0 || devAssert(false, 'column in locationOffset is 1-indexed and must be positive.');
        }
        get [Symbol.toStringTag]() {
            return 'Source';
        }
    }
    function isSource(source) {
        return instanceOf(source, Source);
    }
    function parse(source, options) {
        const parser = new Parser(source, options);
        const document = parser.parseDocument();
        Object.defineProperty(document, 'tokenCount', {
            enumerable: false,
            value: parser.tokenCount
        });
        return document;
    }
    function parseValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(TokenKind.SOF);
        const value = parser.parseValueLiteral(false);
        parser.expectToken(TokenKind.EOF);
        return value;
    }
    function parseConstValue(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(TokenKind.SOF);
        const value = parser.parseConstValueLiteral();
        parser.expectToken(TokenKind.EOF);
        return value;
    }
    function parseType(source, options) {
        const parser = new Parser(source, options);
        parser.expectToken(TokenKind.SOF);
        const type = parser.parseTypeReference();
        parser.expectToken(TokenKind.EOF);
        return type;
    }
    class Parser {
        constructor(source, options = {}){
            const sourceObj = isSource(source) ? source : new Source(source);
            this._lexer = new Lexer(sourceObj);
            this._options = options;
            this._tokenCounter = 0;
        }
        get tokenCount() {
            return this._tokenCounter;
        }
        parseName() {
            const token = this.expectToken(TokenKind.NAME);
            return this.node(token, {
                kind: Kind.NAME,
                value: token.value
            });
        }
        parseDocument() {
            return this.node(this._lexer.token, {
                kind: Kind.DOCUMENT,
                definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
            });
        }
        parseDefinition() {
            if (this.peek(TokenKind.BRACE_L)) {
                return this.parseOperationDefinition();
            }
            const hasDescription = this.peekDescription();
            const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
            if (keywordToken.kind === TokenKind.NAME) {
                switch(keywordToken.value){
                    case 'schema':
                        return this.parseSchemaDefinition();
                    case 'scalar':
                        return this.parseScalarTypeDefinition();
                    case 'type':
                        return this.parseObjectTypeDefinition();
                    case 'interface':
                        return this.parseInterfaceTypeDefinition();
                    case 'union':
                        return this.parseUnionTypeDefinition();
                    case 'enum':
                        return this.parseEnumTypeDefinition();
                    case 'input':
                        return this.parseInputObjectTypeDefinition();
                    case 'directive':
                        return this.parseDirectiveDefinition();
                }
                if (hasDescription) {
                    throw syntaxError(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');
                }
                switch(keywordToken.value){
                    case 'query':
                    case 'mutation':
                    case 'subscription':
                        return this.parseOperationDefinition();
                    case 'fragment':
                        return this.parseFragmentDefinition();
                    case 'extend':
                        return this.parseTypeSystemExtension();
                }
            }
            throw this.unexpected(keywordToken);
        }
        parseOperationDefinition() {
            const start = this._lexer.token;
            if (this.peek(TokenKind.BRACE_L)) {
                return this.node(start, {
                    kind: Kind.OPERATION_DEFINITION,
                    operation: OperationTypeNode.QUERY,
                    name: undefined,
                    variableDefinitions: [],
                    directives: [],
                    selectionSet: this.parseSelectionSet()
                });
            }
            const operation = this.parseOperationType();
            let name;
            if (this.peek(TokenKind.NAME)) {
                name = this.parseName();
            }
            return this.node(start, {
                kind: Kind.OPERATION_DEFINITION,
                operation,
                name,
                variableDefinitions: this.parseVariableDefinitions(),
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet()
            });
        }
        parseOperationType() {
            const operationToken = this.expectToken(TokenKind.NAME);
            switch(operationToken.value){
                case 'query':
                    return OperationTypeNode.QUERY;
                case 'mutation':
                    return OperationTypeNode.MUTATION;
                case 'subscription':
                    return OperationTypeNode.SUBSCRIPTION;
            }
            throw this.unexpected(operationToken);
        }
        parseVariableDefinitions() {
            return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
        }
        parseVariableDefinition() {
            return this.node(this._lexer.token, {
                kind: Kind.VARIABLE_DEFINITION,
                variable: this.parseVariable(),
                type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
                defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
                directives: this.parseConstDirectives()
            });
        }
        parseVariable() {
            const start = this._lexer.token;
            this.expectToken(TokenKind.DOLLAR);
            return this.node(start, {
                kind: Kind.VARIABLE,
                name: this.parseName()
            });
        }
        parseSelectionSet() {
            return this.node(this._lexer.token, {
                kind: Kind.SELECTION_SET,
                selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
            });
        }
        parseSelection() {
            return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        parseField() {
            const start = this._lexer.token;
            const nameOrAlias = this.parseName();
            let alias;
            let name;
            if (this.expectOptionalToken(TokenKind.COLON)) {
                alias = nameOrAlias;
                name = this.parseName();
            } else {
                name = nameOrAlias;
            }
            return this.node(start, {
                kind: Kind.FIELD,
                alias,
                name,
                arguments: this.parseArguments(false),
                directives: this.parseDirectives(false),
                selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
            });
        }
        parseArguments(isConst) {
            const item = isConst ? this.parseConstArgument : this.parseArgument;
            return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
        }
        parseArgument(isConst = false) {
            const start = this._lexer.token;
            const name = this.parseName();
            this.expectToken(TokenKind.COLON);
            return this.node(start, {
                kind: Kind.ARGUMENT,
                name,
                value: this.parseValueLiteral(isConst)
            });
        }
        parseConstArgument() {
            return this.parseArgument(true);
        }
        parseFragment() {
            const start = this._lexer.token;
            this.expectToken(TokenKind.SPREAD);
            const hasTypeCondition = this.expectOptionalKeyword('on');
            if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
                return this.node(start, {
                    kind: Kind.FRAGMENT_SPREAD,
                    name: this.parseFragmentName(),
                    directives: this.parseDirectives(false)
                });
            }
            return this.node(start, {
                kind: Kind.INLINE_FRAGMENT,
                typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet()
            });
        }
        parseFragmentDefinition() {
            const start = this._lexer.token;
            this.expectKeyword('fragment');
            if (this._options.allowLegacyFragmentVariables === true) {
                return this.node(start, {
                    kind: Kind.FRAGMENT_DEFINITION,
                    name: this.parseFragmentName(),
                    variableDefinitions: this.parseVariableDefinitions(),
                    typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
                    directives: this.parseDirectives(false),
                    selectionSet: this.parseSelectionSet()
                });
            }
            return this.node(start, {
                kind: Kind.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet()
            });
        }
        parseFragmentName() {
            if (this._lexer.token.value === 'on') {
                throw this.unexpected();
            }
            return this.parseName();
        }
        parseValueLiteral(isConst) {
            const token = this._lexer.token;
            switch(token.kind){
                case TokenKind.BRACKET_L:
                    return this.parseList(isConst);
                case TokenKind.BRACE_L:
                    return this.parseObject(isConst);
                case TokenKind.INT:
                    this.advanceLexer();
                    return this.node(token, {
                        kind: Kind.INT,
                        value: token.value
                    });
                case TokenKind.FLOAT:
                    this.advanceLexer();
                    return this.node(token, {
                        kind: Kind.FLOAT,
                        value: token.value
                    });
                case TokenKind.STRING:
                case TokenKind.BLOCK_STRING:
                    return this.parseStringLiteral();
                case TokenKind.NAME:
                    this.advanceLexer();
                    switch(token.value){
                        case 'true':
                            return this.node(token, {
                                kind: Kind.BOOLEAN,
                                value: true
                            });
                        case 'false':
                            return this.node(token, {
                                kind: Kind.BOOLEAN,
                                value: false
                            });
                        case 'null':
                            return this.node(token, {
                                kind: Kind.NULL
                            });
                        default:
                            return this.node(token, {
                                kind: Kind.ENUM,
                                value: token.value
                            });
                    }
                case TokenKind.DOLLAR:
                    if (isConst) {
                        this.expectToken(TokenKind.DOLLAR);
                        if (this._lexer.token.kind === TokenKind.NAME) {
                            const varName = this._lexer.token.value;
                            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "$${varName}" in constant value.`);
                        } else {
                            throw this.unexpected(token);
                        }
                    }
                    return this.parseVariable();
                default:
                    throw this.unexpected();
            }
        }
        parseConstValueLiteral() {
            return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
            const token = this._lexer.token;
            this.advanceLexer();
            return this.node(token, {
                kind: Kind.STRING,
                value: token.value,
                block: token.kind === TokenKind.BLOCK_STRING
            });
        }
        parseList(isConst) {
            const item = ()=>this.parseValueLiteral(isConst);
            return this.node(this._lexer.token, {
                kind: Kind.LIST,
                values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
            });
        }
        parseObject(isConst) {
            const item = ()=>this.parseObjectField(isConst);
            return this.node(this._lexer.token, {
                kind: Kind.OBJECT,
                fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
            });
        }
        parseObjectField(isConst) {
            const start = this._lexer.token;
            const name = this.parseName();
            this.expectToken(TokenKind.COLON);
            return this.node(start, {
                kind: Kind.OBJECT_FIELD,
                name,
                value: this.parseValueLiteral(isConst)
            });
        }
        parseDirectives(isConst) {
            const directives = [];
            while(this.peek(TokenKind.AT)){
                directives.push(this.parseDirective(isConst));
            }
            return directives;
        }
        parseConstDirectives() {
            return this.parseDirectives(true);
        }
        parseDirective(isConst) {
            const start = this._lexer.token;
            this.expectToken(TokenKind.AT);
            return this.node(start, {
                kind: Kind.DIRECTIVE,
                name: this.parseName(),
                arguments: this.parseArguments(isConst)
            });
        }
        parseTypeReference() {
            const start = this._lexer.token;
            let type;
            if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
                const innerType = this.parseTypeReference();
                this.expectToken(TokenKind.BRACKET_R);
                type = this.node(start, {
                    kind: Kind.LIST_TYPE,
                    type: innerType
                });
            } else {
                type = this.parseNamedType();
            }
            if (this.expectOptionalToken(TokenKind.BANG)) {
                return this.node(start, {
                    kind: Kind.NON_NULL_TYPE,
                    type
                });
            }
            return type;
        }
        parseNamedType() {
            return this.node(this._lexer.token, {
                kind: Kind.NAMED_TYPE,
                name: this.parseName()
            });
        }
        peekDescription() {
            return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
        }
        parseDescription() {
            if (this.peekDescription()) {
                return this.parseStringLiteral();
            }
        }
        parseSchemaDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('schema');
            const directives = this.parseConstDirectives();
            const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
            return this.node(start, {
                kind: Kind.SCHEMA_DEFINITION,
                description,
                directives,
                operationTypes
            });
        }
        parseOperationTypeDefinition() {
            const start = this._lexer.token;
            const operation = this.parseOperationType();
            this.expectToken(TokenKind.COLON);
            const type = this.parseNamedType();
            return this.node(start, {
                kind: Kind.OPERATION_TYPE_DEFINITION,
                operation,
                type
            });
        }
        parseScalarTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('scalar');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            return this.node(start, {
                kind: Kind.SCALAR_TYPE_DEFINITION,
                description,
                name,
                directives
            });
        }
        parseObjectTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('type');
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            return this.node(start, {
                kind: Kind.OBJECT_TYPE_DEFINITION,
                description,
                name,
                interfaces,
                directives,
                fields
            });
        }
        parseImplementsInterfaces() {
            return this.expectOptionalKeyword('implements') ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
        }
        parseFieldsDefinition() {
            return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
        }
        parseFieldDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            const name = this.parseName();
            const args = this.parseArgumentDefs();
            this.expectToken(TokenKind.COLON);
            const type = this.parseTypeReference();
            const directives = this.parseConstDirectives();
            return this.node(start, {
                kind: Kind.FIELD_DEFINITION,
                description,
                name,
                arguments: args,
                type,
                directives
            });
        }
        parseArgumentDefs() {
            return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
        }
        parseInputValueDef() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            const name = this.parseName();
            this.expectToken(TokenKind.COLON);
            const type = this.parseTypeReference();
            let defaultValue;
            if (this.expectOptionalToken(TokenKind.EQUALS)) {
                defaultValue = this.parseConstValueLiteral();
            }
            const directives = this.parseConstDirectives();
            return this.node(start, {
                kind: Kind.INPUT_VALUE_DEFINITION,
                description,
                name,
                type,
                defaultValue,
                directives
            });
        }
        parseInterfaceTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('interface');
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            return this.node(start, {
                kind: Kind.INTERFACE_TYPE_DEFINITION,
                description,
                name,
                interfaces,
                directives,
                fields
            });
        }
        parseUnionTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('union');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const types = this.parseUnionMemberTypes();
            return this.node(start, {
                kind: Kind.UNION_TYPE_DEFINITION,
                description,
                name,
                directives,
                types
            });
        }
        parseUnionMemberTypes() {
            return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
        }
        parseEnumTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('enum');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const values = this.parseEnumValuesDefinition();
            return this.node(start, {
                kind: Kind.ENUM_TYPE_DEFINITION,
                description,
                name,
                directives,
                values
            });
        }
        parseEnumValuesDefinition() {
            return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
        }
        parseEnumValueDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            const name = this.parseEnumValueName();
            const directives = this.parseConstDirectives();
            return this.node(start, {
                kind: Kind.ENUM_VALUE_DEFINITION,
                description,
                name,
                directives
            });
        }
        parseEnumValueName() {
            if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null') {
                throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
            }
            return this.parseName();
        }
        parseInputObjectTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('input');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const fields = this.parseInputFieldsDefinition();
            return this.node(start, {
                kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
                description,
                name,
                directives,
                fields
            });
        }
        parseInputFieldsDefinition() {
            return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
        }
        parseTypeSystemExtension() {
            const keywordToken = this._lexer.lookahead();
            if (keywordToken.kind === TokenKind.NAME) {
                switch(keywordToken.value){
                    case 'schema':
                        return this.parseSchemaExtension();
                    case 'scalar':
                        return this.parseScalarTypeExtension();
                    case 'type':
                        return this.parseObjectTypeExtension();
                    case 'interface':
                        return this.parseInterfaceTypeExtension();
                    case 'union':
                        return this.parseUnionTypeExtension();
                    case 'enum':
                        return this.parseEnumTypeExtension();
                    case 'input':
                        return this.parseInputObjectTypeExtension();
                }
            }
            throw this.unexpected(keywordToken);
        }
        parseSchemaExtension() {
            const start = this._lexer.token;
            this.expectKeyword('extend');
            this.expectKeyword('schema');
            const directives = this.parseConstDirectives();
            const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
            if (directives.length === 0 && operationTypes.length === 0) {
                throw this.unexpected();
            }
            return this.node(start, {
                kind: Kind.SCHEMA_EXTENSION,
                directives,
                operationTypes
            });
        }
        parseScalarTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword('extend');
            this.expectKeyword('scalar');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            if (directives.length === 0) {
                throw this.unexpected();
            }
            return this.node(start, {
                kind: Kind.SCALAR_TYPE_EXTENSION,
                name,
                directives
            });
        }
        parseObjectTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword('extend');
            this.expectKeyword('type');
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
                throw this.unexpected();
            }
            return this.node(start, {
                kind: Kind.OBJECT_TYPE_EXTENSION,
                name,
                interfaces,
                directives,
                fields
            });
        }
        parseInterfaceTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword('extend');
            this.expectKeyword('interface');
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
                throw this.unexpected();
            }
            return this.node(start, {
                kind: Kind.INTERFACE_TYPE_EXTENSION,
                name,
                interfaces,
                directives,
                fields
            });
        }
        parseUnionTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword('extend');
            this.expectKeyword('union');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const types = this.parseUnionMemberTypes();
            if (directives.length === 0 && types.length === 0) {
                throw this.unexpected();
            }
            return this.node(start, {
                kind: Kind.UNION_TYPE_EXTENSION,
                name,
                directives,
                types
            });
        }
        parseEnumTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword('extend');
            this.expectKeyword('enum');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const values = this.parseEnumValuesDefinition();
            if (directives.length === 0 && values.length === 0) {
                throw this.unexpected();
            }
            return this.node(start, {
                kind: Kind.ENUM_TYPE_EXTENSION,
                name,
                directives,
                values
            });
        }
        parseInputObjectTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword('extend');
            this.expectKeyword('input');
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const fields = this.parseInputFieldsDefinition();
            if (directives.length === 0 && fields.length === 0) {
                throw this.unexpected();
            }
            return this.node(start, {
                kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
                name,
                directives,
                fields
            });
        }
        parseDirectiveDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword('directive');
            this.expectToken(TokenKind.AT);
            const name = this.parseName();
            const args = this.parseArgumentDefs();
            const repeatable = this.expectOptionalKeyword('repeatable');
            this.expectKeyword('on');
            const locations = this.parseDirectiveLocations();
            return this.node(start, {
                kind: Kind.DIRECTIVE_DEFINITION,
                description,
                name,
                arguments: args,
                repeatable,
                locations
            });
        }
        parseDirectiveLocations() {
            return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
        }
        parseDirectiveLocation() {
            const start = this._lexer.token;
            const name = this.parseName();
            if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
                return name;
            }
            throw this.unexpected(start);
        }
        node(startToken, node) {
            if (this._options.noLocation !== true) {
                node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
            }
            return node;
        }
        peek(kind) {
            return this._lexer.token.kind === kind;
        }
        expectToken(kind) {
            const token = this._lexer.token;
            if (token.kind === kind) {
                this.advanceLexer();
                return token;
            }
            throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
        }
        expectOptionalToken(kind) {
            const token = this._lexer.token;
            if (token.kind === kind) {
                this.advanceLexer();
                return true;
            }
            return false;
        }
        expectKeyword(value) {
            const token = this._lexer.token;
            if (token.kind === TokenKind.NAME && token.value === value) {
                this.advanceLexer();
            } else {
                throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
            }
        }
        expectOptionalKeyword(value) {
            const token = this._lexer.token;
            if (token.kind === TokenKind.NAME && token.value === value) {
                this.advanceLexer();
                return true;
            }
            return false;
        }
        unexpected(atToken) {
            const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
            return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
        }
        any(openKind, parseFn, closeKind) {
            this.expectToken(openKind);
            const nodes = [];
            while(!this.expectOptionalToken(closeKind)){
                nodes.push(parseFn.call(this));
            }
            return nodes;
        }
        optionalMany(openKind, parseFn, closeKind) {
            if (this.expectOptionalToken(openKind)) {
                const nodes = [];
                do {
                    nodes.push(parseFn.call(this));
                }while (!this.expectOptionalToken(closeKind));
                return nodes;
            }
            return [];
        }
        many(openKind, parseFn, closeKind) {
            this.expectToken(openKind);
            const nodes = [];
            do {
                nodes.push(parseFn.call(this));
            }while (!this.expectOptionalToken(closeKind));
            return nodes;
        }
        delimitedMany(delimiterKind, parseFn) {
            this.expectOptionalToken(delimiterKind);
            const nodes = [];
            do {
                nodes.push(parseFn.call(this));
            }while (this.expectOptionalToken(delimiterKind));
            return nodes;
        }
        advanceLexer() {
            const { maxTokens } = this._options;
            const token = this._lexer.advance();
            if (token.kind !== TokenKind.EOF) {
                ++this._tokenCounter;
                if (maxTokens !== undefined && this._tokenCounter > maxTokens) {
                    throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
                }
            }
        }
    }
    function getTokenDesc(token) {
        const value = token.value;
        return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : '');
    }
    function getTokenKindDesc(kind) {
        return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
    }
    const MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
        const [subMessage, suggestionsArg] = secondArg ? [
            firstArg,
            secondArg
        ] : [
            undefined,
            firstArg
        ];
        let message = ' Did you mean ';
        if (subMessage) {
            message += subMessage + ' ';
        }
        const suggestions = suggestionsArg.map((x)=>`"${x}"`);
        switch(suggestions.length){
            case 0:
                return '';
            case 1:
                return message + suggestions[0] + '?';
            case 2:
                return message + suggestions[0] + ' or ' + suggestions[1] + '?';
        }
        const selected = suggestions.slice(0, MAX_SUGGESTIONS);
        const lastItem = selected.pop();
        return message + selected.join(', ') + ', or ' + lastItem + '?';
    }
    function identityFunc(x) {
        return x;
    }
    function keyMap(list, keyFn) {
        const result = Object.create(null);
        for (const item of list){
            result[keyFn(item)] = item;
        }
        return result;
    }
    function keyValMap(list, keyFn, valFn) {
        const result = Object.create(null);
        for (const item of list){
            result[keyFn(item)] = valFn(item);
        }
        return result;
    }
    function mapValue(map, fn) {
        const result = Object.create(null);
        for (const key of Object.keys(map)){
            result[key] = fn(map[key], key);
        }
        return result;
    }
    function naturalCompare(aStr, bStr) {
        let aIndex = 0;
        let bIndex = 0;
        while(aIndex < aStr.length && bIndex < bStr.length){
            let aChar = aStr.charCodeAt(aIndex);
            let bChar = bStr.charCodeAt(bIndex);
            if (isDigit(aChar) && isDigit(bChar)) {
                let aNum = 0;
                do {
                    ++aIndex;
                    aNum = aNum * 10 + aChar - DIGIT_0;
                    aChar = aStr.charCodeAt(aIndex);
                }while (isDigit(aChar) && aNum > 0);
                let bNum = 0;
                do {
                    ++bIndex;
                    bNum = bNum * 10 + bChar - DIGIT_0;
                    bChar = bStr.charCodeAt(bIndex);
                }while (isDigit(bChar) && bNum > 0);
                if (aNum < bNum) {
                    return -1;
                }
                if (aNum > bNum) {
                    return 1;
                }
            } else {
                if (aChar < bChar) {
                    return -1;
                }
                if (aChar > bChar) {
                    return 1;
                }
                ++aIndex;
                ++bIndex;
            }
        }
        return aStr.length - bStr.length;
    }
    const DIGIT_0 = 48;
    const DIGIT_9 = 57;
    function isDigit(code) {
        return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
    function suggestionList(input, options) {
        const optionsByDistance = Object.create(null);
        const lexicalDistance = new LexicalDistance(input);
        const threshold = Math.floor(input.length * 0.4) + 1;
        for (const option of options){
            const distance = lexicalDistance.measure(option, threshold);
            if (distance !== undefined) {
                optionsByDistance[option] = distance;
            }
        }
        return Object.keys(optionsByDistance).sort((a, b)=>{
            const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
            return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
        });
    }
    class LexicalDistance {
        constructor(input){
            this._input = input;
            this._inputLowerCase = input.toLowerCase();
            this._inputArray = stringToArray(this._inputLowerCase);
            this._rows = [
                new Array(input.length + 1).fill(0),
                new Array(input.length + 1).fill(0),
                new Array(input.length + 1).fill(0)
            ];
        }
        measure(option, threshold) {
            if (this._input === option) {
                return 0;
            }
            const optionLowerCase = option.toLowerCase();
            if (this._inputLowerCase === optionLowerCase) {
                return 1;
            }
            let a = stringToArray(optionLowerCase);
            let b = this._inputArray;
            if (a.length < b.length) {
                const tmp = a;
                a = b;
                b = tmp;
            }
            const aLength = a.length;
            const bLength = b.length;
            if (aLength - bLength > threshold) {
                return undefined;
            }
            const rows = this._rows;
            for(let j = 0; j <= bLength; j++){
                rows[0][j] = j;
            }
            for(let i = 1; i <= aLength; i++){
                const upRow = rows[(i - 1) % 3];
                const currentRow = rows[i % 3];
                let smallestCell = (currentRow[0] = i);
                for(let j = 1; j <= bLength; j++){
                    const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                    let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
                    if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
                        const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
                        currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
                    }
                    if (currentCell < smallestCell) {
                        smallestCell = currentCell;
                    }
                    currentRow[j] = currentCell;
                }
                if (smallestCell > threshold) {
                    return undefined;
                }
            }
            const distance = rows[aLength % 3][bLength];
            return distance <= threshold ? distance : undefined;
        }
    }
    function stringToArray(str) {
        const strLength = str.length;
        const array = new Array(strLength);
        for(let i = 0; i < strLength; ++i){
            array[i] = str.charCodeAt(i);
        }
        return array;
    }
    function toObjMap(obj) {
        if (obj == null) {
            return Object.create(null);
        }
        if (Object.getPrototypeOf(obj) === null) {
            return obj;
        }
        const map = Object.create(null);
        for (const [key, value] of Object.entries(obj)){
            map[key] = value;
        }
        return map;
    }
    function printString(str) {
        return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
    }
    const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(str) {
        return escapeSequences[str.charCodeAt(0)];
    }
    const escapeSequences = [
        '\\u0000',
        '\\u0001',
        '\\u0002',
        '\\u0003',
        '\\u0004',
        '\\u0005',
        '\\u0006',
        '\\u0007',
        '\\b',
        '\\t',
        '\\n',
        '\\u000B',
        '\\f',
        '\\r',
        '\\u000E',
        '\\u000F',
        '\\u0010',
        '\\u0011',
        '\\u0012',
        '\\u0013',
        '\\u0014',
        '\\u0015',
        '\\u0016',
        '\\u0017',
        '\\u0018',
        '\\u0019',
        '\\u001A',
        '\\u001B',
        '\\u001C',
        '\\u001D',
        '\\u001E',
        '\\u001F',
        '',
        '',
        '\\"',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '\\\\',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '\\u007F',
        '\\u0080',
        '\\u0081',
        '\\u0082',
        '\\u0083',
        '\\u0084',
        '\\u0085',
        '\\u0086',
        '\\u0087',
        '\\u0088',
        '\\u0089',
        '\\u008A',
        '\\u008B',
        '\\u008C',
        '\\u008D',
        '\\u008E',
        '\\u008F',
        '\\u0090',
        '\\u0091',
        '\\u0092',
        '\\u0093',
        '\\u0094',
        '\\u0095',
        '\\u0096',
        '\\u0097',
        '\\u0098',
        '\\u0099',
        '\\u009A',
        '\\u009B',
        '\\u009C',
        '\\u009D',
        '\\u009E',
        '\\u009F'
    ];
    const BREAK = Object.freeze({});
    function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
        const enterLeaveMap = new Map();
        for (const kind of Object.values(Kind)){
            enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
        }
        let stack = undefined;
        let inArray = Array.isArray(root);
        let keys = [
            root
        ];
        let index = -1;
        let edits = [];
        let node = root;
        let key = undefined;
        let parent = undefined;
        const path = [];
        const ancestors = [];
        do {
            index++;
            const isLeaving = index === keys.length;
            const isEdited = isLeaving && edits.length !== 0;
            if (isLeaving) {
                key = ancestors.length === 0 ? undefined : path[path.length - 1];
                node = parent;
                parent = ancestors.pop();
                if (isEdited) {
                    if (inArray) {
                        node = node.slice();
                        let editOffset = 0;
                        for (const [editKey, editValue] of edits){
                            const arrayKey = editKey - editOffset;
                            if (editValue === null) {
                                node.splice(arrayKey, 1);
                                editOffset++;
                            } else {
                                node[arrayKey] = editValue;
                            }
                        }
                    } else {
                        node = {
                            ...node
                        };
                        for (const [editKey, editValue] of edits){
                            node[editKey] = editValue;
                        }
                    }
                }
                index = stack.index;
                keys = stack.keys;
                edits = stack.edits;
                inArray = stack.inArray;
                stack = stack.prev;
            } else if (parent) {
                key = inArray ? index : keys[index];
                node = parent[key];
                if (node === null || node === undefined) {
                    continue;
                }
                path.push(key);
            }
            let result;
            if (!Array.isArray(node)) {
                var _enterLeaveMap$get, _enterLeaveMap$get2;
                isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
                const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
                result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
                if (result === BREAK) {
                    break;
                }
                if (result === false) {
                    if (!isLeaving) {
                        path.pop();
                        continue;
                    }
                } else if (result !== undefined) {
                    edits.push([
                        key,
                        result
                    ]);
                    if (!isLeaving) {
                        if (isNode(result)) {
                            node = result;
                        } else {
                            path.pop();
                            continue;
                        }
                    }
                }
            }
            if (result === undefined && isEdited) {
                edits.push([
                    key,
                    node
                ]);
            }
            if (isLeaving) {
                path.pop();
            } else {
                var _node$kind;
                stack = {
                    inArray,
                    index,
                    keys,
                    edits,
                    prev: stack
                };
                inArray = Array.isArray(node);
                keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
                index = -1;
                edits = [];
                if (parent) {
                    ancestors.push(parent);
                }
                parent = node;
            }
        }while (stack !== undefined);
        if (edits.length !== 0) {
            return edits[edits.length - 1][1];
        }
        return root;
    }
    function visitInParallel(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = Object.create(null);
        for (const kind of Object.values(Kind)){
            let hasVisitor = false;
            const enterList = new Array(visitors.length).fill(undefined);
            const leaveList = new Array(visitors.length).fill(undefined);
            for(let i = 0; i < visitors.length; ++i){
                const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
                hasVisitor || (hasVisitor = enter != null || leave != null);
                enterList[i] = enter;
                leaveList[i] = leave;
            }
            if (!hasVisitor) {
                continue;
            }
            const mergedEnterLeave = {
                enter (...args) {
                    const node = args[0];
                    for(let i = 0; i < visitors.length; i++){
                        if (skipping[i] === null) {
                            var _enterList$i;
                            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                            if (result === false) {
                                skipping[i] = node;
                            } else if (result === BREAK) {
                                skipping[i] = BREAK;
                            } else if (result !== undefined) {
                                return result;
                            }
                        }
                    }
                },
                leave (...args) {
                    const node = args[0];
                    for(let i = 0; i < visitors.length; i++){
                        if (skipping[i] === null) {
                            var _leaveList$i;
                            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                            if (result === BREAK) {
                                skipping[i] = BREAK;
                            } else if (result !== undefined && result !== false) {
                                return result;
                            }
                        } else if (skipping[i] === node) {
                            skipping[i] = null;
                        }
                    }
                }
            };
            mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
    }
    function getEnterLeaveForKind(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === 'object') {
            return kindVisitor;
        } else if (typeof kindVisitor === 'function') {
            return {
                enter: kindVisitor,
                leave: undefined
            };
        }
        return {
            enter: visitor.enter,
            leave: visitor.leave
        };
    }
    function getVisitFn(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind(visitor, kind);
        return isLeaving ? leave : enter;
    }
    function print$1(ast) {
        return visit(ast, printDocASTReducer);
    }
    const MAX_LINE_LENGTH = 80;
    const printDocASTReducer = {
        Name: {
            leave: (node)=>node.value
        },
        Variable: {
            leave: (node)=>'$' + node.name
        },
        Document: {
            leave: (node)=>join(node.definitions, '\n\n')
        },
        OperationDefinition: {
            leave (node) {
                const varDefs = wrap$1('(', join(node.variableDefinitions, ', '), ')');
                const prefix = join([
                    node.operation,
                    join([
                        node.name,
                        varDefs
                    ]),
                    join(node.directives, ' ')
                ], ' ');
                return (prefix === 'query' ? '' : prefix + ' ') + node.selectionSet;
            }
        },
        VariableDefinition: {
            leave: ({ variable, type, defaultValue, directives })=>variable + ': ' + type + wrap$1(' = ', defaultValue) + wrap$1(' ', join(directives, ' '))
        },
        SelectionSet: {
            leave: ({ selections })=>block(selections)
        },
        Field: {
            leave ({ alias, name, arguments: args, directives, selectionSet }) {
                const prefix = wrap$1('', alias, ': ') + name;
                let argsLine = prefix + wrap$1('(', join(args, ', '), ')');
                if (argsLine.length > MAX_LINE_LENGTH) {
                    argsLine = prefix + wrap$1('(\n', indent(join(args, '\n')), '\n)');
                }
                return join([
                    argsLine,
                    join(directives, ' '),
                    selectionSet
                ], ' ');
            }
        },
        Argument: {
            leave: ({ name, value })=>name + ': ' + value
        },
        FragmentSpread: {
            leave: ({ name, directives })=>'...' + name + wrap$1(' ', join(directives, ' '))
        },
        InlineFragment: {
            leave: ({ typeCondition, directives, selectionSet })=>join([
                    '...',
                    wrap$1('on ', typeCondition),
                    join(directives, ' '),
                    selectionSet
                ], ' ')
        },
        FragmentDefinition: {
            leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet })=>`fragment ${name}${wrap$1('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap$1('', join(directives, ' '), ' ')}` + selectionSet
        },
        IntValue: {
            leave: ({ value })=>value
        },
        FloatValue: {
            leave: ({ value })=>value
        },
        StringValue: {
            leave: ({ value, block: isBlockString })=>isBlockString ? printBlockString(value) : printString(value)
        },
        BooleanValue: {
            leave: ({ value })=>(value ? 'true' : 'false')
        },
        NullValue: {
            leave: ()=>'null'
        },
        EnumValue: {
            leave: ({ value })=>value
        },
        ListValue: {
            leave: ({ values })=>'[' + join(values, ', ') + ']'
        },
        ObjectValue: {
            leave: ({ fields })=>'{' + join(fields, ', ') + '}'
        },
        ObjectField: {
            leave: ({ name, value })=>name + ': ' + value
        },
        Directive: {
            leave: ({ name, arguments: args })=>'@' + name + wrap$1('(', join(args, ', '), ')')
        },
        NamedType: {
            leave: ({ name })=>name
        },
        ListType: {
            leave: ({ type })=>'[' + type + ']'
        },
        NonNullType: {
            leave: ({ type })=>type + '!'
        },
        SchemaDefinition: {
            leave: ({ description, directives, operationTypes })=>wrap$1('', description, '\n') + join([
                    'schema',
                    join(directives, ' '),
                    block(operationTypes)
                ], ' ')
        },
        OperationTypeDefinition: {
            leave: ({ operation, type })=>operation + ': ' + type
        },
        ScalarTypeDefinition: {
            leave: ({ description, name, directives })=>wrap$1('', description, '\n') + join([
                    'scalar',
                    name,
                    join(directives, ' ')
                ], ' ')
        },
        ObjectTypeDefinition: {
            leave: ({ description, name, interfaces, directives, fields })=>wrap$1('', description, '\n') + join([
                    'type',
                    name,
                    wrap$1('implements ', join(interfaces, ' & ')),
                    join(directives, ' '),
                    block(fields)
                ], ' ')
        },
        FieldDefinition: {
            leave: ({ description, name, arguments: args, type, directives })=>wrap$1('', description, '\n') + name + (hasMultilineItems(args) ? wrap$1('(\n', indent(join(args, '\n')), '\n)') : wrap$1('(', join(args, ', '), ')')) + ': ' + type + wrap$1(' ', join(directives, ' '))
        },
        InputValueDefinition: {
            leave: ({ description, name, type, defaultValue, directives })=>wrap$1('', description, '\n') + join([
                    name + ': ' + type,
                    wrap$1('= ', defaultValue),
                    join(directives, ' ')
                ], ' ')
        },
        InterfaceTypeDefinition: {
            leave: ({ description, name, interfaces, directives, fields })=>wrap$1('', description, '\n') + join([
                    'interface',
                    name,
                    wrap$1('implements ', join(interfaces, ' & ')),
                    join(directives, ' '),
                    block(fields)
                ], ' ')
        },
        UnionTypeDefinition: {
            leave: ({ description, name, directives, types })=>wrap$1('', description, '\n') + join([
                    'union',
                    name,
                    join(directives, ' '),
                    wrap$1('= ', join(types, ' | '))
                ], ' ')
        },
        EnumTypeDefinition: {
            leave: ({ description, name, directives, values })=>wrap$1('', description, '\n') + join([
                    'enum',
                    name,
                    join(directives, ' '),
                    block(values)
                ], ' ')
        },
        EnumValueDefinition: {
            leave: ({ description, name, directives })=>wrap$1('', description, '\n') + join([
                    name,
                    join(directives, ' ')
                ], ' ')
        },
        InputObjectTypeDefinition: {
            leave: ({ description, name, directives, fields })=>wrap$1('', description, '\n') + join([
                    'input',
                    name,
                    join(directives, ' '),
                    block(fields)
                ], ' ')
        },
        DirectiveDefinition: {
            leave: ({ description, name, arguments: args, repeatable, locations })=>wrap$1('', description, '\n') + 'directive @' + name + (hasMultilineItems(args) ? wrap$1('(\n', indent(join(args, '\n')), '\n)') : wrap$1('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ')
        },
        SchemaExtension: {
            leave: ({ directives, operationTypes })=>join([
                    'extend schema',
                    join(directives, ' '),
                    block(operationTypes)
                ], ' ')
        },
        ScalarTypeExtension: {
            leave: ({ name, directives })=>join([
                    'extend scalar',
                    name,
                    join(directives, ' ')
                ], ' ')
        },
        ObjectTypeExtension: {
            leave: ({ name, interfaces, directives, fields })=>join([
                    'extend type',
                    name,
                    wrap$1('implements ', join(interfaces, ' & ')),
                    join(directives, ' '),
                    block(fields)
                ], ' ')
        },
        InterfaceTypeExtension: {
            leave: ({ name, interfaces, directives, fields })=>join([
                    'extend interface',
                    name,
                    wrap$1('implements ', join(interfaces, ' & ')),
                    join(directives, ' '),
                    block(fields)
                ], ' ')
        },
        UnionTypeExtension: {
            leave: ({ name, directives, types })=>join([
                    'extend union',
                    name,
                    join(directives, ' '),
                    wrap$1('= ', join(types, ' | '))
                ], ' ')
        },
        EnumTypeExtension: {
            leave: ({ name, directives, values })=>join([
                    'extend enum',
                    name,
                    join(directives, ' '),
                    block(values)
                ], ' ')
        },
        InputObjectTypeExtension: {
            leave: ({ name, directives, fields })=>join([
                    'extend input',
                    name,
                    join(directives, ' '),
                    block(fields)
                ], ' ')
        }
    };
    function join(maybeArray, separator = '') {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x)=>x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : '';
    }
    function block(array) {
        return wrap$1('{\n', indent(join(array, '\n')), '\n}');
    }
    function wrap$1(start, maybeString, end = '') {
        return maybeString != null && maybeString !== '' ? start + maybeString + end : '';
    }
    function indent(str) {
        return wrap$1('  ', str.replace(/\n/g, '\n  '));
    }
    function hasMultilineItems(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str)=>str.includes('\n'))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
    }
    function valueFromASTUntyped(valueNode, variables) {
        switch(valueNode.kind){
            case Kind.NULL:
                return null;
            case Kind.INT:
                return parseInt(valueNode.value, 10);
            case Kind.FLOAT:
                return parseFloat(valueNode.value);
            case Kind.STRING:
            case Kind.ENUM:
            case Kind.BOOLEAN:
                return valueNode.value;
            case Kind.LIST:
                return valueNode.values.map((node)=>valueFromASTUntyped(node, variables));
            case Kind.OBJECT:
                return keyValMap(valueNode.fields, (field)=>field.name.value, (field)=>valueFromASTUntyped(field.value, variables));
            case Kind.VARIABLE:
                return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
        }
    }
    function assertName(name) {
        name != null || devAssert(false, 'Must provide name.');
        typeof name === 'string' || devAssert(false, 'Expected name to be a string.');
        if (name.length === 0) {
            throw new GraphQLError('Expected name to be a non-empty string.');
        }
        for(let i = 1; i < name.length; ++i){
            if (!isNameContinue(name.charCodeAt(i))) {
                throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
            }
        }
        if (!isNameStart(name.charCodeAt(0))) {
            throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
        }
        return name;
    }
    function assertEnumValueName(name) {
        if (name === 'true' || name === 'false' || name === 'null') {
            throw new GraphQLError(`Enum values cannot be named: ${name}`);
        }
        return assertName(name);
    }
    function isType(type) {
        return (isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type));
    }
    function assertType(type) {
        if (!isType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);
        }
        return type;
    }
    function isScalarType(type) {
        return instanceOf(type, GraphQLScalarType);
    }
    function assertScalarType(type) {
        if (!isScalarType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);
        }
        return type;
    }
    function isObjectType(type) {
        return instanceOf(type, GraphQLObjectType);
    }
    function assertObjectType(type) {
        if (!isObjectType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);
        }
        return type;
    }
    function isInterfaceType(type) {
        return instanceOf(type, GraphQLInterfaceType);
    }
    function assertInterfaceType(type) {
        if (!isInterfaceType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL Interface type.`);
        }
        return type;
    }
    function isUnionType(type) {
        return instanceOf(type, GraphQLUnionType);
    }
    function assertUnionType(type) {
        if (!isUnionType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);
        }
        return type;
    }
    function isEnumType(type) {
        return instanceOf(type, GraphQLEnumType);
    }
    function assertEnumType(type) {
        if (!isEnumType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);
        }
        return type;
    }
    function isInputObjectType(type) {
        return instanceOf(type, GraphQLInputObjectType);
    }
    function assertInputObjectType(type) {
        if (!isInputObjectType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL Input Object type.`);
        }
        return type;
    }
    function isListType(type) {
        return instanceOf(type, GraphQLList);
    }
    function assertListType(type) {
        if (!isListType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);
        }
        return type;
    }
    function isNonNullType(type) {
        return instanceOf(type, GraphQLNonNull);
    }
    function assertNonNullType(type) {
        if (!isNonNullType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);
        }
        return type;
    }
    function isInputType(type) {
        return (isScalarType(type) || isEnumType(type) || isInputObjectType(type) || (isWrappingType(type) && isInputType(type.ofType)));
    }
    function assertInputType(type) {
        if (!isInputType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);
        }
        return type;
    }
    function isOutputType(type) {
        return (isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || (isWrappingType(type) && isOutputType(type.ofType)));
    }
    function assertOutputType(type) {
        if (!isOutputType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);
        }
        return type;
    }
    function isLeafType(type) {
        return isScalarType(type) || isEnumType(type);
    }
    function assertLeafType(type) {
        if (!isLeafType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);
        }
        return type;
    }
    function isCompositeType(type) {
        return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
    }
    function assertCompositeType(type) {
        if (!isCompositeType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL composite type.`);
        }
        return type;
    }
    function isAbstractType(type) {
        return isInterfaceType(type) || isUnionType(type);
    }
    function assertAbstractType(type) {
        if (!isAbstractType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);
        }
        return type;
    }
    class GraphQLList {
        constructor(ofType){
            isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
            this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLList';
        }
        toString() {
            return '[' + String(this.ofType) + ']';
        }
        toJSON() {
            return this.toString();
        }
    }
    class GraphQLNonNull {
        constructor(ofType){
            isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);
            this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLNonNull';
        }
        toString() {
            return String(this.ofType) + '!';
        }
        toJSON() {
            return this.toString();
        }
    }
    function isWrappingType(type) {
        return isListType(type) || isNonNullType(type);
    }
    function assertWrappingType(type) {
        if (!isWrappingType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);
        }
        return type;
    }
    function isNullableType(type) {
        return isType(type) && !isNonNullType(type);
    }
    function assertNullableType(type) {
        if (!isNullableType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);
        }
        return type;
    }
    function getNullableType(type) {
        if (type) {
            return isNonNullType(type) ? type.ofType : type;
        }
    }
    function isNamedType(type) {
        return (isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type));
    }
    function assertNamedType(type) {
        if (!isNamedType(type)) {
            throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);
        }
        return type;
    }
    function getNamedType(type) {
        if (type) {
            let unwrappedType = type;
            while(isWrappingType(unwrappedType)){
                unwrappedType = unwrappedType.ofType;
            }
            return unwrappedType;
        }
    }
    function resolveReadonlyArrayThunk(thunk) {
        return typeof thunk === 'function' ? thunk() : thunk;
    }
    function resolveObjMapThunk(thunk) {
        return typeof thunk === 'function' ? thunk() : thunk;
    }
    class GraphQLScalarType {
        constructor(config){
            var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
            const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
            this.name = assertName(config.name);
            this.description = config.description;
            this.specifiedByURL = config.specifiedByURL;
            this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
            this.parseValue = parseValue;
            this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables)=>parseValue(valueFromASTUntyped(node, variables));
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
            config.specifiedByURL == null || typeof config.specifiedByURL === 'string' || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${inspect(config.specifiedByURL)}.`);
            config.serialize == null || typeof config.serialize === 'function' || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
            if (config.parseLiteral) {
                (typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
            }
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLScalarType';
        }
        toConfig() {
            return {
                name: this.name,
                description: this.description,
                specifiedByURL: this.specifiedByURL,
                serialize: this.serialize,
                parseValue: this.parseValue,
                parseLiteral: this.parseLiteral,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes
            };
        }
        toString() {
            return this.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    class GraphQLObjectType {
        constructor(config){
            var _config$extensionASTN2;
            this.name = assertName(config.name);
            this.description = config.description;
            this.isTypeOf = config.isTypeOf;
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
            this._fields = ()=>defineFieldMap(config);
            this._interfaces = ()=>defineInterfaces(config);
            config.isTypeOf == null || typeof config.isTypeOf === 'function' || devAssert(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${inspect(config.isTypeOf)}.`);
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLObjectType';
        }
        getFields() {
            if (typeof this._fields === 'function') {
                this._fields = this._fields();
            }
            return this._fields;
        }
        getInterfaces() {
            if (typeof this._interfaces === 'function') {
                this._interfaces = this._interfaces();
            }
            return this._interfaces;
        }
        toConfig() {
            return {
                name: this.name,
                description: this.description,
                interfaces: this.getInterfaces(),
                fields: fieldsToFieldsConfig(this.getFields()),
                isTypeOf: this.isTypeOf,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes
            };
        }
        toString() {
            return this.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    function defineInterfaces(config) {
        var _config$interfaces;
        const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);
        Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
        return interfaces;
    }
    function defineFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
        return mapValue(fieldMap, (fieldConfig, fieldName)=>{
            var _fieldConfig$args;
            isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);
            fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${inspect(fieldConfig.resolve)}.`);
            const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
            isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
            return {
                name: assertName(fieldName),
                description: fieldConfig.description,
                type: fieldConfig.type,
                args: defineArguments(argsConfig),
                resolve: fieldConfig.resolve,
                subscribe: fieldConfig.subscribe,
                deprecationReason: fieldConfig.deprecationReason,
                extensions: toObjMap(fieldConfig.extensions),
                astNode: fieldConfig.astNode
            };
        });
    }
    function defineArguments(config) {
        return Object.entries(config).map(([argName, argConfig])=>({
                name: assertName(argName),
                description: argConfig.description,
                type: argConfig.type,
                defaultValue: argConfig.defaultValue,
                deprecationReason: argConfig.deprecationReason,
                extensions: toObjMap(argConfig.extensions),
                astNode: argConfig.astNode
            }));
    }
    function isPlainObj(obj) {
        return isObjectLike(obj) && !Array.isArray(obj);
    }
    function fieldsToFieldsConfig(fields) {
        return mapValue(fields, (field)=>({
                description: field.description,
                type: field.type,
                args: argsToArgsConfig(field.args),
                resolve: field.resolve,
                subscribe: field.subscribe,
                deprecationReason: field.deprecationReason,
                extensions: field.extensions,
                astNode: field.astNode
            }));
    }
    function argsToArgsConfig(args) {
        return keyValMap(args, (arg)=>arg.name, (arg)=>({
                description: arg.description,
                type: arg.type,
                defaultValue: arg.defaultValue,
                deprecationReason: arg.deprecationReason,
                extensions: arg.extensions,
                astNode: arg.astNode
            }));
    }
    function isRequiredArgument(arg) {
        return isNonNullType(arg.type) && arg.defaultValue === undefined;
    }
    class GraphQLInterfaceType {
        constructor(config){
            var _config$extensionASTN3;
            this.name = assertName(config.name);
            this.description = config.description;
            this.resolveType = config.resolveType;
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
            this._fields = defineFieldMap.bind(undefined, config);
            this._interfaces = defineInterfaces.bind(undefined, config);
            config.resolveType == null || typeof config.resolveType === 'function' || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLInterfaceType';
        }
        getFields() {
            if (typeof this._fields === 'function') {
                this._fields = this._fields();
            }
            return this._fields;
        }
        getInterfaces() {
            if (typeof this._interfaces === 'function') {
                this._interfaces = this._interfaces();
            }
            return this._interfaces;
        }
        toConfig() {
            return {
                name: this.name,
                description: this.description,
                interfaces: this.getInterfaces(),
                fields: fieldsToFieldsConfig(this.getFields()),
                resolveType: this.resolveType,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes
            };
        }
        toString() {
            return this.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    class GraphQLUnionType {
        constructor(config){
            var _config$extensionASTN4;
            this.name = assertName(config.name);
            this.description = config.description;
            this.resolveType = config.resolveType;
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
            this._types = defineTypes.bind(undefined, config);
            config.resolveType == null || typeof config.resolveType === 'function' || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLUnionType';
        }
        getTypes() {
            if (typeof this._types === 'function') {
                this._types = this._types();
            }
            return this._types;
        }
        toConfig() {
            return {
                name: this.name,
                description: this.description,
                types: this.getTypes(),
                resolveType: this.resolveType,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes
            };
        }
        toString() {
            return this.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    function defineTypes(config) {
        const types = resolveReadonlyArrayThunk(config.types);
        Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
        return types;
    }
    class GraphQLEnumType {
        constructor(config){
            var _config$extensionASTN5;
            this.name = assertName(config.name);
            this.description = config.description;
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
            this._values = typeof config.values === 'function' ? config.values : defineEnumValues(this.name, config.values);
            this._valueLookup = null;
            this._nameLookup = null;
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLEnumType';
        }
        getValues() {
            if (typeof this._values === 'function') {
                this._values = defineEnumValues(this.name, this._values());
            }
            return this._values;
        }
        getValue(name) {
            if (this._nameLookup === null) {
                this._nameLookup = keyMap(this.getValues(), (value)=>value.name);
            }
            return this._nameLookup[name];
        }
        serialize(outputValue) {
            if (this._valueLookup === null) {
                this._valueLookup = new Map(this.getValues().map((enumValue)=>[
                        enumValue.value,
                        enumValue
                    ]));
            }
            const enumValue = this._valueLookup.get(outputValue);
            if (enumValue === undefined) {
                throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);
            }
            return enumValue.name;
        }
        parseValue(inputValue) {
            if (typeof inputValue !== 'string') {
                const valueStr = inspect(inputValue);
                throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
            }
            const enumValue = this.getValue(inputValue);
            if (enumValue == null) {
                throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
            }
            return enumValue.value;
        }
        parseLiteral(valueNode, _variables) {
            if (valueNode.kind !== Kind.ENUM) {
                const valueStr = print$1(valueNode);
                throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
                    nodes: valueNode
                });
            }
            const enumValue = this.getValue(valueNode.value);
            if (enumValue == null) {
                const valueStr = print$1(valueNode);
                throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
                    nodes: valueNode
                });
            }
            return enumValue.value;
        }
        toConfig() {
            const values = keyValMap(this.getValues(), (value)=>value.name, (value)=>({
                    description: value.description,
                    value: value.value,
                    deprecationReason: value.deprecationReason,
                    extensions: value.extensions,
                    astNode: value.astNode
                }));
            return {
                name: this.name,
                description: this.description,
                values,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes
            };
        }
        toString() {
            return this.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    function didYouMeanEnumValue(enumType, unknownValueStr) {
        const allNames = enumType.getValues().map((value)=>value.name);
        const suggestedValues = suggestionList(unknownValueStr, allNames);
        return didYouMean('the enum value', suggestedValues);
    }
    function defineEnumValues(typeName, valueMap) {
        isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
        return Object.entries(valueMap).map(([valueName, valueConfig])=>{
            isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${inspect(valueConfig)}.`);
            return {
                name: assertEnumValueName(valueName),
                description: valueConfig.description,
                value: valueConfig.value !== undefined ? valueConfig.value : valueName,
                deprecationReason: valueConfig.deprecationReason,
                extensions: toObjMap(valueConfig.extensions),
                astNode: valueConfig.astNode
            };
        });
    }
    class GraphQLInputObjectType {
        constructor(config){
            var _config$extensionASTN6, _config$isOneOf;
            this.name = assertName(config.name);
            this.description = config.description;
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
            this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
            this._fields = defineInputFieldMap.bind(undefined, config);
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLInputObjectType';
        }
        getFields() {
            if (typeof this._fields === 'function') {
                this._fields = this._fields();
            }
            return this._fields;
        }
        toConfig() {
            const fields = mapValue(this.getFields(), (field)=>({
                    description: field.description,
                    type: field.type,
                    defaultValue: field.defaultValue,
                    deprecationReason: field.deprecationReason,
                    extensions: field.extensions,
                    astNode: field.astNode
                }));
            return {
                name: this.name,
                description: this.description,
                fields,
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes,
                isOneOf: this.isOneOf
            };
        }
        toString() {
            return this.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    function defineInputFieldMap(config) {
        const fieldMap = resolveObjMapThunk(config.fields);
        isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
        return mapValue(fieldMap, (fieldConfig, fieldName)=>{
            !('resolve' in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
            return {
                name: assertName(fieldName),
                description: fieldConfig.description,
                type: fieldConfig.type,
                defaultValue: fieldConfig.defaultValue,
                deprecationReason: fieldConfig.deprecationReason,
                extensions: toObjMap(fieldConfig.extensions),
                astNode: fieldConfig.astNode
            };
        });
    }
    function isRequiredInputField(field) {
        return isNonNullType(field.type) && field.defaultValue === undefined;
    }
    function isEqualType(typeA, typeB) {
        if (typeA === typeB) {
            return true;
        }
        if (isNonNullType(typeA) && isNonNullType(typeB)) {
            return isEqualType(typeA.ofType, typeB.ofType);
        }
        if (isListType(typeA) && isListType(typeB)) {
            return isEqualType(typeA.ofType, typeB.ofType);
        }
        return false;
    }
    function isTypeSubTypeOf(schema, maybeSubType, superType) {
        if (maybeSubType === superType) {
            return true;
        }
        if (isNonNullType(superType)) {
            if (isNonNullType(maybeSubType)) {
                return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
            }
            return false;
        }
        if (isNonNullType(maybeSubType)) {
            return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
        }
        if (isListType(superType)) {
            if (isListType(maybeSubType)) {
                return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
            }
            return false;
        }
        if (isListType(maybeSubType)) {
            return false;
        }
        return (isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType));
    }
    function doTypesOverlap(schema, typeA, typeB) {
        if (typeA === typeB) {
            return true;
        }
        if (isAbstractType(typeA)) {
            if (isAbstractType(typeB)) {
                return schema.getPossibleTypes(typeA).some((type)=>schema.isSubType(typeB, type));
            }
            return schema.isSubType(typeA, typeB);
        }
        if (isAbstractType(typeB)) {
            return schema.isSubType(typeB, typeA);
        }
        return false;
    }
    const GRAPHQL_MAX_INT = 2147483647;
    const GRAPHQL_MIN_INT = -2147483648;
    const GraphQLInt = new GraphQLScalarType({
        name: 'Int',
        description: 'The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.',
        serialize (outputValue) {
            const coercedValue = serializeObject(outputValue);
            if (typeof coercedValue === 'boolean') {
                return coercedValue ? 1 : 0;
            }
            let num = coercedValue;
            if (typeof coercedValue === 'string' && coercedValue !== '') {
                num = Number(coercedValue);
            }
            if (typeof num !== 'number' || !Number.isInteger(num)) {
                throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);
            }
            if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
                throw new GraphQLError('Int cannot represent non 32-bit signed integer value: ' + inspect(coercedValue));
            }
            return num;
        },
        parseValue (inputValue) {
            if (typeof inputValue !== 'number' || !Number.isInteger(inputValue)) {
                throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);
            }
            if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
                throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
            }
            return inputValue;
        },
        parseLiteral (valueNode) {
            if (valueNode.kind !== Kind.INT) {
                throw new GraphQLError(`Int cannot represent non-integer value: ${print$1(valueNode)}`, {
                    nodes: valueNode
                });
            }
            const num = parseInt(valueNode.value, 10);
            if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
                throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
                    nodes: valueNode
                });
            }
            return num;
        }
    });
    const GraphQLFloat = new GraphQLScalarType({
        name: 'Float',
        description: 'The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).',
        serialize (outputValue) {
            const coercedValue = serializeObject(outputValue);
            if (typeof coercedValue === 'boolean') {
                return coercedValue ? 1 : 0;
            }
            let num = coercedValue;
            if (typeof coercedValue === 'string' && coercedValue !== '') {
                num = Number(coercedValue);
            }
            if (typeof num !== 'number' || !Number.isFinite(num)) {
                throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);
            }
            return num;
        },
        parseValue (inputValue) {
            if (typeof inputValue !== 'number' || !Number.isFinite(inputValue)) {
                throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);
            }
            return inputValue;
        },
        parseLiteral (valueNode) {
            if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
                throw new GraphQLError(`Float cannot represent non numeric value: ${print$1(valueNode)}`, valueNode);
            }
            return parseFloat(valueNode.value);
        }
    });
    const GraphQLString = new GraphQLScalarType({
        name: 'String',
        description: 'The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.',
        serialize (outputValue) {
            const coercedValue = serializeObject(outputValue);
            if (typeof coercedValue === 'string') {
                return coercedValue;
            }
            if (typeof coercedValue === 'boolean') {
                return coercedValue ? 'true' : 'false';
            }
            if (typeof coercedValue === 'number' && Number.isFinite(coercedValue)) {
                return coercedValue.toString();
            }
            throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);
        },
        parseValue (inputValue) {
            if (typeof inputValue !== 'string') {
                throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);
            }
            return inputValue;
        },
        parseLiteral (valueNode) {
            if (valueNode.kind !== Kind.STRING) {
                throw new GraphQLError(`String cannot represent a non string value: ${print$1(valueNode)}`, {
                    nodes: valueNode
                });
            }
            return valueNode.value;
        }
    });
    const GraphQLBoolean = new GraphQLScalarType({
        name: 'Boolean',
        description: 'The `Boolean` scalar type represents `true` or `false`.',
        serialize (outputValue) {
            const coercedValue = serializeObject(outputValue);
            if (typeof coercedValue === 'boolean') {
                return coercedValue;
            }
            if (Number.isFinite(coercedValue)) {
                return coercedValue !== 0;
            }
            throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);
        },
        parseValue (inputValue) {
            if (typeof inputValue !== 'boolean') {
                throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);
            }
            return inputValue;
        },
        parseLiteral (valueNode) {
            if (valueNode.kind !== Kind.BOOLEAN) {
                throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print$1(valueNode)}`, {
                    nodes: valueNode
                });
            }
            return valueNode.value;
        }
    });
    const GraphQLID = new GraphQLScalarType({
        name: 'ID',
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize (outputValue) {
            const coercedValue = serializeObject(outputValue);
            if (typeof coercedValue === 'string') {
                return coercedValue;
            }
            if (Number.isInteger(coercedValue)) {
                return String(coercedValue);
            }
            throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);
        },
        parseValue (inputValue) {
            if (typeof inputValue === 'string') {
                return inputValue;
            }
            if (typeof inputValue === 'number' && Number.isInteger(inputValue)) {
                return inputValue.toString();
            }
            throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
        },
        parseLiteral (valueNode) {
            if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
                throw new GraphQLError('ID cannot represent a non-string and non-integer value: ' + print$1(valueNode), {
                    nodes: valueNode
                });
            }
            return valueNode.value;
        }
    });
    const specifiedScalarTypes = Object.freeze([
        GraphQLString,
        GraphQLInt,
        GraphQLFloat,
        GraphQLBoolean,
        GraphQLID
    ]);
    function isSpecifiedScalarType(type) {
        return specifiedScalarTypes.some(({ name })=>type.name === name);
    }
    function serializeObject(outputValue) {
        if (isObjectLike(outputValue)) {
            if (typeof outputValue.valueOf === 'function') {
                const valueOfResult = outputValue.valueOf();
                if (!isObjectLike(valueOfResult)) {
                    return valueOfResult;
                }
            }
            if (typeof outputValue.toJSON === 'function') {
                return outputValue.toJSON();
            }
        }
        return outputValue;
    }
    function isDirective(directive) {
        return instanceOf(directive, GraphQLDirective);
    }
    function assertDirective(directive) {
        if (!isDirective(directive)) {
            throw new Error(`Expected ${inspect(directive)} to be a GraphQL directive.`);
        }
        return directive;
    }
    class GraphQLDirective {
        constructor(config){
            var _config$isRepeatable, _config$args;
            this.name = assertName(config.name);
            this.description = config.description;
            this.locations = config.locations;
            this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
            const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
            (isObjectLike(args) && !Array.isArray(args)) || devAssert(false, `@${config.name} args must be an object with argument names as keys.`);
            this.args = defineArguments(args);
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLDirective';
        }
        toConfig() {
            return {
                name: this.name,
                description: this.description,
                locations: this.locations,
                args: argsToArgsConfig(this.args),
                isRepeatable: this.isRepeatable,
                extensions: this.extensions,
                astNode: this.astNode
            };
        }
        toString() {
            return '@' + this.name;
        }
        toJSON() {
            return this.toString();
        }
    }
    const GraphQLIncludeDirective = new GraphQLDirective({
        name: 'include',
        description: 'Directs the executor to include this field or fragment only when the `if` argument is true.',
        locations: [
            DirectiveLocation.FIELD,
            DirectiveLocation.FRAGMENT_SPREAD,
            DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
            if: {
                type: new GraphQLNonNull(GraphQLBoolean),
                description: 'Included when true.'
            }
        }
    });
    const GraphQLSkipDirective = new GraphQLDirective({
        name: 'skip',
        description: 'Directs the executor to skip this field or fragment when the `if` argument is true.',
        locations: [
            DirectiveLocation.FIELD,
            DirectiveLocation.FRAGMENT_SPREAD,
            DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
            if: {
                type: new GraphQLNonNull(GraphQLBoolean),
                description: 'Skipped when true.'
            }
        }
    });
    const DEFAULT_DEPRECATION_REASON = 'No longer supported';
    const GraphQLDeprecatedDirective = new GraphQLDirective({
        name: 'deprecated',
        description: 'Marks an element of a GraphQL schema as no longer supported.',
        locations: [
            DirectiveLocation.FIELD_DEFINITION,
            DirectiveLocation.ARGUMENT_DEFINITION,
            DirectiveLocation.INPUT_FIELD_DEFINITION,
            DirectiveLocation.ENUM_VALUE
        ],
        args: {
            reason: {
                type: GraphQLString,
                description: 'Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).',
                defaultValue: DEFAULT_DEPRECATION_REASON
            }
        }
    });
    const GraphQLSpecifiedByDirective = new GraphQLDirective({
        name: 'specifiedBy',
        description: 'Exposes a URL that specifies the behavior of this scalar.',
        locations: [
            DirectiveLocation.SCALAR
        ],
        args: {
            url: {
                type: new GraphQLNonNull(GraphQLString),
                description: 'The URL that specifies the behavior of this scalar.'
            }
        }
    });
    const GraphQLOneOfDirective = new GraphQLDirective({
        name: 'oneOf',
        description: 'Indicates exactly one field must be supplied and this field must not be `null`.',
        locations: [
            DirectiveLocation.INPUT_OBJECT
        ],
        args: {}
    });
    const specifiedDirectives = Object.freeze([
        GraphQLIncludeDirective,
        GraphQLSkipDirective,
        GraphQLDeprecatedDirective,
        GraphQLSpecifiedByDirective,
        GraphQLOneOfDirective
    ]);
    function isSpecifiedDirective(directive) {
        return specifiedDirectives.some(({ name })=>name === directive.name);
    }
    function isIterableObject(maybeIterable) {
        return (typeof maybeIterable === 'object' && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === 'function');
    }
    function astFromValue(value, type) {
        if (isNonNullType(type)) {
            const astValue = astFromValue(value, type.ofType);
            if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
                return null;
            }
            return astValue;
        }
        if (value === null) {
            return {
                kind: Kind.NULL
            };
        }
        if (value === undefined) {
            return null;
        }
        if (isListType(type)) {
            const itemType = type.ofType;
            if (isIterableObject(value)) {
                const valuesNodes = [];
                for (const item of value){
                    const itemNode = astFromValue(item, itemType);
                    if (itemNode != null) {
                        valuesNodes.push(itemNode);
                    }
                }
                return {
                    kind: Kind.LIST,
                    values: valuesNodes
                };
            }
            return astFromValue(value, itemType);
        }
        if (isInputObjectType(type)) {
            if (!isObjectLike(value)) {
                return null;
            }
            const fieldNodes = [];
            for (const field of Object.values(type.getFields())){
                const fieldValue = astFromValue(value[field.name], field.type);
                if (fieldValue) {
                    fieldNodes.push({
                        kind: Kind.OBJECT_FIELD,
                        name: {
                            kind: Kind.NAME,
                            value: field.name
                        },
                        value: fieldValue
                    });
                }
            }
            return {
                kind: Kind.OBJECT,
                fields: fieldNodes
            };
        }
        if (isLeafType(type)) {
            const serialized = type.serialize(value);
            if (serialized == null) {
                return null;
            }
            if (typeof serialized === 'boolean') {
                return {
                    kind: Kind.BOOLEAN,
                    value: serialized
                };
            }
            if (typeof serialized === 'number' && Number.isFinite(serialized)) {
                const stringNum = String(serialized);
                return integerStringRegExp.test(stringNum) ? {
                    kind: Kind.INT,
                    value: stringNum
                } : {
                    kind: Kind.FLOAT,
                    value: stringNum
                };
            }
            if (typeof serialized === 'string') {
                if (isEnumType(type)) {
                    return {
                        kind: Kind.ENUM,
                        value: serialized
                    };
                }
                if (type === GraphQLID && integerStringRegExp.test(serialized)) {
                    return {
                        kind: Kind.INT,
                        value: serialized
                    };
                }
                return {
                    kind: Kind.STRING,
                    value: serialized
                };
            }
            throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
        }
        invariant(false, 'Unexpected input type: ' + inspect(type));
    }
    const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
    const __Schema = new GraphQLObjectType({
        name: '__Schema',
        description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.',
        fields: ()=>({
                description: {
                    type: GraphQLString,
                    resolve: (schema)=>schema.description
                },
                types: {
                    description: 'A list of all types supported by this server.',
                    type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
                    resolve (schema) {
                        return Object.values(schema.getTypeMap());
                    }
                },
                queryType: {
                    description: 'The type that query operations will be rooted at.',
                    type: new GraphQLNonNull(__Type),
                    resolve: (schema)=>schema.getQueryType()
                },
                mutationType: {
                    description: 'If this server supports mutation, the type that mutation operations will be rooted at.',
                    type: __Type,
                    resolve: (schema)=>schema.getMutationType()
                },
                subscriptionType: {
                    description: 'If this server support subscription, the type that subscription operations will be rooted at.',
                    type: __Type,
                    resolve: (schema)=>schema.getSubscriptionType()
                },
                directives: {
                    description: 'A list of all directives supported by this server.',
                    type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
                    resolve: (schema)=>schema.getDirectives()
                }
            })
    });
    const __Directive = new GraphQLObjectType({
        name: '__Directive',
        description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
        fields: ()=>({
                name: {
                    type: new GraphQLNonNull(GraphQLString),
                    resolve: (directive)=>directive.name
                },
                description: {
                    type: GraphQLString,
                    resolve: (directive)=>directive.description
                },
                isRepeatable: {
                    type: new GraphQLNonNull(GraphQLBoolean),
                    resolve: (directive)=>directive.isRepeatable
                },
                locations: {
                    type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
                    resolve: (directive)=>directive.locations
                },
                args: {
                    type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
                    args: {
                        includeDeprecated: {
                            type: GraphQLBoolean,
                            defaultValue: false
                        }
                    },
                    resolve (field, { includeDeprecated }) {
                        return includeDeprecated ? field.args : field.args.filter((arg)=>arg.deprecationReason == null);
                    }
                }
            })
    });
    const __DirectiveLocation = new GraphQLEnumType({
        name: '__DirectiveLocation',
        description: 'A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.',
        values: {
            QUERY: {
                value: DirectiveLocation.QUERY,
                description: 'Location adjacent to a query operation.'
            },
            MUTATION: {
                value: DirectiveLocation.MUTATION,
                description: 'Location adjacent to a mutation operation.'
            },
            SUBSCRIPTION: {
                value: DirectiveLocation.SUBSCRIPTION,
                description: 'Location adjacent to a subscription operation.'
            },
            FIELD: {
                value: DirectiveLocation.FIELD,
                description: 'Location adjacent to a field.'
            },
            FRAGMENT_DEFINITION: {
                value: DirectiveLocation.FRAGMENT_DEFINITION,
                description: 'Location adjacent to a fragment definition.'
            },
            FRAGMENT_SPREAD: {
                value: DirectiveLocation.FRAGMENT_SPREAD,
                description: 'Location adjacent to a fragment spread.'
            },
            INLINE_FRAGMENT: {
                value: DirectiveLocation.INLINE_FRAGMENT,
                description: 'Location adjacent to an inline fragment.'
            },
            VARIABLE_DEFINITION: {
                value: DirectiveLocation.VARIABLE_DEFINITION,
                description: 'Location adjacent to a variable definition.'
            },
            SCHEMA: {
                value: DirectiveLocation.SCHEMA,
                description: 'Location adjacent to a schema definition.'
            },
            SCALAR: {
                value: DirectiveLocation.SCALAR,
                description: 'Location adjacent to a scalar definition.'
            },
            OBJECT: {
                value: DirectiveLocation.OBJECT,
                description: 'Location adjacent to an object type definition.'
            },
            FIELD_DEFINITION: {
                value: DirectiveLocation.FIELD_DEFINITION,
                description: 'Location adjacent to a field definition.'
            },
            ARGUMENT_DEFINITION: {
                value: DirectiveLocation.ARGUMENT_DEFINITION,
                description: 'Location adjacent to an argument definition.'
            },
            INTERFACE: {
                value: DirectiveLocation.INTERFACE,
                description: 'Location adjacent to an interface definition.'
            },
            UNION: {
                value: DirectiveLocation.UNION,
                description: 'Location adjacent to a union definition.'
            },
            ENUM: {
                value: DirectiveLocation.ENUM,
                description: 'Location adjacent to an enum definition.'
            },
            ENUM_VALUE: {
                value: DirectiveLocation.ENUM_VALUE,
                description: 'Location adjacent to an enum value definition.'
            },
            INPUT_OBJECT: {
                value: DirectiveLocation.INPUT_OBJECT,
                description: 'Location adjacent to an input object type definition.'
            },
            INPUT_FIELD_DEFINITION: {
                value: DirectiveLocation.INPUT_FIELD_DEFINITION,
                description: 'Location adjacent to an input object field definition.'
            }
        }
    });
    const __Type = new GraphQLObjectType({
        name: '__Type',
        description: 'The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.',
        fields: ()=>({
                kind: {
                    type: new GraphQLNonNull(__TypeKind),
                    resolve (type) {
                        if (isScalarType(type)) {
                            return TypeKind.SCALAR;
                        }
                        if (isObjectType(type)) {
                            return TypeKind.OBJECT;
                        }
                        if (isInterfaceType(type)) {
                            return TypeKind.INTERFACE;
                        }
                        if (isUnionType(type)) {
                            return TypeKind.UNION;
                        }
                        if (isEnumType(type)) {
                            return TypeKind.ENUM;
                        }
                        if (isInputObjectType(type)) {
                            return TypeKind.INPUT_OBJECT;
                        }
                        if (isListType(type)) {
                            return TypeKind.LIST;
                        }
                        if (isNonNullType(type)) {
                            return TypeKind.NON_NULL;
                        }
                        invariant(false, `Unexpected type: "${inspect(type)}".`);
                    }
                },
                name: {
                    type: GraphQLString,
                    resolve: (type)=>('name' in type ? type.name : undefined)
                },
                description: {
                    type: GraphQLString,
                    resolve: (type)=>'description' in type ? type.description : undefined
                },
                specifiedByURL: {
                    type: GraphQLString,
                    resolve: (obj)=>'specifiedByURL' in obj ? obj.specifiedByURL : undefined
                },
                fields: {
                    type: new GraphQLList(new GraphQLNonNull(__Field)),
                    args: {
                        includeDeprecated: {
                            type: GraphQLBoolean,
                            defaultValue: false
                        }
                    },
                    resolve (type, { includeDeprecated }) {
                        if (isObjectType(type) || isInterfaceType(type)) {
                            const fields = Object.values(type.getFields());
                            return includeDeprecated ? fields : fields.filter((field)=>field.deprecationReason == null);
                        }
                    }
                },
                interfaces: {
                    type: new GraphQLList(new GraphQLNonNull(__Type)),
                    resolve (type) {
                        if (isObjectType(type) || isInterfaceType(type)) {
                            return type.getInterfaces();
                        }
                    }
                },
                possibleTypes: {
                    type: new GraphQLList(new GraphQLNonNull(__Type)),
                    resolve (type, _args, _context, { schema }) {
                        if (isAbstractType(type)) {
                            return schema.getPossibleTypes(type);
                        }
                    }
                },
                enumValues: {
                    type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
                    args: {
                        includeDeprecated: {
                            type: GraphQLBoolean,
                            defaultValue: false
                        }
                    },
                    resolve (type, { includeDeprecated }) {
                        if (isEnumType(type)) {
                            const values = type.getValues();
                            return includeDeprecated ? values : values.filter((field)=>field.deprecationReason == null);
                        }
                    }
                },
                inputFields: {
                    type: new GraphQLList(new GraphQLNonNull(__InputValue)),
                    args: {
                        includeDeprecated: {
                            type: GraphQLBoolean,
                            defaultValue: false
                        }
                    },
                    resolve (type, { includeDeprecated }) {
                        if (isInputObjectType(type)) {
                            const values = Object.values(type.getFields());
                            return includeDeprecated ? values : values.filter((field)=>field.deprecationReason == null);
                        }
                    }
                },
                ofType: {
                    type: __Type,
                    resolve: (type)=>('ofType' in type ? type.ofType : undefined)
                },
                isOneOf: {
                    type: GraphQLBoolean,
                    resolve: (type)=>{
                        if (isInputObjectType(type)) {
                            return type.isOneOf;
                        }
                    }
                }
            })
    });
    const __Field = new GraphQLObjectType({
        name: '__Field',
        description: 'Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.',
        fields: ()=>({
                name: {
                    type: new GraphQLNonNull(GraphQLString),
                    resolve: (field)=>field.name
                },
                description: {
                    type: GraphQLString,
                    resolve: (field)=>field.description
                },
                args: {
                    type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
                    args: {
                        includeDeprecated: {
                            type: GraphQLBoolean,
                            defaultValue: false
                        }
                    },
                    resolve (field, { includeDeprecated }) {
                        return includeDeprecated ? field.args : field.args.filter((arg)=>arg.deprecationReason == null);
                    }
                },
                type: {
                    type: new GraphQLNonNull(__Type),
                    resolve: (field)=>field.type
                },
                isDeprecated: {
                    type: new GraphQLNonNull(GraphQLBoolean),
                    resolve: (field)=>field.deprecationReason != null
                },
                deprecationReason: {
                    type: GraphQLString,
                    resolve: (field)=>field.deprecationReason
                }
            })
    });
    const __InputValue = new GraphQLObjectType({
        name: '__InputValue',
        description: 'Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.',
        fields: ()=>({
                name: {
                    type: new GraphQLNonNull(GraphQLString),
                    resolve: (inputValue)=>inputValue.name
                },
                description: {
                    type: GraphQLString,
                    resolve: (inputValue)=>inputValue.description
                },
                type: {
                    type: new GraphQLNonNull(__Type),
                    resolve: (inputValue)=>inputValue.type
                },
                defaultValue: {
                    type: GraphQLString,
                    description: 'A GraphQL-formatted string representing the default value for this input value.',
                    resolve (inputValue) {
                        const { type, defaultValue } = inputValue;
                        const valueAST = astFromValue(defaultValue, type);
                        return valueAST ? print$1(valueAST) : null;
                    }
                },
                isDeprecated: {
                    type: new GraphQLNonNull(GraphQLBoolean),
                    resolve: (field)=>field.deprecationReason != null
                },
                deprecationReason: {
                    type: GraphQLString,
                    resolve: (obj)=>obj.deprecationReason
                }
            })
    });
    const __EnumValue = new GraphQLObjectType({
        name: '__EnumValue',
        description: 'One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.',
        fields: ()=>({
                name: {
                    type: new GraphQLNonNull(GraphQLString),
                    resolve: (enumValue)=>enumValue.name
                },
                description: {
                    type: GraphQLString,
                    resolve: (enumValue)=>enumValue.description
                },
                isDeprecated: {
                    type: new GraphQLNonNull(GraphQLBoolean),
                    resolve: (enumValue)=>enumValue.deprecationReason != null
                },
                deprecationReason: {
                    type: GraphQLString,
                    resolve: (enumValue)=>enumValue.deprecationReason
                }
            })
    });
    var TypeKind;
    (function(TypeKind) {
        TypeKind['SCALAR'] = 'SCALAR';
        TypeKind['OBJECT'] = 'OBJECT';
        TypeKind['INTERFACE'] = 'INTERFACE';
        TypeKind['UNION'] = 'UNION';
        TypeKind['ENUM'] = 'ENUM';
        TypeKind['INPUT_OBJECT'] = 'INPUT_OBJECT';
        TypeKind['LIST'] = 'LIST';
        TypeKind['NON_NULL'] = 'NON_NULL';
    })(TypeKind || (TypeKind = {}));
    const __TypeKind = new GraphQLEnumType({
        name: '__TypeKind',
        description: 'An enum describing what kind of type a given `__Type` is.',
        values: {
            SCALAR: {
                value: TypeKind.SCALAR,
                description: 'Indicates this type is a scalar.'
            },
            OBJECT: {
                value: TypeKind.OBJECT,
                description: 'Indicates this type is an object. `fields` and `interfaces` are valid fields.'
            },
            INTERFACE: {
                value: TypeKind.INTERFACE,
                description: 'Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.'
            },
            UNION: {
                value: TypeKind.UNION,
                description: 'Indicates this type is a union. `possibleTypes` is a valid field.'
            },
            ENUM: {
                value: TypeKind.ENUM,
                description: 'Indicates this type is an enum. `enumValues` is a valid field.'
            },
            INPUT_OBJECT: {
                value: TypeKind.INPUT_OBJECT,
                description: 'Indicates this type is an input object. `inputFields` is a valid field.'
            },
            LIST: {
                value: TypeKind.LIST,
                description: 'Indicates this type is a list. `ofType` is a valid field.'
            },
            NON_NULL: {
                value: TypeKind.NON_NULL,
                description: 'Indicates this type is a non-null. `ofType` is a valid field.'
            }
        }
    });
    const SchemaMetaFieldDef = {
        name: '__schema',
        type: new GraphQLNonNull(__Schema),
        description: 'Access the current type schema of this server.',
        args: [],
        resolve: (_source, _args, _context, { schema })=>schema,
        deprecationReason: undefined,
        extensions: Object.create(null),
        astNode: undefined
    };
    const TypeMetaFieldDef = {
        name: '__type',
        type: __Type,
        description: 'Request the type information of a single type.',
        args: [
            {
                name: 'name',
                description: undefined,
                type: new GraphQLNonNull(GraphQLString),
                defaultValue: undefined,
                deprecationReason: undefined,
                extensions: Object.create(null),
                astNode: undefined
            }
        ],
        resolve: (_source, { name }, _context, { schema })=>schema.getType(name),
        deprecationReason: undefined,
        extensions: Object.create(null),
        astNode: undefined
    };
    const TypeNameMetaFieldDef = {
        name: '__typename',
        type: new GraphQLNonNull(GraphQLString),
        description: 'The name of the current Object type at runtime.',
        args: [],
        resolve: (_source, _args, _context, { parentType })=>parentType.name,
        deprecationReason: undefined,
        extensions: Object.create(null),
        astNode: undefined
    };
    const introspectionTypes = Object.freeze([
        __Schema,
        __Directive,
        __DirectiveLocation,
        __Type,
        __Field,
        __InputValue,
        __EnumValue,
        __TypeKind
    ]);
    function isIntrospectionType(type) {
        return introspectionTypes.some(({ name })=>type.name === name);
    }
    function isSchema(schema) {
        return instanceOf(schema, GraphQLSchema);
    }
    function assertSchema(schema) {
        if (!isSchema(schema)) {
            throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
        }
        return schema;
    }
    class GraphQLSchema {
        constructor(config){
            var _config$extensionASTN, _config$directives;
            this.__validationErrors = config.assumeValid === true ? [] : undefined;
            isObjectLike(config) || devAssert(false, 'Must provide configuration object.');
            !config.types || Array.isArray(config.types) || devAssert(false, `"types" must be Array if provided but got: ${inspect(config.types)}.`);
            !config.directives || Array.isArray(config.directives) || devAssert(false, '"directives" must be Array if provided but got: ' + `${inspect(config.directives)}.`);
            this.description = config.description;
            this.extensions = toObjMap(config.extensions);
            this.astNode = config.astNode;
            this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
            this._queryType = config.query;
            this._mutationType = config.mutation;
            this._subscriptionType = config.subscription;
            this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
            const allReferencedTypes = new Set(config.types);
            if (config.types != null) {
                for (const type of config.types){
                    allReferencedTypes.delete(type);
                    collectReferencedTypes(type, allReferencedTypes);
                }
            }
            if (this._queryType != null) {
                collectReferencedTypes(this._queryType, allReferencedTypes);
            }
            if (this._mutationType != null) {
                collectReferencedTypes(this._mutationType, allReferencedTypes);
            }
            if (this._subscriptionType != null) {
                collectReferencedTypes(this._subscriptionType, allReferencedTypes);
            }
            for (const directive of this._directives){
                if (isDirective(directive)) {
                    for (const arg of directive.args){
                        collectReferencedTypes(arg.type, allReferencedTypes);
                    }
                }
            }
            collectReferencedTypes(__Schema, allReferencedTypes);
            this._typeMap = Object.create(null);
            this._subTypeMap = Object.create(null);
            this._implementationsMap = Object.create(null);
            for (const namedType of allReferencedTypes){
                if (namedType == null) {
                    continue;
                }
                const typeName = namedType.name;
                typeName || devAssert(false, 'One of the provided types for building the Schema is missing a name.');
                if (this._typeMap[typeName] !== undefined) {
                    throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
                }
                this._typeMap[typeName] = namedType;
                if (isInterfaceType(namedType)) {
                    for (const iface of namedType.getInterfaces()){
                        if (isInterfaceType(iface)) {
                            let implementations = this._implementationsMap[iface.name];
                            if (implementations === undefined) {
                                implementations = this._implementationsMap[iface.name] = {
                                    objects: [],
                                    interfaces: []
                                };
                            }
                            implementations.interfaces.push(namedType);
                        }
                    }
                } else if (isObjectType(namedType)) {
                    for (const iface of namedType.getInterfaces()){
                        if (isInterfaceType(iface)) {
                            let implementations = this._implementationsMap[iface.name];
                            if (implementations === undefined) {
                                implementations = this._implementationsMap[iface.name] = {
                                    objects: [],
                                    interfaces: []
                                };
                            }
                            implementations.objects.push(namedType);
                        }
                    }
                }
            }
        }
        get [Symbol.toStringTag]() {
            return 'GraphQLSchema';
        }
        getQueryType() {
            return this._queryType;
        }
        getMutationType() {
            return this._mutationType;
        }
        getSubscriptionType() {
            return this._subscriptionType;
        }
        getRootType(operation) {
            switch(operation){
                case OperationTypeNode.QUERY:
                    return this.getQueryType();
                case OperationTypeNode.MUTATION:
                    return this.getMutationType();
                case OperationTypeNode.SUBSCRIPTION:
                    return this.getSubscriptionType();
            }
        }
        getTypeMap() {
            return this._typeMap;
        }
        getType(name) {
            return this.getTypeMap()[name];
        }
        getPossibleTypes(abstractType) {
            return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
        }
        getImplementations(interfaceType) {
            const implementations = this._implementationsMap[interfaceType.name];
            return implementations !== null && implementations !== void 0 ? implementations : {
                objects: [],
                interfaces: []
            };
        }
        isSubType(abstractType, maybeSubType) {
            let map = this._subTypeMap[abstractType.name];
            if (map === undefined) {
                map = Object.create(null);
                if (isUnionType(abstractType)) {
                    for (const type of abstractType.getTypes()){
                        map[type.name] = true;
                    }
                } else {
                    const implementations = this.getImplementations(abstractType);
                    for (const type of implementations.objects){
                        map[type.name] = true;
                    }
                    for (const type of implementations.interfaces){
                        map[type.name] = true;
                    }
                }
                this._subTypeMap[abstractType.name] = map;
            }
            return map[maybeSubType.name] !== undefined;
        }
        getDirectives() {
            return this._directives;
        }
        getDirective(name) {
            return this.getDirectives().find((directive)=>directive.name === name);
        }
        toConfig() {
            return {
                description: this.description,
                query: this.getQueryType(),
                mutation: this.getMutationType(),
                subscription: this.getSubscriptionType(),
                types: Object.values(this.getTypeMap()),
                directives: this.getDirectives(),
                extensions: this.extensions,
                astNode: this.astNode,
                extensionASTNodes: this.extensionASTNodes,
                assumeValid: this.__validationErrors !== undefined
            };
        }
    }
    function collectReferencedTypes(type, typeSet) {
        const namedType = getNamedType(type);
        if (!typeSet.has(namedType)) {
            typeSet.add(namedType);
            if (isUnionType(namedType)) {
                for (const memberType of namedType.getTypes()){
                    collectReferencedTypes(memberType, typeSet);
                }
            } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
                for (const interfaceType of namedType.getInterfaces()){
                    collectReferencedTypes(interfaceType, typeSet);
                }
                for (const field of Object.values(namedType.getFields())){
                    collectReferencedTypes(field.type, typeSet);
                    for (const arg of field.args){
                        collectReferencedTypes(arg.type, typeSet);
                    }
                }
            } else if (isInputObjectType(namedType)) {
                for (const field of Object.values(namedType.getFields())){
                    collectReferencedTypes(field.type, typeSet);
                }
            }
        }
        return typeSet;
    }
    function validateSchema(schema) {
        assertSchema(schema);
        if (schema.__validationErrors) {
            return schema.__validationErrors;
        }
        const context = new SchemaValidationContext(schema);
        validateRootTypes(context);
        validateDirectives(context);
        validateTypes(context);
        const errors = context.getErrors();
        schema.__validationErrors = errors;
        return errors;
    }
    function assertValidSchema(schema) {
        const errors = validateSchema(schema);
        if (errors.length !== 0) {
            throw new Error(errors.map((error)=>error.message).join('\n\n'));
        }
    }
    class SchemaValidationContext {
        constructor(schema){
            this._errors = [];
            this.schema = schema;
        }
        reportError(message, nodes) {
            const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
            this._errors.push(new GraphQLError(message, {
                nodes: _nodes
            }));
        }
        getErrors() {
            return this._errors;
        }
    }
    function validateRootTypes(context) {
        const schema = context.schema;
        const queryType = schema.getQueryType();
        if (!queryType) {
            context.reportError('Query root type must be provided.', schema.astNode);
        } else if (!isObjectType(queryType)) {
            var _getOperationTypeNode;
            context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
        }
        const mutationType = schema.getMutationType();
        if (mutationType && !isObjectType(mutationType)) {
            var _getOperationTypeNode2;
            context.reportError('Mutation root type must be Object type if provided, it cannot be ' + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && !isObjectType(subscriptionType)) {
            var _getOperationTypeNode3;
            context.reportError('Subscription root type must be Object type if provided, it cannot be ' + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
        }
    }
    function getOperationTypeNode(schema, operation) {
        var _flatMap$find;
        return (_flatMap$find = [
            schema.astNode,
            ...schema.extensionASTNodes
        ].flatMap((schemaNode)=>{
            var _schemaNode$operation;
            return ((_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []);
        }).find((operationNode)=>operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
    }
    function validateDirectives(context) {
        for (const directive of context.schema.getDirectives()){
            if (!isDirective(directive)) {
                context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);
                continue;
            }
            validateName(context, directive);
            if (directive.locations.length === 0) {
                context.reportError(`Directive @${directive.name} must include 1 or more locations.`, directive.astNode);
            }
            for (const arg of directive.args){
                validateName(context, arg);
                if (!isInputType(arg.type)) {
                    context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);
                }
                if (isRequiredArgument(arg) && arg.deprecationReason != null) {
                    var _arg$astNode;
                    context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
                        getDeprecatedDirectiveNode(arg.astNode),
                        (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
                    ]);
                }
            }
        }
    }
    function validateName(context, node) {
        if (node.name.startsWith('__')) {
            context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
        }
    }
    function validateTypes(context) {
        const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
        const typeMap = context.schema.getTypeMap();
        for (const type of Object.values(typeMap)){
            if (!isNamedType(type)) {
                context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);
                continue;
            }
            if (!isIntrospectionType(type)) {
                validateName(context, type);
            }
            if (isObjectType(type)) {
                validateFields(context, type);
                validateInterfaces(context, type);
            } else if (isInterfaceType(type)) {
                validateFields(context, type);
                validateInterfaces(context, type);
            } else if (isUnionType(type)) {
                validateUnionMembers(context, type);
            } else if (isEnumType(type)) {
                validateEnumValues(context, type);
            } else if (isInputObjectType(type)) {
                validateInputFields(context, type);
                validateInputObjectCircularRefs(type);
            }
        }
    }
    function validateFields(context, type) {
        const fields = Object.values(type.getFields());
        if (fields.length === 0) {
            context.reportError(`Type ${type.name} must define one or more fields.`, [
                type.astNode,
                ...type.extensionASTNodes
            ]);
        }
        for (const field of fields){
            validateName(context, field);
            if (!isOutputType(field.type)) {
                var _field$astNode;
                context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
            }
            for (const arg of field.args){
                const argName = arg.name;
                validateName(context, arg);
                if (!isInputType(arg.type)) {
                    var _arg$astNode2;
                    context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
                }
                if (isRequiredArgument(arg) && arg.deprecationReason != null) {
                    var _arg$astNode3;
                    context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
                        getDeprecatedDirectiveNode(arg.astNode),
                        (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
                    ]);
                }
            }
        }
    }
    function validateInterfaces(context, type) {
        const ifaceTypeNames = Object.create(null);
        for (const iface of type.getInterfaces()){
            if (!isInterfaceType(iface)) {
                context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
                continue;
            }
            if (type === iface) {
                context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
                continue;
            }
            if (ifaceTypeNames[iface.name]) {
                context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
                continue;
            }
            ifaceTypeNames[iface.name] = true;
            validateTypeImplementsAncestors(context, type, iface);
            validateTypeImplementsInterface(context, type, iface);
        }
    }
    function validateTypeImplementsInterface(context, type, iface) {
        const typeFieldMap = type.getFields();
        for (const ifaceField of Object.values(iface.getFields())){
            const fieldName = ifaceField.name;
            const typeField = typeFieldMap[fieldName];
            if (!typeField) {
                context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [
                    ifaceField.astNode,
                    type.astNode,
                    ...type.extensionASTNodes
                ]);
                continue;
            }
            if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
                var _ifaceField$astNode, _typeField$astNode;
                context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [
                    (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
                    (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
                ]);
            }
            for (const ifaceArg of ifaceField.args){
                const argName = ifaceArg.name;
                const typeArg = typeField.args.find((arg)=>arg.name === argName);
                if (!typeArg) {
                    context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [
                        ifaceArg.astNode,
                        typeField.astNode
                    ]);
                    continue;
                }
                if (!isEqualType(ifaceArg.type, typeArg.type)) {
                    var _ifaceArg$astNode, _typeArg$astNode;
                    context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [
                        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
                    ]);
                }
            }
            for (const typeArg of typeField.args){
                const argName = typeArg.name;
                const ifaceArg = ifaceField.args.find((arg)=>arg.name === argName);
                if (!ifaceArg && isRequiredArgument(typeArg)) {
                    context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [
                        typeArg.astNode,
                        ifaceField.astNode
                    ]);
                }
            }
        }
    }
    function validateTypeImplementsAncestors(context, type, iface) {
        const ifaceInterfaces = type.getInterfaces();
        for (const transitive of iface.getInterfaces()){
            if (!ifaceInterfaces.includes(transitive)) {
                context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
                    ...getAllImplementsInterfaceNodes(iface, transitive),
                    ...getAllImplementsInterfaceNodes(type, iface)
                ]);
            }
        }
    }
    function validateUnionMembers(context, union) {
        const memberTypes = union.getTypes();
        if (memberTypes.length === 0) {
            context.reportError(`Union type ${union.name} must define one or more member types.`, [
                union.astNode,
                ...union.extensionASTNodes
            ]);
        }
        const includedTypeNames = Object.create(null);
        for (const memberType of memberTypes){
            if (includedTypeNames[memberType.name]) {
                context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
                continue;
            }
            includedTypeNames[memberType.name] = true;
            if (!isObjectType(memberType)) {
                context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
            }
        }
    }
    function validateEnumValues(context, enumType) {
        const enumValues = enumType.getValues();
        if (enumValues.length === 0) {
            context.reportError(`Enum type ${enumType.name} must define one or more values.`, [
                enumType.astNode,
                ...enumType.extensionASTNodes
            ]);
        }
        for (const enumValue of enumValues){
            validateName(context, enumValue);
        }
    }
    function validateInputFields(context, inputObj) {
        const fields = Object.values(inputObj.getFields());
        if (fields.length === 0) {
            context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [
                inputObj.astNode,
                ...inputObj.extensionASTNodes
            ]);
        }
        for (const field of fields){
            validateName(context, field);
            if (!isInputType(field.type)) {
                var _field$astNode2;
                context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
            }
            if (isRequiredInputField(field) && field.deprecationReason != null) {
                var _field$astNode3;
                context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
                    getDeprecatedDirectiveNode(field.astNode),
                    (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
                ]);
            }
            if (inputObj.isOneOf) {
                validateOneOfInputObjectField(inputObj, field, context);
            }
        }
    }
    function validateOneOfInputObjectField(type, field, context) {
        if (isNonNullType(field.type)) {
            var _field$astNode4;
            context.reportError(`OneOf input field ${type.name}.${field.name} must be nullable.`, (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type);
        }
        if (field.defaultValue !== undefined) {
            context.reportError(`OneOf input field ${type.name}.${field.name} cannot have a default value.`, field.astNode);
        }
    }
    function createInputObjectCircularRefsValidator(context) {
        const visitedTypes = Object.create(null);
        const fieldPath = [];
        const fieldPathIndexByTypeName = Object.create(null);
        return detectCycleRecursive;
        function detectCycleRecursive(inputObj) {
            if (visitedTypes[inputObj.name]) {
                return;
            }
            visitedTypes[inputObj.name] = true;
            fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
            const fields = Object.values(inputObj.getFields());
            for (const field of fields){
                if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
                    const fieldType = field.type.ofType;
                    const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
                    fieldPath.push(field);
                    if (cycleIndex === undefined) {
                        detectCycleRecursive(fieldType);
                    } else {
                        const cyclePath = fieldPath.slice(cycleIndex);
                        const pathStr = cyclePath.map((fieldObj)=>fieldObj.name).join('.');
                        context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj)=>fieldObj.astNode));
                    }
                    fieldPath.pop();
                }
            }
            fieldPathIndexByTypeName[inputObj.name] = undefined;
        }
    }
    function getAllImplementsInterfaceNodes(type, iface) {
        const { astNode, extensionASTNodes } = type;
        const nodes = astNode != null ? [
            astNode,
            ...extensionASTNodes
        ] : extensionASTNodes;
        return nodes.flatMap((typeNode)=>{
            var _typeNode$interfaces;
            return ((_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []);
        }).filter((ifaceNode)=>ifaceNode.name.value === iface.name);
    }
    function getUnionMemberTypeNodes(union, typeName) {
        const { astNode, extensionASTNodes } = union;
        const nodes = astNode != null ? [
            astNode,
            ...extensionASTNodes
        ] : extensionASTNodes;
        return nodes.flatMap((unionNode)=>{
            var _unionNode$types;
            return ((_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []);
        }).filter((typeNode)=>typeNode.name.value === typeName);
    }
    function getDeprecatedDirectiveNode(definitionNode) {
        var _definitionNode$direc;
        return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find((node)=>node.name.value === GraphQLDeprecatedDirective.name);
    }
    function typeFromAST(schema, typeNode) {
        switch(typeNode.kind){
            case Kind.LIST_TYPE:
                {
                    const innerType = typeFromAST(schema, typeNode.type);
                    return innerType && new GraphQLList(innerType);
                }
            case Kind.NON_NULL_TYPE:
                {
                    const innerType = typeFromAST(schema, typeNode.type);
                    return innerType && new GraphQLNonNull(innerType);
                }
            case Kind.NAMED_TYPE:
                return schema.getType(typeNode.name.value);
        }
    }
    class TypeInfo {
        constructor(schema, initialType, getFieldDefFn){
            this._schema = schema;
            this._typeStack = [];
            this._parentTypeStack = [];
            this._inputTypeStack = [];
            this._fieldDefStack = [];
            this._defaultValueStack = [];
            this._directive = null;
            this._argument = null;
            this._enumValue = null;
            this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef$1;
            if (initialType) {
                if (isInputType(initialType)) {
                    this._inputTypeStack.push(initialType);
                }
                if (isCompositeType(initialType)) {
                    this._parentTypeStack.push(initialType);
                }
                if (isOutputType(initialType)) {
                    this._typeStack.push(initialType);
                }
            }
        }
        get [Symbol.toStringTag]() {
            return 'TypeInfo';
        }
        getType() {
            if (this._typeStack.length > 0) {
                return this._typeStack[this._typeStack.length - 1];
            }
        }
        getParentType() {
            if (this._parentTypeStack.length > 0) {
                return this._parentTypeStack[this._parentTypeStack.length - 1];
            }
        }
        getInputType() {
            if (this._inputTypeStack.length > 0) {
                return this._inputTypeStack[this._inputTypeStack.length - 1];
            }
        }
        getParentInputType() {
            if (this._inputTypeStack.length > 1) {
                return this._inputTypeStack[this._inputTypeStack.length - 2];
            }
        }
        getFieldDef() {
            if (this._fieldDefStack.length > 0) {
                return this._fieldDefStack[this._fieldDefStack.length - 1];
            }
        }
        getDefaultValue() {
            if (this._defaultValueStack.length > 0) {
                return this._defaultValueStack[this._defaultValueStack.length - 1];
            }
        }
        getDirective() {
            return this._directive;
        }
        getArgument() {
            return this._argument;
        }
        getEnumValue() {
            return this._enumValue;
        }
        enter(node) {
            const schema = this._schema;
            switch(node.kind){
                case Kind.SELECTION_SET:
                    {
                        const namedType = getNamedType(this.getType());
                        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);
                        break;
                    }
                case Kind.FIELD:
                    {
                        const parentType = this.getParentType();
                        let fieldDef;
                        let fieldType;
                        if (parentType) {
                            fieldDef = this._getFieldDef(schema, parentType, node);
                            if (fieldDef) {
                                fieldType = fieldDef.type;
                            }
                        }
                        this._fieldDefStack.push(fieldDef);
                        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);
                        break;
                    }
                case Kind.DIRECTIVE:
                    this._directive = schema.getDirective(node.name.value);
                    break;
                case Kind.OPERATION_DEFINITION:
                    {
                        const rootType = schema.getRootType(node.operation);
                        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);
                        break;
                    }
                case Kind.INLINE_FRAGMENT:
                case Kind.FRAGMENT_DEFINITION:
                    {
                        const typeConditionAST = node.typeCondition;
                        const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
                        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);
                        break;
                    }
                case Kind.VARIABLE_DEFINITION:
                    {
                        const inputType = typeFromAST(schema, node.type);
                        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);
                        break;
                    }
                case Kind.ARGUMENT:
                    {
                        var _this$getDirective;
                        let argDef;
                        let argType;
                        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
                        if (fieldOrDirective) {
                            argDef = fieldOrDirective.args.find((arg)=>arg.name === node.name.value);
                            if (argDef) {
                                argType = argDef.type;
                            }
                        }
                        this._argument = argDef;
                        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
                        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);
                        break;
                    }
                case Kind.LIST:
                    {
                        const listType = getNullableType(this.getInputType());
                        const itemType = isListType(listType) ? listType.ofType : listType;
                        this._defaultValueStack.push(undefined);
                        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);
                        break;
                    }
                case Kind.OBJECT_FIELD:
                    {
                        const objectType = getNamedType(this.getInputType());
                        let inputFieldType;
                        let inputField;
                        if (isInputObjectType(objectType)) {
                            inputField = objectType.getFields()[node.name.value];
                            if (inputField) {
                                inputFieldType = inputField.type;
                            }
                        }
                        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
                        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);
                        break;
                    }
                case Kind.ENUM:
                    {
                        const enumType = getNamedType(this.getInputType());
                        let enumValue;
                        if (isEnumType(enumType)) {
                            enumValue = enumType.getValue(node.value);
                        }
                        this._enumValue = enumValue;
                        break;
                    }
            }
        }
        leave(node) {
            switch(node.kind){
                case Kind.SELECTION_SET:
                    this._parentTypeStack.pop();
                    break;
                case Kind.FIELD:
                    this._fieldDefStack.pop();
                    this._typeStack.pop();
                    break;
                case Kind.DIRECTIVE:
                    this._directive = null;
                    break;
                case Kind.OPERATION_DEFINITION:
                case Kind.INLINE_FRAGMENT:
                case Kind.FRAGMENT_DEFINITION:
                    this._typeStack.pop();
                    break;
                case Kind.VARIABLE_DEFINITION:
                    this._inputTypeStack.pop();
                    break;
                case Kind.ARGUMENT:
                    this._argument = null;
                    this._defaultValueStack.pop();
                    this._inputTypeStack.pop();
                    break;
                case Kind.LIST:
                case Kind.OBJECT_FIELD:
                    this._defaultValueStack.pop();
                    this._inputTypeStack.pop();
                    break;
                case Kind.ENUM:
                    this._enumValue = null;
                    break;
            }
        }
    }
    function getFieldDef$1(schema, parentType, fieldNode) {
        const name = fieldNode.name.value;
        if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
            return SchemaMetaFieldDef;
        }
        if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
            return TypeMetaFieldDef;
        }
        if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
            return TypeNameMetaFieldDef;
        }
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
            return parentType.getFields()[name];
        }
    }
    function visitWithTypeInfo(typeInfo, visitor) {
        return {
            enter (...args) {
                const node = args[0];
                typeInfo.enter(node);
                const fn = getEnterLeaveForKind(visitor, node.kind).enter;
                if (fn) {
                    const result = fn.apply(visitor, args);
                    if (result !== undefined) {
                        typeInfo.leave(node);
                        if (isNode(result)) {
                            typeInfo.enter(result);
                        }
                    }
                    return result;
                }
            },
            leave (...args) {
                const node = args[0];
                const fn = getEnterLeaveForKind(visitor, node.kind).leave;
                let result;
                if (fn) {
                    result = fn.apply(visitor, args);
                }
                typeInfo.leave(node);
                return result;
            }
        };
    }
    function isDefinitionNode(node) {
        return (isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node));
    }
    function isExecutableDefinitionNode(node) {
        return (node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION);
    }
    function isSelectionNode(node) {
        return (node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT);
    }
    function isValueNode(node) {
        return (node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT);
    }
    function isConstValueNode(node) {
        return (isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field)=>isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE));
    }
    function isTypeNode(node) {
        return (node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE);
    }
    function isTypeSystemDefinitionNode(node) {
        return (node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION);
    }
    function isTypeDefinitionNode(node) {
        return (node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION);
    }
    function isTypeSystemExtensionNode(node) {
        return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    function isTypeExtensionNode(node) {
        return (node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION);
    }
    function ExecutableDefinitionsRule(context) {
        return {
            Document (node) {
                for (const definition of node.definitions){
                    if (!isExecutableDefinitionNode(definition)) {
                        const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? 'schema' : '"' + definition.name.value + '"';
                        context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, {
                            nodes: definition
                        }));
                    }
                }
                return false;
            }
        };
    }
    function FieldsOnCorrectTypeRule(context) {
        return {
            Field (node) {
                const type = context.getParentType();
                if (type) {
                    const fieldDef = context.getFieldDef();
                    if (!fieldDef) {
                        const schema = context.getSchema();
                        const fieldName = node.name.value;
                        let suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName));
                        if (suggestion === '') {
                            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
                        }
                        context.reportError(new GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
                            nodes: node
                        }));
                    }
                }
            }
        };
    }
    function getSuggestedTypeNames(schema, type, fieldName) {
        if (!isAbstractType(type)) {
            return [];
        }
        const suggestedTypes = new Set();
        const usageCount = Object.create(null);
        for (const possibleType of schema.getPossibleTypes(type)){
            if (!possibleType.getFields()[fieldName]) {
                continue;
            }
            suggestedTypes.add(possibleType);
            usageCount[possibleType.name] = 1;
            for (const possibleInterface of possibleType.getInterfaces()){
                var _usageCount$possibleI;
                if (!possibleInterface.getFields()[fieldName]) {
                    continue;
                }
                suggestedTypes.add(possibleInterface);
                usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
            }
        }
        return [
            ...suggestedTypes
        ].sort((typeA, typeB)=>{
            const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
            if (usageCountDiff !== 0) {
                return usageCountDiff;
            }
            if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
                return -1;
            }
            if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
                return 1;
            }
            return naturalCompare(typeA.name, typeB.name);
        }).map((x)=>x.name);
    }
    function getSuggestedFieldNames(type, fieldName) {
        if (isObjectType(type) || isInterfaceType(type)) {
            const possibleFieldNames = Object.keys(type.getFields());
            return suggestionList(fieldName, possibleFieldNames);
        }
        return [];
    }
    function FragmentsOnCompositeTypesRule(context) {
        return {
            InlineFragment (node) {
                const typeCondition = node.typeCondition;
                if (typeCondition) {
                    const type = typeFromAST(context.getSchema(), typeCondition);
                    if (type && !isCompositeType(type)) {
                        const typeStr = print$1(typeCondition);
                        context.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
                            nodes: typeCondition
                        }));
                    }
                }
            },
            FragmentDefinition (node) {
                const type = typeFromAST(context.getSchema(), node.typeCondition);
                if (type && !isCompositeType(type)) {
                    const typeStr = print$1(node.typeCondition);
                    context.reportError(new GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
                        nodes: node.typeCondition
                    }));
                }
            }
        };
    }
    function KnownArgumentNamesRule(context) {
        return {
            ...KnownArgumentNamesOnDirectivesRule(context),
            Argument (argNode) {
                const argDef = context.getArgument();
                const fieldDef = context.getFieldDef();
                const parentType = context.getParentType();
                if (!argDef && fieldDef && parentType) {
                    const argName = argNode.name.value;
                    const knownArgsNames = fieldDef.args.map((arg)=>arg.name);
                    const suggestions = suggestionList(argName, knownArgsNames);
                    context.reportError(new GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions), {
                        nodes: argNode
                    }));
                }
            }
        };
    }
    function KnownArgumentNamesOnDirectivesRule(context) {
        const directiveArgs = Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
        for (const directive of definedDirectives){
            directiveArgs[directive.name] = directive.args.map((arg)=>arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions){
            if (def.kind === Kind.DIRECTIVE_DEFINITION) {
                var _def$arguments;
                const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
                directiveArgs[def.name.value] = argsNodes.map((arg)=>arg.name.value);
            }
        }
        return {
            Directive (directiveNode) {
                const directiveName = directiveNode.name.value;
                const knownArgs = directiveArgs[directiveName];
                if (directiveNode.arguments && knownArgs) {
                    for (const argNode of directiveNode.arguments){
                        const argName = argNode.name.value;
                        if (!knownArgs.includes(argName)) {
                            const suggestions = suggestionList(argName, knownArgs);
                            context.reportError(new GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions), {
                                nodes: argNode
                            }));
                        }
                    }
                }
                return false;
            }
        };
    }
    function KnownDirectivesRule(context) {
        const locationsMap = Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
        for (const directive of definedDirectives){
            locationsMap[directive.name] = directive.locations;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions){
            if (def.kind === Kind.DIRECTIVE_DEFINITION) {
                locationsMap[def.name.value] = def.locations.map((name)=>name.value);
            }
        }
        return {
            Directive (node, _key, _parent, _path, ancestors) {
                const name = node.name.value;
                const locations = locationsMap[name];
                if (!locations) {
                    context.reportError(new GraphQLError(`Unknown directive "@${name}".`, {
                        nodes: node
                    }));
                    return;
                }
                const candidateLocation = getDirectiveLocationForASTPath(ancestors);
                if (candidateLocation && !locations.includes(candidateLocation)) {
                    context.reportError(new GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
                        nodes: node
                    }));
                }
            }
        };
    }
    function getDirectiveLocationForASTPath(ancestors) {
        const appliedTo = ancestors[ancestors.length - 1];
        'kind' in appliedTo || invariant(false);
        switch(appliedTo.kind){
            case Kind.OPERATION_DEFINITION:
                return getDirectiveLocationForOperation(appliedTo.operation);
            case Kind.FIELD:
                return DirectiveLocation.FIELD;
            case Kind.FRAGMENT_SPREAD:
                return DirectiveLocation.FRAGMENT_SPREAD;
            case Kind.INLINE_FRAGMENT:
                return DirectiveLocation.INLINE_FRAGMENT;
            case Kind.FRAGMENT_DEFINITION:
                return DirectiveLocation.FRAGMENT_DEFINITION;
            case Kind.VARIABLE_DEFINITION:
                return DirectiveLocation.VARIABLE_DEFINITION;
            case Kind.SCHEMA_DEFINITION:
            case Kind.SCHEMA_EXTENSION:
                return DirectiveLocation.SCHEMA;
            case Kind.SCALAR_TYPE_DEFINITION:
            case Kind.SCALAR_TYPE_EXTENSION:
                return DirectiveLocation.SCALAR;
            case Kind.OBJECT_TYPE_DEFINITION:
            case Kind.OBJECT_TYPE_EXTENSION:
                return DirectiveLocation.OBJECT;
            case Kind.FIELD_DEFINITION:
                return DirectiveLocation.FIELD_DEFINITION;
            case Kind.INTERFACE_TYPE_DEFINITION:
            case Kind.INTERFACE_TYPE_EXTENSION:
                return DirectiveLocation.INTERFACE;
            case Kind.UNION_TYPE_DEFINITION:
            case Kind.UNION_TYPE_EXTENSION:
                return DirectiveLocation.UNION;
            case Kind.ENUM_TYPE_DEFINITION:
            case Kind.ENUM_TYPE_EXTENSION:
                return DirectiveLocation.ENUM;
            case Kind.ENUM_VALUE_DEFINITION:
                return DirectiveLocation.ENUM_VALUE;
            case Kind.INPUT_OBJECT_TYPE_DEFINITION:
            case Kind.INPUT_OBJECT_TYPE_EXTENSION:
                return DirectiveLocation.INPUT_OBJECT;
            case Kind.INPUT_VALUE_DEFINITION:
                {
                    const parentNode = ancestors[ancestors.length - 3];
                    'kind' in parentNode || invariant(false);
                    return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
                }
            default:
                invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));
        }
    }
    function getDirectiveLocationForOperation(operation) {
        switch(operation){
            case OperationTypeNode.QUERY:
                return DirectiveLocation.QUERY;
            case OperationTypeNode.MUTATION:
                return DirectiveLocation.MUTATION;
            case OperationTypeNode.SUBSCRIPTION:
                return DirectiveLocation.SUBSCRIPTION;
        }
    }
    function KnownFragmentNamesRule(context) {
        return {
            FragmentSpread (node) {
                const fragmentName = node.name.value;
                const fragment = context.getFragment(fragmentName);
                if (!fragment) {
                    context.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, {
                        nodes: node.name
                    }));
                }
            }
        };
    }
    function KnownTypeNamesRule(context) {
        const schema = context.getSchema();
        const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
        const definedTypes = Object.create(null);
        for (const def of context.getDocument().definitions){
            if (isTypeDefinitionNode(def)) {
                definedTypes[def.name.value] = true;
            }
        }
        const typeNames = [
            ...Object.keys(existingTypesMap),
            ...Object.keys(definedTypes)
        ];
        return {
            NamedType (node, _1, parent, _2, ancestors) {
                const typeName = node.name.value;
                if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
                    var _ancestors$;
                    const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
                    const isSDL = definitionNode != null && isSDLNode(definitionNode);
                    if (isSDL && standardTypeNames.includes(typeName)) {
                        return;
                    }
                    const suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
                    context.reportError(new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), {
                        nodes: node
                    }));
                }
            }
        };
    }
    const standardTypeNames = [
        ...specifiedScalarTypes,
        ...introspectionTypes
    ].map((type)=>type.name);
    function isSDLNode(value) {
        return ('kind' in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value)));
    }
    function LoneAnonymousOperationRule(context) {
        let operationCount = 0;
        return {
            Document (node) {
                operationCount = node.definitions.filter((definition)=>definition.kind === Kind.OPERATION_DEFINITION).length;
            },
            OperationDefinition (node) {
                if (!node.name && operationCount > 1) {
                    context.reportError(new GraphQLError('This anonymous operation must be the only defined operation.', {
                        nodes: node
                    }));
                }
            }
        };
    }
    function LoneSchemaDefinitionRule(context) {
        var _ref, _ref2, _oldSchema$astNode;
        const oldSchema = context.getSchema();
        const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
        let schemaDefinitionsCount = 0;
        return {
            SchemaDefinition (node) {
                if (alreadyDefined) {
                    context.reportError(new GraphQLError('Cannot define a new schema within a schema extension.', {
                        nodes: node
                    }));
                    return;
                }
                if (schemaDefinitionsCount > 0) {
                    context.reportError(new GraphQLError('Must provide only one schema definition.', {
                        nodes: node
                    }));
                }
                ++schemaDefinitionsCount;
            }
        };
    }
    const MAX_LISTS_DEPTH = 3;
    function MaxIntrospectionDepthRule(context) {
        function checkDepth(node, visitedFragments = Object.create(null), depth = 0) {
            if (node.kind === Kind.FRAGMENT_SPREAD) {
                const fragmentName = node.name.value;
                if (visitedFragments[fragmentName] === true) {
                    return false;
                }
                const fragment = context.getFragment(fragmentName);
                if (!fragment) {
                    return false;
                }
                try {
                    visitedFragments[fragmentName] = true;
                    return checkDepth(fragment, visitedFragments, depth);
                } finally{
                    visitedFragments[fragmentName] = undefined;
                }
            }
            if (node.kind === Kind.FIELD && (node.name.value === 'fields' || node.name.value === 'interfaces' || node.name.value === 'possibleTypes' || node.name.value === 'inputFields')) {
                depth++;
                if (depth >= MAX_LISTS_DEPTH) {
                    return true;
                }
            }
            if ('selectionSet' in node && node.selectionSet) {
                for (const child of node.selectionSet.selections){
                    if (checkDepth(child, visitedFragments, depth)) {
                        return true;
                    }
                }
            }
            return false;
        }
        return {
            Field (node) {
                if (node.name.value === '__schema' || node.name.value === '__type') {
                    if (checkDepth(node)) {
                        context.reportError(new GraphQLError('Maximum introspection depth exceeded', {
                            nodes: [
                                node
                            ]
                        }));
                        return false;
                    }
                }
            }
        };
    }
    function NoFragmentCyclesRule(context) {
        const visitedFrags = Object.create(null);
        const spreadPath = [];
        const spreadPathIndexByName = Object.create(null);
        return {
            OperationDefinition: ()=>false,
            FragmentDefinition (node) {
                detectCycleRecursive(node);
                return false;
            }
        };
        function detectCycleRecursive(fragment) {
            if (visitedFrags[fragment.name.value]) {
                return;
            }
            const fragmentName = fragment.name.value;
            visitedFrags[fragmentName] = true;
            const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
            if (spreadNodes.length === 0) {
                return;
            }
            spreadPathIndexByName[fragmentName] = spreadPath.length;
            for (const spreadNode of spreadNodes){
                const spreadName = spreadNode.name.value;
                const cycleIndex = spreadPathIndexByName[spreadName];
                spreadPath.push(spreadNode);
                if (cycleIndex === undefined) {
                    const spreadFragment = context.getFragment(spreadName);
                    if (spreadFragment) {
                        detectCycleRecursive(spreadFragment);
                    }
                } else {
                    const cyclePath = spreadPath.slice(cycleIndex);
                    const viaPath = cyclePath.slice(0, -1).map((s)=>'"' + s.name.value + '"').join(', ');
                    context.reportError(new GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== '' ? ` via ${viaPath}.` : '.'), {
                        nodes: cyclePath
                    }));
                }
                spreadPath.pop();
            }
            spreadPathIndexByName[fragmentName] = undefined;
        }
    }
    function NoUndefinedVariablesRule(context) {
        let variableNameDefined = Object.create(null);
        return {
            OperationDefinition: {
                enter () {
                    variableNameDefined = Object.create(null);
                },
                leave (operation) {
                    const usages = context.getRecursiveVariableUsages(operation);
                    for (const { node } of usages){
                        const varName = node.name.value;
                        if (variableNameDefined[varName] !== true) {
                            context.reportError(new GraphQLError(operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`, {
                                nodes: [
                                    node,
                                    operation
                                ]
                            }));
                        }
                    }
                }
            },
            VariableDefinition (node) {
                variableNameDefined[node.variable.name.value] = true;
            }
        };
    }
    function NoUnusedFragmentsRule(context) {
        const operationDefs = [];
        const fragmentDefs = [];
        return {
            OperationDefinition (node) {
                operationDefs.push(node);
                return false;
            },
            FragmentDefinition (node) {
                fragmentDefs.push(node);
                return false;
            },
            Document: {
                leave () {
                    const fragmentNameUsed = Object.create(null);
                    for (const operation of operationDefs){
                        for (const fragment of context.getRecursivelyReferencedFragments(operation)){
                            fragmentNameUsed[fragment.name.value] = true;
                        }
                    }
                    for (const fragmentDef of fragmentDefs){
                        const fragName = fragmentDef.name.value;
                        if (fragmentNameUsed[fragName] !== true) {
                            context.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, {
                                nodes: fragmentDef
                            }));
                        }
                    }
                }
            }
        };
    }
    function NoUnusedVariablesRule(context) {
        let variableDefs = [];
        return {
            OperationDefinition: {
                enter () {
                    variableDefs = [];
                },
                leave (operation) {
                    const variableNameUsed = Object.create(null);
                    const usages = context.getRecursiveVariableUsages(operation);
                    for (const { node } of usages){
                        variableNameUsed[node.name.value] = true;
                    }
                    for (const variableDef of variableDefs){
                        const variableName = variableDef.variable.name.value;
                        if (variableNameUsed[variableName] !== true) {
                            context.reportError(new GraphQLError(operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`, {
                                nodes: variableDef
                            }));
                        }
                    }
                }
            },
            VariableDefinition (def) {
                variableDefs.push(def);
            }
        };
    }
    function sortValueNode(valueNode) {
        switch(valueNode.kind){
            case Kind.OBJECT:
                return {
                    ...valueNode,
                    fields: sortFields(valueNode.fields)
                };
            case Kind.LIST:
                return {
                    ...valueNode,
                    values: valueNode.values.map(sortValueNode)
                };
            case Kind.INT:
            case Kind.FLOAT:
            case Kind.STRING:
            case Kind.BOOLEAN:
            case Kind.NULL:
            case Kind.ENUM:
            case Kind.VARIABLE:
                return valueNode;
        }
    }
    function sortFields(fields) {
        return fields.map((fieldNode)=>({
                ...fieldNode,
                value: sortValueNode(fieldNode.value)
            })).sort((fieldA, fieldB)=>naturalCompare(fieldA.name.value, fieldB.name.value));
    }
    function reasonMessage(reason) {
        if (Array.isArray(reason)) {
            return reason.map(([responseName, subReason])=>`subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(' and ');
        }
        return reason;
    }
    function OverlappingFieldsCanBeMergedRule(context) {
        const comparedFieldsAndFragmentPairs = new OrderedPairSet();
        const comparedFragmentPairs = new PairSet();
        const cachedFieldsAndFragmentNames = new Map();
        return {
            SelectionSet (selectionSet) {
                const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, context.getParentType(), selectionSet);
                for (const [[responseName, reason], fields1, fields2] of conflicts){
                    const reasonMsg = reasonMessage(reason);
                    context.reportError(new GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
                        nodes: fields1.concat(fields2)
                    }));
                }
            }
        };
    }
    function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
        const conflicts = [];
        const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
        collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap);
        if (fragmentNames.length !== 0) {
            for(let i = 0; i < fragmentNames.length; i++){
                collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
                for(let j = i + 1; j < fragmentNames.length; j++){
                    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
                }
            }
        }
        return conflicts;
    }
    function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
        if (comparedFieldsAndFragmentPairs.has(fieldMap, fragmentName, areMutuallyExclusive)) {
            return;
        }
        comparedFieldsAndFragmentPairs.add(fieldMap, fragmentName, areMutuallyExclusive);
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
            return;
        }
        const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
        if (fieldMap === fieldMap2) {
            return;
        }
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
        for (const referencedFragmentName of referencedFragmentNames){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
        }
    }
    function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
        if (fragmentName1 === fragmentName2) {
            return;
        }
        if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
            return;
        }
        comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
        const fragment1 = context.getFragment(fragmentName1);
        const fragment2 = context.getFragment(fragmentName2);
        if (!fragment1 || !fragment2) {
            return;
        }
        const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
        const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
        for (const referencedFragmentName2 of referencedFragmentNames2){
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
        }
        for (const referencedFragmentName1 of referencedFragmentNames1){
            collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
        }
    }
    function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
        const conflicts = [];
        const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
        const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
        collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
        for (const fragmentName2 of fragmentNames2){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
        }
        for (const fragmentName1 of fragmentNames1){
            collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
        }
        for (const fragmentName1 of fragmentNames1){
            for (const fragmentName2 of fragmentNames2){
                collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
            }
        }
        return conflicts;
    }
    function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
        for (const [responseName, fields] of Object.entries(fieldMap)){
            if (fields.length > 1) {
                for(let i = 0; i < fields.length; i++){
                    for(let j = i + 1; j < fields.length; j++){
                        const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
                        if (conflict) {
                            conflicts.push(conflict);
                        }
                    }
                }
            }
        }
    }
    function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
        for (const [responseName, fields1] of Object.entries(fieldMap1)){
            const fields2 = fieldMap2[responseName];
            if (fields2) {
                for (const field1 of fields1){
                    for (const field2 of fields2){
                        const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
                        if (conflict) {
                            conflicts.push(conflict);
                        }
                    }
                }
            }
        }
    }
    function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
        const [parentType1, node1, def1] = field1;
        const [parentType2, node2, def2] = field2;
        const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || (parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2));
        if (!areMutuallyExclusive) {
            const name1 = node1.name.value;
            const name2 = node2.name.value;
            if (name1 !== name2) {
                return [
                    [
                        responseName,
                        `"${name1}" and "${name2}" are different fields`
                    ],
                    [
                        node1
                    ],
                    [
                        node2
                    ]
                ];
            }
            if (!sameArguments(node1, node2)) {
                return [
                    [
                        responseName,
                        'they have differing arguments'
                    ],
                    [
                        node1
                    ],
                    [
                        node2
                    ]
                ];
            }
        }
        const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
        const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
        if (type1 && type2 && doTypesConflict(type1, type2)) {
            return [
                [
                    responseName,
                    `they return conflicting types "${inspect(type1)}" and "${inspect(type2)}"`
                ],
                [
                    node1
                ],
                [
                    node2
                ]
            ];
        }
        const selectionSet1 = node1.selectionSet;
        const selectionSet2 = node2.selectionSet;
        if (selectionSet1 && selectionSet2) {
            const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
            return subfieldConflicts(conflicts, responseName, node1, node2);
        }
    }
    function sameArguments(node1, node2) {
        const args1 = node1.arguments;
        const args2 = node2.arguments;
        if (args1 === undefined || args1.length === 0) {
            return args2 === undefined || args2.length === 0;
        }
        if (args2 === undefined || args2.length === 0) {
            return false;
        }
        if (args1.length !== args2.length) {
            return false;
        }
        const values2 = new Map(args2.map(({ name, value })=>[
                name.value,
                value
            ]));
        return args1.every((arg1)=>{
            const value1 = arg1.value;
            const value2 = values2.get(arg1.name.value);
            if (value2 === undefined) {
                return false;
            }
            return stringifyValue$1(value1) === stringifyValue$1(value2);
        });
    }
    function stringifyValue$1(value) {
        return print$1(sortValueNode(value));
    }
    function doTypesConflict(type1, type2) {
        if (isListType(type1)) {
            return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if (isListType(type2)) {
            return true;
        }
        if (isNonNullType(type1)) {
            return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
        }
        if (isNonNullType(type2)) {
            return true;
        }
        if (isLeafType(type1) || isLeafType(type2)) {
            return type1 !== type2;
        }
        return false;
    }
    function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
        const cached = cachedFieldsAndFragmentNames.get(selectionSet);
        if (cached) {
            return cached;
        }
        const nodeAndDefs = Object.create(null);
        const fragmentNames = Object.create(null);
        _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
        const result = [
            nodeAndDefs,
            Object.keys(fragmentNames)
        ];
        cachedFieldsAndFragmentNames.set(selectionSet, result);
        return result;
    }
    function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
        const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
        if (cached) {
            return cached;
        }
        const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
        return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
    }
    function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
        for (const selection of selectionSet.selections){
            switch(selection.kind){
                case Kind.FIELD:
                    {
                        const fieldName = selection.name.value;
                        let fieldDef;
                        if (isObjectType(parentType) || isInterfaceType(parentType)) {
                            fieldDef = parentType.getFields()[fieldName];
                        }
                        const responseName = selection.alias ? selection.alias.value : fieldName;
                        if (!nodeAndDefs[responseName]) {
                            nodeAndDefs[responseName] = [];
                        }
                        nodeAndDefs[responseName].push([
                            parentType,
                            selection,
                            fieldDef
                        ]);
                        break;
                    }
                case Kind.FRAGMENT_SPREAD:
                    fragmentNames[selection.name.value] = true;
                    break;
                case Kind.INLINE_FRAGMENT:
                    {
                        const typeCondition = selection.typeCondition;
                        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
                        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
                        break;
                    }
            }
        }
    }
    function subfieldConflicts(conflicts, responseName, node1, node2) {
        if (conflicts.length > 0) {
            return [
                [
                    responseName,
                    conflicts.map(([reason])=>reason)
                ],
                [
                    node1,
                    ...conflicts.map(([, fields1])=>fields1).flat()
                ],
                [
                    node2,
                    ...conflicts.map(([, , fields2])=>fields2).flat()
                ]
            ];
        }
    }
    class OrderedPairSet {
        constructor(){
            this._data = new Map();
        }
        has(a, b, weaklyPresent) {
            var _this$_data$get;
            const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
            if (result === undefined) {
                return false;
            }
            return weaklyPresent ? true : weaklyPresent === result;
        }
        add(a, b, weaklyPresent) {
            const map = this._data.get(a);
            if (map === undefined) {
                this._data.set(a, new Map([
                    [
                        b,
                        weaklyPresent
                    ]
                ]));
            } else {
                map.set(b, weaklyPresent);
            }
        }
    }
    class PairSet {
        constructor(){
            this._orderedPairSet = new OrderedPairSet();
        }
        has(a, b, weaklyPresent) {
            return a < b ? this._orderedPairSet.has(a, b, weaklyPresent) : this._orderedPairSet.has(b, a, weaklyPresent);
        }
        add(a, b, weaklyPresent) {
            if (a < b) {
                this._orderedPairSet.add(a, b, weaklyPresent);
            } else {
                this._orderedPairSet.add(b, a, weaklyPresent);
            }
        }
    }
    function PossibleFragmentSpreadsRule(context) {
        return {
            InlineFragment (node) {
                const fragType = context.getType();
                const parentType = context.getParentType();
                if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
                    const parentTypeStr = inspect(parentType);
                    const fragTypeStr = inspect(fragType);
                    context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                        nodes: node
                    }));
                }
            },
            FragmentSpread (node) {
                const fragName = node.name.value;
                const fragType = getFragmentType(context, fragName);
                const parentType = context.getParentType();
                if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
                    const parentTypeStr = inspect(parentType);
                    const fragTypeStr = inspect(fragType);
                    context.reportError(new GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
                        nodes: node
                    }));
                }
            }
        };
    }
    function getFragmentType(context, name) {
        const frag = context.getFragment(name);
        if (frag) {
            const type = typeFromAST(context.getSchema(), frag.typeCondition);
            if (isCompositeType(type)) {
                return type;
            }
        }
    }
    function PossibleTypeExtensionsRule(context) {
        const schema = context.getSchema();
        const definedTypes = Object.create(null);
        for (const def of context.getDocument().definitions){
            if (isTypeDefinitionNode(def)) {
                definedTypes[def.name.value] = def;
            }
        }
        return {
            ScalarTypeExtension: checkExtension,
            ObjectTypeExtension: checkExtension,
            InterfaceTypeExtension: checkExtension,
            UnionTypeExtension: checkExtension,
            EnumTypeExtension: checkExtension,
            InputObjectTypeExtension: checkExtension
        };
        function checkExtension(node) {
            const typeName = node.name.value;
            const defNode = definedTypes[typeName];
            const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
            let expectedKind;
            if (defNode) {
                expectedKind = defKindToExtKind[defNode.kind];
            } else if (existingType) {
                expectedKind = typeToExtKind(existingType);
            }
            if (expectedKind) {
                if (expectedKind !== node.kind) {
                    const kindStr = extensionKindToTypeName(node.kind);
                    context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
                        nodes: defNode ? [
                            defNode,
                            node
                        ] : node
                    }));
                }
            } else {
                const allTypeNames = Object.keys({
                    ...definedTypes,
                    ...(schema === null || schema === void 0 ? void 0 : schema.getTypeMap())
                });
                const suggestedTypes = suggestionList(typeName, allTypeNames);
                context.reportError(new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), {
                    nodes: node.name
                }));
            }
        }
    }
    const defKindToExtKind = {
        [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
        [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
        [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
        [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
        [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
        [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
    function typeToExtKind(type) {
        if (isScalarType(type)) {
            return Kind.SCALAR_TYPE_EXTENSION;
        }
        if (isObjectType(type)) {
            return Kind.OBJECT_TYPE_EXTENSION;
        }
        if (isInterfaceType(type)) {
            return Kind.INTERFACE_TYPE_EXTENSION;
        }
        if (isUnionType(type)) {
            return Kind.UNION_TYPE_EXTENSION;
        }
        if (isEnumType(type)) {
            return Kind.ENUM_TYPE_EXTENSION;
        }
        if (isInputObjectType(type)) {
            return Kind.INPUT_OBJECT_TYPE_EXTENSION;
        }
        invariant(false, 'Unexpected type: ' + inspect(type));
    }
    function extensionKindToTypeName(kind) {
        switch(kind){
            case Kind.SCALAR_TYPE_EXTENSION:
                return 'scalar';
            case Kind.OBJECT_TYPE_EXTENSION:
                return 'object';
            case Kind.INTERFACE_TYPE_EXTENSION:
                return 'interface';
            case Kind.UNION_TYPE_EXTENSION:
                return 'union';
            case Kind.ENUM_TYPE_EXTENSION:
                return 'enum';
            case Kind.INPUT_OBJECT_TYPE_EXTENSION:
                return 'input object';
            default:
                invariant(false, 'Unexpected kind: ' + inspect(kind));
        }
    }
    function ProvidedRequiredArgumentsRule(context) {
        return {
            ...ProvidedRequiredArgumentsOnDirectivesRule(context),
            Field: {
                leave (fieldNode) {
                    var _fieldNode$arguments;
                    const fieldDef = context.getFieldDef();
                    if (!fieldDef) {
                        return false;
                    }
                    const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg)=>arg.name.value));
                    for (const argDef of fieldDef.args){
                        if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
                            const argTypeStr = inspect(argDef.type);
                            context.reportError(new GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
                                nodes: fieldNode
                            }));
                        }
                    }
                }
            }
        };
    }
    function ProvidedRequiredArgumentsOnDirectivesRule(context) {
        var _schema$getDirectives;
        const requiredArgsMap = Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
        for (const directive of definedDirectives){
            requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), (arg)=>arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions){
            if (def.kind === Kind.DIRECTIVE_DEFINITION) {
                var _def$arguments;
                const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
                requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), (arg)=>arg.name.value);
            }
        }
        return {
            Directive: {
                leave (directiveNode) {
                    const directiveName = directiveNode.name.value;
                    const requiredArgs = requiredArgsMap[directiveName];
                    if (requiredArgs) {
                        var _directiveNode$argume;
                        const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                        const argNodeMap = new Set(argNodes.map((arg)=>arg.name.value));
                        for (const [argName, argDef] of Object.entries(requiredArgs)){
                            if (!argNodeMap.has(argName)) {
                                const argType = isType(argDef.type) ? inspect(argDef.type) : print$1(argDef.type);
                                context.reportError(new GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                                    nodes: directiveNode
                                }));
                            }
                        }
                    }
                }
            }
        };
    }
    function isRequiredArgumentNode(arg) {
        return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
    function ScalarLeafsRule(context) {
        return {
            Field (node) {
                const type = context.getType();
                const selectionSet = node.selectionSet;
                if (type) {
                    if (isLeafType(getNamedType(type))) {
                        if (selectionSet) {
                            const fieldName = node.name.value;
                            const typeStr = inspect(type);
                            context.reportError(new GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
                                nodes: selectionSet
                            }));
                        }
                    } else if (!selectionSet) {
                        const fieldName = node.name.value;
                        const typeStr = inspect(type);
                        context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
                            nodes: node
                        }));
                    } else if (selectionSet.selections.length === 0) {
                        const fieldName = node.name.value;
                        const typeStr = inspect(type);
                        context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`, {
                            nodes: node
                        }));
                    }
                }
            }
        };
    }
    function printPathArray(path) {
        return path.map((key)=>typeof key === 'number' ? '[' + key.toString() + ']' : '.' + key).join('');
    }
    function addPath(prev, key, typename) {
        return {
            prev,
            key,
            typename
        };
    }
    function pathToArray(path) {
        const flattened = [];
        let curr = path;
        while(curr){
            flattened.push(curr.key);
            curr = curr.prev;
        }
        return flattened.reverse();
    }
    function coerceInputValue(inputValue, type, onError = defaultOnError) {
        return coerceInputValueImpl(inputValue, type, onError, undefined);
    }
    function defaultOnError(path, invalidValue, error) {
        let errorPrefix = 'Invalid value ' + inspect(invalidValue);
        if (path.length > 0) {
            errorPrefix += ` at "value${printPathArray(path)}"`;
        }
        error.message = errorPrefix + ': ' + error.message;
        throw error;
    }
    function coerceInputValueImpl(inputValue, type, onError, path) {
        if (isNonNullType(type)) {
            if (inputValue != null) {
                return coerceInputValueImpl(inputValue, type.ofType, onError, path);
            }
            onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type "${inspect(type)}" not to be null.`));
            return;
        }
        if (inputValue == null) {
            return null;
        }
        if (isListType(type)) {
            const itemType = type.ofType;
            if (isIterableObject(inputValue)) {
                return Array.from(inputValue, (itemValue, index)=>{
                    const itemPath = addPath(path, index, undefined);
                    return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
                });
            }
            return [
                coerceInputValueImpl(inputValue, itemType, onError, path)
            ];
        }
        if (isInputObjectType(type)) {
            if (!isObjectLike(inputValue) || Array.isArray(inputValue)) {
                onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}" to be an object.`));
                return;
            }
            const coercedValue = {};
            const fieldDefs = type.getFields();
            for (const field of Object.values(fieldDefs)){
                const fieldValue = inputValue[field.name];
                if (fieldValue === undefined) {
                    if (field.defaultValue !== undefined) {
                        coercedValue[field.name] = field.defaultValue;
                    } else if (isNonNullType(field.type)) {
                        const typeStr = inspect(field.type);
                        onError(pathToArray(path), inputValue, new GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
                    }
                    continue;
                }
                coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));
            }
            for (const fieldName of Object.keys(inputValue)){
                if (!fieldDefs[fieldName]) {
                    const suggestions = suggestionList(fieldName, Object.keys(type.getFields()));
                    onError(pathToArray(path), inputValue, new GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)));
                }
            }
            if (type.isOneOf) {
                const keys = Object.keys(coercedValue);
                if (keys.length !== 1) {
                    onError(pathToArray(path), inputValue, new GraphQLError(`Exactly one key must be specified for OneOf type "${type.name}".`));
                }
                const key = keys[0];
                const value = coercedValue[key];
                if (value === null) {
                    onError(pathToArray(path).concat(key), value, new GraphQLError(`Field "${key}" must be non-null.`));
                }
            }
            return coercedValue;
        }
        if (isLeafType(type)) {
            let parseResult;
            try {
                parseResult = type.parseValue(inputValue);
            } catch (error) {
                if (error instanceof GraphQLError) {
                    onError(pathToArray(path), inputValue, error);
                } else {
                    onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}". ` + error.message, {
                        originalError: error
                    }));
                }
                return;
            }
            if (parseResult === undefined) {
                onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}".`));
            }
            return parseResult;
        }
        invariant(false, 'Unexpected input type: ' + inspect(type));
    }
    function valueFromAST(valueNode, type, variables) {
        if (!valueNode) {
            return;
        }
        if (valueNode.kind === Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variables == null || variables[variableName] === undefined) {
                return;
            }
            const variableValue = variables[variableName];
            if (variableValue === null && isNonNullType(type)) {
                return;
            }
            return variableValue;
        }
        if (isNonNullType(type)) {
            if (valueNode.kind === Kind.NULL) {
                return;
            }
            return valueFromAST(valueNode, type.ofType, variables);
        }
        if (valueNode.kind === Kind.NULL) {
            return null;
        }
        if (isListType(type)) {
            const itemType = type.ofType;
            if (valueNode.kind === Kind.LIST) {
                const coercedValues = [];
                for (const itemNode of valueNode.values){
                    if (isMissingVariable(itemNode, variables)) {
                        if (isNonNullType(itemType)) {
                            return;
                        }
                        coercedValues.push(null);
                    } else {
                        const itemValue = valueFromAST(itemNode, itemType, variables);
                        if (itemValue === undefined) {
                            return;
                        }
                        coercedValues.push(itemValue);
                    }
                }
                return coercedValues;
            }
            const coercedValue = valueFromAST(valueNode, itemType, variables);
            if (coercedValue === undefined) {
                return;
            }
            return [
                coercedValue
            ];
        }
        if (isInputObjectType(type)) {
            if (valueNode.kind !== Kind.OBJECT) {
                return;
            }
            const coercedObj = Object.create(null);
            const fieldNodes = keyMap(valueNode.fields, (field)=>field.name.value);
            for (const field of Object.values(type.getFields())){
                const fieldNode = fieldNodes[field.name];
                if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
                    if (field.defaultValue !== undefined) {
                        coercedObj[field.name] = field.defaultValue;
                    } else if (isNonNullType(field.type)) {
                        return;
                    }
                    continue;
                }
                const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
                if (fieldValue === undefined) {
                    return;
                }
                coercedObj[field.name] = fieldValue;
            }
            if (type.isOneOf) {
                const keys = Object.keys(coercedObj);
                if (keys.length !== 1) {
                    return;
                }
                if (coercedObj[keys[0]] === null) {
                    return;
                }
            }
            return coercedObj;
        }
        if (isLeafType(type)) {
            let result;
            try {
                result = type.parseLiteral(valueNode, variables);
            } catch (_error) {
                return;
            }
            if (result === undefined) {
                return;
            }
            return result;
        }
        invariant(false, 'Unexpected input type: ' + inspect(type));
    }
    function isMissingVariable(valueNode, variables) {
        return (valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined));
    }
    function getVariableValues(schema, varDefNodes, inputs, options) {
        const errors = [];
        const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
        try {
            const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error)=>{
                if (maxErrors != null && errors.length >= maxErrors) {
                    throw new GraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');
                }
                errors.push(error);
            });
            if (errors.length === 0) {
                return {
                    coerced
                };
            }
        } catch (error) {
            errors.push(error);
        }
        return {
            errors
        };
    }
    function coerceVariableValues(schema, varDefNodes, inputs, onError) {
        const coercedValues = {};
        for (const varDefNode of varDefNodes){
            const varName = varDefNode.variable.name.value;
            const varType = typeFromAST(schema, varDefNode.type);
            if (!isInputType(varType)) {
                const varTypeStr = print$1(varDefNode.type);
                onError(new GraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, {
                    nodes: varDefNode.type
                }));
                continue;
            }
            if (!hasOwnProperty$5(inputs, varName)) {
                if (varDefNode.defaultValue) {
                    coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
                } else if (isNonNullType(varType)) {
                    const varTypeStr = inspect(varType);
                    onError(new GraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, {
                        nodes: varDefNode
                    }));
                }
                continue;
            }
            const value = inputs[varName];
            if (value === null && isNonNullType(varType)) {
                const varTypeStr = inspect(varType);
                onError(new GraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
                    nodes: varDefNode
                }));
                continue;
            }
            coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error)=>{
                let prefix = `Variable "$${varName}" got invalid value ` + inspect(invalidValue);
                if (path.length > 0) {
                    prefix += ` at "${varName}${printPathArray(path)}"`;
                }
                onError(new GraphQLError(prefix + '; ' + error.message, {
                    nodes: varDefNode,
                    originalError: error
                }));
            });
        }
        return coercedValues;
    }
    function getArgumentValues(def, node, variableValues) {
        var _node$arguments;
        const coercedValues = {};
        const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
        const argNodeMap = keyMap(argumentNodes, (arg)=>arg.name.value);
        for (const argDef of def.args){
            const name = argDef.name;
            const argType = argDef.type;
            const argumentNode = argNodeMap[name];
            if (!argumentNode) {
                if (argDef.defaultValue !== undefined) {
                    coercedValues[name] = argDef.defaultValue;
                } else if (isNonNullType(argType)) {
                    throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + 'was not provided.', {
                        nodes: node
                    });
                }
                continue;
            }
            const valueNode = argumentNode.value;
            let isNull = valueNode.kind === Kind.NULL;
            if (valueNode.kind === Kind.VARIABLE) {
                const variableName = valueNode.name.value;
                if (variableValues == null || !hasOwnProperty$5(variableValues, variableName)) {
                    if (argDef.defaultValue !== undefined) {
                        coercedValues[name] = argDef.defaultValue;
                    } else if (isNonNullType(argType)) {
                        throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                            nodes: valueNode
                        });
                    }
                    continue;
                }
                isNull = variableValues[variableName] == null;
            }
            if (isNull && isNonNullType(argType)) {
                throw new GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + 'must not be null.', {
                    nodes: valueNode
                });
            }
            const coercedValue = valueFromAST(valueNode, argType, variableValues);
            if (coercedValue === undefined) {
                throw new GraphQLError(`Argument "${name}" has invalid value ${print$1(valueNode)}.`, {
                    nodes: valueNode
                });
            }
            coercedValues[name] = coercedValue;
        }
        return coercedValues;
    }
    function getDirectiveValues(directiveDef, node, variableValues) {
        var _node$directives;
        const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive)=>directive.name.value === directiveDef.name);
        if (directiveNode) {
            return getArgumentValues(directiveDef, directiveNode, variableValues);
        }
    }
    function hasOwnProperty$5(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
        const fields = new Map();
        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, new Set());
        return fields;
    }
    function collectSubfields$1(schema, fragments, variableValues, returnType, fieldNodes) {
        const subFieldNodes = new Map();
        const visitedFragmentNames = new Set();
        for (const node of fieldNodes){
            if (node.selectionSet) {
                collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
            }
        }
        return subFieldNodes;
    }
    function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
        for (const selection of selectionSet.selections){
            switch(selection.kind){
                case Kind.FIELD:
                    {
                        if (!shouldIncludeNode(variableValues, selection)) {
                            continue;
                        }
                        const name = getFieldEntryKey(selection);
                        const fieldList = fields.get(name);
                        if (fieldList !== undefined) {
                            fieldList.push(selection);
                        } else {
                            fields.set(name, [
                                selection
                            ]);
                        }
                        break;
                    }
                case Kind.INLINE_FRAGMENT:
                    {
                        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
                            continue;
                        }
                        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
                        break;
                    }
                case Kind.FRAGMENT_SPREAD:
                    {
                        const fragName = selection.name.value;
                        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
                            continue;
                        }
                        visitedFragmentNames.add(fragName);
                        const fragment = fragments[fragName];
                        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
                            continue;
                        }
                        collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
                        break;
                    }
            }
        }
    }
    function shouldIncludeNode(variableValues, node) {
        const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
        if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
            return false;
        }
        const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
        if ((include === null || include === void 0 ? void 0 : include.if) === false) {
            return false;
        }
        return true;
    }
    function doesFragmentConditionMatch(schema, fragment, type) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode) {
            return true;
        }
        const conditionalType = typeFromAST(schema, typeConditionNode);
        if (conditionalType === type) {
            return true;
        }
        if (isAbstractType(conditionalType)) {
            return schema.isSubType(conditionalType, type);
        }
        return false;
    }
    function getFieldEntryKey(node) {
        return node.alias ? node.alias.value : node.name.value;
    }
    function SingleFieldSubscriptionsRule(context) {
        return {
            OperationDefinition (node) {
                if (node.operation === 'subscription') {
                    const schema = context.getSchema();
                    const subscriptionType = schema.getSubscriptionType();
                    if (subscriptionType) {
                        const operationName = node.name ? node.name.value : null;
                        const variableValues = Object.create(null);
                        const document = context.getDocument();
                        const fragments = Object.create(null);
                        for (const definition of document.definitions){
                            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
                                fragments[definition.name.value] = definition;
                            }
                        }
                        const fields = collectFields(schema, fragments, variableValues, subscriptionType, node.selectionSet);
                        if (fields.size > 1) {
                            const fieldSelectionLists = [
                                ...fields.values()
                            ];
                            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                            const extraFieldSelections = extraFieldSelectionLists.flat();
                            context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : 'Anonymous Subscription must select only one top level field.', {
                                nodes: extraFieldSelections
                            }));
                        }
                        for (const fieldNodes of fields.values()){
                            const field = fieldNodes[0];
                            const fieldName = field.name.value;
                            if (fieldName.startsWith('__')) {
                                context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : 'Anonymous Subscription must not select an introspection top level field.', {
                                    nodes: fieldNodes
                                }));
                            }
                        }
                    }
                }
            }
        };
    }
    function groupBy(list, keyFn) {
        const result = new Map();
        for (const item of list){
            const key = keyFn(item);
            const group = result.get(key);
            if (group === undefined) {
                result.set(key, [
                    item
                ]);
            } else {
                group.push(item);
            }
        }
        return result;
    }
    function UniqueArgumentDefinitionNamesRule(context) {
        return {
            DirectiveDefinition (directiveNode) {
                var _directiveNode$argume;
                const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
            },
            InterfaceTypeDefinition: checkArgUniquenessPerField,
            InterfaceTypeExtension: checkArgUniquenessPerField,
            ObjectTypeDefinition: checkArgUniquenessPerField,
            ObjectTypeExtension: checkArgUniquenessPerField
        };
        function checkArgUniquenessPerField(typeNode) {
            var _typeNode$fields;
            const typeName = typeNode.name.value;
            const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
            for (const fieldDef of fieldNodes){
                var _fieldDef$arguments;
                const fieldName = fieldDef.name.value;
                const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
                checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
            }
            return false;
        }
        function checkArgUniqueness(parentName, argumentNodes) {
            const seenArgs = groupBy(argumentNodes, (arg)=>arg.name.value);
            for (const [argName, argNodes] of seenArgs){
                if (argNodes.length > 1) {
                    context.reportError(new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
                        nodes: argNodes.map((node)=>node.name)
                    }));
                }
            }
            return false;
        }
    }
    function UniqueArgumentNamesRule(context) {
        return {
            Field: checkArgUniqueness,
            Directive: checkArgUniqueness
        };
        function checkArgUniqueness(parentNode) {
            var _parentNode$arguments;
            const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
            const seenArgs = groupBy(argumentNodes, (arg)=>arg.name.value);
            for (const [argName, argNodes] of seenArgs){
                if (argNodes.length > 1) {
                    context.reportError(new GraphQLError(`There can be only one argument named "${argName}".`, {
                        nodes: argNodes.map((node)=>node.name)
                    }));
                }
            }
        }
    }
    function UniqueDirectiveNamesRule(context) {
        const knownDirectiveNames = Object.create(null);
        const schema = context.getSchema();
        return {
            DirectiveDefinition (node) {
                const directiveName = node.name.value;
                if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
                    context.reportError(new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
                        nodes: node.name
                    }));
                    return;
                }
                if (knownDirectiveNames[directiveName]) {
                    context.reportError(new GraphQLError(`There can be only one directive named "@${directiveName}".`, {
                        nodes: [
                            knownDirectiveNames[directiveName],
                            node.name
                        ]
                    }));
                } else {
                    knownDirectiveNames[directiveName] = node.name;
                }
                return false;
            }
        };
    }
    function UniqueDirectivesPerLocationRule(context) {
        const uniqueDirectiveMap = Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
        for (const directive of definedDirectives){
            uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions){
            if (def.kind === Kind.DIRECTIVE_DEFINITION) {
                uniqueDirectiveMap[def.name.value] = !def.repeatable;
            }
        }
        const schemaDirectives = Object.create(null);
        const typeDirectivesMap = Object.create(null);
        return {
            enter (node) {
                if (!('directives' in node) || !node.directives) {
                    return;
                }
                let seenDirectives;
                if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
                    seenDirectives = schemaDirectives;
                } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
                    const typeName = node.name.value;
                    seenDirectives = typeDirectivesMap[typeName];
                    if (seenDirectives === undefined) {
                        typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
                    }
                } else {
                    seenDirectives = Object.create(null);
                }
                for (const directive of node.directives){
                    const directiveName = directive.name.value;
                    if (uniqueDirectiveMap[directiveName]) {
                        if (seenDirectives[directiveName]) {
                            context.reportError(new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
                                nodes: [
                                    seenDirectives[directiveName],
                                    directive
                                ]
                            }));
                        } else {
                            seenDirectives[directiveName] = directive;
                        }
                    }
                }
            }
        };
    }
    function UniqueEnumValueNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
        const knownValueNames = Object.create(null);
        return {
            EnumTypeDefinition: checkValueUniqueness,
            EnumTypeExtension: checkValueUniqueness
        };
        function checkValueUniqueness(node) {
            var _node$values;
            const typeName = node.name.value;
            if (!knownValueNames[typeName]) {
                knownValueNames[typeName] = Object.create(null);
            }
            const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
            const valueNames = knownValueNames[typeName];
            for (const valueDef of valueNodes){
                const valueName = valueDef.name.value;
                const existingType = existingTypeMap[typeName];
                if (isEnumType(existingType) && existingType.getValue(valueName)) {
                    context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                        nodes: valueDef.name
                    }));
                } else if (valueNames[valueName]) {
                    context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
                        nodes: [
                            valueNames[valueName],
                            valueDef.name
                        ]
                    }));
                } else {
                    valueNames[valueName] = valueDef.name;
                }
            }
            return false;
        }
    }
    function UniqueFieldDefinitionNamesRule(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
        const knownFieldNames = Object.create(null);
        return {
            InputObjectTypeDefinition: checkFieldUniqueness,
            InputObjectTypeExtension: checkFieldUniqueness,
            InterfaceTypeDefinition: checkFieldUniqueness,
            InterfaceTypeExtension: checkFieldUniqueness,
            ObjectTypeDefinition: checkFieldUniqueness,
            ObjectTypeExtension: checkFieldUniqueness
        };
        function checkFieldUniqueness(node) {
            var _node$fields;
            const typeName = node.name.value;
            if (!knownFieldNames[typeName]) {
                knownFieldNames[typeName] = Object.create(null);
            }
            const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
            const fieldNames = knownFieldNames[typeName];
            for (const fieldDef of fieldNodes){
                const fieldName = fieldDef.name.value;
                if (hasField(existingTypeMap[typeName], fieldName)) {
                    context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
                        nodes: fieldDef.name
                    }));
                } else if (fieldNames[fieldName]) {
                    context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
                        nodes: [
                            fieldNames[fieldName],
                            fieldDef.name
                        ]
                    }));
                } else {
                    fieldNames[fieldName] = fieldDef.name;
                }
            }
            return false;
        }
    }
    function hasField(type, fieldName) {
        if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
            return type.getFields()[fieldName] != null;
        }
        return false;
    }
    function UniqueFragmentNamesRule(context) {
        const knownFragmentNames = Object.create(null);
        return {
            OperationDefinition: ()=>false,
            FragmentDefinition (node) {
                const fragmentName = node.name.value;
                if (knownFragmentNames[fragmentName]) {
                    context.reportError(new GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
                        nodes: [
                            knownFragmentNames[fragmentName],
                            node.name
                        ]
                    }));
                } else {
                    knownFragmentNames[fragmentName] = node.name;
                }
                return false;
            }
        };
    }
    function UniqueInputFieldNamesRule(context) {
        const knownNameStack = [];
        let knownNames = Object.create(null);
        return {
            ObjectValue: {
                enter () {
                    knownNameStack.push(knownNames);
                    knownNames = Object.create(null);
                },
                leave () {
                    const prevKnownNames = knownNameStack.pop();
                    prevKnownNames || invariant(false);
                    knownNames = prevKnownNames;
                }
            },
            ObjectField (node) {
                const fieldName = node.name.value;
                if (knownNames[fieldName]) {
                    context.reportError(new GraphQLError(`There can be only one input field named "${fieldName}".`, {
                        nodes: [
                            knownNames[fieldName],
                            node.name
                        ]
                    }));
                } else {
                    knownNames[fieldName] = node.name;
                }
            }
        };
    }
    function UniqueOperationNamesRule(context) {
        const knownOperationNames = Object.create(null);
        return {
            OperationDefinition (node) {
                const operationName = node.name;
                if (operationName) {
                    if (knownOperationNames[operationName.value]) {
                        context.reportError(new GraphQLError(`There can be only one operation named "${operationName.value}".`, {
                            nodes: [
                                knownOperationNames[operationName.value],
                                operationName
                            ]
                        }));
                    } else {
                        knownOperationNames[operationName.value] = operationName;
                    }
                }
                return false;
            },
            FragmentDefinition: ()=>false
        };
    }
    function UniqueOperationTypesRule(context) {
        const schema = context.getSchema();
        const definedOperationTypes = Object.create(null);
        const existingOperationTypes = schema ? {
            query: schema.getQueryType(),
            mutation: schema.getMutationType(),
            subscription: schema.getSubscriptionType()
        } : {};
        return {
            SchemaDefinition: checkOperationTypes,
            SchemaExtension: checkOperationTypes
        };
        function checkOperationTypes(node) {
            var _node$operationTypes;
            const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
            for (const operationType of operationTypesNodes){
                const operation = operationType.operation;
                const alreadyDefinedOperationType = definedOperationTypes[operation];
                if (existingOperationTypes[operation]) {
                    context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
                        nodes: operationType
                    }));
                } else if (alreadyDefinedOperationType) {
                    context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, {
                        nodes: [
                            alreadyDefinedOperationType,
                            operationType
                        ]
                    }));
                } else {
                    definedOperationTypes[operation] = operationType;
                }
            }
            return false;
        }
    }
    function UniqueTypeNamesRule(context) {
        const knownTypeNames = Object.create(null);
        const schema = context.getSchema();
        return {
            ScalarTypeDefinition: checkTypeName,
            ObjectTypeDefinition: checkTypeName,
            InterfaceTypeDefinition: checkTypeName,
            UnionTypeDefinition: checkTypeName,
            EnumTypeDefinition: checkTypeName,
            InputObjectTypeDefinition: checkTypeName
        };
        function checkTypeName(node) {
            const typeName = node.name.value;
            if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
                context.reportError(new GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
                    nodes: node.name
                }));
                return;
            }
            if (knownTypeNames[typeName]) {
                context.reportError(new GraphQLError(`There can be only one type named "${typeName}".`, {
                    nodes: [
                        knownTypeNames[typeName],
                        node.name
                    ]
                }));
            } else {
                knownTypeNames[typeName] = node.name;
            }
            return false;
        }
    }
    function UniqueVariableNamesRule(context) {
        return {
            OperationDefinition (operationNode) {
                var _operationNode$variab;
                const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
                const seenVariableDefinitions = groupBy(variableDefinitions, (node)=>node.variable.name.value);
                for (const [variableName, variableNodes] of seenVariableDefinitions){
                    if (variableNodes.length > 1) {
                        context.reportError(new GraphQLError(`There can be only one variable named "$${variableName}".`, {
                            nodes: variableNodes.map((node)=>node.variable.name)
                        }));
                    }
                }
            }
        };
    }
    function ValuesOfCorrectTypeRule(context) {
        let variableDefinitions = {};
        return {
            OperationDefinition: {
                enter () {
                    variableDefinitions = {};
                }
            },
            VariableDefinition (definition) {
                variableDefinitions[definition.variable.name.value] = definition;
            },
            ListValue (node) {
                const type = getNullableType(context.getParentInputType());
                if (!isListType(type)) {
                    isValidValueNode(context, node);
                    return false;
                }
            },
            ObjectValue (node) {
                const type = getNamedType(context.getInputType());
                if (!isInputObjectType(type)) {
                    isValidValueNode(context, node);
                    return false;
                }
                const fieldNodeMap = keyMap(node.fields, (field)=>field.name.value);
                for (const fieldDef of Object.values(type.getFields())){
                    const fieldNode = fieldNodeMap[fieldDef.name];
                    if (!fieldNode && isRequiredInputField(fieldDef)) {
                        const typeStr = inspect(fieldDef.type);
                        context.reportError(new GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
                            nodes: node
                        }));
                    }
                }
                if (type.isOneOf) {
                    validateOneOfInputObject(context, node, type, fieldNodeMap, variableDefinitions);
                }
            },
            ObjectField (node) {
                const parentType = getNamedType(context.getParentInputType());
                const fieldType = context.getInputType();
                if (!fieldType && isInputObjectType(parentType)) {
                    const suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
                    context.reportError(new GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions), {
                        nodes: node
                    }));
                }
            },
            NullValue (node) {
                const type = context.getInputType();
                if (isNonNullType(type)) {
                    context.reportError(new GraphQLError(`Expected value of type "${inspect(type)}", found ${print$1(node)}.`, {
                        nodes: node
                    }));
                }
            },
            EnumValue: (node)=>isValidValueNode(context, node),
            IntValue: (node)=>isValidValueNode(context, node),
            FloatValue: (node)=>isValidValueNode(context, node),
            StringValue: (node)=>isValidValueNode(context, node),
            BooleanValue: (node)=>isValidValueNode(context, node)
        };
    }
    function isValidValueNode(context, node) {
        const locationType = context.getInputType();
        if (!locationType) {
            return;
        }
        const type = getNamedType(locationType);
        if (!isLeafType(type)) {
            const typeStr = inspect(locationType);
            context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print$1(node)}.`, {
                nodes: node
            }));
            return;
        }
        try {
            const parseResult = type.parseLiteral(node, undefined);
            if (parseResult === undefined) {
                const typeStr = inspect(locationType);
                context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print$1(node)}.`, {
                    nodes: node
                }));
            }
        } catch (error) {
            const typeStr = inspect(locationType);
            if (error instanceof GraphQLError) {
                context.reportError(error);
            } else {
                context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print$1(node)}; ` + error.message, {
                    nodes: node,
                    originalError: error
                }));
            }
        }
    }
    function validateOneOfInputObject(context, node, type, fieldNodeMap, variableDefinitions) {
        var _fieldNodeMap$keys$;
        const keys = Object.keys(fieldNodeMap);
        const isNotExactlyOneField = keys.length !== 1;
        if (isNotExactlyOneField) {
            context.reportError(new GraphQLError(`OneOf Input Object "${type.name}" must specify exactly one key.`, {
                nodes: [
                    node
                ]
            }));
            return;
        }
        const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
        const isNullLiteral = !value || value.kind === Kind.NULL;
        const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === Kind.VARIABLE;
        if (isNullLiteral) {
            context.reportError(new GraphQLError(`Field "${type.name}.${keys[0]}" must be non-null.`, {
                nodes: [
                    node
                ]
            }));
            return;
        }
        if (isVariable) {
            const variableName = value.name.value;
            const definition = variableDefinitions[variableName];
            const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
            if (isNullableVariable) {
                context.reportError(new GraphQLError(`Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`, {
                    nodes: [
                        node
                    ]
                }));
            }
        }
    }
    function VariablesAreInputTypesRule(context) {
        return {
            VariableDefinition (node) {
                const type = typeFromAST(context.getSchema(), node.type);
                if (type !== undefined && !isInputType(type)) {
                    const variableName = node.variable.name.value;
                    const typeName = print$1(node.type);
                    context.reportError(new GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, {
                        nodes: node.type
                    }));
                }
            }
        };
    }
    function VariablesInAllowedPositionRule(context) {
        let varDefMap = Object.create(null);
        return {
            OperationDefinition: {
                enter () {
                    varDefMap = Object.create(null);
                },
                leave (operation) {
                    const usages = context.getRecursiveVariableUsages(operation);
                    for (const { node, type, defaultValue, parentType } of usages){
                        const varName = node.name.value;
                        const varDef = varDefMap[varName];
                        if (varDef && type) {
                            const schema = context.getSchema();
                            const varType = typeFromAST(schema, varDef.type);
                            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
                                const varTypeStr = inspect(varType);
                                const typeStr = inspect(type);
                                context.reportError(new GraphQLError(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                                    nodes: [
                                        varDef,
                                        node
                                    ]
                                }));
                            }
                            if (isInputObjectType(parentType) && parentType.isOneOf && isNullableType(varType)) {
                                context.reportError(new GraphQLError(`Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`, {
                                    nodes: [
                                        varDef,
                                        node
                                    ]
                                }));
                            }
                        }
                    }
                }
            },
            VariableDefinition (node) {
                varDefMap[node.variable.name.value] = node;
            }
        };
    }
    function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
        if (isNonNullType(locationType) && !isNonNullType(varType)) {
            const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
            const hasLocationDefaultValue = locationDefaultValue !== undefined;
            if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
                return false;
            }
            const nullableLocationType = locationType.ofType;
            return isTypeSubTypeOf(schema, varType, nullableLocationType);
        }
        return isTypeSubTypeOf(schema, varType, locationType);
    }
    const recommendedRules = Object.freeze([
        MaxIntrospectionDepthRule
    ]);
    const specifiedRules = Object.freeze([
        ExecutableDefinitionsRule,
        UniqueOperationNamesRule,
        LoneAnonymousOperationRule,
        SingleFieldSubscriptionsRule,
        KnownTypeNamesRule,
        FragmentsOnCompositeTypesRule,
        VariablesAreInputTypesRule,
        ScalarLeafsRule,
        FieldsOnCorrectTypeRule,
        UniqueFragmentNamesRule,
        KnownFragmentNamesRule,
        NoUnusedFragmentsRule,
        PossibleFragmentSpreadsRule,
        NoFragmentCyclesRule,
        UniqueVariableNamesRule,
        NoUndefinedVariablesRule,
        NoUnusedVariablesRule,
        KnownDirectivesRule,
        UniqueDirectivesPerLocationRule,
        KnownArgumentNamesRule,
        UniqueArgumentNamesRule,
        ValuesOfCorrectTypeRule,
        ProvidedRequiredArgumentsRule,
        VariablesInAllowedPositionRule,
        OverlappingFieldsCanBeMergedRule,
        UniqueInputFieldNamesRule,
        ...recommendedRules
    ]);
    const specifiedSDLRules = Object.freeze([
        LoneSchemaDefinitionRule,
        UniqueOperationTypesRule,
        UniqueTypeNamesRule,
        UniqueEnumValueNamesRule,
        UniqueFieldDefinitionNamesRule,
        UniqueArgumentDefinitionNamesRule,
        UniqueDirectiveNamesRule,
        KnownTypeNamesRule,
        KnownDirectivesRule,
        UniqueDirectivesPerLocationRule,
        PossibleTypeExtensionsRule,
        KnownArgumentNamesOnDirectivesRule,
        UniqueArgumentNamesRule,
        UniqueInputFieldNamesRule,
        ProvidedRequiredArgumentsOnDirectivesRule
    ]);
    class ASTValidationContext {
        constructor(ast, onError){
            this._ast = ast;
            this._fragments = undefined;
            this._fragmentSpreads = new Map();
            this._recursivelyReferencedFragments = new Map();
            this._onError = onError;
        }
        get [Symbol.toStringTag]() {
            return 'ASTValidationContext';
        }
        reportError(error) {
            this._onError(error);
        }
        getDocument() {
            return this._ast;
        }
        getFragment(name) {
            let fragments;
            if (this._fragments) {
                fragments = this._fragments;
            } else {
                fragments = Object.create(null);
                for (const defNode of this.getDocument().definitions){
                    if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
                        fragments[defNode.name.value] = defNode;
                    }
                }
                this._fragments = fragments;
            }
            return fragments[name];
        }
        getFragmentSpreads(node) {
            let spreads = this._fragmentSpreads.get(node);
            if (!spreads) {
                spreads = [];
                const setsToVisit = [
                    node
                ];
                let set;
                while((set = setsToVisit.pop())){
                    for (const selection of set.selections){
                        if (selection.kind === Kind.FRAGMENT_SPREAD) {
                            spreads.push(selection);
                        } else if (selection.selectionSet) {
                            setsToVisit.push(selection.selectionSet);
                        }
                    }
                }
                this._fragmentSpreads.set(node, spreads);
            }
            return spreads;
        }
        getRecursivelyReferencedFragments(operation) {
            let fragments = this._recursivelyReferencedFragments.get(operation);
            if (!fragments) {
                fragments = [];
                const collectedNames = Object.create(null);
                const nodesToVisit = [
                    operation.selectionSet
                ];
                let node;
                while((node = nodesToVisit.pop())){
                    for (const spread of this.getFragmentSpreads(node)){
                        const fragName = spread.name.value;
                        if (collectedNames[fragName] !== true) {
                            collectedNames[fragName] = true;
                            const fragment = this.getFragment(fragName);
                            if (fragment) {
                                fragments.push(fragment);
                                nodesToVisit.push(fragment.selectionSet);
                            }
                        }
                    }
                }
                this._recursivelyReferencedFragments.set(operation, fragments);
            }
            return fragments;
        }
    }
    class SDLValidationContext extends ASTValidationContext {
        constructor(ast, schema, onError){
            super(ast, onError);
            this._schema = schema;
        }
        get [Symbol.toStringTag]() {
            return 'SDLValidationContext';
        }
        getSchema() {
            return this._schema;
        }
    }
    class ValidationContext extends ASTValidationContext {
        constructor(schema, ast, typeInfo, onError){
            super(ast, onError);
            this._schema = schema;
            this._typeInfo = typeInfo;
            this._variableUsages = new Map();
            this._recursiveVariableUsages = new Map();
        }
        get [Symbol.toStringTag]() {
            return 'ValidationContext';
        }
        getSchema() {
            return this._schema;
        }
        getVariableUsages(node) {
            let usages = this._variableUsages.get(node);
            if (!usages) {
                const newUsages = [];
                const typeInfo = new TypeInfo(this._schema);
                visit(node, visitWithTypeInfo(typeInfo, {
                    VariableDefinition: ()=>false,
                    Variable (variable) {
                        newUsages.push({
                            node: variable,
                            type: typeInfo.getInputType(),
                            defaultValue: typeInfo.getDefaultValue(),
                            parentType: typeInfo.getParentInputType()
                        });
                    }
                }));
                usages = newUsages;
                this._variableUsages.set(node, usages);
            }
            return usages;
        }
        getRecursiveVariableUsages(operation) {
            let usages = this._recursiveVariableUsages.get(operation);
            if (!usages) {
                usages = this.getVariableUsages(operation);
                for (const frag of this.getRecursivelyReferencedFragments(operation)){
                    usages = usages.concat(this.getVariableUsages(frag));
                }
                this._recursiveVariableUsages.set(operation, usages);
            }
            return usages;
        }
        getType() {
            return this._typeInfo.getType();
        }
        getParentType() {
            return this._typeInfo.getParentType();
        }
        getInputType() {
            return this._typeInfo.getInputType();
        }
        getParentInputType() {
            return this._typeInfo.getParentInputType();
        }
        getFieldDef() {
            return this._typeInfo.getFieldDef();
        }
        getDirective() {
            return this._typeInfo.getDirective();
        }
        getArgument() {
            return this._typeInfo.getArgument();
        }
        getEnumValue() {
            return this._typeInfo.getEnumValue();
        }
    }
    function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
        var _options$maxErrors;
        const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
        documentAST || devAssert(false, 'Must provide document.');
        assertValidSchema(schema);
        const abortObj = Object.freeze({});
        const errors = [];
        const context = new ValidationContext(schema, documentAST, typeInfo, (error)=>{
            if (errors.length >= maxErrors) {
                errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));
                throw abortObj;
            }
            errors.push(error);
        });
        const visitor = visitInParallel(rules.map((rule)=>rule(context)));
        try {
            visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
        } catch (e) {
            if (e !== abortObj) {
                throw e;
            }
        }
        return errors;
    }
    function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
        const errors = [];
        const context = new SDLValidationContext(documentAST, schemaToExtend, (error)=>{
            errors.push(error);
        });
        const visitors = rules.map((rule)=>rule(context));
        visit(documentAST, visitInParallel(visitors));
        return errors;
    }
    function assertValidSDL(documentAST) {
        const errors = validateSDL(documentAST);
        if (errors.length !== 0) {
            throw new Error(errors.map((error)=>error.message).join('\n\n'));
        }
    }
    function assertValidSDLExtension(documentAST, schema) {
        const errors = validateSDL(documentAST, schema);
        if (errors.length !== 0) {
            throw new Error(errors.map((error)=>error.message).join('\n\n'));
        }
    }
    function memoize3(fn) {
        let cache0;
        return function memoized(a1, a2, a3) {
            if (cache0 === undefined) {
                cache0 = new WeakMap();
            }
            let cache1 = cache0.get(a1);
            if (cache1 === undefined) {
                cache1 = new WeakMap();
                cache0.set(a1, cache1);
            }
            let cache2 = cache1.get(a2);
            if (cache2 === undefined) {
                cache2 = new WeakMap();
                cache1.set(a2, cache2);
            }
            let fnResult = cache2.get(a3);
            if (fnResult === undefined) {
                fnResult = fn(a1, a2, a3);
                cache2.set(a3, fnResult);
            }
            return fnResult;
        };
    }
    function promiseForObject(object) {
        return Promise.all(Object.values(object)).then((resolvedValues)=>{
            const resolvedObject = Object.create(null);
            for (const [i, key] of Object.keys(object).entries()){
                resolvedObject[key] = resolvedValues[i];
            }
            return resolvedObject;
        });
    }
    function promiseReduce(values, callbackFn, initialValue) {
        let accumulator = initialValue;
        for (const value of values){
            accumulator = isPromise(accumulator) ? accumulator.then((resolved)=>callbackFn(resolved, value)) : callbackFn(accumulator, value);
        }
        return accumulator;
    }
    function toError(thrownValue) {
        return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
    }
    class NonErrorThrown extends Error {
        constructor(thrownValue){
            super('Unexpected error value: ' + inspect(thrownValue));
            this.name = 'NonErrorThrown';
            this.thrownValue = thrownValue;
        }
    }
    function locatedError(rawOriginalError, nodes, path) {
        var _nodes;
        const originalError = toError(rawOriginalError);
        if (isLocatedGraphQLError(originalError)) {
            return originalError;
        }
        return new GraphQLError(originalError.message, {
            nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
            source: originalError.source,
            positions: originalError.positions,
            path,
            originalError
        });
    }
    function isLocatedGraphQLError(error) {
        return Array.isArray(error.path);
    }
    const collectSubfields = memoize3((exeContext, returnType, fieldNodes)=>collectSubfields$1(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
    function execute$1(args) {
        arguments.length < 2 || devAssert(false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');
        const { schema, document, variableValues, rootValue } = args;
        assertValidExecutionArguments(schema, document, variableValues);
        const exeContext = buildExecutionContext(args);
        if (!('schema' in exeContext)) {
            return {
                errors: exeContext
            };
        }
        try {
            const { operation } = exeContext;
            const result = executeOperation(exeContext, operation, rootValue);
            if (isPromise(result)) {
                return result.then((data)=>buildResponse(data, exeContext.errors), (error)=>{
                    exeContext.errors.push(error);
                    return buildResponse(null, exeContext.errors);
                });
            }
            return buildResponse(result, exeContext.errors);
        } catch (error) {
            exeContext.errors.push(error);
            return buildResponse(null, exeContext.errors);
        }
    }
    function executeSync(args) {
        const result = execute$1(args);
        if (isPromise(result)) {
            throw new Error('GraphQL execution failed to complete synchronously.');
        }
        return result;
    }
    function buildResponse(data, errors) {
        return errors.length === 0 ? {
            data
        } : {
            errors,
            data
        };
    }
    function assertValidExecutionArguments(schema, document, rawVariableValues) {
        document || devAssert(false, 'Must provide document.');
        assertValidSchema(schema);
        rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(false, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');
    }
    function buildExecutionContext(args) {
        var _definition$name, _operation$variableDe, _options$maxCoercionE;
        const { schema, document, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, options } = args;
        let operation;
        const fragments = Object.create(null);
        for (const definition of document.definitions){
            switch(definition.kind){
                case Kind.OPERATION_DEFINITION:
                    if (operationName == null) {
                        if (operation !== undefined) {
                            return [
                                new GraphQLError('Must provide operation name if query contains multiple operations.')
                            ];
                        }
                        operation = definition;
                    } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                        operation = definition;
                    }
                    break;
                case Kind.FRAGMENT_DEFINITION:
                    fragments[definition.name.value] = definition;
                    break;
            }
        }
        if (!operation) {
            if (operationName != null) {
                return [
                    new GraphQLError(`Unknown operation named "${operationName}".`)
                ];
            }
            return [
                new GraphQLError('Must provide an operation.')
            ];
        }
        const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
        const coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
            maxErrors: (_options$maxCoercionE = options === null || options === void 0 ? void 0 : options.maxCoercionErrors) !== null && _options$maxCoercionE !== void 0 ? _options$maxCoercionE : 50
        });
        if (coercedVariableValues.errors) {
            return coercedVariableValues.errors;
        }
        return {
            schema,
            fragments,
            rootValue,
            contextValue,
            operation,
            variableValues: coercedVariableValues.coerced,
            fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
            typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
            subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
            errors: []
        };
    }
    function executeOperation(exeContext, operation, rootValue) {
        const rootType = exeContext.schema.getRootType(operation.operation);
        if (rootType == null) {
            throw new GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
                nodes: operation
            });
        }
        const rootFields = collectFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
        const path = undefined;
        switch(operation.operation){
            case OperationTypeNode.QUERY:
                return executeFields(exeContext, rootType, rootValue, path, rootFields);
            case OperationTypeNode.MUTATION:
                return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
            case OperationTypeNode.SUBSCRIPTION:
                return executeFields(exeContext, rootType, rootValue, path, rootFields);
        }
    }
    function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
        return promiseReduce(fields.entries(), (results, [responseName, fieldNodes])=>{
            const fieldPath = addPath(path, responseName, parentType.name);
            const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
            if (result === undefined) {
                return results;
            }
            if (isPromise(result)) {
                return result.then((resolvedResult)=>{
                    results[responseName] = resolvedResult;
                    return results;
                });
            }
            results[responseName] = result;
            return results;
        }, Object.create(null));
    }
    function executeFields(exeContext, parentType, sourceValue, path, fields) {
        const results = Object.create(null);
        let containsPromise = false;
        try {
            for (const [responseName, fieldNodes] of fields.entries()){
                const fieldPath = addPath(path, responseName, parentType.name);
                const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
                if (result !== undefined) {
                    results[responseName] = result;
                    if (isPromise(result)) {
                        containsPromise = true;
                    }
                }
            }
        } catch (error) {
            if (containsPromise) {
                return promiseForObject(results).finally(()=>{
                    throw error;
                });
            }
            throw error;
        }
        if (!containsPromise) {
            return results;
        }
        return promiseForObject(results);
    }
    function executeField(exeContext, parentType, source, fieldNodes, path) {
        var _fieldDef$resolve;
        const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
        if (!fieldDef) {
            return;
        }
        const returnType = fieldDef.type;
        const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
        const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
        try {
            const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);
            const contextValue = exeContext.contextValue;
            const result = resolveFn(source, args, contextValue, info);
            let completed;
            if (isPromise(result)) {
                completed = result.then((resolved)=>completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
            } else {
                completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
            }
            if (isPromise(completed)) {
                return completed.then(undefined, (rawError)=>{
                    const error = locatedError(rawError, fieldNodes, pathToArray(path));
                    return handleFieldError(error, returnType, exeContext);
                });
            }
            return completed;
        } catch (rawError) {
            const error = locatedError(rawError, fieldNodes, pathToArray(path));
            return handleFieldError(error, returnType, exeContext);
        }
    }
    function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
        return {
            fieldName: fieldDef.name,
            fieldNodes,
            returnType: fieldDef.type,
            parentType,
            path,
            schema: exeContext.schema,
            fragments: exeContext.fragments,
            rootValue: exeContext.rootValue,
            operation: exeContext.operation,
            variableValues: exeContext.variableValues
        };
    }
    function handleFieldError(error, returnType, exeContext) {
        if (isNonNullType(returnType)) {
            throw error;
        }
        exeContext.errors.push(error);
        return null;
    }
    function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (result instanceof Error) {
            throw result;
        }
        if (isNonNullType(returnType)) {
            const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
            if (completed === null) {
                throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
            }
            return completed;
        }
        if (result == null) {
            return null;
        }
        if (isListType(returnType)) {
            return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if (isLeafType(returnType)) {
            return completeLeafValue(returnType, result);
        }
        if (isAbstractType(returnType)) {
            return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if (isObjectType(returnType)) {
            return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        invariant(false, 'Cannot complete value of unexpected output type: ' + inspect(returnType));
    }
    function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
        if (!isIterableObject(result)) {
            throw new GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
        }
        const itemType = returnType.ofType;
        let containsPromise = false;
        const completedResults = Array.from(result, (item, index)=>{
            const itemPath = addPath(path, index, undefined);
            try {
                let completedItem;
                if (isPromise(item)) {
                    completedItem = item.then((resolved)=>completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));
                } else {
                    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
                }
                if (isPromise(completedItem)) {
                    containsPromise = true;
                    return completedItem.then(undefined, (rawError)=>{
                        const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
                        return handleFieldError(error, itemType, exeContext);
                    });
                }
                return completedItem;
            } catch (rawError) {
                const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
                return handleFieldError(error, itemType, exeContext);
            }
        });
        return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    function completeLeafValue(returnType, result) {
        const serializedResult = returnType.serialize(result);
        if (serializedResult == null) {
            throw new Error(`Expected \`${inspect(returnType)}.serialize(${inspect(result)})\` to ` + `return non-nullable value, returned: ${inspect(serializedResult)}`);
        }
        return serializedResult;
    }
    function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
        var _returnType$resolveTy;
        const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
        const contextValue = exeContext.contextValue;
        const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
        if (isPromise(runtimeType)) {
            return runtimeType.then((resolvedRuntimeType)=>completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
        }
        return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
    }
    function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
        if (runtimeTypeName == null) {
            throw new GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
        }
        if (isObjectType(runtimeTypeName)) {
            throw new GraphQLError('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');
        }
        if (typeof runtimeTypeName !== 'string') {
            throw new GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${inspect(result)}, received "${inspect(runtimeTypeName)}".`);
        }
        const runtimeType = exeContext.schema.getType(runtimeTypeName);
        if (runtimeType == null) {
            throw new GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, {
                nodes: fieldNodes
            });
        }
        if (!isObjectType(runtimeType)) {
            throw new GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, {
                nodes: fieldNodes
            });
        }
        if (!exeContext.schema.isSubType(returnType, runtimeType)) {
            throw new GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, {
                nodes: fieldNodes
            });
        }
        return runtimeType;
    }
    function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
        const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
        if (returnType.isTypeOf) {
            const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
            if (isPromise(isTypeOf)) {
                return isTypeOf.then((resolvedIsTypeOf)=>{
                    if (!resolvedIsTypeOf) {
                        throw invalidReturnTypeError(returnType, result, fieldNodes);
                    }
                    return executeFields(exeContext, returnType, result, path, subFieldNodes);
                });
            }
            if (!isTypeOf) {
                throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
        }
        return executeFields(exeContext, returnType, result, path, subFieldNodes);
    }
    function invalidReturnTypeError(returnType, result, fieldNodes) {
        return new GraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect(result)}.`, {
            nodes: fieldNodes
        });
    }
    const defaultTypeResolver = function(value, contextValue, info, abstractType) {
        if (isObjectLike(value) && typeof value.__typename === 'string') {
            return value.__typename;
        }
        const possibleTypes = info.schema.getPossibleTypes(abstractType);
        const promisedIsTypeOfResults = [];
        for(let i = 0; i < possibleTypes.length; i++){
            const type = possibleTypes[i];
            if (type.isTypeOf) {
                const isTypeOfResult = type.isTypeOf(value, contextValue, info);
                if (isPromise(isTypeOfResult)) {
                    promisedIsTypeOfResults[i] = isTypeOfResult;
                } else if (isTypeOfResult) {
                    return type.name;
                }
            }
        }
        if (promisedIsTypeOfResults.length) {
            return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults)=>{
                for(let i = 0; i < isTypeOfResults.length; i++){
                    if (isTypeOfResults[i]) {
                        return possibleTypes[i].name;
                    }
                }
            });
        }
    };
    const defaultFieldResolver = function(source, args, contextValue, info) {
        if (isObjectLike(source) || typeof source === 'function') {
            const property = source[info.fieldName];
            if (typeof property === 'function') {
                return source[info.fieldName](args, contextValue, info);
            }
            return property;
        }
    };
    function getFieldDef(schema, parentType, fieldNode) {
        const fieldName = fieldNode.name.value;
        if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
            return SchemaMetaFieldDef;
        } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
            return TypeMetaFieldDef;
        } else if (fieldName === TypeNameMetaFieldDef.name) {
            return TypeNameMetaFieldDef;
        }
        return parentType.getFields()[fieldName];
    }
    function graphql$1(args) {
        return new Promise((resolve)=>resolve(graphqlImpl(args)));
    }
    function graphqlSync(args) {
        const result = graphqlImpl(args);
        if (isPromise(result)) {
            throw new Error('GraphQL execution failed to complete synchronously.');
        }
        return result;
    }
    function graphqlImpl(args) {
        arguments.length < 2 || devAssert(false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');
        const { schema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver } = args;
        const schemaValidationErrors = validateSchema(schema);
        if (schemaValidationErrors.length > 0) {
            return {
                errors: schemaValidationErrors
            };
        }
        let document;
        try {
            document = parse(source);
        } catch (syntaxError) {
            return {
                errors: [
                    syntaxError
                ]
            };
        }
        const validationErrors = validate(schema, document);
        if (validationErrors.length > 0) {
            return {
                errors: validationErrors
            };
        }
        return execute$1({
            schema,
            document,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver,
            typeResolver
        });
    }
    function isAsyncIterable(maybeAsyncIterable) {
        return (typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === 'function');
    }
    function mapAsyncIterator(iterable, callback) {
        const iterator = iterable[Symbol.asyncIterator]();
        async function mapResult(result) {
            if (result.done) {
                return result;
            }
            try {
                return {
                    value: await callback(result.value),
                    done: false
                };
            } catch (error) {
                if (typeof iterator.return === 'function') {
                    try {
                        await iterator.return();
                    } catch (_e) {}
                }
                throw error;
            }
        }
        return {
            async next () {
                return mapResult(await iterator.next());
            },
            async return () {
                return typeof iterator.return === 'function' ? mapResult(await iterator.return()) : {
                    value: undefined,
                    done: true
                };
            },
            async throw (error) {
                if (typeof iterator.throw === 'function') {
                    return mapResult(await iterator.throw(error));
                }
                throw error;
            },
            [Symbol.asyncIterator] () {
                return this;
            }
        };
    }
    async function subscribe(args) {
        arguments.length < 2 || devAssert(false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');
        const resultOrStream = await createSourceEventStream(args);
        if (!isAsyncIterable(resultOrStream)) {
            return resultOrStream;
        }
        const mapSourceToResponse = (payload)=>execute$1({
                ...args,
                rootValue: payload
            });
        return mapAsyncIterator(resultOrStream, mapSourceToResponse);
    }
    function toNormalizedArgs(args) {
        const firstArg = args[0];
        if (firstArg && 'document' in firstArg) {
            return firstArg;
        }
        return {
            schema: firstArg,
            document: args[1],
            rootValue: args[2],
            contextValue: args[3],
            variableValues: args[4],
            operationName: args[5],
            subscribeFieldResolver: args[6]
        };
    }
    async function createSourceEventStream(...rawArgs) {
        const args = toNormalizedArgs(rawArgs);
        const { schema, document, variableValues } = args;
        assertValidExecutionArguments(schema, document, variableValues);
        const exeContext = buildExecutionContext(args);
        if (!('schema' in exeContext)) {
            return {
                errors: exeContext
            };
        }
        try {
            const eventStream = await executeSubscription(exeContext);
            if (!isAsyncIterable(eventStream)) {
                throw new Error('Subscription field must return Async Iterable. ' + `Received: ${inspect(eventStream)}.`);
            }
            return eventStream;
        } catch (error) {
            if (error instanceof GraphQLError) {
                return {
                    errors: [
                        error
                    ]
                };
            }
            throw error;
        }
    }
    async function executeSubscription(exeContext) {
        const { schema, fragments, operation, variableValues, rootValue } = exeContext;
        const rootType = schema.getSubscriptionType();
        if (rootType == null) {
            throw new GraphQLError('Schema is not configured to execute subscription operation.', {
                nodes: operation
            });
        }
        const rootFields = collectFields(schema, fragments, variableValues, rootType, operation.selectionSet);
        const [responseName, fieldNodes] = [
            ...rootFields.entries()
        ][0];
        const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);
        if (!fieldDef) {
            const fieldName = fieldNodes[0].name.value;
            throw new GraphQLError(`The subscription field "${fieldName}" is not defined.`, {
                nodes: fieldNodes
            });
        }
        const path = addPath(undefined, responseName, rootType.name);
        const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
        try {
            var _fieldDef$subscribe;
            const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
            const contextValue = exeContext.contextValue;
            const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
            const eventStream = await resolveFn(rootValue, args, contextValue, info);
            if (eventStream instanceof Error) {
                throw eventStream;
            }
            return eventStream;
        } catch (error) {
            throw locatedError(error, fieldNodes, pathToArray(path));
        }
    }
    function NoDeprecatedCustomRule(context) {
        return {
            Field (node) {
                const fieldDef = context.getFieldDef();
                const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
                if (fieldDef && deprecationReason != null) {
                    const parentType = context.getParentType();
                    parentType != null || invariant(false);
                    context.reportError(new GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, {
                        nodes: node
                    }));
                }
            },
            Argument (node) {
                const argDef = context.getArgument();
                const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
                if (argDef && deprecationReason != null) {
                    const directiveDef = context.getDirective();
                    if (directiveDef != null) {
                        context.reportError(new GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                            nodes: node
                        }));
                    } else {
                        const parentType = context.getParentType();
                        const fieldDef = context.getFieldDef();
                        (parentType != null && fieldDef != null) || invariant(false);
                        context.reportError(new GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, {
                            nodes: node
                        }));
                    }
                }
            },
            ObjectField (node) {
                const inputObjectDef = getNamedType(context.getParentInputType());
                if (isInputObjectType(inputObjectDef)) {
                    const inputFieldDef = inputObjectDef.getFields()[node.name.value];
                    const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
                    if (deprecationReason != null) {
                        context.reportError(new GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, {
                            nodes: node
                        }));
                    }
                }
            },
            EnumValue (node) {
                const enumValueDef = context.getEnumValue();
                const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
                if (enumValueDef && deprecationReason != null) {
                    const enumTypeDef = getNamedType(context.getInputType());
                    enumTypeDef != null || invariant(false);
                    context.reportError(new GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, {
                        nodes: node
                    }));
                }
            }
        };
    }
    function NoSchemaIntrospectionCustomRule(context) {
        return {
            Field (node) {
                const type = getNamedType(context.getType());
                if (type && isIntrospectionType(type)) {
                    context.reportError(new GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`, {
                        nodes: node
                    }));
                }
            }
        };
    }
    function getIntrospectionQuery(options) {
        const optionsWithDefault = {
            descriptions: true,
            specifiedByUrl: false,
            directiveIsRepeatable: false,
            schemaDescription: false,
            inputValueDeprecation: false,
            oneOf: false,
            ...options
        };
        const descriptions = optionsWithDefault.descriptions ? 'description' : '';
        const specifiedByUrl = optionsWithDefault.specifiedByUrl ? 'specifiedByURL' : '';
        const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? 'isRepeatable' : '';
        const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : '';
        function inputDeprecation(str) {
            return optionsWithDefault.inputValueDeprecation ? str : '';
        }
        const oneOf = optionsWithDefault.oneOf ? 'isOneOf' : '';
        return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation('(includeDeprecated: true)')} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      ${oneOf}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation('(includeDeprecated: true)')} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation('(includeDeprecated: true)')} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation('isDeprecated')}
      ${inputDeprecation('deprecationReason')}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    }
    function getOperationAST(documentAST, operationName) {
        let operation = null;
        for (const definition of documentAST.definitions){
            if (definition.kind === Kind.OPERATION_DEFINITION) {
                var _definition$name;
                if (operationName == null) {
                    if (operation) {
                        return null;
                    }
                    operation = definition;
                } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
                    return definition;
                }
            }
        }
        return operation;
    }
    function getOperationRootType(schema, operation) {
        if (operation.operation === 'query') {
            const queryType = schema.getQueryType();
            if (!queryType) {
                throw new GraphQLError('Schema does not define the required query root type.', {
                    nodes: operation
                });
            }
            return queryType;
        }
        if (operation.operation === 'mutation') {
            const mutationType = schema.getMutationType();
            if (!mutationType) {
                throw new GraphQLError('Schema is not configured for mutations.', {
                    nodes: operation
                });
            }
            return mutationType;
        }
        if (operation.operation === 'subscription') {
            const subscriptionType = schema.getSubscriptionType();
            if (!subscriptionType) {
                throw new GraphQLError('Schema is not configured for subscriptions.', {
                    nodes: operation
                });
            }
            return subscriptionType;
        }
        throw new GraphQLError('Can only have query, mutation and subscription operations.', {
            nodes: operation
        });
    }
    function introspectionFromSchema(schema, options) {
        const optionsWithDefaults = {
            specifiedByUrl: true,
            directiveIsRepeatable: true,
            schemaDescription: true,
            inputValueDeprecation: true,
            oneOf: true,
            ...options
        };
        const document = parse(getIntrospectionQuery(optionsWithDefaults));
        const result = executeSync({
            schema,
            document
        });
        (!result.errors && result.data) || invariant(false);
        return result.data;
    }
    function buildClientSchema(introspection, options) {
        (isObjectLike(introspection) && isObjectLike(introspection.__schema)) || devAssert(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(introspection)}.`);
        const schemaIntrospection = introspection.__schema;
        const typeMap = keyValMap(schemaIntrospection.types, (typeIntrospection)=>typeIntrospection.name, (typeIntrospection)=>buildType(typeIntrospection));
        for (const stdType of [
            ...specifiedScalarTypes,
            ...introspectionTypes
        ]){
            if (typeMap[stdType.name]) {
                typeMap[stdType.name] = stdType;
            }
        }
        const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
        const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
        const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
        const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
        return new GraphQLSchema({
            description: schemaIntrospection.description,
            query: queryType,
            mutation: mutationType,
            subscription: subscriptionType,
            types: Object.values(typeMap),
            directives,
            assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
        function getType(typeRef) {
            if (typeRef.kind === TypeKind.LIST) {
                const itemRef = typeRef.ofType;
                if (!itemRef) {
                    throw new Error('Decorated type deeper than introspection query.');
                }
                return new GraphQLList(getType(itemRef));
            }
            if (typeRef.kind === TypeKind.NON_NULL) {
                const nullableRef = typeRef.ofType;
                if (!nullableRef) {
                    throw new Error('Decorated type deeper than introspection query.');
                }
                const nullableType = getType(nullableRef);
                return new GraphQLNonNull(assertNullableType(nullableType));
            }
            return getNamedType(typeRef);
        }
        function getNamedType(typeRef) {
            const typeName = typeRef.name;
            if (!typeName) {
                throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);
            }
            const type = typeMap[typeName];
            if (!type) {
                throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
            }
            return type;
        }
        function getObjectType(typeRef) {
            return assertObjectType(getNamedType(typeRef));
        }
        function getInterfaceType(typeRef) {
            return assertInterfaceType(getNamedType(typeRef));
        }
        function buildType(type) {
            if (type != null && type.name != null && type.kind != null) {
                switch(type.kind){
                    case TypeKind.SCALAR:
                        return buildScalarDef(type);
                    case TypeKind.OBJECT:
                        return buildObjectDef(type);
                    case TypeKind.INTERFACE:
                        return buildInterfaceDef(type);
                    case TypeKind.UNION:
                        return buildUnionDef(type);
                    case TypeKind.ENUM:
                        return buildEnumDef(type);
                    case TypeKind.INPUT_OBJECT:
                        return buildInputObjectDef(type);
                }
            }
            const typeStr = inspect(type);
            throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
        }
        function buildScalarDef(scalarIntrospection) {
            return new GraphQLScalarType({
                name: scalarIntrospection.name,
                description: scalarIntrospection.description,
                specifiedByURL: scalarIntrospection.specifiedByURL
            });
        }
        function buildImplementationsList(implementingIntrospection) {
            if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
                return [];
            }
            if (!implementingIntrospection.interfaces) {
                const implementingIntrospectionStr = inspect(implementingIntrospection);
                throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
            }
            return implementingIntrospection.interfaces.map(getInterfaceType);
        }
        function buildObjectDef(objectIntrospection) {
            return new GraphQLObjectType({
                name: objectIntrospection.name,
                description: objectIntrospection.description,
                interfaces: ()=>buildImplementationsList(objectIntrospection),
                fields: ()=>buildFieldDefMap(objectIntrospection)
            });
        }
        function buildInterfaceDef(interfaceIntrospection) {
            return new GraphQLInterfaceType({
                name: interfaceIntrospection.name,
                description: interfaceIntrospection.description,
                interfaces: ()=>buildImplementationsList(interfaceIntrospection),
                fields: ()=>buildFieldDefMap(interfaceIntrospection)
            });
        }
        function buildUnionDef(unionIntrospection) {
            if (!unionIntrospection.possibleTypes) {
                const unionIntrospectionStr = inspect(unionIntrospection);
                throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
            }
            return new GraphQLUnionType({
                name: unionIntrospection.name,
                description: unionIntrospection.description,
                types: ()=>unionIntrospection.possibleTypes.map(getObjectType)
            });
        }
        function buildEnumDef(enumIntrospection) {
            if (!enumIntrospection.enumValues) {
                const enumIntrospectionStr = inspect(enumIntrospection);
                throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
            }
            return new GraphQLEnumType({
                name: enumIntrospection.name,
                description: enumIntrospection.description,
                values: keyValMap(enumIntrospection.enumValues, (valueIntrospection)=>valueIntrospection.name, (valueIntrospection)=>({
                        description: valueIntrospection.description,
                        deprecationReason: valueIntrospection.deprecationReason
                    }))
            });
        }
        function buildInputObjectDef(inputObjectIntrospection) {
            if (!inputObjectIntrospection.inputFields) {
                const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
                throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
            }
            return new GraphQLInputObjectType({
                name: inputObjectIntrospection.name,
                description: inputObjectIntrospection.description,
                fields: ()=>buildInputValueDefMap(inputObjectIntrospection.inputFields),
                isOneOf: inputObjectIntrospection.isOneOf
            });
        }
        function buildFieldDefMap(typeIntrospection) {
            if (!typeIntrospection.fields) {
                throw new Error(`Introspection result missing fields: ${inspect(typeIntrospection)}.`);
            }
            return keyValMap(typeIntrospection.fields, (fieldIntrospection)=>fieldIntrospection.name, buildField);
        }
        function buildField(fieldIntrospection) {
            const type = getType(fieldIntrospection.type);
            if (!isOutputType(type)) {
                const typeStr = inspect(type);
                throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
            }
            if (!fieldIntrospection.args) {
                const fieldIntrospectionStr = inspect(fieldIntrospection);
                throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
            }
            return {
                description: fieldIntrospection.description,
                deprecationReason: fieldIntrospection.deprecationReason,
                type,
                args: buildInputValueDefMap(fieldIntrospection.args)
            };
        }
        function buildInputValueDefMap(inputValueIntrospections) {
            return keyValMap(inputValueIntrospections, (inputValue)=>inputValue.name, buildInputValue);
        }
        function buildInputValue(inputValueIntrospection) {
            const type = getType(inputValueIntrospection.type);
            if (!isInputType(type)) {
                const typeStr = inspect(type);
                throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
            }
            const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;
            return {
                description: inputValueIntrospection.description,
                type,
                defaultValue,
                deprecationReason: inputValueIntrospection.deprecationReason
            };
        }
        function buildDirective(directiveIntrospection) {
            if (!directiveIntrospection.args) {
                const directiveIntrospectionStr = inspect(directiveIntrospection);
                throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
            }
            if (!directiveIntrospection.locations) {
                const directiveIntrospectionStr = inspect(directiveIntrospection);
                throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
            }
            return new GraphQLDirective({
                name: directiveIntrospection.name,
                description: directiveIntrospection.description,
                isRepeatable: directiveIntrospection.isRepeatable,
                locations: directiveIntrospection.locations.slice(),
                args: buildInputValueDefMap(directiveIntrospection.args)
            });
        }
    }
    function extendSchema(schema, documentAST, options) {
        assertSchema(schema);
        (documentAST != null && documentAST.kind === Kind.DOCUMENT) || devAssert(false, 'Must provide valid Document AST.');
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
            assertValidSDLExtension(documentAST, schema);
        }
        const schemaConfig = schema.toConfig();
        const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
        return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
    }
    function extendSchemaImpl(schemaConfig, documentAST, options) {
        var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
        const typeDefs = [];
        const typeExtensionsMap = Object.create(null);
        const directiveDefs = [];
        let schemaDef;
        const schemaExtensions = [];
        for (const def of documentAST.definitions){
            if (def.kind === Kind.SCHEMA_DEFINITION) {
                schemaDef = def;
            } else if (def.kind === Kind.SCHEMA_EXTENSION) {
                schemaExtensions.push(def);
            } else if (isTypeDefinitionNode(def)) {
                typeDefs.push(def);
            } else if (isTypeExtensionNode(def)) {
                const extendedTypeName = def.name.value;
                const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
                typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([
                    def
                ]) : [
                    def
                ];
            } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
                directiveDefs.push(def);
            }
        }
        if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
            return schemaConfig;
        }
        const typeMap = Object.create(null);
        for (const existingType of schemaConfig.types){
            typeMap[existingType.name] = extendNamedType(existingType);
        }
        for (const typeNode of typeDefs){
            var _stdTypeMap$name;
            const name = typeNode.name.value;
            typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
        }
        const operationTypes = {
            query: schemaConfig.query && replaceNamedType(schemaConfig.query),
            mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
            subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
            ...(schemaDef && getOperationTypes([
                schemaDef
            ])),
            ...getOperationTypes(schemaExtensions)
        };
        return {
            description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
            ...operationTypes,
            types: Object.values(typeMap),
            directives: [
                ...schemaConfig.directives.map(replaceDirective),
                ...directiveDefs.map(buildDirective)
            ],
            extensions: Object.create(null),
            astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
            extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
            assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
        };
        function replaceType(type) {
            if (isListType(type)) {
                return new GraphQLList(replaceType(type.ofType));
            }
            if (isNonNullType(type)) {
                return new GraphQLNonNull(replaceType(type.ofType));
            }
            return replaceNamedType(type);
        }
        function replaceNamedType(type) {
            return typeMap[type.name];
        }
        function replaceDirective(directive) {
            const config = directive.toConfig();
            return new GraphQLDirective({
                ...config,
                args: mapValue(config.args, extendArg)
            });
        }
        function extendNamedType(type) {
            if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
                return type;
            }
            if (isScalarType(type)) {
                return extendScalarType(type);
            }
            if (isObjectType(type)) {
                return extendObjectType(type);
            }
            if (isInterfaceType(type)) {
                return extendInterfaceType(type);
            }
            if (isUnionType(type)) {
                return extendUnionType(type);
            }
            if (isEnumType(type)) {
                return extendEnumType(type);
            }
            if (isInputObjectType(type)) {
                return extendInputObjectType(type);
            }
            invariant(false, 'Unexpected type: ' + inspect(type));
        }
        function extendInputObjectType(type) {
            var _typeExtensionsMap$co;
            const config = type.toConfig();
            const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
            return new GraphQLInputObjectType({
                ...config,
                fields: ()=>({
                        ...mapValue(config.fields, (field)=>({
                                ...field,
                                type: replaceType(field.type)
                            })),
                        ...buildInputFieldMap(extensions)
                    }),
                extensionASTNodes: config.extensionASTNodes.concat(extensions)
            });
        }
        function extendEnumType(type) {
            var _typeExtensionsMap$ty;
            const config = type.toConfig();
            const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
            return new GraphQLEnumType({
                ...config,
                values: {
                    ...config.values,
                    ...buildEnumValueMap(extensions)
                },
                extensionASTNodes: config.extensionASTNodes.concat(extensions)
            });
        }
        function extendScalarType(type) {
            var _typeExtensionsMap$co2;
            const config = type.toConfig();
            const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
            let specifiedByURL = config.specifiedByURL;
            for (const extensionNode of extensions){
                var _getSpecifiedByURL;
                specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
            }
            return new GraphQLScalarType({
                ...config,
                specifiedByURL,
                extensionASTNodes: config.extensionASTNodes.concat(extensions)
            });
        }
        function extendObjectType(type) {
            var _typeExtensionsMap$co3;
            const config = type.toConfig();
            const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
            return new GraphQLObjectType({
                ...config,
                interfaces: ()=>[
                        ...type.getInterfaces().map(replaceNamedType),
                        ...buildInterfaces(extensions)
                    ],
                fields: ()=>({
                        ...mapValue(config.fields, extendField),
                        ...buildFieldMap(extensions)
                    }),
                extensionASTNodes: config.extensionASTNodes.concat(extensions)
            });
        }
        function extendInterfaceType(type) {
            var _typeExtensionsMap$co4;
            const config = type.toConfig();
            const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
            return new GraphQLInterfaceType({
                ...config,
                interfaces: ()=>[
                        ...type.getInterfaces().map(replaceNamedType),
                        ...buildInterfaces(extensions)
                    ],
                fields: ()=>({
                        ...mapValue(config.fields, extendField),
                        ...buildFieldMap(extensions)
                    }),
                extensionASTNodes: config.extensionASTNodes.concat(extensions)
            });
        }
        function extendUnionType(type) {
            var _typeExtensionsMap$co5;
            const config = type.toConfig();
            const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
            return new GraphQLUnionType({
                ...config,
                types: ()=>[
                        ...type.getTypes().map(replaceNamedType),
                        ...buildUnionTypes(extensions)
                    ],
                extensionASTNodes: config.extensionASTNodes.concat(extensions)
            });
        }
        function extendField(field) {
            return {
                ...field,
                type: replaceType(field.type),
                args: field.args && mapValue(field.args, extendArg)
            };
        }
        function extendArg(arg) {
            return {
                ...arg,
                type: replaceType(arg.type)
            };
        }
        function getOperationTypes(nodes) {
            const opTypes = {};
            for (const node of nodes){
                var _node$operationTypes;
                const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
                for (const operationType of operationTypesNodes){
                    opTypes[operationType.operation] = getNamedType(operationType.type);
                }
            }
            return opTypes;
        }
        function getNamedType(node) {
            var _stdTypeMap$name2;
            const name = node.name.value;
            const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
            if (type === undefined) {
                throw new Error(`Unknown type: "${name}".`);
            }
            return type;
        }
        function getWrappedType(node) {
            if (node.kind === Kind.LIST_TYPE) {
                return new GraphQLList(getWrappedType(node.type));
            }
            if (node.kind === Kind.NON_NULL_TYPE) {
                return new GraphQLNonNull(getWrappedType(node.type));
            }
            return getNamedType(node);
        }
        function buildDirective(node) {
            var _node$description;
            return new GraphQLDirective({
                name: node.name.value,
                description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
                locations: node.locations.map(({ value })=>value),
                isRepeatable: node.repeatable,
                args: buildArgumentMap(node.arguments),
                astNode: node
            });
        }
        function buildFieldMap(nodes) {
            const fieldConfigMap = Object.create(null);
            for (const node of nodes){
                var _node$fields;
                const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
                for (const field of nodeFields){
                    var _field$description;
                    fieldConfigMap[field.name.value] = {
                        type: getWrappedType(field.type),
                        description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
                        args: buildArgumentMap(field.arguments),
                        deprecationReason: getDeprecationReason(field),
                        astNode: field
                    };
                }
            }
            return fieldConfigMap;
        }
        function buildArgumentMap(args) {
            const argsNodes = args !== null && args !== void 0 ? args : [];
            const argConfigMap = Object.create(null);
            for (const arg of argsNodes){
                var _arg$description;
                const type = getWrappedType(arg.type);
                argConfigMap[arg.name.value] = {
                    type,
                    description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
                    defaultValue: valueFromAST(arg.defaultValue, type),
                    deprecationReason: getDeprecationReason(arg),
                    astNode: arg
                };
            }
            return argConfigMap;
        }
        function buildInputFieldMap(nodes) {
            const inputFieldMap = Object.create(null);
            for (const node of nodes){
                var _node$fields2;
                const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
                for (const field of fieldsNodes){
                    var _field$description2;
                    const type = getWrappedType(field.type);
                    inputFieldMap[field.name.value] = {
                        type,
                        description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
                        defaultValue: valueFromAST(field.defaultValue, type),
                        deprecationReason: getDeprecationReason(field),
                        astNode: field
                    };
                }
            }
            return inputFieldMap;
        }
        function buildEnumValueMap(nodes) {
            const enumValueMap = Object.create(null);
            for (const node of nodes){
                var _node$values;
                const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
                for (const value of valuesNodes){
                    var _value$description;
                    enumValueMap[value.name.value] = {
                        description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
                        deprecationReason: getDeprecationReason(value),
                        astNode: value
                    };
                }
            }
            return enumValueMap;
        }
        function buildInterfaces(nodes) {
            return nodes.flatMap((node)=>{
                var _node$interfaces$map, _node$interfaces;
                return ((_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []);
            });
        }
        function buildUnionTypes(nodes) {
            return nodes.flatMap((node)=>{
                var _node$types$map, _node$types;
                return ((_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType)) !== null && _node$types$map !== void 0 ? _node$types$map : []);
            });
        }
        function buildType(astNode) {
            var _typeExtensionsMap$na;
            const name = astNode.name.value;
            const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
            switch(astNode.kind){
                case Kind.OBJECT_TYPE_DEFINITION:
                    {
                        var _astNode$description;
                        const allNodes = [
                            astNode,
                            ...extensionASTNodes
                        ];
                        return new GraphQLObjectType({
                            name,
                            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
                            interfaces: ()=>buildInterfaces(allNodes),
                            fields: ()=>buildFieldMap(allNodes),
                            astNode,
                            extensionASTNodes
                        });
                    }
                case Kind.INTERFACE_TYPE_DEFINITION:
                    {
                        var _astNode$description2;
                        const allNodes = [
                            astNode,
                            ...extensionASTNodes
                        ];
                        return new GraphQLInterfaceType({
                            name,
                            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
                            interfaces: ()=>buildInterfaces(allNodes),
                            fields: ()=>buildFieldMap(allNodes),
                            astNode,
                            extensionASTNodes
                        });
                    }
                case Kind.ENUM_TYPE_DEFINITION:
                    {
                        var _astNode$description3;
                        const allNodes = [
                            astNode,
                            ...extensionASTNodes
                        ];
                        return new GraphQLEnumType({
                            name,
                            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
                            values: buildEnumValueMap(allNodes),
                            astNode,
                            extensionASTNodes
                        });
                    }
                case Kind.UNION_TYPE_DEFINITION:
                    {
                        var _astNode$description4;
                        const allNodes = [
                            astNode,
                            ...extensionASTNodes
                        ];
                        return new GraphQLUnionType({
                            name,
                            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
                            types: ()=>buildUnionTypes(allNodes),
                            astNode,
                            extensionASTNodes
                        });
                    }
                case Kind.SCALAR_TYPE_DEFINITION:
                    {
                        var _astNode$description5;
                        return new GraphQLScalarType({
                            name,
                            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
                            specifiedByURL: getSpecifiedByURL(astNode),
                            astNode,
                            extensionASTNodes
                        });
                    }
                case Kind.INPUT_OBJECT_TYPE_DEFINITION:
                    {
                        var _astNode$description6;
                        const allNodes = [
                            astNode,
                            ...extensionASTNodes
                        ];
                        return new GraphQLInputObjectType({
                            name,
                            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
                            fields: ()=>buildInputFieldMap(allNodes),
                            astNode,
                            extensionASTNodes,
                            isOneOf: isOneOf(astNode)
                        });
                    }
            }
        }
    }
    const stdTypeMap = keyMap([
        ...specifiedScalarTypes,
        ...introspectionTypes
    ], (type)=>type.name);
    function getDeprecationReason(node) {
        const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
        return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    function getSpecifiedByURL(node) {
        const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
        return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
    function isOneOf(node) {
        return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));
    }
    function buildASTSchema(documentAST, options) {
        (documentAST != null && documentAST.kind === Kind.DOCUMENT) || devAssert(false, 'Must provide valid Document AST.');
        if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
            assertValidSDL(documentAST);
        }
        const emptySchemaConfig = {
            description: undefined,
            types: [],
            directives: [],
            extensions: Object.create(null),
            extensionASTNodes: [],
            assumeValid: false
        };
        const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
        if (config.astNode == null) {
            for (const type of config.types){
                switch(type.name){
                    case 'Query':
                        config.query = type;
                        break;
                    case 'Mutation':
                        config.mutation = type;
                        break;
                    case 'Subscription':
                        config.subscription = type;
                        break;
                }
            }
        }
        const directives = [
            ...config.directives,
            ...specifiedDirectives.filter((stdDirective)=>config.directives.every((directive)=>directive.name !== stdDirective.name))
        ];
        return new GraphQLSchema({
            ...config,
            directives
        });
    }
    function buildSchema(source, options) {
        const document = parse(source, {
            noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
            allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
        });
        return buildASTSchema(document, {
            assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
            assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
        });
    }
    function lexicographicSortSchema(schema) {
        const schemaConfig = schema.toConfig();
        const typeMap = keyValMap(sortByName(schemaConfig.types), (type)=>type.name, sortNamedType);
        return new GraphQLSchema({
            ...schemaConfig,
            types: Object.values(typeMap),
            directives: sortByName(schemaConfig.directives).map(sortDirective),
            query: replaceMaybeType(schemaConfig.query),
            mutation: replaceMaybeType(schemaConfig.mutation),
            subscription: replaceMaybeType(schemaConfig.subscription)
        });
        function replaceType(type) {
            if (isListType(type)) {
                return new GraphQLList(replaceType(type.ofType));
            } else if (isNonNullType(type)) {
                return new GraphQLNonNull(replaceType(type.ofType));
            }
            return replaceNamedType(type);
        }
        function replaceNamedType(type) {
            return typeMap[type.name];
        }
        function replaceMaybeType(maybeType) {
            return maybeType && replaceNamedType(maybeType);
        }
        function sortDirective(directive) {
            const config = directive.toConfig();
            return new GraphQLDirective({
                ...config,
                locations: sortBy(config.locations, (x)=>x),
                args: sortArgs(config.args)
            });
        }
        function sortArgs(args) {
            return sortObjMap(args, (arg)=>({
                    ...arg,
                    type: replaceType(arg.type)
                }));
        }
        function sortFields(fieldsMap) {
            return sortObjMap(fieldsMap, (field)=>({
                    ...field,
                    type: replaceType(field.type),
                    args: field.args && sortArgs(field.args)
                }));
        }
        function sortInputFields(fieldsMap) {
            return sortObjMap(fieldsMap, (field)=>({
                    ...field,
                    type: replaceType(field.type)
                }));
        }
        function sortTypes(array) {
            return sortByName(array).map(replaceNamedType);
        }
        function sortNamedType(type) {
            if (isScalarType(type) || isIntrospectionType(type)) {
                return type;
            }
            if (isObjectType(type)) {
                const config = type.toConfig();
                return new GraphQLObjectType({
                    ...config,
                    interfaces: ()=>sortTypes(config.interfaces),
                    fields: ()=>sortFields(config.fields)
                });
            }
            if (isInterfaceType(type)) {
                const config = type.toConfig();
                return new GraphQLInterfaceType({
                    ...config,
                    interfaces: ()=>sortTypes(config.interfaces),
                    fields: ()=>sortFields(config.fields)
                });
            }
            if (isUnionType(type)) {
                const config = type.toConfig();
                return new GraphQLUnionType({
                    ...config,
                    types: ()=>sortTypes(config.types)
                });
            }
            if (isEnumType(type)) {
                const config = type.toConfig();
                return new GraphQLEnumType({
                    ...config,
                    values: sortObjMap(config.values, (value)=>value)
                });
            }
            if (isInputObjectType(type)) {
                const config = type.toConfig();
                return new GraphQLInputObjectType({
                    ...config,
                    fields: ()=>sortInputFields(config.fields)
                });
            }
            invariant(false, 'Unexpected type: ' + inspect(type));
        }
    }
    function sortObjMap(map, sortValueFn) {
        const sortedMap = Object.create(null);
        for (const key of Object.keys(map).sort(naturalCompare)){
            sortedMap[key] = sortValueFn(map[key]);
        }
        return sortedMap;
    }
    function sortByName(array) {
        return sortBy(array, (obj)=>obj.name);
    }
    function sortBy(array, mapToKey) {
        return array.slice().sort((obj1, obj2)=>{
            const key1 = mapToKey(obj1);
            const key2 = mapToKey(obj2);
            return naturalCompare(key1, key2);
        });
    }
    function printSchema(schema) {
        return printFilteredSchema(schema, (n)=>!isSpecifiedDirective(n), isDefinedType);
    }
    function printIntrospectionSchema(schema) {
        return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
    }
    function isDefinedType(type) {
        return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
    }
    function printFilteredSchema(schema, directiveFilter, typeFilter) {
        const directives = schema.getDirectives().filter(directiveFilter);
        const types = Object.values(schema.getTypeMap()).filter(typeFilter);
        return [
            printSchemaDefinition(schema),
            ...directives.map((directive)=>printDirective(directive)),
            ...types.map((type)=>printType(type))
        ].filter(Boolean).join('\n\n');
    }
    function printSchemaDefinition(schema) {
        if (schema.description == null && isSchemaOfCommonNames(schema)) {
            return;
        }
        const operationTypes = [];
        const queryType = schema.getQueryType();
        if (queryType) {
            operationTypes.push(`  query: ${queryType.name}`);
        }
        const mutationType = schema.getMutationType();
        if (mutationType) {
            operationTypes.push(`  mutation: ${mutationType.name}`);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
            operationTypes.push(`  subscription: ${subscriptionType.name}`);
        }
        return printDescription(schema) + `schema {\n${operationTypes.join('\n')}\n}`;
    }
    function isSchemaOfCommonNames(schema) {
        const queryType = schema.getQueryType();
        if (queryType && queryType.name !== 'Query') {
            return false;
        }
        const mutationType = schema.getMutationType();
        if (mutationType && mutationType.name !== 'Mutation') {
            return false;
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && subscriptionType.name !== 'Subscription') {
            return false;
        }
        return true;
    }
    function printType(type) {
        if (isScalarType(type)) {
            return printScalar(type);
        }
        if (isObjectType(type)) {
            return printObject(type);
        }
        if (isInterfaceType(type)) {
            return printInterface(type);
        }
        if (isUnionType(type)) {
            return printUnion(type);
        }
        if (isEnumType(type)) {
            return printEnum(type);
        }
        if (isInputObjectType(type)) {
            return printInputObject(type);
        }
        invariant(false, 'Unexpected type: ' + inspect(type));
    }
    function printScalar(type) {
        return (printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type));
    }
    function printImplementedInterfaces(type) {
        const interfaces = type.getInterfaces();
        return interfaces.length ? ' implements ' + interfaces.map((i)=>i.name).join(' & ') : '';
    }
    function printObject(type) {
        return (printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type));
    }
    function printInterface(type) {
        return (printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type));
    }
    function printUnion(type) {
        const types = type.getTypes();
        const possibleTypes = types.length ? ' = ' + types.join(' | ') : '';
        return printDescription(type) + 'union ' + type.name + possibleTypes;
    }
    function printEnum(type) {
        const values = type.getValues().map((value, i)=>printDescription(value, '  ', !i) + '  ' + value.name + printDeprecated(value.deprecationReason));
        return printDescription(type) + `enum ${type.name}` + printBlock(values);
    }
    function printInputObject(type) {
        const fields = Object.values(type.getFields()).map((f, i)=>printDescription(f, '  ', !i) + '  ' + printInputValue(f));
        return (printDescription(type) + `input ${type.name}` + (type.isOneOf ? ' @oneOf' : '') + printBlock(fields));
    }
    function printFields(type) {
        const fields = Object.values(type.getFields()).map((f, i)=>printDescription(f, '  ', !i) + '  ' + f.name + printArgs(f.args, '  ') + ': ' + String(f.type) + printDeprecated(f.deprecationReason));
        return printBlock(fields);
    }
    function printBlock(items) {
        return items.length !== 0 ? ' {\n' + items.join('\n') + '\n}' : '';
    }
    function printArgs(args, indentation = '') {
        if (args.length === 0) {
            return '';
        }
        if (args.every((arg)=>!arg.description)) {
            return '(' + args.map(printInputValue).join(', ') + ')';
        }
        return ('(\n' + args.map((arg, i)=>printDescription(arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg)).join('\n') + '\n' + indentation + ')');
    }
    function printInputValue(arg) {
        const defaultAST = astFromValue(arg.defaultValue, arg.type);
        let argDecl = arg.name + ': ' + String(arg.type);
        if (defaultAST) {
            argDecl += ` = ${print$1(defaultAST)}`;
        }
        return argDecl + printDeprecated(arg.deprecationReason);
    }
    function printDirective(directive) {
        return (printDescription(directive) + 'directive @' + directive.name + printArgs(directive.args) + (directive.isRepeatable ? ' repeatable' : '') + ' on ' + directive.locations.join(' | '));
    }
    function printDeprecated(reason) {
        if (reason == null) {
            return '';
        }
        if (reason !== DEFAULT_DEPRECATION_REASON) {
            const astValue = print$1({
                kind: Kind.STRING,
                value: reason
            });
            return ` @deprecated(reason: ${astValue})`;
        }
        return ' @deprecated';
    }
    function printSpecifiedByURL(scalar) {
        if (scalar.specifiedByURL == null) {
            return '';
        }
        const astValue = print$1({
            kind: Kind.STRING,
            value: scalar.specifiedByURL
        });
        return ` @specifiedBy(url: ${astValue})`;
    }
    function printDescription(def, indentation = '', firstInBlock = true) {
        const { description } = def;
        if (description == null) {
            return '';
        }
        const blockString = print$1({
            kind: Kind.STRING,
            value: description,
            block: isPrintableAsBlockString(description)
        });
        const prefix = indentation && !firstInBlock ? '\n' + indentation : indentation;
        return prefix + blockString.replace(/\n/g, '\n' + indentation) + '\n';
    }
    function concatAST(documents) {
        const definitions = [];
        for (const doc of documents){
            definitions.push(...doc.definitions);
        }
        return {
            kind: Kind.DOCUMENT,
            definitions
        };
    }
    function separateOperations(documentAST) {
        const operations = [];
        const depGraph = Object.create(null);
        for (const definitionNode of documentAST.definitions){
            switch(definitionNode.kind){
                case Kind.OPERATION_DEFINITION:
                    operations.push(definitionNode);
                    break;
                case Kind.FRAGMENT_DEFINITION:
                    depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
                    break;
            }
        }
        const separatedDocumentASTs = Object.create(null);
        for (const operation of operations){
            const dependencies = new Set();
            for (const fragmentName of collectDependencies(operation.selectionSet)){
                collectTransitiveDependencies(dependencies, depGraph, fragmentName);
            }
            const operationName = operation.name ? operation.name.value : '';
            separatedDocumentASTs[operationName] = {
                kind: Kind.DOCUMENT,
                definitions: documentAST.definitions.filter((node)=>node === operation || (node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)))
            };
        }
        return separatedDocumentASTs;
    }
    function collectTransitiveDependencies(collected, depGraph, fromName) {
        if (!collected.has(fromName)) {
            collected.add(fromName);
            const immediateDeps = depGraph[fromName];
            if (immediateDeps !== undefined) {
                for (const toName of immediateDeps){
                    collectTransitiveDependencies(collected, depGraph, toName);
                }
            }
        }
    }
    function collectDependencies(selectionSet) {
        const dependencies = [];
        visit(selectionSet, {
            FragmentSpread (node) {
                dependencies.push(node.name.value);
            }
        });
        return dependencies;
    }
    function stripIgnoredCharacters(source) {
        const sourceObj = isSource(source) ? source : new Source(source);
        const body = sourceObj.body;
        const lexer = new Lexer(sourceObj);
        let strippedBody = '';
        let wasLastAddedTokenNonPunctuator = false;
        while(lexer.advance().kind !== TokenKind.EOF){
            const currentToken = lexer.token;
            const tokenKind = currentToken.kind;
            const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
            if (wasLastAddedTokenNonPunctuator) {
                if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
                    strippedBody += ' ';
                }
            }
            const tokenBody = body.slice(currentToken.start, currentToken.end);
            if (tokenKind === TokenKind.BLOCK_STRING) {
                strippedBody += printBlockString(currentToken.value, {
                    minimize: true
                });
            } else {
                strippedBody += tokenBody;
            }
            wasLastAddedTokenNonPunctuator = isNonPunctuator;
        }
        return strippedBody;
    }
    function assertValidName(name) {
        const error = isValidNameError(name);
        if (error) {
            throw error;
        }
        return name;
    }
    function isValidNameError(name) {
        typeof name === 'string' || devAssert(false, 'Expected name to be a string.');
        if (name.startsWith('__')) {
            return new GraphQLError(`Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`);
        }
        try {
            assertName(name);
        } catch (error) {
            return error;
        }
    }
    var BreakingChangeType;
    (function(BreakingChangeType) {
        BreakingChangeType['TYPE_REMOVED'] = 'TYPE_REMOVED';
        BreakingChangeType['TYPE_CHANGED_KIND'] = 'TYPE_CHANGED_KIND';
        BreakingChangeType['TYPE_REMOVED_FROM_UNION'] = 'TYPE_REMOVED_FROM_UNION';
        BreakingChangeType['VALUE_REMOVED_FROM_ENUM'] = 'VALUE_REMOVED_FROM_ENUM';
        BreakingChangeType['REQUIRED_INPUT_FIELD_ADDED'] = 'REQUIRED_INPUT_FIELD_ADDED';
        BreakingChangeType['IMPLEMENTED_INTERFACE_REMOVED'] = 'IMPLEMENTED_INTERFACE_REMOVED';
        BreakingChangeType['FIELD_REMOVED'] = 'FIELD_REMOVED';
        BreakingChangeType['FIELD_CHANGED_KIND'] = 'FIELD_CHANGED_KIND';
        BreakingChangeType['REQUIRED_ARG_ADDED'] = 'REQUIRED_ARG_ADDED';
        BreakingChangeType['ARG_REMOVED'] = 'ARG_REMOVED';
        BreakingChangeType['ARG_CHANGED_KIND'] = 'ARG_CHANGED_KIND';
        BreakingChangeType['DIRECTIVE_REMOVED'] = 'DIRECTIVE_REMOVED';
        BreakingChangeType['DIRECTIVE_ARG_REMOVED'] = 'DIRECTIVE_ARG_REMOVED';
        BreakingChangeType['REQUIRED_DIRECTIVE_ARG_ADDED'] = 'REQUIRED_DIRECTIVE_ARG_ADDED';
        BreakingChangeType['DIRECTIVE_REPEATABLE_REMOVED'] = 'DIRECTIVE_REPEATABLE_REMOVED';
        BreakingChangeType['DIRECTIVE_LOCATION_REMOVED'] = 'DIRECTIVE_LOCATION_REMOVED';
    })(BreakingChangeType || (BreakingChangeType = {}));
    var DangerousChangeType;
    (function(DangerousChangeType) {
        DangerousChangeType['VALUE_ADDED_TO_ENUM'] = 'VALUE_ADDED_TO_ENUM';
        DangerousChangeType['TYPE_ADDED_TO_UNION'] = 'TYPE_ADDED_TO_UNION';
        DangerousChangeType['OPTIONAL_INPUT_FIELD_ADDED'] = 'OPTIONAL_INPUT_FIELD_ADDED';
        DangerousChangeType['OPTIONAL_ARG_ADDED'] = 'OPTIONAL_ARG_ADDED';
        DangerousChangeType['IMPLEMENTED_INTERFACE_ADDED'] = 'IMPLEMENTED_INTERFACE_ADDED';
        DangerousChangeType['ARG_DEFAULT_VALUE_CHANGE'] = 'ARG_DEFAULT_VALUE_CHANGE';
    })(DangerousChangeType || (DangerousChangeType = {}));
    function findBreakingChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter((change)=>change.type in BreakingChangeType);
    }
    function findDangerousChanges(oldSchema, newSchema) {
        return findSchemaChanges(oldSchema, newSchema).filter((change)=>change.type in DangerousChangeType);
    }
    function findSchemaChanges(oldSchema, newSchema) {
        return [
            ...findTypeChanges(oldSchema, newSchema),
            ...findDirectiveChanges(oldSchema, newSchema)
        ];
    }
    function findDirectiveChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
        for (const oldDirective of directivesDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.DIRECTIVE_REMOVED,
                description: `${oldDirective.name} was removed.`
            });
        }
        for (const [oldDirective, newDirective] of directivesDiff.persisted){
            const argsDiff = diff(oldDirective.args, newDirective.args);
            for (const newArg of argsDiff.added){
                if (isRequiredArgument(newArg)) {
                    schemaChanges.push({
                        type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
                        description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
                    });
                }
            }
            for (const oldArg of argsDiff.removed){
                schemaChanges.push({
                    type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
                    description: `${oldArg.name} was removed from ${oldDirective.name}.`
                });
            }
            if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
                schemaChanges.push({
                    type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
                    description: `Repeatable flag was removed from ${oldDirective.name}.`
                });
            }
            for (const location of oldDirective.locations){
                if (!newDirective.locations.includes(location)) {
                    schemaChanges.push({
                        type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
                        description: `${location} was removed from ${oldDirective.name}.`
                    });
                }
            }
        }
        return schemaChanges;
    }
    function findTypeChanges(oldSchema, newSchema) {
        const schemaChanges = [];
        const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
        for (const oldType of typesDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.TYPE_REMOVED,
                description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
            });
        }
        for (const [oldType, newType] of typesDiff.persisted){
            if (isEnumType(oldType) && isEnumType(newType)) {
                schemaChanges.push(...findEnumTypeChanges(oldType, newType));
            } else if (isUnionType(oldType) && isUnionType(newType)) {
                schemaChanges.push(...findUnionTypeChanges(oldType, newType));
            } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
                schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
            } else if (isObjectType(oldType) && isObjectType(newType)) {
                schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
            } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
                schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
            } else if (oldType.constructor !== newType.constructor) {
                schemaChanges.push({
                    type: BreakingChangeType.TYPE_CHANGED_KIND,
                    description: `${oldType.name} changed from ` + `${typeKindName(oldType)} to ${typeKindName(newType)}.`
                });
            }
        }
        return schemaChanges;
    }
    function findInputObjectTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
        for (const newField of fieldsDiff.added){
            if (isRequiredInputField(newField)) {
                schemaChanges.push({
                    type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
                    description: `A required field ${newField.name} on input type ${oldType.name} was added.`
                });
            } else {
                schemaChanges.push({
                    type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
                    description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
                });
            }
        }
        for (const oldField of fieldsDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.FIELD_REMOVED,
                description: `${oldType.name}.${oldField.name} was removed.`
            });
        }
        for (const [oldField, newField] of fieldsDiff.persisted){
            const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
            if (!isSafe) {
                schemaChanges.push({
                    type: BreakingChangeType.FIELD_CHANGED_KIND,
                    description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
                });
            }
        }
        return schemaChanges;
    }
    function findUnionTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
        for (const newPossibleType of possibleTypesDiff.added){
            schemaChanges.push({
                type: DangerousChangeType.TYPE_ADDED_TO_UNION,
                description: `${newPossibleType.name} was added to union type ${oldType.name}.`
            });
        }
        for (const oldPossibleType of possibleTypesDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
                description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
            });
        }
        return schemaChanges;
    }
    function findEnumTypeChanges(oldType, newType) {
        const schemaChanges = [];
        const valuesDiff = diff(oldType.getValues(), newType.getValues());
        for (const newValue of valuesDiff.added){
            schemaChanges.push({
                type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
                description: `${newValue.name} was added to enum type ${oldType.name}.`
            });
        }
        for (const oldValue of valuesDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
                description: `${oldValue.name} was removed from enum type ${oldType.name}.`
            });
        }
        return schemaChanges;
    }
    function findImplementedInterfacesChanges(oldType, newType) {
        const schemaChanges = [];
        const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
        for (const newInterface of interfacesDiff.added){
            schemaChanges.push({
                type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
                description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
            });
        }
        for (const oldInterface of interfacesDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
                description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
            });
        }
        return schemaChanges;
    }
    function findFieldChanges(oldType, newType) {
        const schemaChanges = [];
        const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
        for (const oldField of fieldsDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.FIELD_REMOVED,
                description: `${oldType.name}.${oldField.name} was removed.`
            });
        }
        for (const [oldField, newField] of fieldsDiff.persisted){
            schemaChanges.push(...findArgChanges(oldType, oldField, newField));
            const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
            if (!isSafe) {
                schemaChanges.push({
                    type: BreakingChangeType.FIELD_CHANGED_KIND,
                    description: `${oldType.name}.${oldField.name} changed type from ` + `${String(oldField.type)} to ${String(newField.type)}.`
                });
            }
        }
        return schemaChanges;
    }
    function findArgChanges(oldType, oldField, newField) {
        const schemaChanges = [];
        const argsDiff = diff(oldField.args, newField.args);
        for (const oldArg of argsDiff.removed){
            schemaChanges.push({
                type: BreakingChangeType.ARG_REMOVED,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
            });
        }
        for (const [oldArg, newArg] of argsDiff.persisted){
            const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
            if (!isSafe) {
                schemaChanges.push({
                    type: BreakingChangeType.ARG_CHANGED_KIND,
                    description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ` + `${String(oldArg.type)} to ${String(newArg.type)}.`
                });
            } else if (oldArg.defaultValue !== undefined) {
                if (newArg.defaultValue === undefined) {
                    schemaChanges.push({
                        type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
                    });
                } else {
                    const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
                    const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
                    if (oldValueStr !== newValueStr) {
                        schemaChanges.push({
                            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
                        });
                    }
                }
            }
        }
        for (const newArg of argsDiff.added){
            if (isRequiredArgument(newArg)) {
                schemaChanges.push({
                    type: BreakingChangeType.REQUIRED_ARG_ADDED,
                    description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
                });
            } else {
                schemaChanges.push({
                    type: DangerousChangeType.OPTIONAL_ARG_ADDED,
                    description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
                });
            }
        }
        return schemaChanges;
    }
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
        if (isListType(oldType)) {
            return ((isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType)) || (isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)));
        }
        if (isNonNullType(oldType)) {
            return (isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType));
        }
        return ((isNamedType(newType) && oldType.name === newType.name) || (isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)));
    }
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
        if (isListType(oldType)) {
            return (isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType));
        }
        if (isNonNullType(oldType)) {
            return ((isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType)) || (!isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)));
        }
        return isNamedType(newType) && oldType.name === newType.name;
    }
    function typeKindName(type) {
        if (isScalarType(type)) {
            return 'a Scalar type';
        }
        if (isObjectType(type)) {
            return 'an Object type';
        }
        if (isInterfaceType(type)) {
            return 'an Interface type';
        }
        if (isUnionType(type)) {
            return 'a Union type';
        }
        if (isEnumType(type)) {
            return 'an Enum type';
        }
        if (isInputObjectType(type)) {
            return 'an Input type';
        }
        invariant(false, 'Unexpected type: ' + inspect(type));
    }
    function stringifyValue(value, type) {
        const ast = astFromValue(value, type);
        ast != null || invariant(false);
        return print$1(sortValueNode(ast));
    }
    function diff(oldArray, newArray) {
        const added = [];
        const removed = [];
        const persisted = [];
        const oldMap = keyMap(oldArray, ({ name })=>name);
        const newMap = keyMap(newArray, ({ name })=>name);
        for (const oldItem of oldArray){
            const newItem = newMap[oldItem.name];
            if (newItem === undefined) {
                removed.push(oldItem);
            } else {
                persisted.push([
                    oldItem,
                    newItem
                ]);
            }
        }
        for (const newItem of newArray){
            if (oldMap[newItem.name] === undefined) {
                added.push(newItem);
            }
        }
        return {
            added,
            persisted,
            removed
        };
    }
    const graphql = Object.freeze(Object.defineProperty({
        __proto__: null,
        BREAK,
        get BreakingChangeType () {
            return BreakingChangeType;
        },
        DEFAULT_DEPRECATION_REASON,
        get DangerousChangeType () {
            return DangerousChangeType;
        },
        get DirectiveLocation () {
            return DirectiveLocation;
        },
        ExecutableDefinitionsRule,
        FieldsOnCorrectTypeRule,
        FragmentsOnCompositeTypesRule,
        GRAPHQL_MAX_INT,
        GRAPHQL_MIN_INT,
        GraphQLBoolean,
        GraphQLDeprecatedDirective,
        GraphQLDirective,
        GraphQLEnumType,
        GraphQLError,
        GraphQLFloat,
        GraphQLID,
        GraphQLIncludeDirective,
        GraphQLInputObjectType,
        GraphQLInt,
        GraphQLInterfaceType,
        GraphQLList,
        GraphQLNonNull,
        GraphQLObjectType,
        GraphQLOneOfDirective,
        GraphQLScalarType,
        GraphQLSchema,
        GraphQLSkipDirective,
        GraphQLSpecifiedByDirective,
        GraphQLString,
        GraphQLUnionType,
        get Kind () {
            return Kind;
        },
        KnownArgumentNamesRule,
        KnownDirectivesRule,
        KnownFragmentNamesRule,
        KnownTypeNamesRule,
        Lexer,
        Location,
        LoneAnonymousOperationRule,
        LoneSchemaDefinitionRule,
        MaxIntrospectionDepthRule,
        NoDeprecatedCustomRule,
        NoFragmentCyclesRule,
        NoSchemaIntrospectionCustomRule,
        NoUndefinedVariablesRule,
        NoUnusedFragmentsRule,
        NoUnusedVariablesRule,
        get OperationTypeNode () {
            return OperationTypeNode;
        },
        OverlappingFieldsCanBeMergedRule,
        PossibleFragmentSpreadsRule,
        PossibleTypeExtensionsRule,
        ProvidedRequiredArgumentsRule,
        ScalarLeafsRule,
        SchemaMetaFieldDef,
        SingleFieldSubscriptionsRule,
        Source,
        Token,
        get TokenKind () {
            return TokenKind;
        },
        TypeInfo,
        get TypeKind () {
            return TypeKind;
        },
        TypeMetaFieldDef,
        TypeNameMetaFieldDef,
        UniqueArgumentDefinitionNamesRule,
        UniqueArgumentNamesRule,
        UniqueDirectiveNamesRule,
        UniqueDirectivesPerLocationRule,
        UniqueEnumValueNamesRule,
        UniqueFieldDefinitionNamesRule,
        UniqueFragmentNamesRule,
        UniqueInputFieldNamesRule,
        UniqueOperationNamesRule,
        UniqueOperationTypesRule,
        UniqueTypeNamesRule,
        UniqueVariableNamesRule,
        ValidationContext,
        ValuesOfCorrectTypeRule,
        VariablesAreInputTypesRule,
        VariablesInAllowedPositionRule,
        __Directive,
        __DirectiveLocation,
        __EnumValue,
        __Field,
        __InputValue,
        __Schema,
        __Type,
        __TypeKind,
        assertAbstractType,
        assertCompositeType,
        assertDirective,
        assertEnumType,
        assertEnumValueName,
        assertInputObjectType,
        assertInputType,
        assertInterfaceType,
        assertLeafType,
        assertListType,
        assertName,
        assertNamedType,
        assertNonNullType,
        assertNullableType,
        assertObjectType,
        assertOutputType,
        assertScalarType,
        assertSchema,
        assertType,
        assertUnionType,
        assertValidName,
        assertValidSchema,
        assertWrappingType,
        astFromValue,
        buildASTSchema,
        buildClientSchema,
        buildSchema,
        coerceInputValue,
        concatAST,
        createSourceEventStream,
        defaultFieldResolver,
        defaultTypeResolver,
        doTypesOverlap,
        execute: execute$1,
        executeSync,
        extendSchema,
        findBreakingChanges,
        findDangerousChanges,
        formatError,
        getArgumentValues,
        getDirectiveValues,
        getEnterLeaveForKind,
        getIntrospectionQuery,
        getLocation,
        getNamedType,
        getNullableType,
        getOperationAST,
        getOperationRootType,
        getVariableValues,
        getVisitFn,
        graphql: graphql$1,
        graphqlSync,
        introspectionFromSchema,
        introspectionTypes,
        isAbstractType,
        isCompositeType,
        isConstValueNode,
        isDefinitionNode,
        isDirective,
        isEnumType,
        isEqualType,
        isExecutableDefinitionNode,
        isInputObjectType,
        isInputType,
        isInterfaceType,
        isIntrospectionType,
        isLeafType,
        isListType,
        isNamedType,
        isNonNullType,
        isNullableType,
        isObjectType,
        isOutputType,
        isRequiredArgument,
        isRequiredInputField,
        isScalarType,
        isSchema,
        isSelectionNode,
        isSpecifiedDirective,
        isSpecifiedScalarType,
        isType,
        isTypeDefinitionNode,
        isTypeExtensionNode,
        isTypeNode,
        isTypeSubTypeOf,
        isTypeSystemDefinitionNode,
        isTypeSystemExtensionNode,
        isUnionType,
        isValidNameError,
        isValueNode,
        isWrappingType,
        lexicographicSortSchema,
        locatedError,
        parse,
        parseConstValue,
        parseType,
        parseValue,
        print: print$1,
        printError,
        printIntrospectionSchema,
        printLocation,
        printSchema,
        printSourceLocation,
        printType,
        recommendedRules,
        resolveObjMapThunk,
        resolveReadonlyArrayThunk,
        responsePathAsArray: pathToArray,
        separateOperations,
        specifiedDirectives,
        specifiedRules,
        specifiedScalarTypes,
        stripIgnoredCharacters,
        subscribe,
        syntaxError,
        typeFromAST,
        validate,
        validateSchema,
        valueFromAST,
        valueFromASTUntyped,
        version,
        versionInfo,
        visit,
        visitInParallel,
        visitWithTypeInfo
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    function shouldInclude(_a, variables) {
        var directives = _a.directives;
        if (!directives || !directives.length) {
            return true;
        }
        return getInclusionDirectives(directives).every(function(_a) {
            var directive = _a.directive, ifArgument = _a.ifArgument;
            var evaledValue = false;
            if (ifArgument.value.kind === "Variable") {
                evaledValue = variables && variables[ifArgument.value.name.value];
                invariant$1(evaledValue !== void 0, 106, directive.name.value);
            } else {
                evaledValue = ifArgument.value.value;
            }
            return directive.name.value === "skip" ? !evaledValue : evaledValue;
        });
    }
    function getDirectiveNames(root) {
        var names = [];
        visit(root, {
            Directive: function(node) {
                names.push(node.name.value);
            }
        });
        return names;
    }
    var hasAnyDirectives = function(names, root) {
        return hasDirectives(names, root, false);
    };
    var hasAllDirectives = function(names, root) {
        return hasDirectives(names, root, true);
    };
    function hasDirectives(names, root, all) {
        var nameSet = new Set(names);
        var uniqueCount = nameSet.size;
        visit(root, {
            Directive: function(node) {
                if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
                    return BREAK;
                }
            }
        });
        return all ? !nameSet.size : nameSet.size < uniqueCount;
    }
    function hasClientExports(document) {
        return document && hasDirectives([
            "client",
            "export"
        ], document, true);
    }
    function isInclusionDirective(_a) {
        var value = _a.name.value;
        return value === "skip" || value === "include";
    }
    function getInclusionDirectives(directives) {
        var result = [];
        if (directives && directives.length) {
            directives.forEach(function(directive) {
                if (!isInclusionDirective(directive)) return;
                var directiveArguments = directive.arguments;
                var directiveName = directive.name.value;
                invariant$1(directiveArguments && directiveArguments.length === 1, 107, directiveName);
                var ifArgument = directiveArguments[0];
                invariant$1(ifArgument.name && ifArgument.name.value === "if", 108, directiveName);
                var ifValue = ifArgument.value;
                invariant$1(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 109, directiveName);
                result.push({
                    directive: directive,
                    ifArgument: ifArgument
                });
            });
        }
        return result;
    }
    function getFragmentMaskMode(fragment) {
        var _a, _b;
        var directive = (_a = fragment.directives) === null || _a === void 0 ? void 0 : _a.find(function(_a) {
            var name = _a.name;
            return name.value === "unmask";
        });
        if (!directive) {
            return "mask";
        }
        var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function(_a) {
            var name = _a.name;
            return name.value === "mode";
        });
        if (globalThis.__DEV__ !== false) {
            if (modeArg) {
                if (modeArg.value.kind === Kind.VARIABLE) {
                    globalThis.__DEV__ !== false && invariant$1.warn(110);
                } else if (modeArg.value.kind !== Kind.STRING) {
                    globalThis.__DEV__ !== false && invariant$1.warn(111);
                } else if (modeArg.value.value !== "migrate") {
                    globalThis.__DEV__ !== false && invariant$1.warn(112, modeArg.value.value);
                }
            }
        }
        if (modeArg && "value" in modeArg.value && modeArg.value.value === "migrate") {
            return "migrate";
        }
        return "unmask";
    }
    const defaultMakeData = ()=>Object.create(null);
    const { forEach, slice } = Array.prototype;
    const { hasOwnProperty: hasOwnProperty$4 } = Object.prototype;
    class Trie {
        constructor(weakness = true, makeData = defaultMakeData){
            this.weakness = weakness;
            this.makeData = makeData;
        }
        lookup() {
            return this.lookupArray(arguments);
        }
        lookupArray(array) {
            let node = this;
            forEach.call(array, (key)=>node = node.getChildTrie(key));
            return hasOwnProperty$4.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
        }
        peek() {
            return this.peekArray(arguments);
        }
        peekArray(array) {
            let node = this;
            for(let i = 0, len = array.length; node && i < len; ++i){
                const map = node.mapFor(array[i], false);
                node = map && map.get(array[i]);
            }
            return node && node.data;
        }
        remove() {
            return this.removeArray(arguments);
        }
        removeArray(array) {
            let data;
            if (array.length) {
                const head = array[0];
                const map = this.mapFor(head, false);
                const child = map && map.get(head);
                if (child) {
                    data = child.removeArray(slice.call(array, 1));
                    if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
                        map.delete(head);
                    }
                }
            } else {
                data = this.data;
                delete this.data;
            }
            return data;
        }
        getChildTrie(key) {
            const map = this.mapFor(key, true);
            let child = map.get(key);
            if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));
            return child;
        }
        mapFor(key, create) {
            return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = new WeakMap : void 0) : this.strong || (create ? this.strong = new Map : void 0);
        }
    }
    function isObjRef(value) {
        switch(typeof value){
            case "object":
                if (value === null) break;
            case "function":
                return true;
        }
        return false;
    }
    const lib$4 = Object.freeze(Object.defineProperty({
        __proto__: null,
        Trie
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    var isReactNative = maybe$1(function() {
        return navigator.product;
    }) == "ReactNative";
    var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !global.HermesInternal);
    var canUseWeakSet = typeof WeakSet === "function";
    var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
    var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
    var canUseDOM = typeof maybe$1(function() {
        return window.document.createElement;
    }) === "function";
    var usingJSDOM = maybe$1(function() {
        return navigator.userAgent.indexOf("jsdom") >= 0;
    }) || false;
    var canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;
    function isNonNullObject(obj) {
        return obj !== null && typeof obj === "object";
    }
    function isPlainObject(obj) {
        return (obj !== null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null));
    }
    function getFragmentQueryDocument(document, fragmentName) {
        var actualFragmentName = fragmentName;
        var fragments = [];
        document.definitions.forEach(function(definition) {
            if (definition.kind === "OperationDefinition") {
                throw newInvariantError(113, definition.operation, definition.name ? " named '".concat(definition.name.value, "'") : "");
            }
            if (definition.kind === "FragmentDefinition") {
                fragments.push(definition);
            }
        });
        if (typeof actualFragmentName === "undefined") {
            invariant$1(fragments.length === 1, 114, fragments.length);
            actualFragmentName = fragments[0].name.value;
        }
        var query = __assign(__assign({}, document), {
            definitions: __spreadArray([
                {
                    kind: "OperationDefinition",
                    operation: "query",
                    selectionSet: {
                        kind: "SelectionSet",
                        selections: [
                            {
                                kind: "FragmentSpread",
                                name: {
                                    kind: "Name",
                                    value: actualFragmentName
                                }
                            }
                        ]
                    }
                }
            ], document.definitions, true)
        });
        return query;
    }
    function createFragmentMap(fragments) {
        if (fragments === void 0) {
            fragments = [];
        }
        var symTable = {};
        fragments.forEach(function(fragment) {
            symTable[fragment.name.value] = fragment;
        });
        return symTable;
    }
    function getFragmentFromSelection(selection, fragmentMap) {
        switch(selection.kind){
            case "InlineFragment":
                return selection;
            case "FragmentSpread":
                {
                    var fragmentName = selection.name.value;
                    if (typeof fragmentMap === "function") {
                        return fragmentMap(fragmentName);
                    }
                    var fragment = fragmentMap && fragmentMap[fragmentName];
                    invariant$1(fragment, 115, fragmentName);
                    return fragment || null;
                }
            default:
                return null;
        }
    }
    function isFullyUnmaskedOperation(document) {
        var isUnmasked = true;
        visit(document, {
            FragmentSpread: function(node) {
                isUnmasked = !!node.directives && node.directives.some(function(directive) {
                    return directive.name.value === "unmask";
                });
                if (!isUnmasked) {
                    return BREAK;
                }
            }
        });
        return isUnmasked;
    }
    function defaultDispose$1() {}
    class StrongCache {
        constructor(max = Infinity, dispose = defaultDispose$1){
            this.max = max;
            this.dispose = dispose;
            this.map = new Map();
            this.newest = null;
            this.oldest = null;
        }
        has(key) {
            return this.map.has(key);
        }
        get(key) {
            const node = this.getNode(key);
            return node && node.value;
        }
        get size() {
            return this.map.size;
        }
        getNode(key) {
            const node = this.map.get(key);
            if (node && node !== this.newest) {
                const { older, newer } = node;
                if (newer) {
                    newer.older = older;
                }
                if (older) {
                    older.newer = newer;
                }
                node.older = this.newest;
                node.older.newer = node;
                node.newer = null;
                this.newest = node;
                if (node === this.oldest) {
                    this.oldest = newer;
                }
            }
            return node;
        }
        set(key, value) {
            let node = this.getNode(key);
            if (node) {
                return node.value = value;
            }
            node = {
                key,
                value,
                newer: null,
                older: this.newest
            };
            if (this.newest) {
                this.newest.newer = node;
            }
            this.newest = node;
            this.oldest = this.oldest || node;
            this.map.set(key, node);
            return node.value;
        }
        clean() {
            while(this.oldest && this.map.size > this.max){
                this.delete(this.oldest.key);
            }
        }
        delete(key) {
            const node = this.map.get(key);
            if (node) {
                if (node === this.newest) {
                    this.newest = node.older;
                }
                if (node === this.oldest) {
                    this.oldest = node.newer;
                }
                if (node.newer) {
                    node.newer.older = node.older;
                }
                if (node.older) {
                    node.older.newer = node.newer;
                }
                this.map.delete(key);
                this.dispose(node.value, key);
                return true;
            }
            return false;
        }
    }
    function noop() {}
    const defaultDispose = noop;
    const _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
        return {
            deref: ()=>value
        };
    };
    const _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
    const _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
        return {
            register: noop,
            unregister: noop
        };
    };
    const finalizationBatchSize = 10024;
    class WeakCache {
        constructor(max = Infinity, dispose = defaultDispose){
            this.max = max;
            this.dispose = dispose;
            this.map = new _WeakMap();
            this.newest = null;
            this.oldest = null;
            this.unfinalizedNodes = new Set();
            this.finalizationScheduled = false;
            this.size = 0;
            this.finalize = ()=>{
                const iterator = this.unfinalizedNodes.values();
                for(let i = 0; i < finalizationBatchSize; i++){
                    const node = iterator.next().value;
                    if (!node) break;
                    this.unfinalizedNodes.delete(node);
                    const key = node.key;
                    delete node.key;
                    node.keyRef = new _WeakRef(key);
                    this.registry.register(key, node, node);
                }
                if (this.unfinalizedNodes.size > 0) {
                    queueMicrotask(this.finalize);
                } else {
                    this.finalizationScheduled = false;
                }
            };
            this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
        }
        has(key) {
            return this.map.has(key);
        }
        get(key) {
            const node = this.getNode(key);
            return node && node.value;
        }
        getNode(key) {
            const node = this.map.get(key);
            if (node && node !== this.newest) {
                const { older, newer } = node;
                if (newer) {
                    newer.older = older;
                }
                if (older) {
                    older.newer = newer;
                }
                node.older = this.newest;
                node.older.newer = node;
                node.newer = null;
                this.newest = node;
                if (node === this.oldest) {
                    this.oldest = newer;
                }
            }
            return node;
        }
        set(key, value) {
            let node = this.getNode(key);
            if (node) {
                return (node.value = value);
            }
            node = {
                key,
                value,
                newer: null,
                older: this.newest
            };
            if (this.newest) {
                this.newest.newer = node;
            }
            this.newest = node;
            this.oldest = this.oldest || node;
            this.scheduleFinalization(node);
            this.map.set(key, node);
            this.size++;
            return node.value;
        }
        clean() {
            while(this.oldest && this.size > this.max){
                this.deleteNode(this.oldest);
            }
        }
        deleteNode(node) {
            if (node === this.newest) {
                this.newest = node.older;
            }
            if (node === this.oldest) {
                this.oldest = node.newer;
            }
            if (node.newer) {
                node.newer.older = node.older;
            }
            if (node.older) {
                node.older.newer = node.newer;
            }
            this.size--;
            const key = node.key || (node.keyRef && node.keyRef.deref());
            this.dispose(node.value, key);
            if (!node.keyRef) {
                this.unfinalizedNodes.delete(node);
            } else {
                this.registry.unregister(node);
            }
            if (key) this.map.delete(key);
        }
        delete(key) {
            const node = this.map.get(key);
            if (node) {
                this.deleteNode(node);
                return true;
            }
            return false;
        }
        scheduleFinalization(node) {
            this.unfinalizedNodes.add(node);
            if (!this.finalizationScheduled) {
                this.finalizationScheduled = true;
                queueMicrotask(this.finalize);
            }
        }
    }
    const lib$3 = Object.freeze(Object.defineProperty({
        __proto__: null,
        StrongCache,
        WeakCache
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    var scheduledCleanup = new WeakSet();
    function schedule(cache) {
        if (cache.size <= (cache.max || -1)) {
            return;
        }
        if (!scheduledCleanup.has(cache)) {
            scheduledCleanup.add(cache);
            setTimeout(function() {
                cache.clean();
                scheduledCleanup.delete(cache);
            }, 100);
        }
    }
    var AutoCleanedWeakCache = function(max, dispose) {
        var cache = new WeakCache(max, dispose);
        cache.set = function(key, value) {
            var ret = WeakCache.prototype.set.call(this, key, value);
            schedule(this);
            return ret;
        };
        return cache;
    };
    var AutoCleanedStrongCache = function(max, dispose) {
        var cache = new StrongCache(max, dispose);
        cache.set = function(key, value) {
            var ret = StrongCache.prototype.set.call(this, key, value);
            schedule(this);
            return ret;
        };
        return cache;
    };
    var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
    var cacheSizes = __assign({}, untypedGlobal[cacheSizeSymbol]);
    var globalCaches = {};
    function registerGlobalCache(name, getSize) {
        globalCaches[name] = getSize;
    }
    var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : undefined;
    var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : undefined;
    function _getApolloCacheMemoryInternals() {
        return {
            cache: {
                fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
            }
        };
    }
    function _getInMemoryCacheMemoryInternals() {
        var fragments = this.config.fragments;
        return __assign(__assign({}, _getApolloCacheMemoryInternals.apply(this)), {
            addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]),
            inMemoryCache: {
                executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
                executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
                maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
            },
            fragmentRegistry: {
                findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
                lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
                transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
            }
        });
    }
    function isWrapper(f) {
        return !!f && "dirtyKey" in f;
    }
    function getWrapperInformation(f) {
        return isWrapper(f) ? f.size : undefined;
    }
    function isDefined(value) {
        return value != null;
    }
    function transformInfo(transform) {
        return recurseTransformInfo(transform).map(function(cache) {
            return ({
                cache: cache
            });
        });
    }
    function recurseTransformInfo(transform) {
        return transform ? __spreadArray(__spreadArray([
            getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
        ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined) : [];
    }
    var canonicalStringify = Object.assign(function canonicalStringify(value) {
        return JSON.stringify(value, stableObjectReplacer);
    }, {
        reset: function() {
            sortingMap = new AutoCleanedStrongCache(cacheSizes.canonicalStringify || 1000);
        }
    });
    if (globalThis.__DEV__ !== false) {
        registerGlobalCache("canonicalStringify", function() {
            return sortingMap.size;
        });
    }
    var sortingMap;
    canonicalStringify.reset();
    function stableObjectReplacer(key, value) {
        if (value && typeof value === "object") {
            var proto = Object.getPrototypeOf(value);
            if (proto === Object.prototype || proto === null) {
                var keys = Object.keys(value);
                if (keys.every(everyKeyInOrder)) return value;
                var unsortedKey = JSON.stringify(keys);
                var sortedKeys = sortingMap.get(unsortedKey);
                if (!sortedKeys) {
                    keys.sort();
                    var sortedKey = JSON.stringify(keys);
                    sortedKeys = sortingMap.get(sortedKey) || keys;
                    sortingMap.set(unsortedKey, sortedKeys);
                    sortingMap.set(sortedKey, sortedKeys);
                }
                var sortedObject_1 = Object.create(proto);
                sortedKeys.forEach(function(key) {
                    sortedObject_1[key] = value[key];
                });
                return sortedObject_1;
            }
        }
        return value;
    }
    function everyKeyInOrder(key, i, keys) {
        return i === 0 || keys[i - 1] <= key;
    }
    function makeReference(id) {
        return {
            __ref: String(id)
        };
    }
    function isReference(obj) {
        return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
    }
    function isDocumentNode(value) {
        return (isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions));
    }
    function isStringValue(value) {
        return value.kind === "StringValue";
    }
    function isBooleanValue(value) {
        return value.kind === "BooleanValue";
    }
    function isIntValue(value) {
        return value.kind === "IntValue";
    }
    function isFloatValue(value) {
        return value.kind === "FloatValue";
    }
    function isVariable(value) {
        return value.kind === "Variable";
    }
    function isObjectValue(value) {
        return value.kind === "ObjectValue";
    }
    function isListValue(value) {
        return value.kind === "ListValue";
    }
    function isEnumValue(value) {
        return value.kind === "EnumValue";
    }
    function isNullValue(value) {
        return value.kind === "NullValue";
    }
    function valueToObjectRepresentation(argObj, name, value, variables) {
        if (isIntValue(value) || isFloatValue(value)) {
            argObj[name.value] = Number(value.value);
        } else if (isBooleanValue(value) || isStringValue(value)) {
            argObj[name.value] = value.value;
        } else if (isObjectValue(value)) {
            var nestedArgObj_1 = {};
            value.fields.map(function(obj) {
                return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
            });
            argObj[name.value] = nestedArgObj_1;
        } else if (isVariable(value)) {
            var variableValue = (variables || {})[value.name.value];
            argObj[name.value] = variableValue;
        } else if (isListValue(value)) {
            argObj[name.value] = value.values.map(function(listValue) {
                var nestedArgArrayObj = {};
                valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
                return nestedArgArrayObj[name.value];
            });
        } else if (isEnumValue(value)) {
            argObj[name.value] = value.value;
        } else if (isNullValue(value)) {
            argObj[name.value] = null;
        } else {
            throw newInvariantError(124, name.value, value.kind);
        }
    }
    function storeKeyNameFromField(field, variables) {
        var directivesObj = null;
        if (field.directives) {
            directivesObj = {};
            field.directives.forEach(function(directive) {
                directivesObj[directive.name.value] = {};
                if (directive.arguments) {
                    directive.arguments.forEach(function(_a) {
                        var name = _a.name, value = _a.value;
                        return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                    });
                }
            });
        }
        var argObj = null;
        if (field.arguments && field.arguments.length) {
            argObj = {};
            field.arguments.forEach(function(_a) {
                var name = _a.name, value = _a.value;
                return valueToObjectRepresentation(argObj, name, value, variables);
            });
        }
        return getStoreKeyName(field.name.value, argObj, directivesObj);
    }
    var KNOWN_DIRECTIVES = [
        "connection",
        "include",
        "skip",
        "client",
        "rest",
        "export",
        "nonreactive"
    ];
    var storeKeyNameStringify = canonicalStringify;
    var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
        if (args && directives && directives["connection"] && directives["connection"]["key"]) {
            if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
                var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
                filterKeys.sort();
                var filteredArgs_1 = {};
                filterKeys.forEach(function(key) {
                    filteredArgs_1[key] = args[key];
                });
                return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
            } else {
                return directives["connection"]["key"];
            }
        }
        var completeFieldName = fieldName;
        if (args) {
            var stringifiedArgs = storeKeyNameStringify(args);
            completeFieldName += "(".concat(stringifiedArgs, ")");
        }
        if (directives) {
            Object.keys(directives).forEach(function(key) {
                if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;
                if (directives[key] && Object.keys(directives[key]).length) {
                    completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
                } else {
                    completeFieldName += "@".concat(key);
                }
            });
        }
        return completeFieldName;
    }, {
        setStringify: function(s) {
            var previous = storeKeyNameStringify;
            storeKeyNameStringify = s;
            return previous;
        }
    });
    function argumentsObjectFromField(field, variables) {
        if (field.arguments && field.arguments.length) {
            var argObj_1 = {};
            field.arguments.forEach(function(_a) {
                var name = _a.name, value = _a.value;
                return valueToObjectRepresentation(argObj_1, name, value, variables);
            });
            return argObj_1;
        }
        return null;
    }
    function resultKeyNameFromField(field) {
        return field.alias ? field.alias.value : field.name.value;
    }
    function getTypenameFromResult(result, selectionSet, fragmentMap) {
        var fragments;
        for(var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++){
            var selection = _a[_i];
            if (isField(selection)) {
                if (selection.name.value === "__typename") {
                    return result[resultKeyNameFromField(selection)];
                }
            } else if (fragments) {
                fragments.push(selection);
            } else {
                fragments = [
                    selection
                ];
            }
        }
        if (typeof result.__typename === "string") {
            return result.__typename;
        }
        if (fragments) {
            for(var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++){
                var selection = fragments_1[_b];
                var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
                if (typeof typename === "string") {
                    return typename;
                }
            }
        }
    }
    function isField(selection) {
        return selection.kind === "Field";
    }
    function isInlineFragment(selection) {
        return selection.kind === "InlineFragment";
    }
    function checkDocument(doc) {
        invariant$1(doc && doc.kind === "Document", 116);
        var operations = doc.definitions.filter(function(d) {
            return d.kind !== "FragmentDefinition";
        }).map(function(definition) {
            if (definition.kind !== "OperationDefinition") {
                throw newInvariantError(117, definition.kind);
            }
            return definition;
        });
        invariant$1(operations.length <= 1, 118, operations.length);
        return doc;
    }
    function getOperationDefinition(doc) {
        checkDocument(doc);
        return doc.definitions.filter(function(definition) {
            return definition.kind === "OperationDefinition";
        })[0];
    }
    function getOperationName(doc) {
        return (doc.definitions.filter(function(definition) {
            return definition.kind === "OperationDefinition" && !!definition.name;
        }).map(function(x) {
            return x.name.value;
        })[0] || null);
    }
    function getFragmentDefinitions(doc) {
        return doc.definitions.filter(function(definition) {
            return definition.kind === "FragmentDefinition";
        });
    }
    function getQueryDefinition(doc) {
        var queryDef = getOperationDefinition(doc);
        invariant$1(queryDef && queryDef.operation === "query", 119);
        return queryDef;
    }
    function getFragmentDefinition(doc) {
        invariant$1(doc.kind === "Document", 120);
        invariant$1(doc.definitions.length <= 1, 121);
        var fragmentDef = doc.definitions[0];
        invariant$1(fragmentDef.kind === "FragmentDefinition", 122);
        return fragmentDef;
    }
    function getMainDefinition(queryDoc) {
        checkDocument(queryDoc);
        var fragmentDefinition;
        for(var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++){
            var definition = _a[_i];
            if (definition.kind === "OperationDefinition") {
                var operation = definition.operation;
                if (operation === "query" || operation === "mutation" || operation === "subscription") {
                    return definition;
                }
            }
            if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
                fragmentDefinition = definition;
            }
        }
        if (fragmentDefinition) {
            return fragmentDefinition;
        }
        throw newInvariantError(123);
    }
    function getDefaultValues(definition) {
        var defaultValues = Object.create(null);
        var defs = definition && definition.variableDefinitions;
        if (defs && defs.length) {
            defs.forEach(function(def) {
                if (def.defaultValue) {
                    valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
                }
            });
        }
        return defaultValues;
    }
    let currentContext = null;
    const MISSING_VALUE = {};
    let idCounter = 1;
    const makeSlotClass = ()=>class Slot {
            constructor(){
                this.id = [
                    "slot",
                    idCounter++,
                    Date.now(),
                    Math.random().toString(36).slice(2)
                ].join(":");
            }
            hasValue() {
                for(let context = currentContext; context; context = context.parent){
                    if (this.id in context.slots) {
                        const value = context.slots[this.id];
                        if (value === MISSING_VALUE) break;
                        if (context !== currentContext) {
                            currentContext.slots[this.id] = value;
                        }
                        return true;
                    }
                }
                if (currentContext) {
                    currentContext.slots[this.id] = MISSING_VALUE;
                }
                return false;
            }
            getValue() {
                if (this.hasValue()) {
                    return currentContext.slots[this.id];
                }
            }
            withValue(value, callback, args, thisArg) {
                const slots = {
                    __proto__: null,
                    [this.id]: value
                };
                const parent = currentContext;
                currentContext = {
                    parent,
                    slots
                };
                try {
                    return callback.apply(thisArg, args);
                } finally{
                    currentContext = parent;
                }
            }
            static bind(callback) {
                const context = currentContext;
                return function() {
                    const saved = currentContext;
                    try {
                        currentContext = context;
                        return callback.apply(this, arguments);
                    } finally{
                        currentContext = saved;
                    }
                };
            }
            static noContext(callback, args, thisArg) {
                if (currentContext) {
                    const saved = currentContext;
                    try {
                        currentContext = null;
                        return callback.apply(thisArg, args);
                    } finally{
                        currentContext = saved;
                    }
                } else {
                    return callback.apply(thisArg, args);
                }
            }
        };
    function maybe(fn) {
        try {
            return fn();
        } catch (ignored) {}
    }
    const globalKey = "@wry/context:Slot";
    const host = maybe(()=>globalThis) || maybe(()=>global) || Object.create(null);
    const globalHost = host;
    const Slot = globalHost[globalKey] || Array[globalKey] || (function(Slot) {
        try {
            Object.defineProperty(globalHost, globalKey, {
                value: Slot,
                enumerable: false,
                writable: false,
                configurable: true
            });
        } finally{
            return Slot;
        }
    })(makeSlotClass());
    const { bind, noContext } = Slot;
    function setTimeoutWithContext(callback, delay) {
        return setTimeout(bind(callback), delay);
    }
    function asyncFromGen(genFn) {
        return function() {
            const gen = genFn.apply(this, arguments);
            const boundNext = bind(gen.next);
            const boundThrow = bind(gen.throw);
            return new Promise((resolve, reject)=>{
                function invoke(method, argument) {
                    try {
                        var result = method.call(gen, argument);
                    } catch (error) {
                        return reject(error);
                    }
                    const next = result.done ? resolve : invokeNext;
                    if (isPromiseLike$1(result.value)) {
                        result.value.then(next, result.done ? reject : invokeThrow);
                    } else {
                        next(result.value);
                    }
                }
                const invokeNext = (value)=>invoke(boundNext, value);
                const invokeThrow = (error)=>invoke(boundThrow, error);
                invokeNext();
            });
        };
    }
    function isPromiseLike$1(value) {
        return value && typeof value.then === "function";
    }
    const parentEntrySlot = new Slot();
    function nonReactive(fn) {
        return parentEntrySlot.withValue(void 0, fn);
    }
    const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
    const arrayFromSet = Array.from || function(set) {
        const array = [];
        set.forEach((item)=>array.push(item));
        return array;
    };
    function maybeUnsubscribe(entryOrDep) {
        const { unsubscribe } = entryOrDep;
        if (typeof unsubscribe === "function") {
            entryOrDep.unsubscribe = void 0;
            unsubscribe();
        }
    }
    const emptySetPool = [];
    const POOL_TARGET_SIZE = 100;
    function assert(condition, optionalMessage) {
        if (!condition) {
            throw new Error(optionalMessage || "assertion failure");
        }
    }
    function valueIs(a, b) {
        const len = a.length;
        return (len > 0 && len === b.length && a[len - 1] === b[len - 1]);
    }
    function valueGet(value) {
        switch(value.length){
            case 0:
                throw new Error("unknown value");
            case 1:
                return value[0];
            case 2:
                throw value[1];
        }
    }
    function valueCopy(value) {
        return value.slice(0);
    }
    class Entry {
        constructor(fn){
            this.fn = fn;
            this.parents = new Set();
            this.childValues = new Map();
            this.dirtyChildren = null;
            this.dirty = true;
            this.recomputing = false;
            this.value = [];
            this.deps = null;
            ++Entry.count;
        }
        peek() {
            if (this.value.length === 1 && !mightBeDirty(this)) {
                rememberParent(this);
                return this.value[0];
            }
        }
        recompute(args) {
            assert(!this.recomputing, "already recomputing");
            rememberParent(this);
            return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
        }
        setDirty() {
            if (this.dirty) return;
            this.dirty = true;
            reportDirty(this);
            maybeUnsubscribe(this);
        }
        dispose() {
            this.setDirty();
            forgetChildren(this);
            eachParent(this, (parent, child)=>{
                parent.setDirty();
                forgetChild(parent, this);
            });
        }
        forget() {
            this.dispose();
        }
        dependOn(dep) {
            dep.add(this);
            if (!this.deps) {
                this.deps = emptySetPool.pop() || new Set();
            }
            this.deps.add(dep);
        }
        forgetDeps() {
            if (this.deps) {
                arrayFromSet(this.deps).forEach((dep)=>dep.delete(this));
                this.deps.clear();
                emptySetPool.push(this.deps);
                this.deps = null;
            }
        }
    }
    Entry.count = 0;
    function rememberParent(child) {
        const parent = parentEntrySlot.getValue();
        if (parent) {
            child.parents.add(parent);
            if (!parent.childValues.has(child)) {
                parent.childValues.set(child, []);
            }
            if (mightBeDirty(child)) {
                reportDirtyChild(parent, child);
            } else {
                reportCleanChild(parent, child);
            }
            return parent;
        }
    }
    function reallyRecompute(entry, args) {
        forgetChildren(entry);
        parentEntrySlot.withValue(entry, recomputeNewValue, [
            entry,
            args
        ]);
        if (maybeSubscribe(entry, args)) {
            setClean(entry);
        }
        return valueGet(entry.value);
    }
    function recomputeNewValue(entry, args) {
        entry.recomputing = true;
        const { normalizeResult } = entry;
        let oldValueCopy;
        if (normalizeResult && entry.value.length === 1) {
            oldValueCopy = valueCopy(entry.value);
        }
        entry.value.length = 0;
        try {
            entry.value[0] = entry.fn.apply(null, args);
            if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
                try {
                    entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
                } catch (_a) {}
            }
        } catch (e) {
            entry.value[1] = e;
        }
        entry.recomputing = false;
    }
    function mightBeDirty(entry) {
        return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
    }
    function setClean(entry) {
        entry.dirty = false;
        if (mightBeDirty(entry)) {
            return;
        }
        reportClean(entry);
    }
    function reportDirty(child) {
        eachParent(child, reportDirtyChild);
    }
    function reportClean(child) {
        eachParent(child, reportCleanChild);
    }
    function eachParent(child, callback) {
        const parentCount = child.parents.size;
        if (parentCount) {
            const parents = arrayFromSet(child.parents);
            for(let i = 0; i < parentCount; ++i){
                callback(parents[i], child);
            }
        }
    }
    function reportDirtyChild(parent, child) {
        assert(parent.childValues.has(child));
        assert(mightBeDirty(child));
        const parentWasClean = !mightBeDirty(parent);
        if (!parent.dirtyChildren) {
            parent.dirtyChildren = emptySetPool.pop() || new Set;
        } else if (parent.dirtyChildren.has(child)) {
            return;
        }
        parent.dirtyChildren.add(child);
        if (parentWasClean) {
            reportDirty(parent);
        }
    }
    function reportCleanChild(parent, child) {
        assert(parent.childValues.has(child));
        assert(!mightBeDirty(child));
        const childValue = parent.childValues.get(child);
        if (childValue.length === 0) {
            parent.childValues.set(child, valueCopy(child.value));
        } else if (!valueIs(childValue, child.value)) {
            parent.setDirty();
        }
        removeDirtyChild(parent, child);
        if (mightBeDirty(parent)) {
            return;
        }
        reportClean(parent);
    }
    function removeDirtyChild(parent, child) {
        const dc = parent.dirtyChildren;
        if (dc) {
            dc.delete(child);
            if (dc.size === 0) {
                if (emptySetPool.length < POOL_TARGET_SIZE) {
                    emptySetPool.push(dc);
                }
                parent.dirtyChildren = null;
            }
        }
    }
    function forgetChildren(parent) {
        if (parent.childValues.size > 0) {
            parent.childValues.forEach((_value, child)=>{
                forgetChild(parent, child);
            });
        }
        parent.forgetDeps();
        assert(parent.dirtyChildren === null);
    }
    function forgetChild(parent, child) {
        child.parents.delete(parent);
        parent.childValues.delete(child);
        removeDirtyChild(parent, child);
    }
    function maybeSubscribe(entry, args) {
        if (typeof entry.subscribe === "function") {
            try {
                maybeUnsubscribe(entry);
                entry.unsubscribe = entry.subscribe.apply(null, args);
            } catch (e) {
                entry.setDirty();
                return false;
            }
        }
        return true;
    }
    const EntryMethods = {
        setDirty: true,
        dispose: true,
        forget: true
    };
    function dep(options) {
        const depsByKey = new Map();
        const subscribe = options && options.subscribe;
        function depend(key) {
            const parent = parentEntrySlot.getValue();
            if (parent) {
                let dep = depsByKey.get(key);
                if (!dep) {
                    depsByKey.set(key, dep = new Set);
                }
                parent.dependOn(dep);
                if (typeof subscribe === "function") {
                    maybeUnsubscribe(dep);
                    dep.unsubscribe = subscribe(key);
                }
            }
        }
        depend.dirty = function dirty(key, entryMethodName) {
            const dep = depsByKey.get(key);
            if (dep) {
                const m = (entryMethodName && hasOwnProperty$3.call(EntryMethods, entryMethodName)) ? entryMethodName : "setDirty";
                arrayFromSet(dep).forEach((entry)=>entry[m]());
                depsByKey.delete(key);
                maybeUnsubscribe(dep);
            }
        };
        return depend;
    }
    let defaultKeyTrie;
    function defaultMakeCacheKey(...args) {
        const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === "function"));
        return trie.lookupArray(args);
    }
    const caches = new Set();
    function wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache } = Object.create(null)) {
        const cache = typeof cacheOption === "function" ? new cacheOption(max, (entry)=>entry.dispose()) : cacheOption;
        const optimistic = function() {
            const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
            if (key === void 0) {
                return originalFunction.apply(null, arguments);
            }
            let entry = cache.get(key);
            if (!entry) {
                cache.set(key, entry = new Entry(originalFunction));
                entry.normalizeResult = normalizeResult;
                entry.subscribe = subscribe;
                entry.forget = ()=>cache.delete(key);
            }
            const value = entry.recompute(Array.prototype.slice.call(arguments));
            cache.set(key, entry);
            caches.add(cache);
            if (!parentEntrySlot.hasValue()) {
                caches.forEach((cache)=>cache.clean());
                caches.clear();
            }
            return value;
        };
        Object.defineProperty(optimistic, "size", {
            get: ()=>cache.size,
            configurable: false,
            enumerable: false
        });
        Object.freeze(optimistic.options = {
            max,
            keyArgs,
            makeCacheKey,
            normalizeResult,
            subscribe,
            cache
        });
        function dirtyKey(key) {
            const entry = key && cache.get(key);
            if (entry) {
                entry.setDirty();
            }
        }
        optimistic.dirtyKey = dirtyKey;
        optimistic.dirty = function dirty() {
            dirtyKey(makeCacheKey.apply(null, arguments));
        };
        function peekKey(key) {
            const entry = key && cache.get(key);
            if (entry) {
                return entry.peek();
            }
        }
        optimistic.peekKey = peekKey;
        optimistic.peek = function peek() {
            return peekKey(makeCacheKey.apply(null, arguments));
        };
        function forgetKey(key) {
            return key ? cache.delete(key) : false;
        }
        optimistic.forgetKey = forgetKey;
        optimistic.forget = function forget() {
            return forgetKey(makeCacheKey.apply(null, arguments));
        };
        optimistic.makeCacheKey = makeCacheKey;
        optimistic.getKey = keyArgs ? function getKey() {
            return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
        } : makeCacheKey;
        return Object.freeze(optimistic);
    }
    const lib$2 = Object.freeze(Object.defineProperty({
        __proto__: null,
        KeyTrie: Trie,
        Slot,
        asyncFromGen,
        bindContext: bind,
        defaultMakeCacheKey,
        dep,
        noContext,
        nonReactive,
        setTimeout: setTimeoutWithContext,
        wrap
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    function identity(document) {
        return document;
    }
    var DocumentTransform = (function() {
        function DocumentTransform(transform, options) {
            if (options === void 0) {
                options = Object.create(null);
            }
            this.resultCache = canUseWeakSet ? new WeakSet() : new Set();
            this.transform = transform;
            if (options.getCacheKey) {
                this.getCacheKey = options.getCacheKey;
            }
            this.cached = options.cache !== false;
            this.resetCache();
        }
        DocumentTransform.prototype.getCacheKey = function(document) {
            return [
                document
            ];
        };
        DocumentTransform.identity = function() {
            return new DocumentTransform(identity, {
                cache: false
            });
        };
        DocumentTransform.split = function(predicate, left, right) {
            if (right === void 0) {
                right = DocumentTransform.identity();
            }
            return Object.assign(new DocumentTransform(function(document) {
                var documentTransform = predicate(document) ? left : right;
                return documentTransform.transformDocument(document);
            }, {
                cache: false
            }), {
                left: left,
                right: right
            });
        };
        DocumentTransform.prototype.resetCache = function() {
            var _this = this;
            if (this.cached) {
                var stableCacheKeys_1 = new Trie(canUseWeakMap);
                this.performWork = wrap(DocumentTransform.prototype.performWork.bind(this), {
                    makeCacheKey: function(document) {
                        var cacheKeys = _this.getCacheKey(document);
                        if (cacheKeys) {
                            invariant$1(Array.isArray(cacheKeys), 105);
                            return stableCacheKeys_1.lookupArray(cacheKeys);
                        }
                    },
                    max: cacheSizes["documentTransform.cache"],
                    cache: (WeakCache)
                });
            }
        };
        DocumentTransform.prototype.performWork = function(document) {
            checkDocument(document);
            return this.transform(document);
        };
        DocumentTransform.prototype.transformDocument = function(document) {
            if (this.resultCache.has(document)) {
                return document;
            }
            var transformedDocument = this.performWork(document);
            this.resultCache.add(transformedDocument);
            return transformedDocument;
        };
        DocumentTransform.prototype.concat = function(otherTransform) {
            var _this = this;
            return Object.assign(new DocumentTransform(function(document) {
                return otherTransform.transformDocument(_this.transformDocument(document));
            }, {
                cache: false
            }), {
                left: this,
                right: otherTransform
            });
        };
        return DocumentTransform;
    }());
    var printCache;
    var print = Object.assign(function(ast) {
        var result = printCache.get(ast);
        if (!result) {
            result = print$1(ast);
            printCache.set(ast, result);
        }
        return result;
    }, {
        reset: function() {
            printCache = new AutoCleanedWeakCache(cacheSizes.print || 2000);
        }
    });
    print.reset();
    if (globalThis.__DEV__ !== false) {
        registerGlobalCache("print", function() {
            return (printCache ? printCache.size : 0);
        });
    }
    var isArray = Array.isArray;
    function isNonEmptyArray(value) {
        return Array.isArray(value) && value.length > 0;
    }
    var TYPENAME_FIELD = {
        kind: Kind.FIELD,
        name: {
            kind: Kind.NAME,
            value: "__typename"
        }
    };
    function isEmpty(op, fragmentMap) {
        return (!op || op.selectionSet.selections.every(function(selection) {
            return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
        }));
    }
    function nullIfDocIsEmpty(doc) {
        return (isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))) ? null : doc;
    }
    function getDirectiveMatcher(configs) {
        var names = new Map();
        var tests = new Map();
        configs.forEach(function(directive) {
            if (directive) {
                if (directive.name) {
                    names.set(directive.name, directive);
                } else if (directive.test) {
                    tests.set(directive.test, directive);
                }
            }
        });
        return function(directive) {
            var config = names.get(directive.name.value);
            if (!config && tests.size) {
                tests.forEach(function(testConfig, test) {
                    if (test(directive)) {
                        config = testConfig;
                    }
                });
            }
            return config;
        };
    }
    function makeInUseGetterFunction(defaultKey) {
        var map = new Map();
        return function inUseGetterFunction(key) {
            if (key === void 0) {
                key = defaultKey;
            }
            var inUse = map.get(key);
            if (!inUse) {
                map.set(key, (inUse = {
                    variables: new Set(),
                    fragmentSpreads: new Set()
                }));
            }
            return inUse;
        };
    }
    function removeDirectivesFromDocument(directives, doc) {
        checkDocument(doc);
        var getInUseByOperationName = makeInUseGetterFunction("");
        var getInUseByFragmentName = makeInUseGetterFunction("");
        var getInUse = function(ancestors) {
            for(var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p){
                if (isArray(ancestor)) continue;
                if (ancestor.kind === Kind.OPERATION_DEFINITION) {
                    return getInUseByOperationName(ancestor.name && ancestor.name.value);
                }
                if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
                    return getInUseByFragmentName(ancestor.name.value);
                }
            }
            globalThis.__DEV__ !== false && invariant$1.error(125);
            return null;
        };
        var operationCount = 0;
        for(var i = doc.definitions.length - 1; i >= 0; --i){
            if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {
                ++operationCount;
            }
        }
        var directiveMatcher = getDirectiveMatcher(directives);
        var shouldRemoveField = function(nodeDirectives) {
            return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
                return config && config.remove;
            });
        };
        var originalFragmentDefsByPath = new Map();
        var firstVisitMadeChanges = false;
        var fieldOrInlineFragmentVisitor = {
            enter: function(node) {
                if (shouldRemoveField(node.directives)) {
                    firstVisitMadeChanges = true;
                    return null;
                }
            }
        };
        var docWithoutDirectiveSubtrees = visit(doc, {
            Field: fieldOrInlineFragmentVisitor,
            InlineFragment: fieldOrInlineFragmentVisitor,
            VariableDefinition: {
                enter: function() {
                    return false;
                }
            },
            Variable: {
                enter: function(node, _key, _parent, _path, ancestors) {
                    var inUse = getInUse(ancestors);
                    if (inUse) {
                        inUse.variables.add(node.name.value);
                    }
                }
            },
            FragmentSpread: {
                enter: function(node, _key, _parent, _path, ancestors) {
                    if (shouldRemoveField(node.directives)) {
                        firstVisitMadeChanges = true;
                        return null;
                    }
                    var inUse = getInUse(ancestors);
                    if (inUse) {
                        inUse.fragmentSpreads.add(node.name.value);
                    }
                }
            },
            FragmentDefinition: {
                enter: function(node, _key, _parent, path) {
                    originalFragmentDefsByPath.set(JSON.stringify(path), node);
                },
                leave: function(node, _key, _parent, path) {
                    var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
                    if (node === originalNode) {
                        return node;
                    }
                    if (operationCount > 0 && node.selectionSet.selections.every(function(selection) {
                        return selection.kind === Kind.FIELD && selection.name.value === "__typename";
                    })) {
                        getInUseByFragmentName(node.name.value).removed = true;
                        firstVisitMadeChanges = true;
                        return null;
                    }
                }
            },
            Directive: {
                leave: function(node) {
                    if (directiveMatcher(node)) {
                        firstVisitMadeChanges = true;
                        return null;
                    }
                }
            }
        });
        if (!firstVisitMadeChanges) {
            return doc;
        }
        var populateTransitiveVars = function(inUse) {
            if (!inUse.transitiveVars) {
                inUse.transitiveVars = new Set(inUse.variables);
                if (!inUse.removed) {
                    inUse.fragmentSpreads.forEach(function(childFragmentName) {
                        populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
                            inUse.transitiveVars.add(varName);
                        });
                    });
                }
            }
            return inUse;
        };
        var allFragmentNamesUsed = new Set();
        docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
            if (def.kind === Kind.OPERATION_DEFINITION) {
                populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
                    allFragmentNamesUsed.add(childFragmentName);
                });
            } else if (def.kind === Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
                allFragmentNamesUsed.add(def.name.value);
            }
        });
        allFragmentNamesUsed.forEach(function(fragmentName) {
            populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
                allFragmentNamesUsed.add(childFragmentName);
            });
        });
        var fragmentWillBeRemoved = function(fragmentName) {
            return !!((!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed));
        };
        var enterVisitor = {
            enter: function(node) {
                if (fragmentWillBeRemoved(node.name.value)) {
                    return null;
                }
            }
        };
        return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
            FragmentSpread: enterVisitor,
            FragmentDefinition: enterVisitor,
            OperationDefinition: {
                leave: function(node) {
                    if (node.variableDefinitions) {
                        var usedVariableNames_1 = populateTransitiveVars(getInUseByOperationName(node.name && node.name.value)).transitiveVars;
                        if (usedVariableNames_1.size < node.variableDefinitions.length) {
                            return __assign(__assign({}, node), {
                                variableDefinitions: node.variableDefinitions.filter(function(varDef) {
                                    return usedVariableNames_1.has(varDef.variable.name.value);
                                })
                            });
                        }
                    }
                }
            }
        }));
    }
    var addTypenameToDocument = Object.assign(function(doc) {
        return visit(doc, {
            SelectionSet: {
                enter: function(node, _key, parent) {
                    if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
                        return;
                    }
                    var selections = node.selections;
                    if (!selections) {
                        return;
                    }
                    var skip = selections.some(function(selection) {
                        return (isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0));
                    });
                    if (skip) {
                        return;
                    }
                    var field = parent;
                    if (isField(field) && field.directives && field.directives.some(function(d) {
                        return d.name.value === "export";
                    })) {
                        return;
                    }
                    return __assign(__assign({}, node), {
                        selections: __spreadArray(__spreadArray([], selections, true), [
                            TYPENAME_FIELD
                        ], false)
                    });
                }
            }
        });
    }, {
        added: function(field) {
            return field === TYPENAME_FIELD;
        }
    });
    var connectionRemoveConfig = {
        test: function(directive) {
            var willRemove = directive.name.value === "connection";
            if (willRemove) {
                if (!directive.arguments || !directive.arguments.some(function(arg) {
                    return arg.name.value === "key";
                })) {
                    globalThis.__DEV__ !== false && invariant$1.warn(126);
                }
            }
            return willRemove;
        }
    };
    function removeConnectionDirectiveFromDocument(doc) {
        return removeDirectivesFromDocument([
            connectionRemoveConfig
        ], checkDocument(doc));
    }
    function getArgumentMatcher(config) {
        return function argumentMatcher(argument) {
            return config.some(function(aConfig) {
                return argument.value && argument.value.kind === Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || (aConfig.test && aConfig.test(argument)));
            });
        };
    }
    function removeArgumentsFromDocument(config, doc) {
        var argMatcher = getArgumentMatcher(config);
        return nullIfDocIsEmpty(visit(doc, {
            OperationDefinition: {
                enter: function(node) {
                    return __assign(__assign({}, node), {
                        variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
                            return !config.some(function(arg) {
                                return arg.name === varDef.variable.name.value;
                            });
                        }) : []
                    });
                }
            },
            Field: {
                enter: function(node) {
                    var shouldRemoveField = config.some(function(argConfig) {
                        return argConfig.remove;
                    });
                    if (shouldRemoveField) {
                        var argMatchCount_1 = 0;
                        if (node.arguments) {
                            node.arguments.forEach(function(arg) {
                                if (argMatcher(arg)) {
                                    argMatchCount_1 += 1;
                                }
                            });
                        }
                        if (argMatchCount_1 === 1) {
                            return null;
                        }
                    }
                }
            },
            Argument: {
                enter: function(node) {
                    if (argMatcher(node)) {
                        return null;
                    }
                }
            }
        }));
    }
    function removeFragmentSpreadFromDocument(config, doc) {
        function enter(node) {
            if (config.some(function(def) {
                return def.name === node.name.value;
            })) {
                return null;
            }
        }
        return nullIfDocIsEmpty(visit(doc, {
            FragmentSpread: {
                enter: enter
            },
            FragmentDefinition: {
                enter: enter
            }
        }));
    }
    function buildQueryFromSelectionSet(document) {
        var definition = getMainDefinition(document);
        var definitionOperation = definition.operation;
        if (definitionOperation === "query") {
            return document;
        }
        var modifiedDoc = visit(document, {
            OperationDefinition: {
                enter: function(node) {
                    return __assign(__assign({}, node), {
                        operation: "query"
                    });
                }
            }
        });
        return modifiedDoc;
    }
    function removeClientSetsFromDocument(document) {
        checkDocument(document);
        var modifiedDoc = removeDirectivesFromDocument([
            {
                test: function(directive) {
                    return directive.name.value === "client";
                },
                remove: true
            }
        ], document);
        return modifiedDoc;
    }
    function addNonReactiveToNamedFragments(document) {
        checkDocument(document);
        return visit(document, {
            FragmentSpread: function(node) {
                var _a;
                if ((_a = node.directives) === null || _a === void 0 ? void 0 : _a.some(function(directive) {
                    return directive.name.value === "unmask";
                })) {
                    return;
                }
                return __assign(__assign({}, node), {
                    directives: __spreadArray(__spreadArray([], (node.directives || []), true), [
                        {
                            kind: Kind.DIRECTIVE,
                            name: {
                                kind: Kind.NAME,
                                value: "nonreactive"
                            }
                        }
                    ], false)
                });
            }
        });
    }
    function isOperation(document, operation) {
        var _a;
        return ((_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation) === operation;
    }
    function isMutationOperation(document) {
        return isOperation(document, "mutation");
    }
    function isQueryOperation(document) {
        return isOperation(document, "query");
    }
    function isSubscriptionOperation(document) {
        return isOperation(document, "subscription");
    }
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    function mergeDeep() {
        var sources = [];
        for(var _i = 0; _i < arguments.length; _i++){
            sources[_i] = arguments[_i];
        }
        return mergeDeepArray(sources);
    }
    function mergeDeepArray(sources) {
        var target = sources[0] || {};
        var count = sources.length;
        if (count > 1) {
            var merger = new DeepMerger();
            for(var i = 1; i < count; ++i){
                target = merger.merge(target, sources[i]);
            }
        }
        return target;
    }
    var defaultReconciler = function(target, source, property) {
        return this.merge(target[property], source[property]);
    };
    var DeepMerger = (function() {
        function DeepMerger(reconciler) {
            if (reconciler === void 0) {
                reconciler = defaultReconciler;
            }
            this.reconciler = reconciler;
            this.isObject = isNonNullObject;
            this.pastCopies = new Set();
        }
        DeepMerger.prototype.merge = function(target, source) {
            var _this = this;
            var context = [];
            for(var _i = 2; _i < arguments.length; _i++){
                context[_i - 2] = arguments[_i];
            }
            if (isNonNullObject(source) && isNonNullObject(target)) {
                Object.keys(source).forEach(function(sourceKey) {
                    if (hasOwnProperty$2.call(target, sourceKey)) {
                        var targetValue = target[sourceKey];
                        if (source[sourceKey] !== targetValue) {
                            var result = _this.reconciler.apply(_this, __spreadArray([
                                target,
                                source,
                                sourceKey
                            ], context, false));
                            if (result !== targetValue) {
                                target = _this.shallowCopyForMerge(target);
                                target[sourceKey] = result;
                            }
                        }
                    } else {
                        target = _this.shallowCopyForMerge(target);
                        target[sourceKey] = source[sourceKey];
                    }
                });
                return target;
            }
            return source;
        };
        DeepMerger.prototype.shallowCopyForMerge = function(value) {
            if (isNonNullObject(value)) {
                if (!this.pastCopies.has(value)) {
                    if (Array.isArray(value)) {
                        value = value.slice(0);
                    } else {
                        value = __assign({
                            __proto__: Object.getPrototypeOf(value)
                        }, value);
                    }
                    this.pastCopies.add(value);
                }
            }
            return value;
        };
        return DeepMerger;
    }());
    function concatPagination(keyArgs) {
        if (keyArgs === void 0) {
            keyArgs = false;
        }
        return {
            keyArgs: keyArgs,
            merge: function(existing, incoming) {
                return existing ? __spreadArray(__spreadArray([], existing, true), incoming, true) : incoming;
            }
        };
    }
    function offsetLimitPagination(keyArgs) {
        if (keyArgs === void 0) {
            keyArgs = false;
        }
        return {
            keyArgs: keyArgs,
            merge: function(existing, incoming, _a) {
                var args = _a.args;
                var merged = existing ? existing.slice(0) : [];
                if (incoming) {
                    if (args) {
                        var _b = args.offset, offset = _b === void 0 ? 0 : _b;
                        for(var i = 0; i < incoming.length; ++i){
                            merged[offset + i] = incoming[i];
                        }
                    } else {
                        merged.push.apply(merged, incoming);
                    }
                }
                return merged;
            }
        };
    }
    function relayStylePagination(keyArgs) {
        if (keyArgs === void 0) {
            keyArgs = false;
        }
        return {
            keyArgs: keyArgs,
            read: function(existing, _a) {
                var canRead = _a.canRead, readField = _a.readField;
                if (!existing) return existing;
                var edges = [];
                var firstEdgeCursor = "";
                var lastEdgeCursor = "";
                existing.edges.forEach(function(edge) {
                    if (canRead(readField("node", edge))) {
                        edges.push(edge);
                        if (edge.cursor) {
                            firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                            lastEdgeCursor = edge.cursor || lastEdgeCursor;
                        }
                    }
                });
                if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {
                    firstEdgeCursor = "";
                }
                var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
                return __assign(__assign({}, getExtras(existing)), {
                    edges: edges,
                    pageInfo: __assign(__assign({}, existing.pageInfo), {
                        startCursor: startCursor || firstEdgeCursor,
                        endCursor: endCursor || lastEdgeCursor
                    })
                });
            },
            merge: function(existing, incoming, _a) {
                var args = _a.args, isReference = _a.isReference, readField = _a.readField;
                if (!existing) {
                    existing = makeEmptyData();
                }
                if (!incoming) {
                    return existing;
                }
                var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
                    if (isReference((edge = __assign({}, edge)))) {
                        edge.cursor = readField("cursor", edge);
                    }
                    return edge;
                }) : [];
                if (incoming.pageInfo) {
                    var pageInfo_1 = incoming.pageInfo;
                    var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
                    var firstEdge = incomingEdges[0];
                    var lastEdge = incomingEdges[incomingEdges.length - 1];
                    if (firstEdge && startCursor) {
                        firstEdge.cursor = startCursor;
                    }
                    if (lastEdge && endCursor) {
                        lastEdge.cursor = endCursor;
                    }
                    var firstCursor = firstEdge && firstEdge.cursor;
                    if (firstCursor && !startCursor) {
                        incoming = mergeDeep(incoming, {
                            pageInfo: {
                                startCursor: firstCursor
                            }
                        });
                    }
                    var lastCursor = lastEdge && lastEdge.cursor;
                    if (lastCursor && !endCursor) {
                        incoming = mergeDeep(incoming, {
                            pageInfo: {
                                endCursor: lastCursor
                            }
                        });
                    }
                }
                var prefix = existing.edges;
                var suffix = [];
                if (args && args.after) {
                    var index = prefix.findIndex(function(edge) {
                        return edge.cursor === args.after;
                    });
                    if (index >= 0) {
                        prefix = prefix.slice(0, index + 1);
                    }
                } else if (args && args.before) {
                    var index = prefix.findIndex(function(edge) {
                        return edge.cursor === args.before;
                    });
                    suffix = index < 0 ? prefix : prefix.slice(index);
                    prefix = [];
                } else if (incoming.edges) {
                    prefix = [];
                }
                var edges = __spreadArray(__spreadArray(__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
                var pageInfo = __assign(__assign({}, incoming.pageInfo), existing.pageInfo);
                if (incoming.pageInfo) {
                    var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = __rest(_b, [
                        "hasPreviousPage",
                        "hasNextPage",
                        "startCursor",
                        "endCursor"
                    ]);
                    Object.assign(pageInfo, extras);
                    if (!prefix.length) {
                        if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;
                        if (void 0 !== startCursor) pageInfo.startCursor = startCursor;
                    }
                    if (!suffix.length) {
                        if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;
                        if (void 0 !== endCursor) pageInfo.endCursor = endCursor;
                    }
                }
                return __assign(__assign(__assign({}, getExtras(existing)), getExtras(incoming)), {
                    edges: edges,
                    pageInfo: pageInfo
                });
            }
        };
    }
    var getExtras = function(obj) {
        return __rest(obj, notExtras);
    };
    var notExtras = [
        "edges",
        "pageInfo"
    ];
    function makeEmptyData() {
        return {
            edges: [],
            pageInfo: {
                hasPreviousPage: false,
                hasNextPage: true,
                startCursor: "",
                endCursor: ""
            }
        };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it) return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
            if (it) o = it;
            var i = 0;
            return function() {
                if (i >= o.length) return {
                    done: true
                };
                return {
                    done: false,
                    value: o[i++]
                };
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++){
            arr2[i] = arr[i];
        }
        return arr2;
    }
    function _defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
            writable: false
        });
        return Constructor;
    }
    var hasSymbols = function() {
        return typeof Symbol === 'function';
    };
    var hasSymbol = function(name) {
        return hasSymbols() && Boolean(Symbol[name]);
    };
    var getSymbol = function(name) {
        return hasSymbol(name) ? Symbol[name] : '@@' + name;
    };
    if (hasSymbols() && !hasSymbol('observable')) {
        Symbol.observable = Symbol('observable');
    }
    var SymbolIterator = getSymbol('iterator');
    var SymbolObservable = getSymbol('observable');
    var SymbolSpecies = getSymbol('species');
    function getMethod(obj, key) {
        var value = obj[key];
        if (value == null) return undefined;
        if (typeof value !== 'function') throw new TypeError(value + ' is not a function');
        return value;
    }
    function getSpecies(obj) {
        var ctor = obj.constructor;
        if (ctor !== undefined) {
            ctor = ctor[SymbolSpecies];
            if (ctor === null) {
                ctor = undefined;
            }
        }
        return ctor !== undefined ? ctor : Observable;
    }
    function isObservable(x) {
        return x instanceof Observable;
    }
    function hostReportError(e) {
        if (hostReportError.log) {
            hostReportError.log(e);
        } else {
            setTimeout(function() {
                throw e;
            });
        }
    }
    function enqueue(fn) {
        Promise.resolve().then(function() {
            try {
                fn();
            } catch (e) {
                hostReportError(e);
            }
        });
    }
    function cleanupSubscription(subscription) {
        var cleanup = subscription._cleanup;
        if (cleanup === undefined) return;
        subscription._cleanup = undefined;
        if (!cleanup) {
            return;
        }
        try {
            if (typeof cleanup === 'function') {
                cleanup();
            } else {
                var unsubscribe = getMethod(cleanup, 'unsubscribe');
                if (unsubscribe) {
                    unsubscribe.call(cleanup);
                }
            }
        } catch (e) {
            hostReportError(e);
        }
    }
    function closeSubscription(subscription) {
        subscription._observer = undefined;
        subscription._queue = undefined;
        subscription._state = 'closed';
    }
    function flushSubscription(subscription) {
        var queue = subscription._queue;
        if (!queue) {
            return;
        }
        subscription._queue = undefined;
        subscription._state = 'ready';
        for(var i = 0; i < queue.length; ++i){
            notifySubscription(subscription, queue[i].type, queue[i].value);
            if (subscription._state === 'closed') break;
        }
    }
    function notifySubscription(subscription, type, value) {
        subscription._state = 'running';
        var observer = subscription._observer;
        try {
            var m = getMethod(observer, type);
            switch(type){
                case 'next':
                    if (m) m.call(observer, value);
                    break;
                case 'error':
                    closeSubscription(subscription);
                    if (m) m.call(observer, value);
                    else throw value;
                    break;
                case 'complete':
                    closeSubscription(subscription);
                    if (m) m.call(observer);
                    break;
            }
        } catch (e) {
            hostReportError(e);
        }
        if (subscription._state === 'closed') cleanupSubscription(subscription);
        else if (subscription._state === 'running') subscription._state = 'ready';
    }
    function onNotify(subscription, type, value) {
        if (subscription._state === 'closed') return;
        if (subscription._state === 'buffering') {
            subscription._queue.push({
                type: type,
                value: value
            });
            return;
        }
        if (subscription._state !== 'ready') {
            subscription._state = 'buffering';
            subscription._queue = [
                {
                    type: type,
                    value: value
                }
            ];
            enqueue(function() {
                return flushSubscription(subscription);
            });
            return;
        }
        notifySubscription(subscription, type, value);
    }
    var Subscription = function() {
        function Subscription(observer, subscriber) {
            this._cleanup = undefined;
            this._observer = observer;
            this._queue = undefined;
            this._state = 'initializing';
            var subscriptionObserver = new SubscriptionObserver(this);
            try {
                this._cleanup = subscriber.call(undefined, subscriptionObserver);
            } catch (e) {
                subscriptionObserver.error(e);
            }
            if (this._state === 'initializing') this._state = 'ready';
        }
        var _proto = Subscription.prototype;
        _proto.unsubscribe = function unsubscribe() {
            if (this._state !== 'closed') {
                closeSubscription(this);
                cleanupSubscription(this);
            }
        };
        _createClass(Subscription, [
            {
                key: "closed",
                get: function() {
                    return this._state === 'closed';
                }
            }
        ]);
        return Subscription;
    }();
    var SubscriptionObserver = function() {
        function SubscriptionObserver(subscription) {
            this._subscription = subscription;
        }
        var _proto2 = SubscriptionObserver.prototype;
        _proto2.next = function next(value) {
            onNotify(this._subscription, 'next', value);
        };
        _proto2.error = function error(value) {
            onNotify(this._subscription, 'error', value);
        };
        _proto2.complete = function complete() {
            onNotify(this._subscription, 'complete');
        };
        _createClass(SubscriptionObserver, [
            {
                key: "closed",
                get: function() {
                    return this._subscription._state === 'closed';
                }
            }
        ]);
        return SubscriptionObserver;
    }();
    var Observable = function() {
        function Observable(subscriber) {
            if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');
            if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');
            this._subscriber = subscriber;
        }
        var _proto3 = Observable.prototype;
        _proto3.subscribe = function subscribe(observer) {
            if (typeof observer !== 'object' || observer === null) {
                observer = {
                    next: observer,
                    error: arguments[1],
                    complete: arguments[2]
                };
            }
            return new Subscription(observer, this._subscriber);
        };
        _proto3.forEach = function forEach(fn) {
            var _this = this;
            return new Promise(function(resolve, reject) {
                if (typeof fn !== 'function') {
                    reject(new TypeError(fn + ' is not a function'));
                    return;
                }
                function done() {
                    subscription.unsubscribe();
                    resolve();
                }
                var subscription = _this.subscribe({
                    next: function(value) {
                        try {
                            fn(value, done);
                        } catch (e) {
                            reject(e);
                            subscription.unsubscribe();
                        }
                    },
                    error: reject,
                    complete: resolve
                });
            });
        };
        _proto3.map = function map(fn) {
            var _this2 = this;
            if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
            var C = getSpecies(this);
            return new C(function(observer) {
                return _this2.subscribe({
                    next: function(value) {
                        try {
                            value = fn(value);
                        } catch (e) {
                            return observer.error(e);
                        }
                        observer.next(value);
                    },
                    error: function(e) {
                        observer.error(e);
                    },
                    complete: function() {
                        observer.complete();
                    }
                });
            });
        };
        _proto3.filter = function filter(fn) {
            var _this3 = this;
            if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
            var C = getSpecies(this);
            return new C(function(observer) {
                return _this3.subscribe({
                    next: function(value) {
                        try {
                            if (!fn(value)) return;
                        } catch (e) {
                            return observer.error(e);
                        }
                        observer.next(value);
                    },
                    error: function(e) {
                        observer.error(e);
                    },
                    complete: function() {
                        observer.complete();
                    }
                });
            });
        };
        _proto3.reduce = function reduce(fn) {
            var _this4 = this;
            if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
            var C = getSpecies(this);
            var hasSeed = arguments.length > 1;
            var hasValue = false;
            var seed = arguments[1];
            var acc = seed;
            return new C(function(observer) {
                return _this4.subscribe({
                    next: function(value) {
                        var first = !hasValue;
                        hasValue = true;
                        if (!first || hasSeed) {
                            try {
                                acc = fn(acc, value);
                            } catch (e) {
                                return observer.error(e);
                            }
                        } else {
                            acc = value;
                        }
                    },
                    error: function(e) {
                        observer.error(e);
                    },
                    complete: function() {
                        if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));
                        observer.next(acc);
                        observer.complete();
                    }
                });
            });
        };
        _proto3.concat = function concat() {
            var _this5 = this;
            for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){
                sources[_key] = arguments[_key];
            }
            var C = getSpecies(this);
            return new C(function(observer) {
                var subscription;
                var index = 0;
                function startNext(next) {
                    subscription = next.subscribe({
                        next: function(v) {
                            observer.next(v);
                        },
                        error: function(e) {
                            observer.error(e);
                        },
                        complete: function() {
                            if (index === sources.length) {
                                subscription = undefined;
                                observer.complete();
                            } else {
                                startNext(C.from(sources[index++]));
                            }
                        }
                    });
                }
                startNext(_this5);
                return function() {
                    if (subscription) {
                        subscription.unsubscribe();
                        subscription = undefined;
                    }
                };
            });
        };
        _proto3.flatMap = function flatMap(fn) {
            var _this6 = this;
            if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
            var C = getSpecies(this);
            return new C(function(observer) {
                var subscriptions = [];
                var outer = _this6.subscribe({
                    next: function(value) {
                        if (fn) {
                            try {
                                value = fn(value);
                            } catch (e) {
                                return observer.error(e);
                            }
                        }
                        var inner = C.from(value).subscribe({
                            next: function(value) {
                                observer.next(value);
                            },
                            error: function(e) {
                                observer.error(e);
                            },
                            complete: function() {
                                var i = subscriptions.indexOf(inner);
                                if (i >= 0) subscriptions.splice(i, 1);
                                completeIfDone();
                            }
                        });
                        subscriptions.push(inner);
                    },
                    error: function(e) {
                        observer.error(e);
                    },
                    complete: function() {
                        completeIfDone();
                    }
                });
                function completeIfDone() {
                    if (outer.closed && subscriptions.length === 0) observer.complete();
                }
                return function() {
                    subscriptions.forEach(function(s) {
                        return s.unsubscribe();
                    });
                    outer.unsubscribe();
                };
            });
        };
        _proto3[SymbolObservable] = function() {
            return this;
        };
        Observable.from = function from(x) {
            var C = typeof this === 'function' ? this : Observable;
            if (x == null) throw new TypeError(x + ' is not an object');
            var method = getMethod(x, SymbolObservable);
            if (method) {
                var observable = method.call(x);
                if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');
                if (isObservable(observable) && observable.constructor === C) return observable;
                return new C(function(observer) {
                    return observable.subscribe(observer);
                });
            }
            if (hasSymbol('iterator')) {
                method = getMethod(x, SymbolIterator);
                if (method) {
                    return new C(function(observer) {
                        enqueue(function() {
                            if (observer.closed) return;
                            for(var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;){
                                var item = _step.value;
                                observer.next(item);
                                if (observer.closed) return;
                            }
                            observer.complete();
                        });
                    });
                }
            }
            if (Array.isArray(x)) {
                return new C(function(observer) {
                    enqueue(function() {
                        if (observer.closed) return;
                        for(var i = 0; i < x.length; ++i){
                            observer.next(x[i]);
                            if (observer.closed) return;
                        }
                        observer.complete();
                    });
                });
            }
            throw new TypeError(x + ' is not observable');
        };
        Observable.of = function of() {
            for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
                items[_key2] = arguments[_key2];
            }
            var C = typeof this === 'function' ? this : Observable;
            return new C(function(observer) {
                enqueue(function() {
                    if (observer.closed) return;
                    for(var i = 0; i < items.length; ++i){
                        observer.next(items[i]);
                        if (observer.closed) return;
                    }
                    observer.complete();
                });
            });
        };
        _createClass(Observable, null, [
            {
                key: SymbolSpecies,
                get: function() {
                    return this;
                }
            }
        ]);
        return Observable;
    }();
    if (hasSymbols()) {
        Object.defineProperty(Observable, Symbol('extensions'), {
            value: {
                symbol: SymbolObservable,
                hostReportError: hostReportError
            },
            configurable: true
        });
    }
    const module$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        Observable
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    function symbolObservablePonyfill(root) {
        var result;
        var Symbol = root.Symbol;
        if (typeof Symbol === 'function') {
            if (Symbol.observable) {
                result = Symbol.observable;
            } else {
                if (typeof Symbol.for === 'function') {
                    result = Symbol.for('https://github.com/benlesh/symbol-observable');
                } else {
                    result = Symbol('https://github.com/benlesh/symbol-observable');
                }
                try {
                    Symbol.observable = result;
                } catch (err) {}
            }
        } else {
            result = '@@observable';
        }
        return result;
    }
    var root;
    if (typeof self !== 'undefined') {
        root = self;
    } else if (typeof window !== 'undefined') {
        root = window;
    } else if (typeof global !== 'undefined') {
        root = global;
    } else if (typeof module !== 'undefined') {
        root = module;
    } else {
        root = Function('return this')();
    }
    symbolObservablePonyfill(root);
    function createFulfilledPromise(value) {
        var promise = Promise.resolve(value);
        promise.status = "fulfilled";
        promise.value = value;
        return promise;
    }
    function createRejectedPromise(reason) {
        var promise = Promise.reject(reason);
        promise.catch(function() {});
        promise.status = "rejected";
        promise.reason = reason;
        return promise;
    }
    function isStatefulPromise(promise) {
        return "status" in promise;
    }
    function wrapPromiseWithState(promise) {
        if (isStatefulPromise(promise)) {
            return promise;
        }
        var pendingPromise = promise;
        pendingPromise.status = "pending";
        pendingPromise.then(function(value) {
            if (pendingPromise.status === "pending") {
                var fulfilledPromise = pendingPromise;
                fulfilledPromise.status = "fulfilled";
                fulfilledPromise.value = value;
            }
        }, function(reason) {
            if (pendingPromise.status === "pending") {
                var rejectedPromise = pendingPromise;
                rejectedPromise.status = "rejected";
                rejectedPromise.reason = reason;
            }
        });
        return promise;
    }
    function preventUnhandledRejection(promise) {
        promise.catch(function() {});
        return promise;
    }
    var toString$2 = Object.prototype.toString;
    function cloneDeep(value) {
        return cloneDeepHelper(value);
    }
    function cloneDeepHelper(val, seen) {
        switch(toString$2.call(val)){
            case "[object Array]":
                {
                    seen = seen || new Map();
                    if (seen.has(val)) return seen.get(val);
                    var copy_1 = val.slice(0);
                    seen.set(val, copy_1);
                    copy_1.forEach(function(child, i) {
                        copy_1[i] = cloneDeepHelper(child, seen);
                    });
                    return copy_1;
                }
            case "[object Object]":
                {
                    seen = seen || new Map();
                    if (seen.has(val)) return seen.get(val);
                    var copy_2 = Object.create(Object.getPrototypeOf(val));
                    seen.set(val, copy_2);
                    Object.keys(val).forEach(function(key) {
                        copy_2[key] = cloneDeepHelper(val[key], seen);
                    });
                    return copy_2;
                }
            default:
                return val;
        }
    }
    function deepFreeze(value) {
        var workSet = new Set([
            value
        ]);
        workSet.forEach(function(obj) {
            if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
                Object.getOwnPropertyNames(obj).forEach(function(name) {
                    if (isNonNullObject(obj[name])) workSet.add(obj[name]);
                });
            }
        });
        return value;
    }
    function shallowFreeze(obj) {
        if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
            try {
                Object.freeze(obj);
            } catch (e) {
                if (e instanceof TypeError) return null;
                throw e;
            }
        }
        return obj;
    }
    function maybeDeepFreeze(obj) {
        if (globalThis.__DEV__ !== false) {
            deepFreeze(obj);
        }
        return obj;
    }
    function iterateObserversSafely(observers, method, argument) {
        var observersWithMethod = [];
        observers.forEach(function(obs) {
            return obs[method] && observersWithMethod.push(obs);
        });
        observersWithMethod.forEach(function(obs) {
            return obs[method](argument);
        });
    }
    function asyncMap(observable, mapFn, catchFn) {
        return new Observable(function(observer) {
            var promiseQueue = {
                then: function(callback) {
                    return new Promise(function(resolve) {
                        return resolve(callback());
                    });
                }
            };
            function makeCallback(examiner, key) {
                return function(arg) {
                    if (examiner) {
                        var both = function() {
                            return observer.closed ? 0 : examiner(arg);
                        };
                        promiseQueue = promiseQueue.then(both, both).then(function(result) {
                            return observer.next(result);
                        }, function(error) {
                            return observer.error(error);
                        });
                    } else {
                        observer[key](arg);
                    }
                };
            }
            var handler = {
                next: makeCallback(mapFn, "next"),
                error: makeCallback(catchFn, "error"),
                complete: function() {
                    promiseQueue.then(function() {
                        return observer.complete();
                    });
                }
            };
            var sub = observable.subscribe(handler);
            return function() {
                return sub.unsubscribe();
            };
        });
    }
    function fixObservableSubclass(subclass) {
        function set(key) {
            Object.defineProperty(subclass, key, {
                value: Observable
            });
        }
        if (canUseSymbol && Symbol.species) {
            set(Symbol.species);
        }
        set("@@species");
        return subclass;
    }
    function isPromiseLike(value) {
        return value && typeof value.then === "function";
    }
    var Concast = (function(_super) {
        __extends(Concast, _super);
        function Concast(sources) {
            var _this = _super.call(this, function(observer) {
                _this.addObserver(observer);
                return function() {
                    return _this.removeObserver(observer);
                };
            }) || this;
            _this.observers = new Set();
            _this.promise = new Promise(function(resolve, reject) {
                _this.resolve = resolve;
                _this.reject = reject;
            });
            _this.handlers = {
                next: function(result) {
                    if (_this.sub !== null) {
                        _this.latest = [
                            "next",
                            result
                        ];
                        _this.notify("next", result);
                        iterateObserversSafely(_this.observers, "next", result);
                    }
                },
                error: function(error) {
                    var sub = _this.sub;
                    if (sub !== null) {
                        if (sub) setTimeout(function() {
                            return sub.unsubscribe();
                        });
                        _this.sub = null;
                        _this.latest = [
                            "error",
                            error
                        ];
                        _this.reject(error);
                        _this.notify("error", error);
                        iterateObserversSafely(_this.observers, "error", error);
                    }
                },
                complete: function() {
                    var _a = _this, sub = _a.sub, _b = _a.sources, sources = _b === void 0 ? [] : _b;
                    if (sub !== null) {
                        var value = sources.shift();
                        if (!value) {
                            if (sub) setTimeout(function() {
                                return sub.unsubscribe();
                            });
                            _this.sub = null;
                            if (_this.latest && _this.latest[0] === "next") {
                                _this.resolve(_this.latest[1]);
                            } else {
                                _this.resolve();
                            }
                            _this.notify("complete");
                            iterateObserversSafely(_this.observers, "complete");
                        } else if (isPromiseLike(value)) {
                            value.then(function(obs) {
                                return (_this.sub = obs.subscribe(_this.handlers));
                            }, _this.handlers.error);
                        } else {
                            _this.sub = value.subscribe(_this.handlers);
                        }
                    }
                }
            };
            _this.nextResultListeners = new Set();
            _this.cancel = function(reason) {
                _this.reject(reason);
                _this.sources = [];
                _this.handlers.error(reason);
            };
            _this.promise.catch(function(_) {});
            if (typeof sources === "function") {
                sources = [
                    new Observable(sources)
                ];
            }
            if (isPromiseLike(sources)) {
                sources.then(function(iterable) {
                    return _this.start(iterable);
                }, _this.handlers.error);
            } else {
                _this.start(sources);
            }
            return _this;
        }
        Concast.prototype.start = function(sources) {
            if (this.sub !== void 0) return;
            this.sources = Array.from(sources);
            this.handlers.complete();
        };
        Concast.prototype.deliverLastMessage = function(observer) {
            if (this.latest) {
                var nextOrError = this.latest[0];
                var method = observer[nextOrError];
                if (method) {
                    method.call(observer, this.latest[1]);
                }
                if (this.sub === null && nextOrError === "next" && observer.complete) {
                    observer.complete();
                }
            }
        };
        Concast.prototype.addObserver = function(observer) {
            if (!this.observers.has(observer)) {
                this.deliverLastMessage(observer);
                this.observers.add(observer);
            }
        };
        Concast.prototype.removeObserver = function(observer) {
            if (this.observers.delete(observer) && this.observers.size < 1) {
                this.handlers.complete();
            }
        };
        Concast.prototype.notify = function(method, arg) {
            var nextResultListeners = this.nextResultListeners;
            if (nextResultListeners.size) {
                this.nextResultListeners = new Set();
                nextResultListeners.forEach(function(listener) {
                    return listener(method, arg);
                });
            }
        };
        Concast.prototype.beforeNext = function(callback) {
            var called = false;
            this.nextResultListeners.add(function(method, arg) {
                if (!called) {
                    called = true;
                    callback(method, arg);
                }
            });
        };
        return Concast;
    }(Observable));
    fixObservableSubclass(Concast);
    function isExecutionPatchIncrementalResult(value) {
        return "incremental" in value;
    }
    function isExecutionPatchInitialResult(value) {
        return "hasNext" in value && "data" in value;
    }
    function isExecutionPatchResult(value) {
        return (isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value));
    }
    function isApolloPayloadResult(value) {
        return isNonNullObject(value) && "payload" in value;
    }
    function mergeIncrementalData(prevResult, result) {
        var mergedData = prevResult;
        var merger = new DeepMerger();
        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
            result.incremental.forEach(function(_a) {
                var data = _a.data, path = _a.path;
                for(var i = path.length - 1; i >= 0; --i){
                    var key = path[i];
                    var isNumericKey = !isNaN(+key);
                    var parent_1 = isNumericKey ? [] : {};
                    parent_1[key] = data;
                    data = parent_1;
                }
                mergedData = merger.merge(mergedData, data);
            });
        }
        return mergedData;
    }
    function graphQLResultHasError(result) {
        var errors = getGraphQLErrorsFromResult(result);
        return isNonEmptyArray(errors);
    }
    function getGraphQLErrorsFromResult(result) {
        var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
            result.incremental.forEach(function(incrementalResult) {
                if (incrementalResult.errors) {
                    graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
                }
            });
        }
        return graphQLErrors;
    }
    function compact() {
        var objects = [];
        for(var _i = 0; _i < arguments.length; _i++){
            objects[_i] = arguments[_i];
        }
        var result = Object.create(null);
        objects.forEach(function(obj) {
            if (!obj) return;
            Object.keys(obj).forEach(function(key) {
                var value = obj[key];
                if (value !== void 0) {
                    result[key] = value;
                }
            });
        });
        return result;
    }
    function mergeOptions(defaults, options) {
        return compact(defaults, options, options.variables && {
            variables: compact(__assign(__assign({}, (defaults && defaults.variables)), options.variables))
        });
    }
    function omitDeep(value, key) {
        return __omitDeep(value, key);
    }
    function __omitDeep(value, key, known) {
        if (known === void 0) {
            known = new Map();
        }
        if (known.has(value)) {
            return known.get(value);
        }
        var modified = false;
        if (Array.isArray(value)) {
            var array_1 = [];
            known.set(value, array_1);
            value.forEach(function(value, index) {
                var result = __omitDeep(value, key, known);
                modified || (modified = result !== value);
                array_1[index] = result;
            });
            if (modified) {
                return array_1;
            }
        } else if (isPlainObject(value)) {
            var obj_1 = Object.create(Object.getPrototypeOf(value));
            known.set(value, obj_1);
            Object.keys(value).forEach(function(k) {
                if (k === key) {
                    modified = true;
                    return;
                }
                var result = __omitDeep(value[k], key, known);
                modified || (modified = result !== value[k]);
                obj_1[k] = result;
            });
            if (modified) {
                return obj_1;
            }
        }
        return value;
    }
    function stripTypename(value) {
        return omitDeep(value, "__typename");
    }
    const utilities$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        AutoCleanedStrongCache,
        AutoCleanedWeakCache,
        Concast,
        DEV,
        DeepMerger,
        DocumentTransform,
        Observable,
        addNonReactiveToNamedFragments,
        addTypenameToDocument,
        argumentsObjectFromField,
        asyncMap,
        buildQueryFromSelectionSet,
        cacheSizes,
        canUseAsyncIteratorSymbol,
        canUseDOM,
        canUseLayoutEffect,
        canUseSymbol,
        canUseWeakMap,
        canUseWeakSet,
        canonicalStringify,
        checkDocument,
        cloneDeep,
        compact,
        concatPagination,
        createFragmentMap,
        createFulfilledPromise,
        createRejectedPromise,
        fixObservableSubclass,
        getDefaultValues,
        getDirectiveNames,
        getFragmentDefinition,
        getFragmentDefinitions,
        getFragmentFromSelection,
        getFragmentMaskMode,
        getFragmentQueryDocument,
        getGraphQLErrorsFromResult,
        getInclusionDirectives,
        getMainDefinition,
        getOperationDefinition,
        getOperationName,
        getQueryDefinition,
        getStoreKeyName,
        getTypenameFromResult,
        graphQLResultHasError,
        hasAllDirectives,
        hasAnyDirectives,
        hasClientExports,
        hasDirectives,
        isApolloPayloadResult,
        isArray,
        isDocumentNode,
        isExecutionPatchIncrementalResult,
        isExecutionPatchInitialResult,
        isExecutionPatchResult,
        isField,
        isFullyUnmaskedOperation,
        isInlineFragment,
        isMutationOperation,
        isNonEmptyArray,
        isNonNullObject,
        isPlainObject,
        isQueryOperation,
        isReference,
        isStatefulPromise,
        isSubscriptionOperation,
        iterateObserversSafely,
        makeReference,
        makeUniqueId,
        maybe: maybe$1,
        maybeDeepFreeze,
        mergeDeep,
        mergeDeepArray,
        mergeIncrementalData,
        mergeOptions,
        offsetLimitPagination,
        omitDeep,
        preventUnhandledRejection,
        print,
        relayStylePagination,
        removeArgumentsFromDocument,
        removeClientSetsFromDocument,
        removeConnectionDirectiveFromDocument,
        removeDirectivesFromDocument,
        removeFragmentSpreadFromDocument,
        resultKeyNameFromField,
        shouldInclude,
        storeKeyNameFromField,
        stringifyForDisplay,
        stripTypename,
        valueToObjectRepresentation,
        wrapPromiseWithState
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    function fromError(errorValue) {
        return new Observable(function(observer) {
            observer.error(errorValue);
        });
    }
    function toPromise(observable) {
        var completed = false;
        return new Promise(function(resolve, reject) {
            observable.subscribe({
                next: function(data) {
                    if (completed) {
                        globalThis.__DEV__ !== false && invariant$1.warn(57);
                    } else {
                        completed = true;
                        resolve(data);
                    }
                },
                error: reject
            });
        });
    }
    function fromPromise(promise) {
        return new Observable(function(observer) {
            promise.then(function(value) {
                observer.next(value);
                observer.complete();
            }).catch(observer.error.bind(observer));
        });
    }
    var throwServerError = function(response, result, message) {
        var error = new Error(message);
        error.name = "ServerError";
        error.response = response;
        error.statusCode = response.status;
        error.result = result;
        throw error;
    };
    function validateOperation(operation) {
        var OPERATION_FIELDS = [
            "query",
            "operationName",
            "variables",
            "extensions",
            "context"
        ];
        for(var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++){
            var key = _a[_i];
            if (OPERATION_FIELDS.indexOf(key) < 0) {
                throw newInvariantError(58, key);
            }
        }
        return operation;
    }
    function createOperation(starting, operation) {
        var context = __assign({}, starting);
        var setContext = function(next) {
            if (typeof next === "function") {
                context = __assign(__assign({}, context), next(context));
            } else {
                context = __assign(__assign({}, context), next);
            }
        };
        var getContext = function() {
            return (__assign({}, context));
        };
        Object.defineProperty(operation, "setContext", {
            enumerable: false,
            value: setContext
        });
        Object.defineProperty(operation, "getContext", {
            enumerable: false,
            value: getContext
        });
        return operation;
    }
    function transformOperation(operation) {
        var transformedOperation = {
            variables: operation.variables || {},
            extensions: operation.extensions || {},
            operationName: operation.operationName,
            query: operation.query
        };
        if (!transformedOperation.operationName) {
            transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || undefined : "";
        }
        return transformedOperation;
    }
    function filterOperationVariables(variables, query) {
        var result = __assign({}, variables);
        var unusedNames = new Set(Object.keys(variables));
        visit(query, {
            Variable: function(node, _key, parent) {
                if (parent && parent.kind !== "VariableDefinition") {
                    unusedNames.delete(node.name.value);
                }
            }
        });
        unusedNames.forEach(function(name) {
            delete result[name];
        });
        return result;
    }
    const utils = Object.freeze(Object.defineProperty({
        __proto__: null,
        createOperation,
        filterOperationVariables,
        fromError,
        fromPromise,
        throwServerError,
        toPromise,
        transformOperation,
        validateOperation
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    var muteAllDeprecations = Symbol.for("apollo.deprecations");
    var global$1 = untypedGlobal;
    var slot = new Slot();
    function isMuted(name) {
        return global$1[muteAllDeprecations] || (slot.getValue() || []).includes(name);
    }
    function muteDeprecations(name) {
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++){
            args[_i - 1] = arguments[_i];
        }
        return slot.withValue.apply(slot, __spreadArray([
            Array.isArray(name) ? name : [
                name
            ]
        ], args, false));
    }
    function warnRemovedOption(options, name, callSite, recommendation) {
        if (recommendation === void 0) {
            recommendation = "Please remove this option.";
        }
        warnDeprecated(name, function() {
            if (name in options) {
                globalThis.__DEV__ !== false && invariant$1.warn(104, callSite, name, recommendation);
            }
        });
    }
    function warnDeprecated(name, cb) {
        if (!isMuted(name)) {
            cb();
        }
    }
    function passthrough(op, forward) {
        return (forward ? forward(op) : Observable.of());
    }
    function toLink(handler) {
        return typeof handler === "function" ? new ApolloLink(handler) : handler;
    }
    function isTerminating(link) {
        return link.request.length <= 1;
    }
    var ApolloLink = (function() {
        function ApolloLink(request) {
            if (request) this.request = request;
        }
        ApolloLink.empty = function() {
            return new ApolloLink(function() {
                return Observable.of();
            });
        };
        ApolloLink.from = function(links) {
            if (links.length === 0) return ApolloLink.empty();
            return links.map(toLink).reduce(function(x, y) {
                return x.concat(y);
            });
        };
        ApolloLink.split = function(test, left, right) {
            var leftLink = toLink(left);
            var rightLink = toLink(right || new ApolloLink(passthrough));
            var ret;
            if (isTerminating(leftLink) && isTerminating(rightLink)) {
                ret = new ApolloLink(function(operation) {
                    return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
                });
            } else {
                ret = new ApolloLink(function(operation, forward) {
                    return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
                });
            }
            return Object.assign(ret, {
                left: leftLink,
                right: rightLink
            });
        };
        ApolloLink.execute = function(link, operation) {
            return (link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of());
        };
        ApolloLink.concat = function(first, second) {
            var firstLink = toLink(first);
            if (isTerminating(firstLink)) {
                globalThis.__DEV__ !== false && invariant$1.warn(47, firstLink);
                return firstLink;
            }
            var nextLink = toLink(second);
            var ret;
            if (isTerminating(nextLink)) {
                ret = new ApolloLink(function(operation) {
                    return firstLink.request(operation, function(op) {
                        return nextLink.request(op) || Observable.of();
                    }) || Observable.of();
                });
            } else {
                ret = new ApolloLink(function(operation, forward) {
                    return (firstLink.request(operation, function(op) {
                        return nextLink.request(op, forward) || Observable.of();
                    }) || Observable.of());
                });
            }
            return Object.assign(ret, {
                left: firstLink,
                right: nextLink
            });
        };
        ApolloLink.prototype.split = function(test, left, right) {
            return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough)));
        };
        ApolloLink.prototype.concat = function(next) {
            return ApolloLink.concat(this, next);
        };
        ApolloLink.prototype.request = function(operation, forward) {
            throw newInvariantError(48);
        };
        ApolloLink.prototype.onError = function(error, observer) {
            if (globalThis.__DEV__ !== false) {
                warnDeprecated("onError", function() {
                    globalThis.__DEV__ !== false && invariant$1.warn(49);
                });
            }
            if (observer && observer.error) {
                observer.error(error);
                return false;
            }
            throw error;
        };
        ApolloLink.prototype.setOnError = function(fn) {
            if (globalThis.__DEV__ !== false) {
                globalThis.__DEV__ !== false && invariant$1.warn(50);
            }
            this.onError = fn;
            return this;
        };
        return ApolloLink;
    }());
    var empty = ApolloLink.empty;
    var from = ApolloLink.from;
    var split = ApolloLink.split;
    var concat = ApolloLink.concat;
    var execute = ApolloLink.execute;
    const core$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        ApolloLink,
        concat,
        empty,
        execute,
        from,
        split
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    const require$$2$1 = getAugmentedNamespace(core$1);
    function asyncIterator(source) {
        var _a;
        var iterator = source[Symbol.asyncIterator]();
        return _a = {
            next: function() {
                return iterator.next();
            }
        }, _a[Symbol.asyncIterator] = function() {
            return this;
        }, _a;
    }
    function nodeStreamIterator(stream) {
        var cleanup = null;
        var error = null;
        var done = false;
        var data = [];
        var waiting = [];
        function onData(chunk) {
            if (error) return;
            if (waiting.length) {
                var shiftedArr = waiting.shift();
                if (Array.isArray(shiftedArr) && shiftedArr[0]) {
                    return shiftedArr[0]({
                        value: chunk,
                        done: false
                    });
                }
            }
            data.push(chunk);
        }
        function onError(err) {
            error = err;
            var all = waiting.slice();
            all.forEach(function(pair) {
                pair[1](err);
            });
            !cleanup || cleanup();
        }
        function onEnd() {
            done = true;
            var all = waiting.slice();
            all.forEach(function(pair) {
                pair[0]({
                    value: undefined,
                    done: true
                });
            });
            !cleanup || cleanup();
        }
        cleanup = function() {
            cleanup = null;
            stream.removeListener("data", onData);
            stream.removeListener("error", onError);
            stream.removeListener("end", onEnd);
            stream.removeListener("finish", onEnd);
            stream.removeListener("close", onEnd);
        };
        stream.on("data", onData);
        stream.on("error", onError);
        stream.on("end", onEnd);
        stream.on("finish", onEnd);
        stream.on("close", onEnd);
        function getNext() {
            return new Promise(function(resolve, reject) {
                if (error) return reject(error);
                if (data.length) return resolve({
                    value: data.shift(),
                    done: false
                });
                if (done) return resolve({
                    value: undefined,
                    done: true
                });
                waiting.push([
                    resolve,
                    reject
                ]);
            });
        }
        var iterator = {
            next: function() {
                return getNext();
            }
        };
        if (canUseAsyncIteratorSymbol) {
            iterator[Symbol.asyncIterator] = function() {
                return this;
            };
        }
        return iterator;
    }
    function promiseIterator(promise) {
        var resolved = false;
        var iterator = {
            next: function() {
                if (resolved) return Promise.resolve({
                    value: undefined,
                    done: true
                });
                resolved = true;
                return new Promise(function(resolve, reject) {
                    promise.then(function(value) {
                        resolve({
                            value: value,
                            done: false
                        });
                    }).catch(reject);
                });
            }
        };
        if (canUseAsyncIteratorSymbol) {
            iterator[Symbol.asyncIterator] = function() {
                return this;
            };
        }
        return iterator;
    }
    function readerIterator(reader) {
        var iterator = {
            next: function() {
                return reader.read();
            }
        };
        if (canUseAsyncIteratorSymbol) {
            iterator[Symbol.asyncIterator] = function() {
                return this;
            };
        }
        return iterator;
    }
    function isNodeResponse(value) {
        return !!value.body;
    }
    function isReadableStream(value) {
        return !!value.getReader;
    }
    function isAsyncIterableIterator(value) {
        return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
    }
    function isStreamableBlob(value) {
        return !!value.stream;
    }
    function isBlob(value) {
        return !!value.arrayBuffer;
    }
    function isNodeReadableStream(value) {
        return !!value.pipe;
    }
    function responseIterator(response) {
        var body = response;
        if (isNodeResponse(response)) body = response.body;
        if (isAsyncIterableIterator(body)) return asyncIterator(body);
        if (isReadableStream(body)) return readerIterator(body.getReader());
        if (isStreamableBlob(body)) {
            return readerIterator(body.stream().getReader());
        }
        if (isBlob(body)) return promiseIterator(body.arrayBuffer());
        if (isNodeReadableStream(body)) return nodeStreamIterator(body);
        throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
    }
    var PROTOCOL_ERRORS_SYMBOL = Symbol();
    function graphQLResultHasProtocolErrors(result) {
        if (result.extensions) {
            return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);
        }
        return false;
    }
    function isApolloError(err) {
        return err.hasOwnProperty("graphQLErrors");
    }
    var generateErrorMessage = function(err) {
        var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
        if (err.networkError) errors.push(err.networkError);
        return (errors.map(function(err) {
            return (isNonNullObject(err) && err.message) || "Error message not found.";
        }).join("\n"));
    };
    var ApolloError = (function(_super) {
        __extends(ApolloError, _super);
        function ApolloError(_a) {
            var graphQLErrors = _a.graphQLErrors, protocolErrors = _a.protocolErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
            var _this = _super.call(this, errorMessage) || this;
            _this.name = "ApolloError";
            _this.graphQLErrors = graphQLErrors || [];
            _this.protocolErrors = protocolErrors || [];
            _this.clientErrors = clientErrors || [];
            _this.networkError = networkError || null;
            _this.message = errorMessage || generateErrorMessage(_this);
            _this.extraInfo = extraInfo;
            _this.cause = __spreadArray(__spreadArray(__spreadArray([
                networkError
            ], (graphQLErrors || []), true), (protocolErrors || []), true), (clientErrors || []), true).find(function(e) {
                return !!e;
            }) || null;
            _this.__proto__ = ApolloError.prototype;
            return _this;
        }
        return ApolloError;
    }(Error));
    const errors = Object.freeze(Object.defineProperty({
        __proto__: null,
        ApolloError,
        PROTOCOL_ERRORS_SYMBOL,
        graphQLResultHasProtocolErrors,
        isApolloError
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    function readMultipartBody(response, nextValue) {
        return __awaiter(this, void 0, void 0, function() {
            var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;
            var _b, _c;
            var _d;
            return __generator(this, function(_e) {
                switch(_e.label){
                    case 0:
                        if (TextDecoder === undefined) {
                            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
                        }
                        decoder = new TextDecoder("utf-8");
                        contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
                        delimiter = "boundary=";
                        boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
                        boundary = "\r\n--".concat(boundaryVal);
                        buffer = "";
                        iterator = responseIterator(response);
                        running = true;
                        _e.label = 1;
                    case 1:
                        if (!running) return [
                            3,
                            3
                        ];
                        return [
                            4,
                            iterator.next()
                        ];
                    case 2:
                        _a = _e.sent(), value = _a.value, done = _a.done;
                        chunk = typeof value === "string" ? value : decoder.decode(value);
                        searchFrom = buffer.length - boundary.length + 1;
                        running = !done;
                        buffer += chunk;
                        bi = buffer.indexOf(boundary, searchFrom);
                        while(bi > -1){
                            message = void 0;
                            _b = [
                                buffer.slice(0, bi),
                                buffer.slice(bi + boundary.length)
                            ], message = _b[0], buffer = _b[1];
                            i = message.indexOf("\r\n\r\n");
                            headers = parseHeaders(message.slice(0, i));
                            contentType_1 = headers["content-type"];
                            if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                                throw new Error("Unsupported patch content type: application/json is required.");
                            }
                            body = message.slice(i);
                            if (body) {
                                result = parseJsonBody(response, body);
                                if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result || "payload" in result) {
                                    if (isApolloPayloadResult(result)) {
                                        next = {};
                                        if ("payload" in result) {
                                            if (Object.keys(result).length === 1 && result.payload === null) {
                                                return [
                                                    2
                                                ];
                                            }
                                            next = __assign({}, result.payload);
                                        }
                                        if ("errors" in result) {
                                            next = __assign(__assign({}, next), {
                                                extensions: __assign(__assign({}, ("extensions" in next ? next.extensions : null)), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result.errors, _c))
                                            });
                                        }
                                        nextValue(next);
                                    } else {
                                        nextValue(result);
                                    }
                                } else if (Object.keys(result).length === 1 && "hasNext" in result && !result.hasNext) {
                                    return [
                                        2
                                    ];
                                }
                            }
                            bi = buffer.indexOf(boundary);
                        }
                        return [
                            3,
                            1
                        ];
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    }
    function parseHeaders(headerText) {
        var headersInit = {};
        headerText.split("\n").forEach(function(line) {
            var i = line.indexOf(":");
            if (i > -1) {
                var name_1 = line.slice(0, i).trim().toLowerCase();
                var value = line.slice(i + 1).trim();
                headersInit[name_1] = value;
            }
        });
        return headersInit;
    }
    function parseJsonBody(response, bodyText) {
        if (response.status >= 300) {
            var getResult = function() {
                try {
                    return JSON.parse(bodyText);
                } catch (err) {
                    return bodyText;
                }
            };
            throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
        }
        try {
            return JSON.parse(bodyText);
        } catch (err) {
            var parseError = err;
            parseError.name = "ServerParseError";
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            throw parseError;
        }
    }
    function handleError$1(err, observer) {
        if (err.result && err.result.errors && err.result.data) {
            observer.next(err.result);
        }
        observer.error(err);
    }
    function parseAndCheckHttpResponse(operations) {
        return function(response) {
            return response.text().then(function(bodyText) {
                return parseJsonBody(response, bodyText);
            }).then(function(result) {
                if (!Array.isArray(result) && !hasOwnProperty$1.call(result, "data") && !hasOwnProperty$1.call(result, "errors")) {
                    throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
                        return op.operationName;
                    }) : operations.operationName, "'."));
                }
                return result;
            });
        };
    }
    var serializeFetchParameter = function(p, label) {
        var serialized;
        try {
            serialized = JSON.stringify(p);
        } catch (e) {
            var parseError = newInvariantError(54, label, e.message);
            parseError.parseError = e;
            throw parseError;
        }
        return serialized;
    };
    var defaultHttpOptions = {
        includeQuery: true,
        includeExtensions: false,
        preserveHeaderCase: false
    };
    var defaultHeaders = {
        accept: "*/*",
        "content-type": "application/json"
    };
    var defaultOptions = {
        method: "POST"
    };
    var fallbackHttpConfig = {
        http: defaultHttpOptions,
        headers: defaultHeaders,
        options: defaultOptions
    };
    var defaultPrinter = function(ast, printer) {
        return printer(ast);
    };
    function selectHttpOptionsAndBody(operation, fallbackConfig) {
        var configs = [];
        for(var _i = 2; _i < arguments.length; _i++){
            configs[_i - 2] = arguments[_i];
        }
        configs.unshift(fallbackConfig);
        return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([
            operation,
            defaultPrinter
        ], configs, false));
    }
    function selectHttpOptionsAndBodyInternal(operation, printer) {
        var configs = [];
        for(var _i = 2; _i < arguments.length; _i++){
            configs[_i - 2] = arguments[_i];
        }
        var options = {};
        var http = {};
        configs.forEach(function(config) {
            options = __assign(__assign(__assign({}, options), config.options), {
                headers: __assign(__assign({}, options.headers), config.headers)
            });
            if (config.credentials) {
                options.credentials = config.credentials;
            }
            http = __assign(__assign({}, http), config.http);
        });
        if (options.headers) {
            options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
        }
        var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
        var body = {
            operationName: operationName,
            variables: variables
        };
        if (http.includeExtensions) body.extensions = extensions;
        if (http.includeQuery) body.query = printer(query, print);
        return {
            options: options,
            body: body
        };
    }
    function removeDuplicateHeaders(headers, preserveHeaderCase) {
        if (!preserveHeaderCase) {
            var normalizedHeaders_1 = {};
            Object.keys(Object(headers)).forEach(function(name) {
                normalizedHeaders_1[name.toLowerCase()] = headers[name];
            });
            return normalizedHeaders_1;
        }
        var headerData = {};
        Object.keys(Object(headers)).forEach(function(name) {
            headerData[name.toLowerCase()] = {
                originalName: name,
                value: headers[name]
            };
        });
        var normalizedHeaders = {};
        Object.keys(headerData).forEach(function(name) {
            normalizedHeaders[headerData[name].originalName] = headerData[name].value;
        });
        return normalizedHeaders;
    }
    var checkFetcher = function(fetcher) {
        if (!fetcher && typeof fetch === "undefined") {
            throw newInvariantError(51);
        }
    };
    var createSignalIfSupported = function() {
        if (typeof AbortController === "undefined") return {
            controller: false,
            signal: false
        };
        var controller = new AbortController();
        var signal = controller.signal;
        return {
            controller: controller,
            signal: signal
        };
    };
    var selectURI = function(operation, fallbackURI) {
        var context = operation.getContext();
        var contextURI = context.uri;
        if (contextURI) {
            return contextURI;
        } else if (typeof fallbackURI === "function") {
            return fallbackURI(operation);
        } else {
            return fallbackURI || "/graphql";
        }
    };
    function rewriteURIForGET(chosenURI, body) {
        var queryParams = [];
        var addQueryParam = function(key, value) {
            queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
        };
        if ("query" in body) {
            addQueryParam("query", body.query);
        }
        if (body.operationName) {
            addQueryParam("operationName", body.operationName);
        }
        if (body.variables) {
            var serializedVariables = void 0;
            try {
                serializedVariables = serializeFetchParameter(body.variables, "Variables map");
            } catch (parseError) {
                return {
                    parseError: parseError
                };
            }
            addQueryParam("variables", serializedVariables);
        }
        if (body.extensions) {
            var serializedExtensions = void 0;
            try {
                serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
            } catch (parseError) {
                return {
                    parseError: parseError
                };
            }
            addQueryParam("extensions", serializedExtensions);
        }
        var fragment = "", preFragment = chosenURI;
        var fragmentStart = chosenURI.indexOf("#");
        if (fragmentStart !== -1) {
            fragment = chosenURI.substr(fragmentStart);
            preFragment = chosenURI.substr(0, fragmentStart);
        }
        var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
        var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
        return {
            newURI: newURI
        };
    }
    var backupFetch = maybe$1(function() {
        return fetch;
    });
    var createHttpLink = function(linkOptions) {
        if (linkOptions === void 0) {
            linkOptions = {};
        }
        var _a = linkOptions.uri, uri = _a === void 0 ? "/graphql" : _a, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, [
            "uri",
            "fetch",
            "print",
            "includeExtensions",
            "preserveHeaderCase",
            "useGETForQueries",
            "includeUnusedVariables"
        ]);
        if (globalThis.__DEV__ !== false) {
            checkFetcher(preferredFetch || backupFetch);
        }
        var linkConfig = {
            http: {
                includeExtensions: includeExtensions,
                preserveHeaderCase: preserveHeaderCase
            },
            options: requestOptions.fetchOptions,
            credentials: requestOptions.credentials,
            headers: requestOptions.headers
        };
        return new ApolloLink(function(operation) {
            var chosenURI = selectURI(operation, uri);
            var context = operation.getContext();
            var clientAwarenessHeaders = {};
            if (context.clientAwareness) {
                var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
                if (name_1) {
                    clientAwarenessHeaders["apollographql-client-name"] = name_1;
                }
                if (version) {
                    clientAwarenessHeaders["apollographql-client-version"] = version;
                }
            }
            var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
            var contextConfig = {
                http: context.http,
                options: context.fetchOptions,
                credentials: context.credentials,
                headers: contextHeaders
            };
            if (hasDirectives([
                "client"
            ], operation.query)) {
                if (globalThis.__DEV__ !== false) {
                    globalThis.__DEV__ !== false && invariant$1.warn(52);
                }
                var transformedQuery = removeClientSetsFromDocument(operation.query);
                if (!transformedQuery) {
                    return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
                }
                operation.query = transformedQuery;
            }
            var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
            if (body.variables && !includeUnusedVariables) {
                body.variables = filterOperationVariables(body.variables, operation.query);
            }
            var controller;
            if (!options.signal && typeof AbortController !== "undefined") {
                controller = new AbortController();
                options.signal = controller.signal;
            }
            var definitionIsMutation = function(d) {
                return d.kind === "OperationDefinition" && d.operation === "mutation";
            };
            var definitionIsSubscription = function(d) {
                return d.kind === "OperationDefinition" && d.operation === "subscription";
            };
            var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));
            var hasDefer = hasDirectives([
                "defer"
            ], operation.query);
            if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
                options.method = "GET";
            }
            if (hasDefer || isSubscription) {
                options.headers = options.headers || {};
                var acceptHeader = "multipart/mixed;";
                if (isSubscription && hasDefer) {
                    globalThis.__DEV__ !== false && invariant$1.warn(53);
                }
                if (isSubscription) {
                    acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
                } else if (hasDefer) {
                    acceptHeader += "deferSpec=20220824,application/json";
                }
                options.headers.accept = acceptHeader;
            }
            if (options.method === "GET") {
                var _c = rewriteURIForGET(chosenURI, body), newURI = _c.newURI, parseError = _c.parseError;
                if (parseError) {
                    return fromError(parseError);
                }
                chosenURI = newURI;
            } else {
                try {
                    options.body = serializeFetchParameter(body, "Payload");
                } catch (parseError) {
                    return fromError(parseError);
                }
            }
            return new Observable(function(observer) {
                var currentFetch = preferredFetch || maybe$1(function() {
                    return fetch;
                }) || backupFetch;
                var observerNext = observer.next.bind(observer);
                currentFetch(chosenURI, options).then(function(response) {
                    var _a;
                    operation.setContext({
                        response: response
                    });
                    var ctype = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get("content-type");
                    if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
                        return readMultipartBody(response, observerNext);
                    } else {
                        return parseAndCheckHttpResponse(operation)(response).then(observerNext);
                    }
                }).then(function() {
                    controller = undefined;
                    observer.complete();
                }).catch(function(err) {
                    controller = undefined;
                    handleError$1(err, observer);
                });
                return function() {
                    if (controller) controller.abort();
                };
            });
        });
    };
    var HttpLink = (function(_super) {
        __extends(HttpLink, _super);
        function HttpLink(options) {
            if (options === void 0) {
                options = {};
            }
            var _this = _super.call(this, createHttpLink(options).request) || this;
            _this.options = options;
            return _this;
        }
        return HttpLink;
    }(ApolloLink));
    const http$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        HttpLink,
        checkFetcher,
        createHttpLink,
        createSignalIfSupported,
        defaultPrinter,
        fallbackHttpConfig,
        parseAndCheckHttpResponse,
        rewriteURIForGET,
        selectHttpOptionsAndBody,
        selectHttpOptionsAndBodyInternal,
        selectURI,
        serializeFetchParameter
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    const require$$3$2 = getAugmentedNamespace(http$1);
    const { toString: toString$1, hasOwnProperty } = Object.prototype;
    const fnToStr = Function.prototype.toString;
    const previousComparisons = new Map();
    function equal(a, b) {
        try {
            return check(a, b);
        } finally{
            previousComparisons.clear();
        }
    }
    function check(a, b) {
        if (a === b) {
            return true;
        }
        const aTag = toString$1.call(a);
        const bTag = toString$1.call(b);
        if (aTag !== bTag) {
            return false;
        }
        switch(aTag){
            case '[object Array]':
                if (a.length !== b.length) return false;
            case '[object Object]':
                {
                    if (previouslyCompared(a, b)) return true;
                    const aKeys = definedKeys(a);
                    const bKeys = definedKeys(b);
                    const keyCount = aKeys.length;
                    if (keyCount !== bKeys.length) return false;
                    for(let k = 0; k < keyCount; ++k){
                        if (!hasOwnProperty.call(b, aKeys[k])) {
                            return false;
                        }
                    }
                    for(let k = 0; k < keyCount; ++k){
                        const key = aKeys[k];
                        if (!check(a[key], b[key])) {
                            return false;
                        }
                    }
                    return true;
                }
            case '[object Error]':
                return a.name === b.name && a.message === b.message;
            case '[object Number]':
                if (a !== a) return b !== b;
            case '[object Boolean]':
            case '[object Date]':
                return +a === +b;
            case '[object RegExp]':
            case '[object String]':
                return a == `${b}`;
            case '[object Map]':
            case '[object Set]':
                {
                    if (a.size !== b.size) return false;
                    if (previouslyCompared(a, b)) return true;
                    const aIterator = a.entries();
                    const isMap = aTag === '[object Map]';
                    while(true){
                        const info = aIterator.next();
                        if (info.done) break;
                        const [aKey, aValue] = info.value;
                        if (!b.has(aKey)) {
                            return false;
                        }
                        if (isMap && !check(aValue, b.get(aKey))) {
                            return false;
                        }
                    }
                    return true;
                }
            case '[object Uint16Array]':
            case '[object Uint8Array]':
            case '[object Uint32Array]':
            case '[object Int32Array]':
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object ArrayBuffer]':
                a = new Uint8Array(a);
                b = new Uint8Array(b);
            case '[object DataView]':
                {
                    let len = a.byteLength;
                    if (len === b.byteLength) {
                        while(len-- && a[len] === b[len]){}
                    }
                    return len === -1;
                }
            case '[object AsyncFunction]':
            case '[object GeneratorFunction]':
            case '[object AsyncGeneratorFunction]':
            case '[object Function]':
                {
                    const aCode = fnToStr.call(a);
                    if (aCode !== fnToStr.call(b)) {
                        return false;
                    }
                    return !endsWith(aCode, nativeCodeSuffix);
                }
        }
        return false;
    }
    function definedKeys(obj) {
        return Object.keys(obj).filter(isDefinedKey, obj);
    }
    function isDefinedKey(key) {
        return this[key] !== void 0;
    }
    const nativeCodeSuffix = "{ [native code] }";
    function endsWith(full, suffix) {
        const fromIndex = full.length - suffix.length;
        return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
    }
    function previouslyCompared(a, b) {
        let bSet = previousComparisons.get(a);
        if (bSet) {
            if (bSet.has(b)) return true;
        } else {
            previousComparisons.set(a, bSet = new Set);
        }
        bSet.add(b);
        return false;
    }
    const lib$1 = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: equal,
        equal
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    const require$$4$1 = getAugmentedNamespace(lib$1);
    const require$$1$1 = getAugmentedNamespace(utilities$1);
    function equalByQuery(query, _a, _b, variables) {
        var aData = _a.data, aRest = __rest(_a, [
            "data"
        ]);
        var bData = _b.data, bRest = __rest(_b, [
            "data"
        ]);
        return (equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
            fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
            variables: variables
        }));
    }
    function equalBySelectionSet(selectionSet, aResult, bResult, context) {
        if (aResult === bResult) {
            return true;
        }
        var seenSelections = new Set();
        return selectionSet.selections.every(function(selection) {
            if (seenSelections.has(selection)) return true;
            seenSelections.add(selection);
            if (!shouldInclude(selection, context.variables)) return true;
            if (selectionHasNonreactiveDirective(selection)) return true;
            if (isField(selection)) {
                var resultKey = resultKeyNameFromField(selection);
                var aResultChild = aResult && aResult[resultKey];
                var bResultChild = bResult && bResult[resultKey];
                var childSelectionSet = selection.selectionSet;
                if (!childSelectionSet) {
                    return equal(aResultChild, bResultChild);
                }
                var aChildIsArray = Array.isArray(aResultChild);
                var bChildIsArray = Array.isArray(bResultChild);
                if (aChildIsArray !== bChildIsArray) return false;
                if (aChildIsArray && bChildIsArray) {
                    var length_1 = aResultChild.length;
                    if (bResultChild.length !== length_1) {
                        return false;
                    }
                    for(var i = 0; i < length_1; ++i){
                        if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
                            return false;
                        }
                    }
                    return true;
                }
                return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
            } else {
                var fragment = getFragmentFromSelection(selection, context.fragmentMap);
                if (fragment) {
                    if (selectionHasNonreactiveDirective(fragment)) return true;
                    return equalBySelectionSet(fragment.selectionSet, aResult, bResult, context);
                }
            }
        });
    }
    function selectionHasNonreactiveDirective(selection) {
        return (!!selection.directives && selection.directives.some(directiveIsNonreactive));
    }
    function directiveIsNonreactive(dir) {
        return dir.name.value === "nonreactive";
    }
    var MapImpl = canUseWeakMap ? WeakMap : Map;
    var SetImpl = canUseWeakSet ? WeakSet : Set;
    var disableWarningsSlot = new Slot();
    var issuedWarning = false;
    function warnOnImproperCacheImplementation() {
        if (!issuedWarning) {
            issuedWarning = true;
            globalThis.__DEV__ !== false && invariant$1.warn(64);
        }
    }
    function maskDefinition(data, selectionSet, context) {
        return disableWarningsSlot.withValue(true, function() {
            var masked = maskSelectionSet(data, selectionSet, context, false);
            if (Object.isFrozen(data)) {
                maybeDeepFreeze(masked);
            }
            return masked;
        });
    }
    function getMutableTarget(data, mutableTargets) {
        if (mutableTargets.has(data)) {
            return mutableTargets.get(data);
        }
        var mutableTarget = Array.isArray(data) ? [] : Object.create(null);
        mutableTargets.set(data, mutableTarget);
        return mutableTarget;
    }
    function maskSelectionSet(data, selectionSet, context, migration, path) {
        var _a;
        var knownChanged = context.knownChanged;
        var memo = getMutableTarget(data, context.mutableTargets);
        if (Array.isArray(data)) {
            for(var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++){
                var _c = _b[_i], index = _c[0], item = _c[1];
                if (item === null) {
                    memo[index] = null;
                    continue;
                }
                var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", "[").concat(index, "]") : void 0);
                if (knownChanged.has(masked)) {
                    knownChanged.add(memo);
                }
                memo[index] = masked;
            }
            return knownChanged.has(memo) ? memo : data;
        }
        for(var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++){
            var selection = _e[_d];
            var value = void 0;
            if (migration) {
                knownChanged.add(memo);
            }
            if (selection.kind === Kind.FIELD) {
                var keyName = resultKeyNameFromField(selection);
                var childSelectionSet = selection.selectionSet;
                value = memo[keyName] || data[keyName];
                if (value === void 0) {
                    continue;
                }
                if (childSelectionSet && value !== null) {
                    var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", ".").concat(keyName) : void 0);
                    if (knownChanged.has(masked)) {
                        value = masked;
                    }
                }
                if (!(globalThis.__DEV__ !== false)) {
                    memo[keyName] = value;
                }
                if (globalThis.__DEV__ !== false) {
                    if (migration && keyName !== "__typename" && !((_a = Object.getOwnPropertyDescriptor(memo, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {
                        Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || "", context.operationName, context.operationType));
                    } else {
                        delete memo[keyName];
                        memo[keyName] = value;
                    }
                }
            }
            if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {
                value = maskSelectionSet(data, selection.selectionSet, context, migration, path);
            }
            if (selection.kind === Kind.FRAGMENT_SPREAD) {
                var fragmentName = selection.name.value;
                var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));
                invariant$1(fragment, 59, fragmentName);
                var mode = getFragmentMaskMode(selection);
                if (mode !== "mask") {
                    value = maskSelectionSet(data, fragment.selectionSet, context, mode === "migrate", path);
                }
            }
            if (knownChanged.has(value)) {
                knownChanged.add(memo);
            }
        }
        if ("__typename" in data && !("__typename" in memo)) {
            memo.__typename = data.__typename;
        }
        if (Object.keys(memo).length !== Object.keys(data).length) {
            knownChanged.add(memo);
        }
        return knownChanged.has(memo) ? memo : data;
    }
    function getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {
        var getValue = function() {
            if (disableWarningsSlot.getValue()) {
                return value;
            }
            globalThis.__DEV__ !== false && invariant$1.warn(60, operationName ? "".concat(operationType, " '").concat(operationName, "'") : "anonymous ".concat(operationType), "".concat(path, ".").concat(fieldName).replace(/^\./, ""));
            getValue = function() {
                return value;
            };
            return value;
        };
        return {
            get: function() {
                return getValue();
            },
            set: function(newValue) {
                getValue = function() {
                    return newValue;
                };
            },
            enumerable: true,
            configurable: true
        };
    }
    function maskFragment(data, document, cache, fragmentName) {
        if (!cache.fragmentMatches) {
            if (globalThis.__DEV__ !== false) {
                warnOnImproperCacheImplementation();
            }
            return data;
        }
        var fragments = document.definitions.filter(function(node) {
            return node.kind === Kind.FRAGMENT_DEFINITION;
        });
        if (typeof fragmentName === "undefined") {
            invariant$1(fragments.length === 1, 61, fragments.length);
            fragmentName = fragments[0].name.value;
        }
        var fragment = fragments.find(function(fragment) {
            return fragment.name.value === fragmentName;
        });
        invariant$1(!!fragment, 62, fragmentName);
        if (data == null) {
            return data;
        }
        if (equal(data, {})) {
            return data;
        }
        return maskDefinition(data, fragment.selectionSet, {
            operationType: "fragment",
            operationName: fragment.name.value,
            fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
            cache: cache,
            mutableTargets: new MapImpl(),
            knownChanged: new SetImpl()
        });
    }
    function maskOperation(data, document, cache) {
        var _a;
        if (!cache.fragmentMatches) {
            if (globalThis.__DEV__ !== false) {
                warnOnImproperCacheImplementation();
            }
            return data;
        }
        var definition = getOperationDefinition(document);
        invariant$1(definition, 63);
        if (data == null) {
            return data;
        }
        return maskDefinition(data, definition.selectionSet, {
            operationType: definition.operation,
            operationName: (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value,
            fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
            cache: cache,
            mutableTargets: new MapImpl(),
            knownChanged: new SetImpl()
        });
    }
    const masking = Object.freeze(Object.defineProperty({
        __proto__: null,
        disableWarningsSlot,
        maskFragment,
        maskOperation
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    var ApolloCache = (function() {
        function ApolloCache() {
            this.assumeImmutableResults = false;
            this.getFragmentDoc = wrap(getFragmentQueryDocument, {
                max: cacheSizes["cache.fragmentQueryDocuments"] || 1000,
                cache: WeakCache
            });
        }
        ApolloCache.prototype.lookupFragment = function(fragmentName) {
            return null;
        };
        ApolloCache.prototype.batch = function(options) {
            var _this = this;
            var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
            var updateResult;
            this.performTransaction(function() {
                return (updateResult = options.update(_this));
            }, optimisticId);
            return updateResult;
        };
        ApolloCache.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
            this.performTransaction(transaction, optimisticId);
        };
        ApolloCache.prototype.transformDocument = function(document) {
            return document;
        };
        ApolloCache.prototype.transformForLink = function(document) {
            return document;
        };
        ApolloCache.prototype.identify = function(object) {
            return;
        };
        ApolloCache.prototype.gc = function() {
            return [];
        };
        ApolloCache.prototype.modify = function(options) {
            return false;
        };
        ApolloCache.prototype.readQuery = function(options, optimistic) {
            var _this = this;
            if (optimistic === void 0) {
                optimistic = !!options.optimistic;
            }
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(options, "canonizeResults", "cache.readQuery");
            }
            return muteDeprecations("canonizeResults", function() {
                return _this.read(__assign(__assign({}, options), {
                    rootId: options.id || "ROOT_QUERY",
                    optimistic: optimistic
                }));
            });
        };
        ApolloCache.prototype.watchFragment = function(options) {
            var _this = this;
            var fragment = options.fragment, fragmentName = options.fragmentName, from = options.from, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, otherOptions = __rest(options, [
                "fragment",
                "fragmentName",
                "from",
                "optimistic"
            ]);
            var query = this.getFragmentDoc(fragment, fragmentName);
            var id = typeof from === "undefined" || typeof from === "string" ? from : this.identify(from);
            var dataMasking = !!options[Symbol.for("apollo.dataMasking")];
            if (globalThis.__DEV__ !== false) {
                var actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;
                if (!id) {
                    globalThis.__DEV__ !== false && invariant$1.warn(1, actualFragmentName);
                }
            }
            var diffOptions = __assign(__assign({}, otherOptions), {
                returnPartialData: true,
                id: id,
                query: query,
                optimistic: optimistic
            });
            var latestDiff;
            return new Observable(function(observer) {
                return _this.watch(__assign(__assign({}, diffOptions), {
                    immediate: true,
                    callback: function(diff) {
                        var data = dataMasking ? maskFragment(diff.result, fragment, _this, fragmentName) : diff.result;
                        if (latestDiff && equalByQuery(query, {
                            data: latestDiff.result
                        }, {
                            data: data
                        }, options.variables)) {
                            return;
                        }
                        var result = {
                            data: data,
                            complete: !!diff.complete
                        };
                        if (diff.missing) {
                            result.missing = mergeDeepArray(diff.missing.map(function(error) {
                                return error.missing;
                            }));
                        }
                        latestDiff = __assign(__assign({}, diff), {
                            result: data
                        });
                        observer.next(result);
                    }
                }));
            });
        };
        ApolloCache.prototype.readFragment = function(options, optimistic) {
            var _this = this;
            if (optimistic === void 0) {
                optimistic = !!options.optimistic;
            }
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(options, "canonizeResults", "cache.readFragment");
            }
            return muteDeprecations("canonizeResults", function() {
                return _this.read(__assign(__assign({}, options), {
                    query: _this.getFragmentDoc(options.fragment, options.fragmentName),
                    rootId: options.id,
                    optimistic: optimistic
                }));
            });
        };
        ApolloCache.prototype.writeQuery = function(_a) {
            var id = _a.id, data = _a.data, options = __rest(_a, [
                "id",
                "data"
            ]);
            return this.write(Object.assign(options, {
                dataId: id || "ROOT_QUERY",
                result: data
            }));
        };
        ApolloCache.prototype.writeFragment = function(_a) {
            var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = __rest(_a, [
                "id",
                "data",
                "fragment",
                "fragmentName"
            ]);
            return this.write(Object.assign(options, {
                query: this.getFragmentDoc(fragment, fragmentName),
                dataId: id,
                result: data
            }));
        };
        ApolloCache.prototype.updateQuery = function(options, update) {
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(options, "canonizeResults", "cache.updateQuery");
            }
            return this.batch({
                update: function(cache) {
                    var value = muteDeprecations("canonizeResults", function() {
                        return cache.readQuery(options);
                    });
                    var data = update(value);
                    if (data === void 0 || data === null) return value;
                    cache.writeQuery(__assign(__assign({}, options), {
                        data: data
                    }));
                    return data;
                }
            });
        };
        ApolloCache.prototype.updateFragment = function(options, update) {
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(options, "canonizeResults", "cache.updateFragment");
            }
            return this.batch({
                update: function(cache) {
                    var value = muteDeprecations("canonizeResults", function() {
                        return cache.readFragment(options);
                    });
                    var data = update(value);
                    if (data === void 0 || data === null) return value;
                    cache.writeFragment(__assign(__assign({}, options), {
                        data: data
                    }));
                    return data;
                }
            });
        };
        return ApolloCache;
    }());
    if (globalThis.__DEV__ !== false) {
        ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
    }
    var Cache;
    (function(Cache) {})(Cache || (Cache = {}));
    var MissingFieldError = (function(_super) {
        __extends(MissingFieldError, _super);
        function MissingFieldError(message, path, query, variables) {
            var _a;
            var _this = _super.call(this, message) || this;
            _this.message = message;
            _this.path = path;
            _this.query = query;
            _this.variables = variables;
            if (Array.isArray(_this.path)) {
                _this.missing = _this.message;
                for(var i = _this.path.length - 1; i >= 0; --i){
                    _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);
                }
            } else {
                _this.missing = _this.path;
            }
            _this.__proto__ = MissingFieldError.prototype;
            return _this;
        }
        return MissingFieldError;
    }(Error));
    var hasOwn = Object.prototype.hasOwnProperty;
    function isNullish(value) {
        return value === null || value === void 0;
    }
    function defaultDataIdFromObject(_a, context) {
        var __typename = _a.__typename, id = _a.id, _id = _a._id;
        if (typeof __typename === "string") {
            if (context) {
                context.keyObject = !isNullish(id) ? {
                    id: id
                } : !isNullish(_id) ? {
                    _id: _id
                } : void 0;
            }
            if (isNullish(id) && !isNullish(_id)) {
                id = _id;
            }
            if (!isNullish(id)) {
                return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
            }
        }
    }
    var defaultConfig = {
        dataIdFromObject: defaultDataIdFromObject,
        addTypename: true,
        resultCaching: true,
        canonizeResults: false
    };
    function normalizeConfig(config) {
        return compact(defaultConfig, config);
    }
    function shouldCanonizeResults(config) {
        var value = config.canonizeResults;
        return value === void 0 ? defaultConfig.canonizeResults : value;
    }
    function getTypenameFromStoreObject(store, objectOrReference) {
        return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
    }
    var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
    function fieldNameFromStoreName(storeFieldName) {
        var match = storeFieldName.match(TypeOrFieldNameRegExp);
        return match ? match[0] : storeFieldName;
    }
    function selectionSetMatchesResult(selectionSet, result, variables) {
        if (isNonNullObject(result)) {
            return isArray(result) ? result.every(function(item) {
                return selectionSetMatchesResult(selectionSet, item, variables);
            }) : selectionSet.selections.every(function(field) {
                if (isField(field) && shouldInclude(field, variables)) {
                    var key = resultKeyNameFromField(field);
                    return (hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables)));
                }
                return true;
            });
        }
        return false;
    }
    function storeValueIsStoreObject(value) {
        return isNonNullObject(value) && !isReference(value) && !isArray(value);
    }
    function makeProcessedFieldsMerger() {
        return new DeepMerger();
    }
    function extractFragmentContext(document, fragments) {
        var fragmentMap = createFragmentMap(getFragmentDefinitions(document));
        return {
            fragmentMap: fragmentMap,
            lookupFragment: function(name) {
                var def = fragmentMap[name];
                if (!def && fragments) {
                    def = fragments.lookup(name);
                }
                return def || null;
            }
        };
    }
    var DELETE = Object.create(null);
    var delModifier = function() {
        return DELETE;
    };
    var INVALIDATE = Object.create(null);
    var EntityStore = (function() {
        function EntityStore(policies, group) {
            var _this = this;
            this.policies = policies;
            this.group = group;
            this.data = Object.create(null);
            this.rootIds = Object.create(null);
            this.refs = Object.create(null);
            this.getFieldValue = function(objectOrReference, storeFieldName) {
                return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
            };
            this.canRead = function(objOrRef) {
                return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
            };
            this.toReference = function(objOrIdOrRef, mergeIntoStore) {
                if (typeof objOrIdOrRef === "string") {
                    return makeReference(objOrIdOrRef);
                }
                if (isReference(objOrIdOrRef)) {
                    return objOrIdOrRef;
                }
                var id = _this.policies.identify(objOrIdOrRef)[0];
                if (id) {
                    var ref = makeReference(id);
                    if (mergeIntoStore) {
                        _this.merge(id, objOrIdOrRef);
                    }
                    return ref;
                }
            };
        }
        EntityStore.prototype.toObject = function() {
            return __assign({}, this.data);
        };
        EntityStore.prototype.has = function(dataId) {
            return this.lookup(dataId, true) !== void 0;
        };
        EntityStore.prototype.get = function(dataId, fieldName) {
            this.group.depend(dataId, fieldName);
            if (hasOwn.call(this.data, dataId)) {
                var storeObject = this.data[dataId];
                if (storeObject && hasOwn.call(storeObject, fieldName)) {
                    return storeObject[fieldName];
                }
            }
            if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
                return this.policies.rootTypenamesById[dataId];
            }
            if (this instanceof Layer) {
                return this.parent.get(dataId, fieldName);
            }
        };
        EntityStore.prototype.lookup = function(dataId, dependOnExistence) {
            if (dependOnExistence) this.group.depend(dataId, "__exists");
            if (hasOwn.call(this.data, dataId)) {
                return this.data[dataId];
            }
            if (this instanceof Layer) {
                return this.parent.lookup(dataId, dependOnExistence);
            }
            if (this.policies.rootTypenamesById[dataId]) {
                return Object.create(null);
            }
        };
        EntityStore.prototype.merge = function(older, newer) {
            var _this = this;
            var dataId;
            if (isReference(older)) older = older.__ref;
            if (isReference(newer)) newer = newer.__ref;
            var existing = typeof older === "string" ? this.lookup((dataId = older)) : older;
            var incoming = typeof newer === "string" ? this.lookup((dataId = newer)) : newer;
            if (!incoming) return;
            invariant$1(typeof dataId === "string", 2);
            var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
            this.data[dataId] = merged;
            if (merged !== existing) {
                delete this.refs[dataId];
                if (this.group.caching) {
                    var fieldsToDirty_1 = Object.create(null);
                    if (!existing) fieldsToDirty_1.__exists = 1;
                    Object.keys(incoming).forEach(function(storeFieldName) {
                        if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                            fieldsToDirty_1[storeFieldName] = 1;
                            var fieldName = fieldNameFromStoreName(storeFieldName);
                            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                                fieldsToDirty_1[fieldName] = 1;
                            }
                            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                                delete merged[storeFieldName];
                            }
                        }
                    });
                    if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
                        delete fieldsToDirty_1.__typename;
                    }
                    Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
                        return _this.group.dirty(dataId, fieldName);
                    });
                }
            }
        };
        EntityStore.prototype.modify = function(dataId, fields) {
            var _this = this;
            var storeObject = this.lookup(dataId);
            if (storeObject) {
                var changedFields_1 = Object.create(null);
                var needToMerge_1 = false;
                var allDeleted_1 = true;
                var sharedDetails_1 = {
                    DELETE: DELETE,
                    INVALIDATE: INVALIDATE,
                    isReference: isReference,
                    toReference: this.toReference,
                    canRead: this.canRead,
                    readField: function(fieldNameOrOptions, from) {
                        return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                            fieldName: fieldNameOrOptions,
                            from: from || makeReference(dataId)
                        } : fieldNameOrOptions, {
                            store: _this
                        });
                    }
                };
                Object.keys(storeObject).forEach(function(storeFieldName) {
                    var fieldName = fieldNameFromStoreName(storeFieldName);
                    var fieldValue = storeObject[storeFieldName];
                    if (fieldValue === void 0) return;
                    var modify = typeof fields === "function" ? fields : (fields[storeFieldName] || fields[fieldName]);
                    if (modify) {
                        var newValue = modify === delModifier ? DELETE : (modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), {
                            fieldName: fieldName,
                            storeFieldName: storeFieldName,
                            storage: _this.getStorage(dataId, storeFieldName)
                        })));
                        if (newValue === INVALIDATE) {
                            _this.group.dirty(dataId, storeFieldName);
                        } else {
                            if (newValue === DELETE) newValue = void 0;
                            if (newValue !== fieldValue) {
                                changedFields_1[storeFieldName] = newValue;
                                needToMerge_1 = true;
                                fieldValue = newValue;
                                if (globalThis.__DEV__ !== false) {
                                    var checkReference = function(ref) {
                                        if (_this.lookup(ref.__ref) === undefined) {
                                            globalThis.__DEV__ !== false && invariant$1.warn(3, ref);
                                            return true;
                                        }
                                    };
                                    if (isReference(newValue)) {
                                        checkReference(newValue);
                                    } else if (Array.isArray(newValue)) {
                                        var seenReference = false;
                                        var someNonReference = void 0;
                                        for(var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++){
                                            var value = newValue_1[_i];
                                            if (isReference(value)) {
                                                seenReference = true;
                                                if (checkReference(value)) break;
                                            } else {
                                                if (typeof value === "object" && !!value) {
                                                    var id = _this.policies.identify(value)[0];
                                                    if (id) {
                                                        someNonReference = value;
                                                    }
                                                }
                                            }
                                            if (seenReference && someNonReference !== undefined) {
                                                globalThis.__DEV__ !== false && invariant$1.warn(4, someNonReference);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (fieldValue !== void 0) {
                        allDeleted_1 = false;
                    }
                });
                if (needToMerge_1) {
                    this.merge(dataId, changedFields_1);
                    if (allDeleted_1) {
                        if (this instanceof Layer) {
                            this.data[dataId] = void 0;
                        } else {
                            delete this.data[dataId];
                        }
                        this.group.dirty(dataId, "__exists");
                    }
                    return true;
                }
            }
            return false;
        };
        EntityStore.prototype.delete = function(dataId, fieldName, args) {
            var _a;
            var storeObject = this.lookup(dataId);
            if (storeObject) {
                var typename = this.getFieldValue(storeObject, "__typename");
                var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({
                    typename: typename,
                    fieldName: fieldName,
                    args: args
                }) : fieldName;
                return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);
            }
            return false;
        };
        EntityStore.prototype.evict = function(options, limit) {
            var evicted = false;
            if (options.id) {
                if (hasOwn.call(this.data, options.id)) {
                    evicted = this.delete(options.id, options.fieldName, options.args);
                }
                if (this instanceof Layer && this !== limit) {
                    evicted = this.parent.evict(options, limit) || evicted;
                }
                if (options.fieldName || evicted) {
                    this.group.dirty(options.id, options.fieldName || "__exists");
                }
            }
            return evicted;
        };
        EntityStore.prototype.clear = function() {
            this.replace(null);
        };
        EntityStore.prototype.extract = function() {
            var _this = this;
            var obj = this.toObject();
            var extraRootIds = [];
            this.getRootIdSet().forEach(function(id) {
                if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
                    extraRootIds.push(id);
                }
            });
            if (extraRootIds.length) {
                obj.__META = {
                    extraRootIds: extraRootIds.sort()
                };
            }
            return obj;
        };
        EntityStore.prototype.replace = function(newData) {
            var _this = this;
            Object.keys(this.data).forEach(function(dataId) {
                if (!(newData && hasOwn.call(newData, dataId))) {
                    _this.delete(dataId);
                }
            });
            if (newData) {
                var __META = newData.__META, rest_1 = __rest(newData, [
                    "__META"
                ]);
                Object.keys(rest_1).forEach(function(dataId) {
                    _this.merge(dataId, rest_1[dataId]);
                });
                if (__META) {
                    __META.extraRootIds.forEach(this.retain, this);
                }
            }
        };
        EntityStore.prototype.retain = function(rootId) {
            return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);
        };
        EntityStore.prototype.release = function(rootId) {
            if (this.rootIds[rootId] > 0) {
                var count = --this.rootIds[rootId];
                if (!count) delete this.rootIds[rootId];
                return count;
            }
            return 0;
        };
        EntityStore.prototype.getRootIdSet = function(ids) {
            if (ids === void 0) {
                ids = new Set();
            }
            Object.keys(this.rootIds).forEach(ids.add, ids);
            if (this instanceof Layer) {
                this.parent.getRootIdSet(ids);
            } else {
                Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
            }
            return ids;
        };
        EntityStore.prototype.gc = function() {
            var _this = this;
            var ids = this.getRootIdSet();
            var snapshot = this.toObject();
            ids.forEach(function(id) {
                if (hasOwn.call(snapshot, id)) {
                    Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
                    delete snapshot[id];
                }
            });
            var idsToRemove = Object.keys(snapshot);
            if (idsToRemove.length) {
                var root_1 = this;
                while(root_1 instanceof Layer)root_1 = root_1.parent;
                idsToRemove.forEach(function(id) {
                    return root_1.delete(id);
                });
            }
            return idsToRemove;
        };
        EntityStore.prototype.findChildRefIds = function(dataId) {
            if (!hasOwn.call(this.refs, dataId)) {
                var found_1 = (this.refs[dataId] = Object.create(null));
                var root = this.data[dataId];
                if (!root) return found_1;
                var workSet_1 = new Set([
                    root
                ]);
                workSet_1.forEach(function(obj) {
                    if (isReference(obj)) {
                        found_1[obj.__ref] = true;
                    }
                    if (isNonNullObject(obj)) {
                        Object.keys(obj).forEach(function(key) {
                            var child = obj[key];
                            if (isNonNullObject(child)) {
                                workSet_1.add(child);
                            }
                        });
                    }
                });
            }
            return this.refs[dataId];
        };
        EntityStore.prototype.makeCacheKey = function() {
            return this.group.keyMaker.lookupArray(arguments);
        };
        return EntityStore;
    }());
    var CacheGroup = (function() {
        function CacheGroup(caching, parent) {
            if (parent === void 0) {
                parent = null;
            }
            this.caching = caching;
            this.parent = parent;
            this.d = null;
            this.resetCaching();
        }
        CacheGroup.prototype.resetCaching = function() {
            this.d = this.caching ? dep() : null;
            this.keyMaker = new Trie(canUseWeakMap);
        };
        CacheGroup.prototype.depend = function(dataId, storeFieldName) {
            if (this.d) {
                this.d(makeDepKey(dataId, storeFieldName));
                var fieldName = fieldNameFromStoreName(storeFieldName);
                if (fieldName !== storeFieldName) {
                    this.d(makeDepKey(dataId, fieldName));
                }
                if (this.parent) {
                    this.parent.depend(dataId, storeFieldName);
                }
            }
        };
        CacheGroup.prototype.dirty = function(dataId, storeFieldName) {
            if (this.d) {
                this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
            }
        };
        return CacheGroup;
    }());
    function makeDepKey(dataId, storeFieldName) {
        return storeFieldName + "#" + dataId;
    }
    function maybeDependOnExistenceOfEntity(store, entityId) {
        if (supportsResultCaching(store)) {
            store.group.depend(entityId, "__exists");
        }
    }
    (function(EntityStore) {
        var Root = (function(_super) {
            __extends(Root, _super);
            function Root(_a) {
                var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
                var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
                _this.stump = new Stump(_this);
                _this.storageTrie = new Trie(canUseWeakMap);
                if (seed) _this.replace(seed);
                return _this;
            }
            Root.prototype.addLayer = function(layerId, replay) {
                return this.stump.addLayer(layerId, replay);
            };
            Root.prototype.removeLayer = function() {
                return this;
            };
            Root.prototype.getStorage = function() {
                return this.storageTrie.lookupArray(arguments);
            };
            return Root;
        }(EntityStore));
        EntityStore.Root = Root;
    })(EntityStore || (EntityStore = {}));
    var Layer = (function(_super) {
        __extends(Layer, _super);
        function Layer(id, parent, replay, group) {
            var _this = _super.call(this, parent.policies, group) || this;
            _this.id = id;
            _this.parent = parent;
            _this.replay = replay;
            _this.group = group;
            replay(_this);
            return _this;
        }
        Layer.prototype.addLayer = function(layerId, replay) {
            return new Layer(layerId, this, replay, this.group);
        };
        Layer.prototype.removeLayer = function(layerId) {
            var _this = this;
            var parent = this.parent.removeLayer(layerId);
            if (layerId === this.id) {
                if (this.group.caching) {
                    Object.keys(this.data).forEach(function(dataId) {
                        var ownStoreObject = _this.data[dataId];
                        var parentStoreObject = parent["lookup"](dataId);
                        if (!parentStoreObject) {
                            _this.delete(dataId);
                        } else if (!ownStoreObject) {
                            _this.group.dirty(dataId, "__exists");
                            Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                                _this.group.dirty(dataId, storeFieldName);
                            });
                        } else if (ownStoreObject !== parentStoreObject) {
                            Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                                if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                                    _this.group.dirty(dataId, storeFieldName);
                                }
                            });
                        }
                    });
                }
                return parent;
            }
            if (parent === this.parent) return this;
            return parent.addLayer(this.id, this.replay);
        };
        Layer.prototype.toObject = function() {
            return __assign(__assign({}, this.parent.toObject()), this.data);
        };
        Layer.prototype.findChildRefIds = function(dataId) {
            var fromParent = this.parent.findChildRefIds(dataId);
            return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
        };
        Layer.prototype.getStorage = function() {
            var p = this.parent;
            while(p.parent)p = p.parent;
            return p.getStorage.apply(p, arguments);
        };
        return Layer;
    }(EntityStore));
    var Stump = (function(_super) {
        __extends(Stump, _super);
        function Stump(root) {
            return _super.call(this, "EntityStore.Stump", root, function() {}, new CacheGroup(root.group.caching, root.group)) || this;
        }
        Stump.prototype.removeLayer = function() {
            return this;
        };
        Stump.prototype.merge = function(older, newer) {
            return this.parent.merge(older, newer);
        };
        return Stump;
    }(Layer));
    function storeObjectReconciler(existingObject, incomingObject, property) {
        var existingValue = existingObject[property];
        var incomingValue = incomingObject[property];
        return equal(existingValue, incomingValue) ? existingValue : incomingValue;
    }
    function supportsResultCaching(store) {
        return !!(store instanceof EntityStore && store.group.caching);
    }
    function shallowCopy(value) {
        if (isNonNullObject(value)) {
            return isArray(value) ? value.slice(0) : __assign({
                __proto__: Object.getPrototypeOf(value)
            }, value);
        }
        return value;
    }
    var ObjectCanon = (function() {
        function ObjectCanon() {
            this.known = new (canUseWeakSet ? WeakSet : Set)();
            this.pool = new Trie(canUseWeakMap);
            this.passes = new WeakMap();
            this.keysByJSON = new Map();
            this.empty = this.admit({});
        }
        ObjectCanon.prototype.isKnown = function(value) {
            return isNonNullObject(value) && this.known.has(value);
        };
        ObjectCanon.prototype.pass = function(value) {
            if (isNonNullObject(value)) {
                var copy = shallowCopy(value);
                this.passes.set(copy, value);
                return copy;
            }
            return value;
        };
        ObjectCanon.prototype.admit = function(value) {
            var _this = this;
            if (isNonNullObject(value)) {
                var original = this.passes.get(value);
                if (original) return original;
                var proto = Object.getPrototypeOf(value);
                switch(proto){
                    case Array.prototype:
                        {
                            if (this.known.has(value)) return value;
                            var array = value.map(this.admit, this);
                            var node = this.pool.lookupArray(array);
                            if (!node.array) {
                                this.known.add((node.array = array));
                                if (globalThis.__DEV__ !== false) {
                                    Object.freeze(array);
                                }
                            }
                            return node.array;
                        }
                    case null:
                    case Object.prototype:
                        {
                            if (this.known.has(value)) return value;
                            var proto_1 = Object.getPrototypeOf(value);
                            var array_1 = [
                                proto_1
                            ];
                            var keys = this.sortedKeys(value);
                            array_1.push(keys.json);
                            var firstValueIndex_1 = array_1.length;
                            keys.sorted.forEach(function(key) {
                                array_1.push(_this.admit(value[key]));
                            });
                            var node = this.pool.lookupArray(array_1);
                            if (!node.object) {
                                var obj_1 = (node.object = Object.create(proto_1));
                                this.known.add(obj_1);
                                keys.sorted.forEach(function(key, i) {
                                    obj_1[key] = array_1[firstValueIndex_1 + i];
                                });
                                if (globalThis.__DEV__ !== false) {
                                    Object.freeze(obj_1);
                                }
                            }
                            return node.object;
                        }
                }
            }
            return value;
        };
        ObjectCanon.prototype.sortedKeys = function(obj) {
            var keys = Object.keys(obj);
            var node = this.pool.lookupArray(keys);
            if (!node.keys) {
                keys.sort();
                var json = JSON.stringify(keys);
                if (!(node.keys = this.keysByJSON.get(json))) {
                    this.keysByJSON.set(json, (node.keys = {
                        sorted: keys,
                        json: json
                    }));
                }
            }
            return node.keys;
        };
        return ObjectCanon;
    }());
    function execSelectionSetKeyArgs(options) {
        return [
            options.selectionSet,
            options.objectOrReference,
            options.context,
            options.context.canonizeResults
        ];
    }
    var StoreReader = (function() {
        function StoreReader(config) {
            var _this = this;
            this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
            this.config = compact(config, {
                addTypename: config.addTypename !== false,
                canonizeResults: shouldCanonizeResults(config)
            });
            this.canon = config.canon || new ObjectCanon();
            this.executeSelectionSet = wrap(function(options) {
                var _a;
                var canonizeResults = options.context.canonizeResults;
                var peekArgs = execSelectionSetKeyArgs(options);
                peekArgs[3] = !canonizeResults;
                var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);
                if (other) {
                    if (canonizeResults) {
                        return __assign(__assign({}, other), {
                            result: _this.canon.admit(other.result)
                        });
                    }
                    return other;
                }
                maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
                return _this.execSelectionSetImpl(options);
            }, {
                max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSelectionSet"] || 50000,
                keyArgs: execSelectionSetKeyArgs,
                makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
                    if (supportsResultCaching(context.store)) {
                        return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
                    }
                }
            });
            this.executeSubSelectedArray = wrap(function(options) {
                maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
                return _this.execSubSelectedArrayImpl(options);
            }, {
                max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSubSelectedArray"] || 10000,
                makeCacheKey: function(_a) {
                    var field = _a.field, array = _a.array, context = _a.context;
                    if (supportsResultCaching(context.store)) {
                        return context.store.makeCacheKey(field, array, context.varString);
                    }
                }
            });
        }
        StoreReader.prototype.resetCanon = function() {
            this.canon = new ObjectCanon();
        };
        StoreReader.prototype.diffQueryAgainstStore = function(_a) {
            var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
            var policies = this.config.cache.policies;
            variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
            var rootRef = makeReference(rootId);
            var execResult = this.executeSelectionSet({
                selectionSet: getMainDefinition(query).selectionSet,
                objectOrReference: rootRef,
                enclosingRef: rootRef,
                context: __assign({
                    store: store,
                    query: query,
                    policies: policies,
                    variables: variables,
                    varString: canonicalStringify(variables),
                    canonizeResults: canonizeResults
                }, extractFragmentContext(query, this.config.fragments))
            });
            var missing;
            if (execResult.missing) {
                missing = [
                    new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
                ];
                if (!returnPartialData) {
                    throw missing[0];
                }
            }
            return {
                result: execResult.result,
                complete: !missing,
                missing: missing
            };
        };
        StoreReader.prototype.isFresh = function(result, parent, selectionSet, context) {
            if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {
                var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));
                if (latest && result === latest.result) {
                    return true;
                }
            }
            return false;
        };
        StoreReader.prototype.execSelectionSetImpl = function(_a) {
            var _this = this;
            var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;
            if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
                return {
                    result: this.canon.empty,
                    missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
                };
            }
            var variables = context.variables, policies = context.policies, store = context.store;
            var typename = store.getFieldValue(objectOrReference, "__typename");
            var objectsToMerge = [];
            var missing;
            var missingMerger = new DeepMerger();
            if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
                objectsToMerge.push({
                    __typename: typename
                });
            }
            function handleMissing(result, resultName) {
                var _a;
                if (result.missing) {
                    missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));
                }
                return result.result;
            }
            var workSet = new Set(selectionSet.selections);
            workSet.forEach(function(selection) {
                var _a, _b;
                if (!shouldInclude(selection, variables)) return;
                if (isField(selection)) {
                    var fieldValue = policies.readField({
                        fieldName: selection.name.value,
                        field: selection,
                        variables: context.variables,
                        from: objectOrReference
                    }, context);
                    var resultName = resultKeyNameFromField(selection);
                    if (fieldValue === void 0) {
                        if (!addTypenameToDocument.added(selection)) {
                            missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a));
                        }
                    } else if (isArray(fieldValue)) {
                        if (fieldValue.length > 0) {
                            fieldValue = handleMissing(_this.executeSubSelectedArray({
                                field: selection,
                                array: fieldValue,
                                enclosingRef: enclosingRef,
                                context: context
                            }), resultName);
                        }
                    } else if (!selection.selectionSet) {
                        if (context.canonizeResults) {
                            fieldValue = _this.canon.pass(fieldValue);
                        }
                    } else if (fieldValue != null) {
                        fieldValue = handleMissing(_this.executeSelectionSet({
                            selectionSet: selection.selectionSet,
                            objectOrReference: fieldValue,
                            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
                            context: context
                        }), resultName);
                    }
                    if (fieldValue !== void 0) {
                        objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
                    }
                } else {
                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);
                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
                        throw newInvariantError(10, selection.name.value);
                    }
                    if (fragment && policies.fragmentMatches(fragment, typename)) {
                        fragment.selectionSet.selections.forEach(workSet.add, workSet);
                    }
                }
            });
            var result = mergeDeepArray(objectsToMerge);
            var finalResult = {
                result: result,
                missing: missing
            };
            var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
            if (frozen.result) {
                this.knownResults.set(frozen.result, selectionSet);
            }
            return frozen;
        };
        StoreReader.prototype.execSubSelectedArrayImpl = function(_a) {
            var _this = this;
            var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;
            var missing;
            var missingMerger = new DeepMerger();
            function handleMissing(childResult, i) {
                var _a;
                if (childResult.missing) {
                    missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));
                }
                return childResult.result;
            }
            if (field.selectionSet) {
                array = array.filter(context.store.canRead);
            }
            array = array.map(function(item, i) {
                if (item === null) {
                    return null;
                }
                if (isArray(item)) {
                    return handleMissing(_this.executeSubSelectedArray({
                        field: field,
                        array: item,
                        enclosingRef: enclosingRef,
                        context: context
                    }), i);
                }
                if (field.selectionSet) {
                    return handleMissing(_this.executeSelectionSet({
                        selectionSet: field.selectionSet,
                        objectOrReference: item,
                        enclosingRef: isReference(item) ? item : enclosingRef,
                        context: context
                    }), i);
                }
                if (globalThis.__DEV__ !== false) {
                    assertSelectionSetForIdValue(context.store, field, item);
                }
                return item;
            });
            return {
                result: context.canonizeResults ? this.canon.admit(array) : array,
                missing: missing
            };
        };
        return StoreReader;
    }());
    function firstMissing(tree) {
        try {
            JSON.stringify(tree, function(_, value) {
                if (typeof value === "string") throw value;
                return value;
            });
        } catch (result) {
            return result;
        }
    }
    function assertSelectionSetForIdValue(store, field, fieldValue) {
        if (!field.selectionSet) {
            var workSet_1 = new Set([
                fieldValue
            ]);
            workSet_1.forEach(function(value) {
                if (isNonNullObject(value)) {
                    invariant$1(!isReference(value), 11, getTypenameFromStoreObject(store, value), field.name.value);
                    Object.values(value).forEach(workSet_1.add, workSet_1);
                }
            });
        }
    }
    var cacheSlot = new Slot();
    var cacheInfoMap = new WeakMap();
    function getCacheInfo(cache) {
        var info = cacheInfoMap.get(cache);
        if (!info) {
            cacheInfoMap.set(cache, (info = {
                vars: new Set(),
                dep: dep()
            }));
        }
        return info;
    }
    function forgetCache(cache) {
        getCacheInfo(cache).vars.forEach(function(rv) {
            return rv.forgetCache(cache);
        });
    }
    function recallCache(cache) {
        getCacheInfo(cache).vars.forEach(function(rv) {
            return rv.attachCache(cache);
        });
    }
    function makeVar(value) {
        var caches = new Set();
        var listeners = new Set();
        var rv = function(newValue) {
            if (arguments.length > 0) {
                if (value !== newValue) {
                    value = newValue;
                    caches.forEach(function(cache) {
                        getCacheInfo(cache).dep.dirty(rv);
                        broadcast(cache);
                    });
                    var oldListeners = Array.from(listeners);
                    listeners.clear();
                    oldListeners.forEach(function(listener) {
                        return listener(value);
                    });
                }
            } else {
                var cache = cacheSlot.getValue();
                if (cache) {
                    attach(cache);
                    getCacheInfo(cache).dep(rv);
                }
            }
            return value;
        };
        rv.onNextChange = function(listener) {
            listeners.add(listener);
            return function() {
                listeners.delete(listener);
            };
        };
        var attach = (rv.attachCache = function(cache) {
            caches.add(cache);
            getCacheInfo(cache).vars.add(rv);
            return rv;
        });
        rv.forgetCache = function(cache) {
            return caches.delete(cache);
        };
        return rv;
    }
    function broadcast(cache) {
        if (cache.broadcastWatches) {
            cache.broadcastWatches();
        }
    }
    var specifierInfoCache = Object.create(null);
    function lookupSpecifierInfo(spec) {
        var cacheKey = JSON.stringify(spec);
        return (specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = Object.create(null)));
    }
    function keyFieldsFnFromSpecifier(specifier) {
        var info = lookupSpecifierInfo(specifier);
        return (info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
            var extract = function(from, key) {
                return context.readField(key, from);
            };
            var keyObject = (context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
                var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);
                if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
                    extracted = extractKeyPath(object, schemaKeyPath, extractKey);
                }
                invariant$1(extracted !== void 0, 5, schemaKeyPath.join("."), object);
                return extracted;
            }));
            return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
        }));
    }
    function keyArgsFnFromSpecifier(specifier) {
        var info = lookupSpecifierInfo(specifier);
        return (info.keyArgsFn || (info.keyArgsFn = function(args, _a) {
            var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;
            var collected = collectSpecifierPaths(specifier, function(keyPath) {
                var firstKey = keyPath[0];
                var firstChar = firstKey.charAt(0);
                if (firstChar === "@") {
                    if (field && isNonEmptyArray(field.directives)) {
                        var directiveName_1 = firstKey.slice(1);
                        var d = field.directives.find(function(d) {
                            return d.name.value === directiveName_1;
                        });
                        var directiveArgs = d && argumentsObjectFromField(d, variables);
                        return (directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1)));
                    }
                    return;
                }
                if (firstChar === "$") {
                    var variableName = firstKey.slice(1);
                    if (variables && hasOwn.call(variables, variableName)) {
                        var varKeyPath = keyPath.slice(0);
                        varKeyPath[0] = variableName;
                        return extractKeyPath(variables, varKeyPath);
                    }
                    return;
                }
                if (args) {
                    return extractKeyPath(args, keyPath);
                }
            });
            var suffix = JSON.stringify(collected);
            if (args || suffix !== "{}") {
                fieldName += ":" + suffix;
            }
            return fieldName;
        }));
    }
    function collectSpecifierPaths(specifier, extractor) {
        var merger = new DeepMerger();
        return getSpecifierPaths(specifier).reduce(function(collected, path) {
            var _a;
            var toMerge = extractor(path);
            if (toMerge !== void 0) {
                for(var i = path.length - 1; i >= 0; --i){
                    toMerge = (_a = {}, _a[path[i]] = toMerge, _a);
                }
                collected = merger.merge(collected, toMerge);
            }
            return collected;
        }, Object.create(null));
    }
    function getSpecifierPaths(spec) {
        var info = lookupSpecifierInfo(spec);
        if (!info.paths) {
            var paths_1 = (info.paths = []);
            var currentPath_1 = [];
            spec.forEach(function(s, i) {
                if (isArray(s)) {
                    getSpecifierPaths(s).forEach(function(p) {
                        return paths_1.push(currentPath_1.concat(p));
                    });
                    currentPath_1.length = 0;
                } else {
                    currentPath_1.push(s);
                    if (!isArray(spec[i + 1])) {
                        paths_1.push(currentPath_1.slice(0));
                        currentPath_1.length = 0;
                    }
                }
            });
        }
        return info.paths;
    }
    function extractKey(object, key) {
        return object[key];
    }
    function extractKeyPath(object, path, extract) {
        extract = extract || extractKey;
        return normalize$1(path.reduce(function reducer(obj, key) {
            return isArray(obj) ? obj.map(function(child) {
                return reducer(child, key);
            }) : obj && extract(obj, key);
        }, object));
    }
    function normalize$1(value) {
        if (isNonNullObject(value)) {
            if (isArray(value)) {
                return value.map(normalize$1);
            }
            return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
                return extractKeyPath(value, path);
            });
        }
        return value;
    }
    function argsFromFieldSpecifier(spec) {
        return (spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null);
    }
    var nullKeyFieldsFn = function() {
        return void 0;
    };
    var simpleKeyArgsFn = function(_args, context) {
        return context.fieldName;
    };
    var mergeTrueFn = function(existing, incoming, _a) {
        var mergeObjects = _a.mergeObjects;
        return mergeObjects(existing, incoming);
    };
    var mergeFalseFn = function(_, incoming) {
        return incoming;
    };
    var Policies = (function() {
        function Policies(config) {
            this.config = config;
            this.typePolicies = Object.create(null);
            this.toBeAdded = Object.create(null);
            this.supertypeMap = new Map();
            this.fuzzySubtypes = new Map();
            this.rootIdsByTypename = Object.create(null);
            this.rootTypenamesById = Object.create(null);
            this.usingPossibleTypes = false;
            this.config = __assign({
                dataIdFromObject: defaultDataIdFromObject
            }, config);
            this.cache = this.config.cache;
            this.setRootTypename("Query");
            this.setRootTypename("Mutation");
            this.setRootTypename("Subscription");
            if (config.possibleTypes) {
                this.addPossibleTypes(config.possibleTypes);
            }
            if (config.typePolicies) {
                this.addTypePolicies(config.typePolicies);
            }
        }
        Policies.prototype.identify = function(object, partialContext) {
            var _a;
            var policies = this;
            var typename = (partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename))) || object.__typename;
            if (typename === this.rootTypenamesById.ROOT_QUERY) {
                return [
                    "ROOT_QUERY"
                ];
            }
            var storeObject = (partialContext && partialContext.storeObject) || object;
            var context = __assign(__assign({}, partialContext), {
                typename: typename,
                storeObject: storeObject,
                readField: (partialContext && partialContext.readField) || function() {
                    var options = normalizeReadFieldOptions(arguments, storeObject);
                    return policies.readField(options, {
                        store: policies.cache["data"],
                        variables: options.variables
                    });
                }
            });
            var id;
            var policy = typename && this.getTypePolicy(typename);
            var keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;
            disableWarningsSlot.withValue(true, function() {
                while(keyFn){
                    var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);
                    if (isArray(specifierOrId)) {
                        keyFn = keyFieldsFnFromSpecifier(specifierOrId);
                    } else {
                        id = specifierOrId;
                        break;
                    }
                }
            });
            id = id ? String(id) : void 0;
            return context.keyObject ? [
                id,
                context.keyObject
            ] : [
                id
            ];
        };
        Policies.prototype.addTypePolicies = function(typePolicies) {
            var _this = this;
            Object.keys(typePolicies).forEach(function(typename) {
                var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [
                    "queryType",
                    "mutationType",
                    "subscriptionType"
                ]);
                if (queryType) _this.setRootTypename("Query", typename);
                if (mutationType) _this.setRootTypename("Mutation", typename);
                if (subscriptionType) _this.setRootTypename("Subscription", typename);
                if (hasOwn.call(_this.toBeAdded, typename)) {
                    _this.toBeAdded[typename].push(incoming);
                } else {
                    _this.toBeAdded[typename] = [
                        incoming
                    ];
                }
            });
        };
        Policies.prototype.updateTypePolicy = function(typename, incoming, existingFieldPolicies) {
            var existing = this.getTypePolicy(typename);
            var keyFields = incoming.keyFields, fields = incoming.fields;
            function setMerge(existing, merge) {
                existing.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;
            }
            setMerge(existing, incoming.merge);
            existing.keyFn = keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
            if (fields) {
                Object.keys(fields).forEach(function(fieldName) {
                    var existing = existingFieldPolicies[fieldName];
                    if (!existing || (existing === null || existing === void 0 ? void 0 : existing.typename) !== typename) {
                        existing = existingFieldPolicies[fieldName] = {
                            typename: typename
                        };
                    }
                    var incoming = fields[fieldName];
                    if (typeof incoming === "function") {
                        existing.read = incoming;
                    } else {
                        var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;
                        existing.keyFn = keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing.keyFn;
                        if (typeof read === "function") {
                            existing.read = read;
                        }
                        setMerge(existing, merge);
                    }
                    if (existing.read && existing.merge) {
                        existing.keyFn = existing.keyFn || simpleKeyArgsFn;
                    }
                });
            }
        };
        Policies.prototype.setRootTypename = function(which, typename) {
            if (typename === void 0) {
                typename = which;
            }
            var rootId = "ROOT_" + which.toUpperCase();
            var old = this.rootTypenamesById[rootId];
            if (typename !== old) {
                invariant$1(!old || old === which, 6, which);
                if (old) delete this.rootIdsByTypename[old];
                this.rootIdsByTypename[typename] = rootId;
                this.rootTypenamesById[rootId] = typename;
            }
        };
        Policies.prototype.addPossibleTypes = function(possibleTypes) {
            var _this = this;
            this.usingPossibleTypes = true;
            Object.keys(possibleTypes).forEach(function(supertype) {
                _this.getSupertypeSet(supertype, true);
                possibleTypes[supertype].forEach(function(subtype) {
                    _this.getSupertypeSet(subtype, true).add(supertype);
                    var match = subtype.match(TypeOrFieldNameRegExp);
                    if (!match || match[0] !== subtype) {
                        _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
                    }
                });
            });
        };
        Policies.prototype.getTypePolicy = function(typename) {
            var _this = this;
            if (!hasOwn.call(this.typePolicies, typename)) {
                var policy_1 = (this.typePolicies[typename] = Object.create(null));
                policy_1.fields = Object.create(null);
                var supertypes_1 = this.supertypeMap.get(typename);
                if (!supertypes_1 && this.fuzzySubtypes.size) {
                    supertypes_1 = this.getSupertypeSet(typename, true);
                    this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
                        if (regExp.test(typename)) {
                            var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
                            if (fuzzySupertypes) {
                                fuzzySupertypes.forEach(function(supertype) {
                                    return supertypes_1.add(supertype);
                                });
                            }
                        }
                    });
                }
                if (supertypes_1 && supertypes_1.size) {
                    supertypes_1.forEach(function(supertype) {
                        var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [
                            "fields"
                        ]);
                        Object.assign(policy_1, rest);
                        Object.assign(policy_1.fields, fields);
                    });
                }
            }
            var inbox = this.toBeAdded[typename];
            if (inbox && inbox.length) {
                inbox.splice(0).forEach(function(policy) {
                    _this.updateTypePolicy(typename, policy, _this.typePolicies[typename].fields);
                });
            }
            return this.typePolicies[typename];
        };
        Policies.prototype.getFieldPolicy = function(typename, fieldName) {
            if (typename) {
                return this.getTypePolicy(typename).fields[fieldName];
            }
        };
        Policies.prototype.getSupertypeSet = function(subtype, createIfMissing) {
            var supertypeSet = this.supertypeMap.get(subtype);
            if (!supertypeSet && createIfMissing) {
                this.supertypeMap.set(subtype, (supertypeSet = new Set()));
            }
            return supertypeSet;
        };
        Policies.prototype.fragmentMatches = function(fragment, typename, result, variables) {
            var _this = this;
            if (!fragment.typeCondition) return true;
            if (!typename) return false;
            var supertype = fragment.typeCondition.name.value;
            if (typename === supertype) return true;
            if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
                var typenameSupertypeSet = this.getSupertypeSet(typename, true);
                var workQueue_1 = [
                    typenameSupertypeSet
                ];
                var maybeEnqueue_1 = function(subtype) {
                    var supertypeSet = _this.getSupertypeSet(subtype, false);
                    if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {
                        workQueue_1.push(supertypeSet);
                    }
                };
                var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
                var checkingFuzzySubtypes = false;
                for(var i = 0; i < workQueue_1.length; ++i){
                    var supertypeSet = workQueue_1[i];
                    if (supertypeSet.has(supertype)) {
                        if (!typenameSupertypeSet.has(supertype)) {
                            if (checkingFuzzySubtypes) {
                                globalThis.__DEV__ !== false && invariant$1.warn(7, typename, supertype);
                            }
                            typenameSupertypeSet.add(supertype);
                        }
                        return true;
                    }
                    supertypeSet.forEach(maybeEnqueue_1);
                    if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
                        needToCheckFuzzySubtypes = false;
                        checkingFuzzySubtypes = true;
                        this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                            var match = typename.match(regExp);
                            if (match && match[0] === typename) {
                                maybeEnqueue_1(fuzzyString);
                            }
                        });
                    }
                }
            }
            return false;
        };
        Policies.prototype.hasKeyArgs = function(typename, fieldName) {
            var policy = this.getFieldPolicy(typename, fieldName);
            return !!(policy && policy.keyFn);
        };
        Policies.prototype.getStoreFieldName = function(fieldSpec) {
            var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
            var policy = this.getFieldPolicy(typename, fieldName);
            var storeFieldName;
            var keyFn = policy && policy.keyFn;
            if (keyFn && typename) {
                var context = {
                    typename: typename,
                    fieldName: fieldName,
                    field: fieldSpec.field || null,
                    variables: fieldSpec.variables
                };
                var args = argsFromFieldSpecifier(fieldSpec);
                while(keyFn){
                    var specifierOrString = keyFn(args, context);
                    if (isArray(specifierOrString)) {
                        keyFn = keyArgsFnFromSpecifier(specifierOrString);
                    } else {
                        storeFieldName = specifierOrString || fieldName;
                        break;
                    }
                }
            }
            if (storeFieldName === void 0) {
                storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
            }
            if (storeFieldName === false) {
                return fieldName;
            }
            return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
        };
        Policies.prototype.readField = function(options, context) {
            var objectOrReference = options.from;
            if (!objectOrReference) return;
            var nameOrField = options.field || options.fieldName;
            if (!nameOrField) return;
            if (options.typename === void 0) {
                var typename = context.store.getFieldValue(objectOrReference, "__typename");
                if (typename) options.typename = typename;
            }
            var storeFieldName = this.getStoreFieldName(options);
            var fieldName = fieldNameFromStoreName(storeFieldName);
            var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
            var policy = this.getFieldPolicy(options.typename, fieldName);
            var read = policy && policy.read;
            if (read) {
                var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
                return cacheSlot.withValue(this.cache, read, [
                    existing,
                    readOptions
                ]);
            }
            return existing;
        };
        Policies.prototype.getReadFunction = function(typename, fieldName) {
            var policy = this.getFieldPolicy(typename, fieldName);
            return policy && policy.read;
        };
        Policies.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
            var policy = this.getFieldPolicy(parentTypename, fieldName);
            var merge = policy && policy.merge;
            if (!merge && childTypename) {
                policy = this.getTypePolicy(childTypename);
                merge = policy && policy.merge;
            }
            return merge;
        };
        Policies.prototype.runMergeFunction = function(existing, incoming, _a, context, storage) {
            var field = _a.field, typename = _a.typename, merge = _a.merge;
            if (merge === mergeTrueFn) {
                return makeMergeObjectsFunction(context.store)(existing, incoming);
            }
            if (merge === mergeFalseFn) {
                return incoming;
            }
            if (context.overwrite) {
                existing = void 0;
            }
            return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, {
                typename: typename,
                fieldName: field.name.value,
                field: field,
                variables: context.variables
            }, context, storage || Object.create(null)));
        };
        return Policies;
    }());
    function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
        var storeFieldName = policies.getStoreFieldName(fieldSpec);
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var variables = fieldSpec.variables || context.variables;
        var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;
        return {
            args: argsFromFieldSpecifier(fieldSpec),
            field: fieldSpec.field || null,
            fieldName: fieldName,
            storeFieldName: storeFieldName,
            variables: variables,
            isReference: isReference,
            toReference: toReference,
            storage: storage,
            cache: policies.cache,
            canRead: canRead,
            readField: function() {
                return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
            },
            mergeObjects: makeMergeObjectsFunction(context.store)
        };
    }
    function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
        var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;
        var options;
        if (typeof fieldNameOrOptions === "string") {
            options = {
                fieldName: fieldNameOrOptions,
                from: argc > 1 ? from : objectOrReference
            };
        } else {
            options = __assign({}, fieldNameOrOptions);
            if (!hasOwn.call(options, "from")) {
                options.from = objectOrReference;
            }
        }
        if (globalThis.__DEV__ !== false && options.from === void 0) {
            globalThis.__DEV__ !== false && invariant$1.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));
        }
        if (void 0 === options.variables) {
            options.variables = variables;
        }
        return options;
    }
    function makeMergeObjectsFunction(store) {
        return function mergeObjects(existing, incoming) {
            if (isArray(existing) || isArray(incoming)) {
                throw newInvariantError(9);
            }
            if (isNonNullObject(existing) && isNonNullObject(incoming)) {
                var eType = store.getFieldValue(existing, "__typename");
                var iType = store.getFieldValue(incoming, "__typename");
                var typesDiffer = eType && iType && eType !== iType;
                if (typesDiffer) {
                    return incoming;
                }
                if (isReference(existing) && storeValueIsStoreObject(incoming)) {
                    store.merge(existing.__ref, incoming);
                    return existing;
                }
                if (storeValueIsStoreObject(existing) && isReference(incoming)) {
                    store.merge(existing, incoming.__ref);
                    return incoming;
                }
                if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
                    return __assign(__assign({}, existing), incoming);
                }
            }
            return incoming;
        };
    }
    function getContextFlavor(context, clientOnly, deferred) {
        var key = "".concat(clientOnly).concat(deferred);
        var flavored = context.flavors.get(key);
        if (!flavored) {
            context.flavors.set(key, (flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), {
                clientOnly: clientOnly,
                deferred: deferred
            })));
        }
        return flavored;
    }
    var StoreWriter = (function() {
        function StoreWriter(cache, reader, fragments) {
            this.cache = cache;
            this.reader = reader;
            this.fragments = fragments;
        }
        StoreWriter.prototype.writeToStore = function(store, _a) {
            var _this = this;
            var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;
            var operationDefinition = getOperationDefinition(query);
            var merger = makeProcessedFieldsMerger();
            variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
            var context = __assign(__assign({
                store: store,
                written: Object.create(null),
                merge: function(existing, incoming) {
                    return merger.merge(existing, incoming);
                },
                variables: variables,
                varString: canonicalStringify(variables)
            }, extractFragmentContext(query, this.fragments)), {
                overwrite: !!overwrite,
                incomingById: new Map(),
                clientOnly: false,
                deferred: false,
                flavors: new Map()
            });
            var ref = this.processSelectionSet({
                result: result || Object.create(null),
                dataId: dataId,
                selectionSet: operationDefinition.selectionSet,
                mergeTree: {
                    map: new Map()
                },
                context: context
            });
            if (!isReference(ref)) {
                throw newInvariantError(12, result);
            }
            context.incomingById.forEach(function(_a, dataId) {
                var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;
                var entityRef = makeReference(dataId);
                if (mergeTree && mergeTree.map.size) {
                    var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
                    if (isReference(applied)) {
                        return;
                    }
                    storeObject = applied;
                }
                if (globalThis.__DEV__ !== false && !context.overwrite) {
                    var fieldsWithSelectionSets_1 = Object.create(null);
                    fieldNodeSet.forEach(function(field) {
                        if (field.selectionSet) {
                            fieldsWithSelectionSets_1[field.name.value] = true;
                        }
                    });
                    var hasSelectionSet_1 = function(storeFieldName) {
                        return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
                    };
                    var hasMergeFunction_1 = function(storeFieldName) {
                        var childTree = mergeTree && mergeTree.map.get(storeFieldName);
                        return Boolean(childTree && childTree.info && childTree.info.merge);
                    };
                    Object.keys(storeObject).forEach(function(storeFieldName) {
                        if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
                        }
                    });
                }
                store.merge(dataId, storeObject);
            });
            store.retain(ref.__ref);
            return ref;
        };
        StoreWriter.prototype.processSelectionSet = function(_a) {
            var _this = this;
            var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;
            var policies = this.cache.policies;
            var incoming = Object.create(null);
            var typename = (dataId && policies.rootTypenamesById[dataId]) || getTypenameFromResult(result, selectionSet, context.fragmentMap) || (dataId && context.store.get(dataId, "__typename"));
            if ("string" === typeof typename) {
                incoming.__typename = typename;
            }
            var readField = function() {
                var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
                if (isReference(options.from)) {
                    var info = context.incomingById.get(options.from.__ref);
                    if (info) {
                        var result_1 = policies.readField(__assign(__assign({}, options), {
                            from: info.storeObject
                        }), context);
                        if (result_1 !== void 0) {
                            return result_1;
                        }
                    }
                }
                return policies.readField(options, context);
            };
            var fieldNodeSet = new Set();
            this.flattenFields(selectionSet, result, context, typename).forEach(function(context, field) {
                var _a;
                var resultFieldKey = resultKeyNameFromField(field);
                var value = result[resultFieldKey];
                fieldNodeSet.add(field);
                if (value !== void 0) {
                    var storeFieldName = policies.getStoreFieldName({
                        typename: typename,
                        fieldName: field.name.value,
                        field: field,
                        variables: context.variables
                    });
                    var childTree = getChildMergeTree(mergeTree, storeFieldName);
                    var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context, false, false) : context, childTree);
                    var childTypename = void 0;
                    if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
                        childTypename = readField("__typename", incomingValue);
                    }
                    var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
                    if (merge) {
                        childTree.info = {
                            field: field,
                            typename: typename,
                            merge: merge
                        };
                    } else {
                        maybeRecycleChildMergeTree(mergeTree, storeFieldName);
                    }
                    incoming = context.merge(incoming, (_a = {}, _a[storeFieldName] = incomingValue, _a));
                } else if (globalThis.__DEV__ !== false && !context.clientOnly && !context.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
                    globalThis.__DEV__ !== false && invariant$1.error(13, resultKeyNameFromField(field), result);
                }
            });
            try {
                var _b = policies.identify(result, {
                    typename: typename,
                    selectionSet: selectionSet,
                    fragmentMap: context.fragmentMap,
                    storeObject: incoming,
                    readField: readField
                }), id = _b[0], keyObject = _b[1];
                dataId = dataId || id;
                if (keyObject) {
                    incoming = context.merge(incoming, keyObject);
                }
            } catch (e) {
                if (!dataId) throw e;
            }
            if ("string" === typeof dataId) {
                var dataRef = makeReference(dataId);
                var sets = context.written[dataId] || (context.written[dataId] = []);
                if (sets.indexOf(selectionSet) >= 0) return dataRef;
                sets.push(selectionSet);
                if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
                    return dataRef;
                }
                var previous_1 = context.incomingById.get(dataId);
                if (previous_1) {
                    previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
                    previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
                    fieldNodeSet.forEach(function(field) {
                        return previous_1.fieldNodeSet.add(field);
                    });
                } else {
                    context.incomingById.set(dataId, {
                        storeObject: incoming,
                        mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
                        fieldNodeSet: fieldNodeSet
                    });
                }
                return dataRef;
            }
            return incoming;
        };
        StoreWriter.prototype.processFieldValue = function(value, field, context, mergeTree) {
            var _this = this;
            if (!field.selectionSet || value === null) {
                return globalThis.__DEV__ !== false ? cloneDeep(value) : value;
            }
            if (isArray(value)) {
                return value.map(function(item, i) {
                    var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
                    maybeRecycleChildMergeTree(mergeTree, i);
                    return value;
                });
            }
            return this.processSelectionSet({
                result: value,
                selectionSet: field.selectionSet,
                context: context,
                mergeTree: mergeTree
            });
        };
        StoreWriter.prototype.flattenFields = function(selectionSet, result, context, typename) {
            if (typename === void 0) {
                typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);
            }
            var fieldMap = new Map();
            var policies = this.cache.policies;
            var limitingTrie = new Trie(false);
            (function flatten(selectionSet, inheritedContext) {
                var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);
                if (visitedNode.visited) return;
                visitedNode.visited = true;
                selectionSet.selections.forEach(function(selection) {
                    if (!shouldInclude(selection, context.variables)) return;
                    var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
                    if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {
                        selection.directives.forEach(function(dir) {
                            var name = dir.name.value;
                            if (name === "client") clientOnly = true;
                            if (name === "defer") {
                                var args = argumentsObjectFromField(dir, context.variables);
                                if (!args || args.if !== false) {
                                    deferred = true;
                                }
                            }
                        });
                    }
                    if (isField(selection)) {
                        var existing = fieldMap.get(selection);
                        if (existing) {
                            clientOnly = clientOnly && existing.clientOnly;
                            deferred = deferred && existing.deferred;
                        }
                        fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
                    } else {
                        var fragment = getFragmentFromSelection(selection, context.lookupFragment);
                        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
                            throw newInvariantError(14, selection.name.value);
                        }
                        if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {
                            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
                        }
                    }
                });
            })(selectionSet, context);
            return fieldMap;
        };
        StoreWriter.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
            var _a;
            var _this = this;
            if (mergeTree.map.size && !isReference(incoming)) {
                var e_1 = (!isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing))) ? existing : void 0;
                var i_1 = incoming;
                if (e_1 && !getStorageArgs) {
                    getStorageArgs = [
                        isReference(e_1) ? e_1.__ref : e_1
                    ];
                }
                var changedFields_1;
                var getValue_1 = function(from, name) {
                    return (isArray(from) ? typeof name === "number" ? from[name] : void 0 : context.store.getFieldValue(from, String(name)));
                };
                mergeTree.map.forEach(function(childTree, storeFieldName) {
                    var eVal = getValue_1(e_1, storeFieldName);
                    var iVal = getValue_1(i_1, storeFieldName);
                    if (void 0 === iVal) return;
                    if (getStorageArgs) {
                        getStorageArgs.push(storeFieldName);
                    }
                    var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
                    if (aVal !== iVal) {
                        changedFields_1 = changedFields_1 || new Map();
                        changedFields_1.set(storeFieldName, aVal);
                    }
                    if (getStorageArgs) {
                        invariant$1(getStorageArgs.pop() === storeFieldName);
                    }
                });
                if (changedFields_1) {
                    incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));
                    changedFields_1.forEach(function(value, name) {
                        incoming[name] = value;
                    });
                }
            }
            if (mergeTree.info) {
                return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));
            }
            return incoming;
        };
        return StoreWriter;
    }());
    var emptyMergeTreePool = [];
    function getChildMergeTree(_a, name) {
        var map = _a.map;
        if (!map.has(name)) {
            map.set(name, emptyMergeTreePool.pop() || {
                map: new Map()
            });
        }
        return map.get(name);
    }
    function mergeMergeTrees(left, right) {
        if (left === right || !right || mergeTreeIsEmpty(right)) return left;
        if (!left || mergeTreeIsEmpty(left)) return right;
        var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;
        var needToMergeMaps = left.map.size && right.map.size;
        var map = needToMergeMaps ? new Map() : left.map.size ? left.map : right.map;
        var merged = {
            info: info,
            map: map
        };
        if (needToMergeMaps) {
            var remainingRightKeys_1 = new Set(right.map.keys());
            left.map.forEach(function(leftTree, key) {
                merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
                remainingRightKeys_1.delete(key);
            });
            remainingRightKeys_1.forEach(function(key) {
                merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
            });
        }
        return merged;
    }
    function mergeTreeIsEmpty(tree) {
        return !tree || !(tree.info || tree.map.size);
    }
    function maybeRecycleChildMergeTree(_a, name) {
        var map = _a.map;
        var childTree = map.get(name);
        if (childTree && mergeTreeIsEmpty(childTree)) {
            emptyMergeTreePool.push(childTree);
            map.delete(name);
        }
    }
    var warnings = new Set();
    function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
        var getChild = function(objOrRef) {
            var child = store.getFieldValue(objOrRef, storeFieldName);
            return typeof child === "object" && child;
        };
        var existing = getChild(existingRef);
        if (!existing) return;
        var incoming = getChild(incomingObj);
        if (!incoming) return;
        if (isReference(existing)) return;
        if (equal(existing, incoming)) return;
        if (Object.keys(existing).every(function(key) {
            return store.getFieldValue(incoming, key) !== void 0;
        })) {
            return;
        }
        var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
        var fieldName = fieldNameFromStoreName(storeFieldName);
        var typeDotName = "".concat(parentType, ".").concat(fieldName);
        if (warnings.has(typeDotName)) return;
        warnings.add(typeDotName);
        var childTypenames = [];
        if (!isArray(existing) && !isArray(incoming)) {
            [
                existing,
                incoming
            ].forEach(function(child) {
                var typename = store.getFieldValue(child, "__typename");
                if (typeof typename === "string" && !childTypenames.includes(typename)) {
                    childTypenames.push(typename);
                }
            });
        }
        globalThis.__DEV__ !== false && invariant$1.warn(15, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, __assign({}, existing), __assign({}, incoming));
    }
    var InMemoryCache = (function(_super) {
        __extends(InMemoryCache, _super);
        function InMemoryCache(config) {
            if (config === void 0) {
                config = {};
            }
            var _this = _super.call(this) || this;
            _this.watches = new Set();
            _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);
            _this.assumeImmutableResults = true;
            _this.makeVar = makeVar;
            _this.txCount = 0;
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(config, "addTypename", "InMemoryCache", "Please remove the `addTypename` option when initializing `InMemoryCache`.");
                warnRemovedOption(config, "canonizeResults", "InMemoryCache", "Please remove the `canonizeResults` option when initializing `InMemoryCache`.");
            }
            _this.config = normalizeConfig(config);
            _this.addTypename = !!_this.config.addTypename;
            _this.policies = new Policies({
                cache: _this,
                dataIdFromObject: _this.config.dataIdFromObject,
                possibleTypes: _this.config.possibleTypes,
                typePolicies: _this.config.typePolicies
            });
            _this.init();
            return _this;
        }
        InMemoryCache.prototype.init = function() {
            var rootStore = (this.data = new EntityStore.Root({
                policies: this.policies,
                resultCaching: this.config.resultCaching
            }));
            this.optimisticData = rootStore.stump;
            this.resetResultCache();
        };
        InMemoryCache.prototype.resetResultCache = function(resetResultIdentities) {
            var _this = this;
            var previousReader = this.storeReader;
            var fragments = this.config.fragments;
            this.addTypenameTransform.resetCache();
            fragments === null || fragments === void 0 ? void 0 : fragments.resetCaches();
            this.storeWriter = new StoreWriter(this, (this.storeReader = new StoreReader({
                cache: this,
                addTypename: this.addTypename,
                resultCacheMaxSize: this.config.resultCacheMaxSize,
                canonizeResults: shouldCanonizeResults(this.config),
                canon: resetResultIdentities ? void 0 : (previousReader && previousReader.canon),
                fragments: fragments
            })), fragments);
            this.maybeBroadcastWatch = wrap(function(c, options) {
                return _this.broadcastWatch(c, options);
            }, {
                max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5000,
                makeCacheKey: function(c) {
                    var store = c.optimistic ? _this.optimisticData : _this.data;
                    if (supportsResultCaching(store)) {
                        var optimistic = c.optimistic, id = c.id, variables = c.variables;
                        return store.makeCacheKey(c.query, c.callback, canonicalStringify({
                            optimistic: optimistic,
                            id: id,
                            variables: variables
                        }));
                    }
                }
            });
            new Set([
                this.data.group,
                this.optimisticData.group
            ]).forEach(function(group) {
                return group.resetCaching();
            });
        };
        InMemoryCache.prototype.restore = function(data) {
            this.init();
            if (data) this.data.replace(data);
            return this;
        };
        InMemoryCache.prototype.extract = function(optimistic) {
            if (optimistic === void 0) {
                optimistic = false;
            }
            return (optimistic ? this.optimisticData : this.data).extract();
        };
        InMemoryCache.prototype.read = function(options) {
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(options, "canonizeResults", "cache.read");
            }
            var _a = options.returnPartialData, returnPartialData = _a === void 0 ? false : _a;
            try {
                return (this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {
                    store: options.optimistic ? this.optimisticData : this.data,
                    config: this.config,
                    returnPartialData: returnPartialData
                })).result || null);
            } catch (e) {
                if (e instanceof MissingFieldError) {
                    return null;
                }
                throw e;
            }
        };
        InMemoryCache.prototype.write = function(options) {
            try {
                ++this.txCount;
                return this.storeWriter.writeToStore(this.data, options);
            } finally{
                if (!--this.txCount && options.broadcast !== false) {
                    this.broadcastWatches();
                }
            }
        };
        InMemoryCache.prototype.modify = function(options) {
            if (hasOwn.call(options, "id") && !options.id) {
                return false;
            }
            var store = ((options.optimistic)) ? this.optimisticData : this.data;
            try {
                ++this.txCount;
                return store.modify(options.id || "ROOT_QUERY", options.fields);
            } finally{
                if (!--this.txCount && options.broadcast !== false) {
                    this.broadcastWatches();
                }
            }
        };
        InMemoryCache.prototype.diff = function(options) {
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(options, "canonizeResults", "cache.diff");
            }
            return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), {
                store: options.optimistic ? this.optimisticData : this.data,
                rootId: options.id || "ROOT_QUERY",
                config: this.config
            }));
        };
        InMemoryCache.prototype.watch = function(watch) {
            var _this = this;
            if (!this.watches.size) {
                recallCache(this);
            }
            this.watches.add(watch);
            if (watch.immediate) {
                this.maybeBroadcastWatch(watch);
            }
            return function() {
                if (_this.watches.delete(watch) && !_this.watches.size) {
                    forgetCache(_this);
                }
                _this.maybeBroadcastWatch.forget(watch);
            };
        };
        InMemoryCache.prototype.gc = function(options) {
            if (globalThis.__DEV__ !== false) {
                warnRemovedOption(options || {}, "resetResultIdentities", "cache.gc", "First ensure all usages of `canonizeResults` are removed, then remove this option.");
            }
            canonicalStringify.reset();
            print.reset();
            var ids = this.optimisticData.gc();
            if (options && !this.txCount) {
                if (options.resetResultCache) {
                    this.resetResultCache(options.resetResultIdentities);
                } else if (options.resetResultIdentities) {
                    this.storeReader.resetCanon();
                }
            }
            return ids;
        };
        InMemoryCache.prototype.retain = function(rootId, optimistic) {
            return (optimistic ? this.optimisticData : this.data).retain(rootId);
        };
        InMemoryCache.prototype.release = function(rootId, optimistic) {
            return (optimistic ? this.optimisticData : this.data).release(rootId);
        };
        InMemoryCache.prototype.identify = function(object) {
            if (isReference(object)) return object.__ref;
            try {
                return this.policies.identify(object)[0];
            } catch (e) {
                globalThis.__DEV__ !== false && invariant$1.warn(e);
            }
        };
        InMemoryCache.prototype.evict = function(options) {
            if (!options.id) {
                if (hasOwn.call(options, "id")) {
                    return false;
                }
                options = __assign(__assign({}, options), {
                    id: "ROOT_QUERY"
                });
            }
            try {
                ++this.txCount;
                return this.optimisticData.evict(options, this.data);
            } finally{
                if (!--this.txCount && options.broadcast !== false) {
                    this.broadcastWatches();
                }
            }
        };
        InMemoryCache.prototype.reset = function(options) {
            var _this = this;
            this.init();
            canonicalStringify.reset();
            if (options && options.discardWatches) {
                this.watches.forEach(function(watch) {
                    return _this.maybeBroadcastWatch.forget(watch);
                });
                this.watches.clear();
                forgetCache(this);
            } else {
                this.broadcastWatches();
            }
            return Promise.resolve();
        };
        InMemoryCache.prototype.removeOptimistic = function(idToRemove) {
            var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
            if (newOptimisticData !== this.optimisticData) {
                this.optimisticData = newOptimisticData;
                this.broadcastWatches();
            }
        };
        InMemoryCache.prototype.batch = function(options) {
            var _this = this;
            var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
            var updateResult;
            var perform = function(layer) {
                var _a = _this, data = _a.data, optimisticData = _a.optimisticData;
                ++_this.txCount;
                if (layer) {
                    _this.data = _this.optimisticData = layer;
                }
                try {
                    return (updateResult = update(_this));
                } finally{
                    --_this.txCount;
                    _this.data = data;
                    _this.optimisticData = optimisticData;
                }
            };
            var alreadyDirty = new Set();
            if (onWatchUpdated && !this.txCount) {
                this.broadcastWatches(__assign(__assign({}, options), {
                    onWatchUpdated: function(watch) {
                        alreadyDirty.add(watch);
                        return false;
                    }
                }));
            }
            if (typeof optimistic === "string") {
                this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
            } else if (optimistic === false) {
                perform(this.data);
            } else {
                perform();
            }
            if (typeof removeOptimistic === "string") {
                this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
            }
            if (onWatchUpdated && alreadyDirty.size) {
                this.broadcastWatches(__assign(__assign({}, options), {
                    onWatchUpdated: function(watch, diff) {
                        var result = onWatchUpdated.call(this, watch, diff);
                        if (result !== false) {
                            alreadyDirty.delete(watch);
                        }
                        return result;
                    }
                }));
                if (alreadyDirty.size) {
                    alreadyDirty.forEach(function(watch) {
                        return _this.maybeBroadcastWatch.dirty(watch);
                    });
                }
            } else {
                this.broadcastWatches(options);
            }
            return updateResult;
        };
        InMemoryCache.prototype.performTransaction = function(update, optimisticId) {
            return this.batch({
                update: update,
                optimistic: optimisticId || optimisticId !== null
            });
        };
        InMemoryCache.prototype.transformDocument = function(document) {
            return this.addTypenameToDocument(this.addFragmentsToDocument(document));
        };
        InMemoryCache.prototype.fragmentMatches = function(fragment, typename) {
            return this.policies.fragmentMatches(fragment, typename);
        };
        InMemoryCache.prototype.lookupFragment = function(fragmentName) {
            var _a;
            return ((_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.lookup(fragmentName)) || null;
        };
        InMemoryCache.prototype.broadcastWatches = function(options) {
            var _this = this;
            if (!this.txCount) {
                this.watches.forEach(function(c) {
                    return _this.maybeBroadcastWatch(c, options);
                });
            }
        };
        InMemoryCache.prototype.addFragmentsToDocument = function(document) {
            var fragments = this.config.fragments;
            return fragments ? fragments.transform(document) : document;
        };
        InMemoryCache.prototype.addTypenameToDocument = function(document) {
            if (this.addTypename) {
                return this.addTypenameTransform.transformDocument(document);
            }
            return document;
        };
        InMemoryCache.prototype.broadcastWatch = function(c, options) {
            var _this = this;
            var lastDiff = c.lastDiff;
            var diff = muteDeprecations("canonizeResults", function() {
                return _this.diff(c);
            });
            if (options) {
                if (c.optimistic && typeof options.optimistic === "string") {
                    diff.fromOptimisticTransaction = true;
                }
                if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
                    return;
                }
            }
            if (!lastDiff || !equal(lastDiff.result, diff.result)) {
                c.callback((c.lastDiff = diff), lastDiff);
            }
        };
        return InMemoryCache;
    }(ApolloCache));
    if (globalThis.__DEV__ !== false) {
        InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
    }
    function createFragmentRegistry() {
        var fragments = [];
        for(var _i = 0; _i < arguments.length; _i++){
            fragments[_i] = arguments[_i];
        }
        return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([
            void 0
        ], fragments, false)))();
    }
    var FragmentRegistry = (function() {
        function FragmentRegistry() {
            var fragments = [];
            for(var _i = 0; _i < arguments.length; _i++){
                fragments[_i] = arguments[_i];
            }
            this.registry = Object.create(null);
            this.resetCaches();
            if (fragments.length) {
                this.register.apply(this, fragments);
            }
        }
        FragmentRegistry.prototype.register = function() {
            var _this = this;
            var fragments = [];
            for(var _i = 0; _i < arguments.length; _i++){
                fragments[_i] = arguments[_i];
            }
            var definitions = new Map();
            fragments.forEach(function(doc) {
                getFragmentDefinitions(doc).forEach(function(node) {
                    definitions.set(node.name.value, node);
                });
            });
            definitions.forEach(function(node, name) {
                if (node !== _this.registry[name]) {
                    _this.registry[name] = node;
                    _this.invalidate(name);
                }
            });
            return this;
        };
        FragmentRegistry.prototype.invalidate = function(name) {};
        FragmentRegistry.prototype.resetCaches = function() {
            var proto = FragmentRegistry.prototype;
            this.invalidate = (this.lookup = wrap(proto.lookup.bind(this), {
                makeCacheKey: function(arg) {
                    return arg;
                },
                max: cacheSizes["fragmentRegistry.lookup"] || 1000
            })).dirty;
            this.transform = wrap(proto.transform.bind(this), {
                cache: WeakCache,
                max: cacheSizes["fragmentRegistry.transform"] || 2000
            });
            this.findFragmentSpreads = wrap(proto.findFragmentSpreads.bind(this), {
                cache: WeakCache,
                max: cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4000
            });
        };
        FragmentRegistry.prototype.lookup = function(fragmentName) {
            return this.registry[fragmentName] || null;
        };
        FragmentRegistry.prototype.transform = function(document) {
            var _this = this;
            var defined = new Map();
            getFragmentDefinitions(document).forEach(function(def) {
                defined.set(def.name.value, def);
            });
            var unbound = new Set();
            var enqueue = function(spreadName) {
                if (!defined.has(spreadName)) {
                    unbound.add(spreadName);
                }
            };
            var enqueueChildSpreads = function(node) {
                return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);
            };
            enqueueChildSpreads(document);
            var missing = [];
            var map = Object.create(null);
            unbound.forEach(function(fragmentName) {
                var knownFragmentDef = defined.get(fragmentName);
                if (knownFragmentDef) {
                    enqueueChildSpreads((map[fragmentName] = knownFragmentDef));
                } else {
                    missing.push(fragmentName);
                    var def = _this.lookup(fragmentName);
                    if (def) {
                        enqueueChildSpreads((map[fragmentName] = def));
                    }
                }
            });
            if (missing.length) {
                var defsToAppend_1 = [];
                missing.forEach(function(name) {
                    var def = map[name];
                    if (def) {
                        defsToAppend_1.push(def);
                    }
                });
                if (defsToAppend_1.length) {
                    document = __assign(__assign({}, document), {
                        definitions: document.definitions.concat(defsToAppend_1)
                    });
                }
            }
            return document;
        };
        FragmentRegistry.prototype.findFragmentSpreads = function(root) {
            var spreads = Object.create(null);
            visit(root, {
                FragmentSpread: function(node) {
                    spreads[node.name.value] = node;
                }
            });
            return spreads;
        };
        return FragmentRegistry;
    }());
    const cache = Object.freeze(Object.defineProperty({
        __proto__: null,
        ApolloCache,
        get Cache () {
            return Cache;
        },
        get EntityStore () {
            return EntityStore;
        },
        InMemoryCache,
        MissingFieldError,
        Policies,
        cacheSlot,
        canonicalStringify,
        createFragmentRegistry,
        defaultDataIdFromObject,
        fieldNameFromStoreName,
        isReference,
        makeReference,
        makeVar
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    const require$$6$1 = getAugmentedNamespace(cache);
    const require$$3$1 = getAugmentedNamespace(errors);
    const require$$5 = getAugmentedNamespace(lib$2);
    const require$$2 = getAugmentedNamespace(lib$4);
    const require$$10 = getAugmentedNamespace(masking);
    const require$$1 = getAugmentedNamespace(graphql);
    const require$$3 = getAugmentedNamespace(utils);
    const require$$13 = getAugmentedNamespace(invariant$4);
    var docCache = new Map();
    var fragmentSourceMap = new Map();
    var printFragmentWarnings = true;
    var experimentalFragmentVariables = false;
    function normalize(string) {
        return string.replace(/[\s,]+/g, ' ').trim();
    }
    function cacheKeyFromLoc(loc) {
        return normalize(loc.source.body.substring(loc.start, loc.end));
    }
    function processFragments(ast) {
        var seenKeys = new Set();
        var definitions = [];
        ast.definitions.forEach(function(fragmentDefinition) {
            if (fragmentDefinition.kind === 'FragmentDefinition') {
                var fragmentName = fragmentDefinition.name.value;
                var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
                var sourceKeySet = fragmentSourceMap.get(fragmentName);
                if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
                    if (printFragmentWarnings) {
                        console.warn("Warning: fragment with name " + fragmentName + " already exists.\n" + "graphql-tag enforces all fragment names across your application to be unique; read more about\n" + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
                    }
                } else if (!sourceKeySet) {
                    fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);
                }
                sourceKeySet.add(sourceKey);
                if (!seenKeys.has(sourceKey)) {
                    seenKeys.add(sourceKey);
                    definitions.push(fragmentDefinition);
                }
            } else {
                definitions.push(fragmentDefinition);
            }
        });
        return __assign(__assign({}, ast), {
            definitions: definitions
        });
    }
    function stripLoc(doc) {
        var workSet = new Set(doc.definitions);
        workSet.forEach(function(node) {
            if (node.loc) delete node.loc;
            Object.keys(node).forEach(function(key) {
                var value = node[key];
                if (value && typeof value === 'object') {
                    workSet.add(value);
                }
            });
        });
        var loc = doc.loc;
        if (loc) {
            delete loc.startToken;
            delete loc.endToken;
        }
        return doc;
    }
    function parseDocument(source) {
        var cacheKey = normalize(source);
        if (!docCache.has(cacheKey)) {
            var parsed = parse(source, {
                experimentalFragmentVariables: experimentalFragmentVariables,
                allowLegacyFragmentVariables: experimentalFragmentVariables
            });
            if (!parsed || parsed.kind !== 'Document') {
                throw new Error('Not a valid GraphQL document.');
            }
            docCache.set(cacheKey, stripLoc(processFragments(parsed)));
        }
        return docCache.get(cacheKey);
    }
    function gql$1(literals) {
        var args = [];
        for(var _i = 1; _i < arguments.length; _i++){
            args[_i - 1] = arguments[_i];
        }
        if (typeof literals === 'string') {
            literals = [
                literals
            ];
        }
        var result = literals[0];
        args.forEach(function(arg, i) {
            if (arg && arg.kind === 'Document') {
                result += arg.loc.source.body;
            } else {
                result += arg;
            }
            result += literals[i + 1];
        });
        return parseDocument(result);
    }
    function resetCaches() {
        docCache.clear();
        fragmentSourceMap.clear();
    }
    function disableFragmentWarnings() {
        printFragmentWarnings = false;
    }
    function enableExperimentalFragmentVariables() {
        experimentalFragmentVariables = true;
    }
    function disableExperimentalFragmentVariables() {
        experimentalFragmentVariables = false;
    }
    var extras = {
        gql: gql$1,
        resetCaches: resetCaches,
        disableFragmentWarnings: disableFragmentWarnings,
        enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,
        disableExperimentalFragmentVariables: disableExperimentalFragmentVariables
    };
    (function(gql_1) {
        gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
    })(gql$1 || (gql$1 = {}));
    gql$1["default"] = gql$1;
    const gql$2 = gql$1;
    const lib = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: gql$2,
        disableExperimentalFragmentVariables,
        disableFragmentWarnings,
        enableExperimentalFragmentVariables,
        get gql () {
            return gql$1;
        },
        resetCaches
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    const require$$14 = getAugmentedNamespace(lib);
    var hasRequiredCore$1;
    function requireCore$1() {
        if (hasRequiredCore$1) return core$2;
        hasRequiredCore$1 = 1;
        (function(exports) {
            Object.defineProperty(exports, '__esModule', {
                value: true
            });
            var tslib = require$$0$1;
            var globals = require$$0;
            var core = require$$2$1;
            var http = require$$3$2;
            var equal = require$$4$1;
            var utilities = require$$1$1;
            var cache = require$$6$1;
            var errors = require$$3$1;
            var optimism = require$$5;
            var trie = require$$2;
            var masking = require$$10;
            var graphql = require$$1;
            var utils = require$$3;
            var tsInvariant = require$$13;
            var graphqlTag = require$$14;
            function _interopDefaultLegacy(e) {
                return e && typeof e === 'object' && 'default' in e ? e["default"] : e;
            }
            var equal__default = _interopDefaultLegacy(equal);
            var version = "3.14.0";
            function isNonNullObject(obj) {
                return obj !== null && typeof obj === "object";
            }
            function isNonEmptyArray(value) {
                return Array.isArray(value) && value.length > 0;
            }
            var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
            var defaultReconciler = function(target, source, property) {
                return this.merge(target[property], source[property]);
            };
            var DeepMerger = (function() {
                function DeepMerger(reconciler) {
                    if (reconciler === void 0) {
                        reconciler = defaultReconciler;
                    }
                    this.reconciler = reconciler;
                    this.isObject = isNonNullObject;
                    this.pastCopies = new Set();
                }
                DeepMerger.prototype.merge = function(target, source) {
                    var _this = this;
                    var context = [];
                    for(var _i = 2; _i < arguments.length; _i++){
                        context[_i - 2] = arguments[_i];
                    }
                    if (isNonNullObject(source) && isNonNullObject(target)) {
                        Object.keys(source).forEach(function(sourceKey) {
                            if (hasOwnProperty$2.call(target, sourceKey)) {
                                var targetValue = target[sourceKey];
                                if (source[sourceKey] !== targetValue) {
                                    var result = _this.reconciler.apply(_this, tslib.__spreadArray([
                                        target,
                                        source,
                                        sourceKey
                                    ], context, false));
                                    if (result !== targetValue) {
                                        target = _this.shallowCopyForMerge(target);
                                        target[sourceKey] = result;
                                    }
                                }
                            } else {
                                target = _this.shallowCopyForMerge(target);
                                target[sourceKey] = source[sourceKey];
                            }
                        });
                        return target;
                    }
                    return source;
                };
                DeepMerger.prototype.shallowCopyForMerge = function(value) {
                    if (isNonNullObject(value)) {
                        if (!this.pastCopies.has(value)) {
                            if (Array.isArray(value)) {
                                value = value.slice(0);
                            } else {
                                value = tslib.__assign({
                                    __proto__: Object.getPrototypeOf(value)
                                }, value);
                            }
                            this.pastCopies.add(value);
                        }
                    }
                    return value;
                };
                return DeepMerger;
            }());
            function isExecutionPatchIncrementalResult(value) {
                return "incremental" in value;
            }
            function mergeIncrementalData(prevResult, result) {
                var mergedData = prevResult;
                var merger = new DeepMerger();
                if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
                    result.incremental.forEach(function(_a) {
                        var data = _a.data, path = _a.path;
                        for(var i = path.length - 1; i >= 0; --i){
                            var key = path[i];
                            var isNumericKey = !isNaN(+key);
                            var parent_1 = isNumericKey ? [] : {};
                            parent_1[key] = data;
                            data = parent_1;
                        }
                        mergedData = merger.merge(mergedData, data);
                    });
                }
                return mergedData;
            }
            exports.NetworkStatus = void 0;
            (function(NetworkStatus) {
                NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
                NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
                NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
                NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
                NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
                NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
                NetworkStatus[NetworkStatus["error"] = 8] = "error";
            })(exports.NetworkStatus || (exports.NetworkStatus = {}));
            function isNetworkRequestInFlight(networkStatus) {
                return networkStatus ? networkStatus < 7 : false;
            }
            function isNetworkRequestSettled(networkStatus) {
                return networkStatus === 7 || networkStatus === 8;
            }
            function equalByQuery(query, _a, _b, variables) {
                var aData = _a.data, aRest = tslib.__rest(_a, [
                    "data"
                ]);
                var bData = _b.data, bRest = tslib.__rest(_b, [
                    "data"
                ]);
                return (equal__default(aRest, bRest) && equalBySelectionSet(utilities.getMainDefinition(query).selectionSet, aData, bData, {
                    fragmentMap: utilities.createFragmentMap(utilities.getFragmentDefinitions(query)),
                    variables: variables
                }));
            }
            function equalBySelectionSet(selectionSet, aResult, bResult, context) {
                if (aResult === bResult) {
                    return true;
                }
                var seenSelections = new Set();
                return selectionSet.selections.every(function(selection) {
                    if (seenSelections.has(selection)) return true;
                    seenSelections.add(selection);
                    if (!utilities.shouldInclude(selection, context.variables)) return true;
                    if (selectionHasNonreactiveDirective(selection)) return true;
                    if (utilities.isField(selection)) {
                        var resultKey = utilities.resultKeyNameFromField(selection);
                        var aResultChild = aResult && aResult[resultKey];
                        var bResultChild = bResult && bResult[resultKey];
                        var childSelectionSet = selection.selectionSet;
                        if (!childSelectionSet) {
                            return equal__default(aResultChild, bResultChild);
                        }
                        var aChildIsArray = Array.isArray(aResultChild);
                        var bChildIsArray = Array.isArray(bResultChild);
                        if (aChildIsArray !== bChildIsArray) return false;
                        if (aChildIsArray && bChildIsArray) {
                            var length_1 = aResultChild.length;
                            if (bResultChild.length !== length_1) {
                                return false;
                            }
                            for(var i = 0; i < length_1; ++i){
                                if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
                    } else {
                        var fragment = utilities.getFragmentFromSelection(selection, context.fragmentMap);
                        if (fragment) {
                            if (selectionHasNonreactiveDirective(fragment)) return true;
                            return equalBySelectionSet(fragment.selectionSet, aResult, bResult, context);
                        }
                    }
                });
            }
            function selectionHasNonreactiveDirective(selection) {
                return (!!selection.directives && selection.directives.some(directiveIsNonreactive));
            }
            function directiveIsNonreactive(dir) {
                return dir.name.value === "nonreactive";
            }
            var muteAllDeprecations = Symbol.for("apollo.deprecations");
            var global = globals.global;
            var slot = new optimism.Slot();
            function isMuted(name) {
                return global[muteAllDeprecations] || (slot.getValue() || []).includes(name);
            }
            function muteDeprecations(name) {
                var args = [];
                for(var _i = 1; _i < arguments.length; _i++){
                    args[_i - 1] = arguments[_i];
                }
                return slot.withValue.apply(slot, tslib.__spreadArray([
                    Array.isArray(name) ? name : [
                        name
                    ]
                ], args, false));
            }
            function warnRemovedOption(options, name, callSite, recommendation) {
                if (recommendation === void 0) {
                    recommendation = "Please remove this option.";
                }
                warnDeprecated(name, function() {
                    if (name in options) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(104, callSite, name, recommendation);
                    }
                });
            }
            function warnDeprecated(name, cb) {
                if (!isMuted(name)) {
                    cb();
                }
            }
            var assign = Object.assign, hasOwnProperty$1 = Object.hasOwnProperty;
            var ObservableQuery = (function(_super) {
                tslib.__extends(ObservableQuery, _super);
                function ObservableQuery(_a) {
                    var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;
                    var _this = this;
                    var startedInactive = ObservableQuery.inactiveOnCreation.getValue();
                    _this = _super.call(this, function(observer) {
                        _this._getOrCreateQuery();
                        try {
                            var subObserver = observer._subscription._observer;
                            if (subObserver && !subObserver.error) {
                                subObserver.error = defaultSubscriptionObserverErrorCallback;
                            }
                        } catch (_a) {}
                        var first = !_this.observers.size;
                        _this.observers.add(observer);
                        var last = _this.last;
                        if (last && last.error) {
                            observer.error && observer.error(last.error);
                        } else if (last && last.result) {
                            observer.next && observer.next(_this.maskResult(last.result));
                        }
                        if (first) {
                            _this.reobserve().catch(function() {});
                        }
                        return function() {
                            if (_this.observers.delete(observer) && !_this.observers.size) {
                                _this.tearDownQuery();
                            }
                        };
                    }) || this;
                    _this.observers = new Set();
                    _this.subscriptions = new Set();
                    _this.dirty = false;
                    _this._getOrCreateQuery = function() {
                        if (startedInactive) {
                            queryManager["queries"].set(_this.queryId, queryInfo);
                            startedInactive = false;
                        }
                        return _this.queryManager.getOrCreateQuery(_this.queryId);
                    };
                    _this.queryInfo = queryInfo;
                    _this.queryManager = queryManager;
                    _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);
                    _this.isTornDown = false;
                    _this.subscribeToMore = _this.subscribeToMore.bind(_this);
                    _this.maskResult = _this.maskResult.bind(_this);
                    var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
                    var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : (fetchPolicy) : _f;
                    _this.options = tslib.__assign(tslib.__assign({}, options), {
                        initialFetchPolicy: initialFetchPolicy,
                        fetchPolicy: fetchPolicy
                    });
                    _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
                    var opDef = utilities.getOperationDefinition(_this.query);
                    _this.queryName = opDef && opDef.name && opDef.name.value;
                    return _this;
                }
                Object.defineProperty(ObservableQuery.prototype, "query", {
                    get: function() {
                        return this.lastQuery || this.options.query;
                    },
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(ObservableQuery.prototype, "variables", {
                    get: function() {
                        return this.options.variables;
                    },
                    enumerable: false,
                    configurable: true
                });
                ObservableQuery.prototype.result = function() {
                    var _this = this;
                    if (globalThis.__DEV__ !== false) {
                        warnDeprecated("observableQuery.result", function() {
                            globalThis.__DEV__ !== false && globals.invariant.warn(23);
                        });
                    }
                    return new Promise(function(resolve, reject) {
                        var observer = {
                            next: function(result) {
                                resolve(result);
                                _this.observers.delete(observer);
                                if (!_this.observers.size) {
                                    _this.queryManager.removeQuery(_this.queryId);
                                }
                                setTimeout(function() {
                                    subscription.unsubscribe();
                                }, 0);
                            },
                            error: reject
                        };
                        var subscription = _this.subscribe(observer);
                    });
                };
                ObservableQuery.prototype.resetDiff = function() {
                    this.queryInfo.resetDiff();
                };
                ObservableQuery.prototype.getCurrentFullResult = function(saveAsLastResult) {
                    var _this = this;
                    if (saveAsLastResult === void 0) {
                        saveAsLastResult = true;
                    }
                    var lastResult = muteDeprecations("getLastResult", function() {
                        return _this.getLastResult(true);
                    });
                    var networkStatus = this.queryInfo.networkStatus || (lastResult && lastResult.networkStatus) || exports.NetworkStatus.ready;
                    var result = tslib.__assign(tslib.__assign({}, lastResult), {
                        loading: isNetworkRequestInFlight(networkStatus),
                        networkStatus: networkStatus
                    });
                    var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a;
                    if (skipCacheDataFor(fetchPolicy) || this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) ;
                    else if (this.waitForOwnResult) {
                        this.queryInfo["updateWatch"]();
                    } else {
                        var diff = this.queryInfo.getDiff();
                        if (diff.complete || this.options.returnPartialData) {
                            result.data = diff.result;
                        }
                        if (equal.equal(result.data, {})) {
                            result.data = void 0;
                        }
                        if (diff.complete) {
                            delete result.partial;
                            if (diff.complete && result.networkStatus === exports.NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
                                result.networkStatus = exports.NetworkStatus.ready;
                                result.loading = false;
                            }
                        } else {
                            result.partial = true;
                        }
                        if (result.networkStatus === exports.NetworkStatus.ready && (result.error || result.errors)) {
                            result.networkStatus = exports.NetworkStatus.error;
                        }
                        if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
                            logMissingFieldErrors(diff.missing);
                        }
                    }
                    if (saveAsLastResult) {
                        this.updateLastResult(result);
                    }
                    return result;
                };
                ObservableQuery.prototype.getCurrentResult = function(saveAsLastResult) {
                    if (saveAsLastResult === void 0) {
                        saveAsLastResult = true;
                    }
                    return this.maskResult(this.getCurrentFullResult(saveAsLastResult));
                };
                ObservableQuery.prototype.isDifferentFromLastResult = function(newResult, variables) {
                    if (!this.last) {
                        return true;
                    }
                    var documentInfo = this.queryManager.getDocumentInfo(this.query);
                    var dataMasking = this.queryManager.dataMasking;
                    var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;
                    var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ? !equalByQuery(query, this.last.result, newResult, this.variables) : !equal.equal(this.last.result, newResult);
                    return (resultIsDifferent || (variables && !equal.equal(this.last.variables, variables)));
                };
                ObservableQuery.prototype.getLast = function(key, variablesMustMatch) {
                    var last = this.last;
                    if (last && last[key] && (!variablesMustMatch || equal.equal(last.variables, this.variables))) {
                        return last[key];
                    }
                };
                ObservableQuery.prototype.getLastResult = function(variablesMustMatch) {
                    if (globalThis.__DEV__ !== false) {
                        warnDeprecated("getLastResult", function() {
                            globalThis.__DEV__ !== false && globals.invariant.warn(24);
                        });
                    }
                    return this.getLast("result", variablesMustMatch);
                };
                ObservableQuery.prototype.getLastError = function(variablesMustMatch) {
                    if (globalThis.__DEV__ !== false) {
                        warnDeprecated("getLastError", function() {
                            globalThis.__DEV__ !== false && globals.invariant.warn(25);
                        });
                    }
                    return this.getLast("error", variablesMustMatch);
                };
                ObservableQuery.prototype.resetLastResults = function() {
                    if (globalThis.__DEV__ !== false) {
                        warnDeprecated("resetLastResults", function() {
                            globalThis.__DEV__ !== false && globals.invariant.warn(26);
                        });
                    }
                    delete this.last;
                    this.isTornDown = false;
                };
                ObservableQuery.prototype.resetQueryStoreErrors = function() {
                    if (globalThis.__DEV__ !== false) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(27);
                    }
                    this.queryManager.resetErrors(this.queryId);
                };
                ObservableQuery.prototype.refetch = function(variables) {
                    var _a;
                    var reobserveOptions = {
                        pollInterval: 0
                    };
                    var fetchPolicy = this.options.fetchPolicy;
                    if (fetchPolicy === "no-cache") {
                        reobserveOptions.fetchPolicy = "no-cache";
                    } else {
                        reobserveOptions.fetchPolicy = "network-only";
                    }
                    if (globalThis.__DEV__ !== false && variables && hasOwnProperty$1.call(variables, "variables")) {
                        var queryDef = utilities.getQueryDefinition(this.query);
                        var vars = queryDef.variableDefinitions;
                        if (!vars || !vars.some(function(v) {
                            return v.variable.name.value === "variables";
                        })) {
                            globalThis.__DEV__ !== false && globals.invariant.warn(28, variables, ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef);
                        }
                    }
                    if (variables && !equal.equal(this.options.variables, variables)) {
                        reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);
                    }
                    this.queryInfo.resetLastWrite();
                    return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
                };
                ObservableQuery.prototype.fetchMore = function(fetchMoreOptions) {
                    var _this = this;
                    var combinedOptions = tslib.__assign(tslib.__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : (tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), {
                        query: this.options.query
                    }), fetchMoreOptions), {
                        variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables)
                    })))), {
                        fetchPolicy: "no-cache"
                    });
                    combinedOptions.query = this.transformDocument(combinedOptions.query);
                    var qid = this.queryManager.generateQueryId();
                    this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
                    var queryInfo = this.queryInfo;
                    var originalNetworkStatus = queryInfo.networkStatus;
                    queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
                    if (combinedOptions.notifyOnNetworkStatusChange) {
                        this.observe();
                    }
                    var updatedQuerySet = new Set();
                    var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;
                    var isCached = this.options.fetchPolicy !== "no-cache";
                    if (!isCached) {
                        globals.invariant(updateQuery, 29);
                    }
                    return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function(fetchMoreResult) {
                        _this.queryManager.removeQuery(qid);
                        if (queryInfo.networkStatus === exports.NetworkStatus.fetchMore) {
                            queryInfo.networkStatus = originalNetworkStatus;
                        }
                        if (isCached) {
                            _this.queryManager.cache.batch({
                                update: function(cache) {
                                    var updateQuery = fetchMoreOptions.updateQuery;
                                    if (updateQuery) {
                                        cache.updateQuery({
                                            query: _this.query,
                                            variables: _this.variables,
                                            returnPartialData: true,
                                            optimistic: false
                                        }, function(previous) {
                                            return updateQuery(previous, {
                                                fetchMoreResult: fetchMoreResult.data,
                                                variables: combinedOptions.variables
                                            });
                                        });
                                    } else {
                                        cache.writeQuery({
                                            query: combinedOptions.query,
                                            variables: combinedOptions.variables,
                                            data: fetchMoreResult.data
                                        });
                                    }
                                },
                                onWatchUpdated: function(watch) {
                                    updatedQuerySet.add(watch.query);
                                }
                            });
                        } else {
                            var lastResult = _this.getLast("result");
                            var data = updateQuery(lastResult.data, {
                                fetchMoreResult: fetchMoreResult.data,
                                variables: combinedOptions.variables
                            });
                            _this.reportResult(tslib.__assign(tslib.__assign({}, lastResult), {
                                networkStatus: originalNetworkStatus,
                                loading: isNetworkRequestInFlight(originalNetworkStatus),
                                data: data
                            }), _this.variables);
                        }
                        return _this.maskResult(fetchMoreResult);
                    }).finally(function() {
                        if (isCached && !updatedQuerySet.has(_this.query)) {
                            _this.reobserveCacheFirst();
                        }
                    });
                };
                ObservableQuery.prototype.subscribeToMore = function(options) {
                    var _this = this;
                    var subscription = this.queryManager.startGraphQLSubscription({
                        query: options.document,
                        variables: options.variables,
                        context: options.context
                    }).subscribe({
                        next: function(subscriptionData) {
                            var updateQuery = options.updateQuery;
                            if (updateQuery) {
                                _this.updateQuery(function(previous, updateOptions) {
                                    return updateQuery(previous, tslib.__assign({
                                        subscriptionData: subscriptionData
                                    }, updateOptions));
                                });
                            }
                        },
                        error: function(err) {
                            if (options.onError) {
                                options.onError(err);
                                return;
                            }
                            globalThis.__DEV__ !== false && globals.invariant.error(30, err);
                        }
                    });
                    this.subscriptions.add(subscription);
                    return function() {
                        if (_this.subscriptions.delete(subscription)) {
                            subscription.unsubscribe();
                        }
                    };
                };
                ObservableQuery.prototype.setOptions = function(newOptions) {
                    if (globalThis.__DEV__ !== false) {
                        warnRemovedOption(newOptions, "canonizeResults", "setOptions");
                        warnDeprecated("setOptions", function() {
                            globalThis.__DEV__ !== false && globals.invariant.warn(31);
                        });
                    }
                    return this.reobserve(newOptions);
                };
                ObservableQuery.prototype.silentSetOptions = function(newOptions) {
                    var mergedOptions = utilities.compact(this.options, newOptions || {});
                    assign(this.options, mergedOptions);
                };
                ObservableQuery.prototype.setVariables = function(variables) {
                    var _this = this;
                    if (equal.equal(this.variables, variables)) {
                        return this.observers.size ? muteDeprecations("observableQuery.result", function() {
                            return _this.result();
                        }) : Promise.resolve();
                    }
                    this.options.variables = variables;
                    if (!this.observers.size) {
                        return Promise.resolve();
                    }
                    return this.reobserve({
                        fetchPolicy: this.options.initialFetchPolicy,
                        variables: variables
                    }, exports.NetworkStatus.setVariables);
                };
                ObservableQuery.prototype.updateQuery = function(mapFn) {
                    var queryManager = this.queryManager;
                    var _a = queryManager.cache.diff({
                        query: this.options.query,
                        variables: this.variables,
                        returnPartialData: true,
                        optimistic: false
                    }), result = _a.result, complete = _a.complete;
                    var newResult = mapFn(result, {
                        variables: this.variables,
                        complete: !!complete,
                        previousData: result
                    });
                    if (newResult) {
                        queryManager.cache.writeQuery({
                            query: this.options.query,
                            data: newResult,
                            variables: this.variables
                        });
                        queryManager.broadcastQueries();
                    }
                };
                ObservableQuery.prototype.startPolling = function(pollInterval) {
                    this.options.pollInterval = pollInterval;
                    this.updatePolling();
                };
                ObservableQuery.prototype.stopPolling = function() {
                    this.options.pollInterval = 0;
                    this.updatePolling();
                };
                ObservableQuery.prototype.applyNextFetchPolicy = function(reason, options) {
                    if (options.nextFetchPolicy) {
                        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
                        if (fetchPolicy === "standby") ;
                        else if (typeof options.nextFetchPolicy === "function") {
                            options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
                                reason: reason,
                                options: options,
                                observable: this,
                                initialFetchPolicy: initialFetchPolicy
                            });
                        } else if (reason === "variables-changed") {
                            options.fetchPolicy = initialFetchPolicy;
                        } else {
                            options.fetchPolicy = options.nextFetchPolicy;
                        }
                    }
                    return options.fetchPolicy;
                };
                ObservableQuery.prototype.fetch = function(options, newNetworkStatus, query) {
                    var queryInfo = this._getOrCreateQuery();
                    queryInfo.setObservableQuery(this);
                    return this.queryManager["fetchConcastWithInfo"](queryInfo, options, newNetworkStatus, query);
                };
                ObservableQuery.prototype.updatePolling = function() {
                    var _this = this;
                    if (this.queryManager.ssrMode) {
                        return;
                    }
                    var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;
                    if (!pollInterval || !this.hasObservers()) {
                        if (pollingInfo) {
                            clearTimeout(pollingInfo.timeout);
                            delete this.pollingInfo;
                        }
                        return;
                    }
                    if (pollingInfo && pollingInfo.interval === pollInterval) {
                        return;
                    }
                    globals.invariant(pollInterval, 32);
                    var info = pollingInfo || (this.pollingInfo = {});
                    info.interval = pollInterval;
                    var maybeFetch = function() {
                        var _a, _b;
                        if (_this.pollingInfo) {
                            if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {
                                _this.reobserve({
                                    fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
                                }, exports.NetworkStatus.poll).then(poll, poll);
                            } else {
                                poll();
                            }
                        }
                    };
                    var poll = function() {
                        var info = _this.pollingInfo;
                        if (info) {
                            clearTimeout(info.timeout);
                            info.timeout = setTimeout(maybeFetch, info.interval);
                        }
                    };
                    poll();
                };
                ObservableQuery.prototype.updateLastResult = function(newResult, variables) {
                    var _this = this;
                    if (variables === void 0) {
                        variables = this.variables;
                    }
                    var error = muteDeprecations("getLastError", function() {
                        return _this.getLastError();
                    });
                    if (error && this.last && !equal.equal(variables, this.last.variables)) {
                        error = void 0;
                    }
                    return (this.last = tslib.__assign({
                        result: this.queryManager.assumeImmutableResults ? newResult : utilities.cloneDeep(newResult),
                        variables: variables
                    }, (error ? {
                        error: error
                    } : null)));
                };
                ObservableQuery.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
                    var _this = this;
                    this.isTornDown = false;
                    var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch || newNetworkStatus === exports.NetworkStatus.fetchMore || newNetworkStatus === exports.NetworkStatus.poll;
                    var oldVariables = this.options.variables;
                    var oldFetchPolicy = this.options.fetchPolicy;
                    var mergedOptions = utilities.compact(this.options, newOptions || {});
                    var options = useDisposableConcast ? mergedOptions : assign(this.options, mergedOptions);
                    var query = this.transformDocument(options.query);
                    this.lastQuery = query;
                    if (!useDisposableConcast) {
                        this.updatePolling();
                        if (newOptions && newOptions.variables && !equal.equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && (options.fetchPolicy === oldFetchPolicy || typeof options.nextFetchPolicy === "function")) {
                            this.applyNextFetchPolicy("variables-changed", options);
                            if (newNetworkStatus === void 0) {
                                newNetworkStatus = exports.NetworkStatus.setVariables;
                            }
                        }
                    }
                    this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));
                    var finishWaitingForOwnResult = function() {
                        if (_this.concast === concast) {
                            _this.waitForOwnResult = false;
                        }
                    };
                    var variables = options.variables && tslib.__assign({}, options.variables);
                    var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;
                    var observer = {
                        next: function(result) {
                            if (equal.equal(_this.variables, variables)) {
                                finishWaitingForOwnResult();
                                _this.reportResult(result, variables);
                            }
                        },
                        error: function(error) {
                            if (equal.equal(_this.variables, variables)) {
                                if (!errors.isApolloError(error)) {
                                    error = new errors.ApolloError({
                                        networkError: error
                                    });
                                }
                                finishWaitingForOwnResult();
                                _this.reportError(error, variables);
                            }
                        }
                    };
                    if (!useDisposableConcast && (fromLink || !this.concast)) {
                        if (this.concast && this.observer) {
                            this.concast.removeObserver(this.observer);
                        }
                        this.concast = concast;
                        this.observer = observer;
                    }
                    concast.addObserver(observer);
                    return concast;
                };
                ObservableQuery.prototype.reobserve = function(newOptions, newNetworkStatus) {
                    return utilities.preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));
                };
                ObservableQuery.prototype.resubscribeAfterError = function() {
                    var _this = this;
                    var args = [];
                    for(var _i = 0; _i < arguments.length; _i++){
                        args[_i] = arguments[_i];
                    }
                    var last = this.last;
                    muteDeprecations("resetLastResults", function() {
                        return _this.resetLastResults();
                    });
                    var subscription = this.subscribe.apply(this, args);
                    this.last = last;
                    return subscription;
                };
                ObservableQuery.prototype.observe = function() {
                    this.reportResult(this.getCurrentFullResult(false), this.variables);
                };
                ObservableQuery.prototype.reportResult = function(result, variables) {
                    var _this = this;
                    var lastError = muteDeprecations("getLastError", function() {
                        return _this.getLastError();
                    });
                    var isDifferent = this.isDifferentFromLastResult(result, variables);
                    if (lastError || !result.partial || this.options.returnPartialData) {
                        this.updateLastResult(result, variables);
                    }
                    if (lastError || isDifferent) {
                        utilities.iterateObserversSafely(this.observers, "next", this.maskResult(result));
                    }
                };
                ObservableQuery.prototype.reportError = function(error, variables) {
                    var _this = this;
                    var errorResult = tslib.__assign(tslib.__assign({}, muteDeprecations("getLastResult", function() {
                        return _this.getLastResult();
                    })), {
                        error: error,
                        errors: error.graphQLErrors,
                        networkStatus: exports.NetworkStatus.error,
                        loading: false
                    });
                    this.updateLastResult(errorResult, variables);
                    utilities.iterateObserversSafely(this.observers, "error", (this.last.error = error));
                };
                ObservableQuery.prototype.hasObservers = function() {
                    return this.observers.size > 0;
                };
                ObservableQuery.prototype.tearDownQuery = function() {
                    if (this.isTornDown) return;
                    if (this.concast && this.observer) {
                        this.concast.removeObserver(this.observer);
                        delete this.concast;
                        delete this.observer;
                    }
                    this.stopPolling();
                    this.subscriptions.forEach(function(sub) {
                        return sub.unsubscribe();
                    });
                    this.subscriptions.clear();
                    this.queryManager.stopQuery(this.queryId);
                    this.observers.clear();
                    this.isTornDown = true;
                };
                ObservableQuery.prototype.transformDocument = function(document) {
                    return this.queryManager.transform(document);
                };
                ObservableQuery.prototype.maskResult = function(result) {
                    return result && "data" in result ? tslib.__assign(tslib.__assign({}, result), {
                        data: this.queryManager.maskOperation({
                            document: this.query,
                            data: result.data,
                            fetchPolicy: this.options.fetchPolicy,
                            id: this.queryId
                        })
                    }) : result;
                };
                ObservableQuery.prototype.resetNotifications = function() {
                    this.cancelNotifyTimeout();
                    this.dirty = false;
                };
                ObservableQuery.prototype.cancelNotifyTimeout = function() {
                    if (this.notifyTimeout) {
                        clearTimeout(this.notifyTimeout);
                        this.notifyTimeout = void 0;
                    }
                };
                ObservableQuery.prototype.scheduleNotify = function() {
                    var _this = this;
                    if (this.dirty) return;
                    this.dirty = true;
                    if (!this.notifyTimeout) {
                        this.notifyTimeout = setTimeout(function() {
                            return _this.notify();
                        }, 0);
                    }
                };
                ObservableQuery.prototype.notify = function() {
                    this.cancelNotifyTimeout();
                    if (this.dirty) {
                        if (this.options.fetchPolicy == "cache-only" || this.options.fetchPolicy == "cache-and-network" || !isNetworkRequestInFlight(this.queryInfo.networkStatus)) {
                            var diff = this.queryInfo.getDiff();
                            if (diff.fromOptimisticTransaction) {
                                this.observe();
                            } else {
                                this.reobserveCacheFirst();
                            }
                        }
                    }
                    this.dirty = false;
                };
                ObservableQuery.prototype.reobserveCacheFirst = function() {
                    var _a = this.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;
                    if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
                        return this.reobserve({
                            fetchPolicy: "cache-first",
                            nextFetchPolicy: function(currentFetchPolicy, context) {
                                this.nextFetchPolicy = nextFetchPolicy;
                                if (typeof this.nextFetchPolicy === "function") {
                                    return this.nextFetchPolicy(currentFetchPolicy, context);
                                }
                                return fetchPolicy;
                            }
                        });
                    }
                    return this.reobserve();
                };
                ObservableQuery.inactiveOnCreation = new optimism.Slot();
                return ObservableQuery;
            }(utilities.Observable));
            utilities.fixObservableSubclass(ObservableQuery);
            function defaultSubscriptionObserverErrorCallback(error) {
                globalThis.__DEV__ !== false && globals.invariant.error(33, error.message, error.stack);
            }
            function logMissingFieldErrors(missing) {
                if (globalThis.__DEV__ !== false && missing) {
                    globalThis.__DEV__ !== false && globals.invariant.debug(34, missing);
                }
            }
            function skipCacheDataFor(fetchPolicy) {
                return (fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby");
            }
            var destructiveMethodCounts = new (utilities.canUseWeakMap ? WeakMap : Map)();
            function wrapDestructiveCacheMethod(cache, methodName) {
                var original = cache[methodName];
                if (typeof original === "function") {
                    cache[methodName] = function() {
                        destructiveMethodCounts.set(cache, (destructiveMethodCounts.get(cache) + 1) % 1e15);
                        return original.apply(this, arguments);
                    };
                }
            }
            var QueryInfo = (function() {
                function QueryInfo(queryManager, queryId) {
                    if (queryId === void 0) {
                        queryId = queryManager.generateQueryId();
                    }
                    this.queryId = queryId;
                    this.document = null;
                    this.lastRequestId = 1;
                    this.stopped = false;
                    this.observableQuery = null;
                    var cache = (this.cache = queryManager.cache);
                    if (!destructiveMethodCounts.has(cache)) {
                        destructiveMethodCounts.set(cache, 0);
                        wrapDestructiveCacheMethod(cache, "evict");
                        wrapDestructiveCacheMethod(cache, "modify");
                        wrapDestructiveCacheMethod(cache, "reset");
                    }
                }
                QueryInfo.prototype.init = function(query) {
                    var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
                    if (this.variables && this.networkStatus !== exports.NetworkStatus.loading && !equal.equal(this.variables, query.variables)) {
                        networkStatus = exports.NetworkStatus.setVariables;
                    }
                    if (!equal.equal(query.variables, this.variables)) {
                        this.lastDiff = void 0;
                        this.cancel();
                    }
                    Object.assign(this, {
                        document: query.document,
                        variables: query.variables,
                        networkError: null,
                        graphQLErrors: this.graphQLErrors || [],
                        networkStatus: networkStatus
                    });
                    if (query.observableQuery) {
                        this.setObservableQuery(query.observableQuery);
                    }
                    if (query.lastRequestId) {
                        this.lastRequestId = query.lastRequestId;
                    }
                    return this;
                };
                QueryInfo.prototype.resetDiff = function() {
                    this.lastDiff = void 0;
                };
                QueryInfo.prototype.getDiff = function() {
                    var _this = this;
                    var options = this.getDiffOptions();
                    if (this.lastDiff && equal.equal(options, this.lastDiff.options)) {
                        return this.lastDiff.diff;
                    }
                    this.updateWatch(this.variables);
                    var oq = this.observableQuery;
                    if (oq && oq.options.fetchPolicy === "no-cache") {
                        return {
                            complete: false
                        };
                    }
                    var diff = muteDeprecations("canonizeResults", function() {
                        return _this.cache.diff(options);
                    });
                    this.updateLastDiff(diff, options);
                    return diff;
                };
                QueryInfo.prototype.updateLastDiff = function(diff, options) {
                    this.lastDiff = diff ? {
                        diff: diff,
                        options: options || this.getDiffOptions()
                    } : void 0;
                };
                QueryInfo.prototype.getDiffOptions = function(variables) {
                    var _a;
                    if (variables === void 0) {
                        variables = this.variables;
                    }
                    return {
                        query: this.document,
                        variables: variables,
                        returnPartialData: true,
                        optimistic: true,
                        canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults
                    };
                };
                QueryInfo.prototype.setDiff = function(diff) {
                    var _this = this;
                    var _a;
                    var oldDiff = this.lastDiff && this.lastDiff.diff;
                    if (diff && !diff.complete && muteDeprecations("getLastError", function() {
                        var _a;
                        return (_a = _this.observableQuery) === null || _a === void 0 ? void 0 : _a.getLastError();
                    })) {
                        return;
                    }
                    this.updateLastDiff(diff);
                    if (!equal.equal(oldDiff && oldDiff.result, diff && diff.result)) {
                        (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a["scheduleNotify"]();
                    }
                };
                QueryInfo.prototype.setObservableQuery = function(oq) {
                    if (oq === this.observableQuery) return;
                    this.observableQuery = oq;
                    if (oq) {
                        oq["queryInfo"] = this;
                    }
                };
                QueryInfo.prototype.stop = function() {
                    var _a;
                    if (!this.stopped) {
                        this.stopped = true;
                        (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a["resetNotifications"]();
                        this.cancel();
                        var oq = this.observableQuery;
                        if (oq) oq.stopPolling();
                    }
                };
                QueryInfo.prototype.cancel = function() {
                    var _a;
                    (_a = this.cancelWatch) === null || _a === void 0 ? void 0 : _a.call(this);
                    this.cancelWatch = void 0;
                };
                QueryInfo.prototype.updateWatch = function(variables) {
                    var _this = this;
                    if (variables === void 0) {
                        variables = this.variables;
                    }
                    var oq = this.observableQuery;
                    if (oq && oq.options.fetchPolicy === "no-cache") {
                        return;
                    }
                    var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), {
                        watcher: this,
                        callback: function(diff) {
                            return _this.setDiff(diff);
                        }
                    });
                    if (!this.lastWatch || !equal.equal(watchOptions, this.lastWatch)) {
                        this.cancel();
                        this.cancelWatch = this.cache.watch((this.lastWatch = watchOptions));
                    }
                };
                QueryInfo.prototype.resetLastWrite = function() {
                    this.lastWrite = void 0;
                };
                QueryInfo.prototype.shouldWrite = function(result, variables) {
                    var lastWrite = this.lastWrite;
                    return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal.equal(variables, lastWrite.variables) && equal.equal(result.data, lastWrite.result.data));
                };
                QueryInfo.prototype.markResult = function(result, document, options, cacheWriteBehavior) {
                    var _this = this;
                    var _a;
                    var merger = new utilities.DeepMerger();
                    var graphQLErrors = utilities.isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
                    (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a["resetNotifications"]();
                    if ("incremental" in result && utilities.isNonEmptyArray(result.incremental)) {
                        var mergedData = utilities.mergeIncrementalData(this.getDiff().result, result);
                        result.data = mergedData;
                    } else if ("hasNext" in result && result.hasNext) {
                        var diff = this.getDiff();
                        result.data = merger.merge(diff.result, result.data);
                    }
                    this.graphQLErrors = graphQLErrors;
                    if (options.fetchPolicy === "no-cache") {
                        this.updateLastDiff({
                            result: result.data,
                            complete: true
                        }, this.getDiffOptions(options.variables));
                    } else if (cacheWriteBehavior !== 0) {
                        if (shouldWriteResult(result, options.errorPolicy)) {
                            this.cache.performTransaction(function(cache) {
                                if (_this.shouldWrite(result, options.variables)) {
                                    cache.writeQuery({
                                        query: document,
                                        data: result.data,
                                        variables: options.variables,
                                        overwrite: cacheWriteBehavior === 1
                                    });
                                    _this.lastWrite = {
                                        result: result,
                                        variables: options.variables,
                                        dmCount: destructiveMethodCounts.get(_this.cache)
                                    };
                                } else {
                                    if (_this.lastDiff && _this.lastDiff.diff.complete) {
                                        result.data = _this.lastDiff.diff.result;
                                        return;
                                    }
                                }
                                var diffOptions = _this.getDiffOptions(options.variables);
                                var diff = muteDeprecations("canonizeResults", function() {
                                    return cache.diff(diffOptions);
                                });
                                if (!_this.stopped && equal.equal(_this.variables, options.variables)) {
                                    _this.updateWatch(options.variables);
                                }
                                _this.updateLastDiff(diff, diffOptions);
                                if (diff.complete) {
                                    result.data = diff.result;
                                }
                            });
                        } else {
                            this.lastWrite = void 0;
                        }
                    }
                };
                QueryInfo.prototype.markReady = function() {
                    this.networkError = null;
                    return (this.networkStatus = exports.NetworkStatus.ready);
                };
                QueryInfo.prototype.markError = function(error) {
                    var _a;
                    this.networkStatus = exports.NetworkStatus.error;
                    this.lastWrite = void 0;
                    (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a["resetNotifications"]();
                    if (error.graphQLErrors) {
                        this.graphQLErrors = error.graphQLErrors;
                    }
                    if (error.networkError) {
                        this.networkError = error.networkError;
                    }
                    return error;
                };
                return QueryInfo;
            }());
            function shouldWriteResult(result, errorPolicy) {
                if (errorPolicy === void 0) {
                    errorPolicy = "none";
                }
                var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
                var writeWithErrors = !utilities.graphQLResultHasError(result);
                if (!writeWithErrors && ignoreErrors && result.data) {
                    writeWithErrors = true;
                }
                return writeWithErrors;
            }
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var IGNORE = Object.create(null);
            var QueryManager = (function() {
                function QueryManager(options) {
                    var _this = this;
                    this.clientAwareness = {};
                    this.queries = new Map();
                    this.fetchCancelFns = new Map();
                    this.transformCache = new utilities.AutoCleanedWeakCache(utilities.cacheSizes["queryManager.getDocumentInfo"] || 2000);
                    this.queryIdCounter = 1;
                    this.requestIdCounter = 1;
                    this.mutationIdCounter = 1;
                    this.inFlightLinkObservables = new trie.Trie(false);
                    this.noCacheWarningsByQueryId = new Set();
                    var defaultDocumentTransform = new utilities.DocumentTransform(function(document) {
                        return _this.cache.transformDocument(document);
                    }, {
                        cache: false
                    });
                    this.cache = options.cache;
                    this.link = options.link;
                    this.defaultOptions = options.defaultOptions;
                    this.queryDeduplication = options.queryDeduplication;
                    this.clientAwareness = options.clientAwareness;
                    this.localState = options.localState;
                    this.ssrMode = options.ssrMode;
                    this.assumeImmutableResults = options.assumeImmutableResults;
                    this.dataMasking = options.dataMasking;
                    var documentTransform = options.documentTransform;
                    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
                    this.defaultContext = options.defaultContext || Object.create(null);
                    if ((this.onBroadcast = options.onBroadcast)) {
                        this.mutationStore = Object.create(null);
                    }
                }
                QueryManager.prototype.stop = function() {
                    var _this = this;
                    this.queries.forEach(function(_info, queryId) {
                        _this.stopQueryNoBroadcast(queryId);
                    });
                    this.cancelPendingFetches(globals.newInvariantError(35));
                };
                QueryManager.prototype.cancelPendingFetches = function(error) {
                    this.fetchCancelFns.forEach(function(cancel) {
                        return cancel(error);
                    });
                    this.fetchCancelFns.clear();
                };
                QueryManager.prototype.mutate = function(_a) {
                    return tslib.__awaiter(this, arguments, void 0, function(_b) {
                        var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;
                        var _c, _d;
                        var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
                        return tslib.__generator(this, function(_j) {
                            switch(_j.label){
                                case 0:
                                    globals.invariant(mutation, 36);
                                    globals.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 37);
                                    mutationId = this.generateMutationId();
                                    mutation = this.cache.transformForLink(this.transform(mutation));
                                    hasClientExports = this.getDocumentInfo(mutation).hasClientExports;
                                    variables = this.getVariables(mutation, variables);
                                    if (!hasClientExports) return [
                                        3,
                                        2
                                    ];
                                    return [
                                        4,
                                        this.localState.addExportedVariables(mutation, variables, context)
                                    ];
                                case 1:
                                    variables = (_j.sent());
                                    _j.label = 2;
                                case 2:
                                    mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                                        mutation: mutation,
                                        variables: variables,
                                        loading: true,
                                        error: null
                                    });
                                    isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                                        mutationId: mutationId,
                                        document: mutation,
                                        variables: variables,
                                        fetchPolicy: fetchPolicy,
                                        errorPolicy: errorPolicy,
                                        context: context,
                                        updateQueries: updateQueries,
                                        update: updateWithProxyFn,
                                        keepRootFields: keepRootFields
                                    });
                                    this.broadcastQueries();
                                    self = this;
                                    return [
                                        2,
                                        new Promise(function(resolve, reject) {
                                            return utilities.asyncMap(self.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context), {
                                                optimisticResponse: isOptimistic ? optimisticResponse : void 0
                                            }), variables, {}, false), function(result) {
                                                if (utilities.graphQLResultHasError(result) && errorPolicy === "none") {
                                                    throw new errors.ApolloError({
                                                        graphQLErrors: utilities.getGraphQLErrorsFromResult(result)
                                                    });
                                                }
                                                if (mutationStoreValue) {
                                                    mutationStoreValue.loading = false;
                                                    mutationStoreValue.error = null;
                                                }
                                                var storeResult = tslib.__assign({}, result);
                                                if (typeof refetchQueries === "function") {
                                                    refetchQueries = refetchQueries(storeResult);
                                                }
                                                if (errorPolicy === "ignore" && utilities.graphQLResultHasError(storeResult)) {
                                                    delete storeResult.errors;
                                                }
                                                return self.markMutationResult({
                                                    mutationId: mutationId,
                                                    result: storeResult,
                                                    document: mutation,
                                                    variables: variables,
                                                    fetchPolicy: fetchPolicy,
                                                    errorPolicy: errorPolicy,
                                                    context: context,
                                                    update: updateWithProxyFn,
                                                    updateQueries: updateQueries,
                                                    awaitRefetchQueries: awaitRefetchQueries,
                                                    refetchQueries: refetchQueries,
                                                    removeOptimistic: isOptimistic ? mutationId : void 0,
                                                    onQueryUpdated: onQueryUpdated,
                                                    keepRootFields: keepRootFields
                                                });
                                            }).subscribe({
                                                next: function(storeResult) {
                                                    self.broadcastQueries();
                                                    if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                                                        resolve(tslib.__assign(tslib.__assign({}, storeResult), {
                                                            data: self.maskOperation({
                                                                document: mutation,
                                                                data: storeResult.data,
                                                                fetchPolicy: fetchPolicy,
                                                                id: mutationId
                                                            })
                                                        }));
                                                    }
                                                },
                                                error: function(err) {
                                                    if (mutationStoreValue) {
                                                        mutationStoreValue.loading = false;
                                                        mutationStoreValue.error = err;
                                                    }
                                                    if (isOptimistic) {
                                                        self.cache.removeOptimistic(mutationId);
                                                    }
                                                    self.broadcastQueries();
                                                    reject(err instanceof errors.ApolloError ? err : (new errors.ApolloError({
                                                        networkError: err
                                                    })));
                                                }
                                            });
                                        })
                                    ];
                            }
                        });
                    });
                };
                QueryManager.prototype.markMutationResult = function(mutation, cache) {
                    var _this = this;
                    if (cache === void 0) {
                        cache = this.cache;
                    }
                    var result = mutation.result;
                    var cacheWrites = [];
                    var skipCache = mutation.fetchPolicy === "no-cache";
                    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
                        if (!utilities.isExecutionPatchIncrementalResult(result)) {
                            cacheWrites.push({
                                result: result.data,
                                dataId: "ROOT_MUTATION",
                                query: mutation.document,
                                variables: mutation.variables
                            });
                        }
                        if (utilities.isExecutionPatchIncrementalResult(result) && utilities.isNonEmptyArray(result.incremental)) {
                            var diff = cache.diff({
                                id: "ROOT_MUTATION",
                                query: this.getDocumentInfo(mutation.document).asQuery,
                                variables: mutation.variables,
                                optimistic: false,
                                returnPartialData: true
                            });
                            var mergedData = void 0;
                            if (diff.result) {
                                mergedData = mergeIncrementalData(diff.result, result);
                            }
                            if (typeof mergedData !== "undefined") {
                                result.data = mergedData;
                                cacheWrites.push({
                                    result: mergedData,
                                    dataId: "ROOT_MUTATION",
                                    query: mutation.document,
                                    variables: mutation.variables
                                });
                            }
                        }
                        var updateQueries_1 = mutation.updateQueries;
                        if (updateQueries_1) {
                            this.queries.forEach(function(_a, queryId) {
                                var observableQuery = _a.observableQuery;
                                var queryName = observableQuery && observableQuery.queryName;
                                if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {
                                    return;
                                }
                                var updater = updateQueries_1[queryName];
                                var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;
                                var _c = cache.diff({
                                    query: document,
                                    variables: variables,
                                    returnPartialData: true,
                                    optimistic: false
                                }), currentQueryResult = _c.result, complete = _c.complete;
                                if (complete && currentQueryResult) {
                                    var nextQueryResult = updater(currentQueryResult, {
                                        mutationResult: result,
                                        queryName: (document && utilities.getOperationName(document)) || void 0,
                                        queryVariables: variables
                                    });
                                    if (nextQueryResult) {
                                        cacheWrites.push({
                                            result: nextQueryResult,
                                            dataId: "ROOT_QUERY",
                                            query: document,
                                            variables: variables
                                        });
                                    }
                                }
                            });
                        }
                    }
                    if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
                        var results_1 = [];
                        this.refetchQueries({
                            updateCache: function(cache) {
                                if (!skipCache) {
                                    cacheWrites.forEach(function(write) {
                                        return cache.write(write);
                                    });
                                }
                                var update = mutation.update;
                                var isFinalResult = !utilities.isExecutionPatchResult(result) || (utilities.isExecutionPatchIncrementalResult(result) && !result.hasNext);
                                if (update) {
                                    if (!skipCache) {
                                        var diff = cache.diff({
                                            id: "ROOT_MUTATION",
                                            query: _this.getDocumentInfo(mutation.document).asQuery,
                                            variables: mutation.variables,
                                            optimistic: false,
                                            returnPartialData: true
                                        });
                                        if (diff.complete) {
                                            result = tslib.__assign(tslib.__assign({}, result), {
                                                data: diff.result
                                            });
                                            if ("incremental" in result) {
                                                delete result.incremental;
                                            }
                                            if ("hasNext" in result) {
                                                delete result.hasNext;
                                            }
                                        }
                                    }
                                    if (isFinalResult) {
                                        update(cache, result, {
                                            context: mutation.context,
                                            variables: mutation.variables
                                        });
                                    }
                                }
                                if (!skipCache && !mutation.keepRootFields && isFinalResult) {
                                    cache.modify({
                                        id: "ROOT_MUTATION",
                                        fields: function(value, _a) {
                                            var fieldName = _a.fieldName, DELETE = _a.DELETE;
                                            return fieldName === "__typename" ? value : DELETE;
                                        }
                                    });
                                }
                            },
                            include: mutation.refetchQueries,
                            optimistic: false,
                            removeOptimistic: mutation.removeOptimistic,
                            onQueryUpdated: mutation.onQueryUpdated || null
                        }).forEach(function(result) {
                            return results_1.push(result);
                        });
                        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
                            return Promise.all(results_1).then(function() {
                                return result;
                            });
                        }
                    }
                    return Promise.resolve(result);
                };
                QueryManager.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
                    var _this = this;
                    var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, {
                        IGNORE: IGNORE
                    }) : optimisticResponse;
                    if (data === IGNORE) {
                        return false;
                    }
                    this.cache.recordOptimisticTransaction(function(cache) {
                        try {
                            _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), {
                                result: {
                                    data: data
                                }
                            }), cache);
                        } catch (error) {
                            globalThis.__DEV__ !== false && globals.invariant.error(error);
                        }
                    }, mutation.mutationId);
                    return true;
                };
                QueryManager.prototype.fetchQuery = function(queryId, options, networkStatus) {
                    return this.fetchConcastWithInfo(this.getOrCreateQuery(queryId), options, networkStatus).concast.promise;
                };
                QueryManager.prototype.getQueryStore = function() {
                    var store = Object.create(null);
                    this.queries.forEach(function(info, queryId) {
                        store[queryId] = {
                            variables: info.variables,
                            networkStatus: info.networkStatus,
                            networkError: info.networkError,
                            graphQLErrors: info.graphQLErrors
                        };
                    });
                    return store;
                };
                QueryManager.prototype.resetErrors = function(queryId) {
                    var queryInfo = this.queries.get(queryId);
                    if (queryInfo) {
                        queryInfo.networkError = undefined;
                        queryInfo.graphQLErrors = [];
                    }
                };
                QueryManager.prototype.transform = function(document) {
                    return this.documentTransform.transformDocument(document);
                };
                QueryManager.prototype.getDocumentInfo = function(document) {
                    var transformCache = this.transformCache;
                    if (!transformCache.has(document)) {
                        var cacheEntry = {
                            hasClientExports: utilities.hasClientExports(document),
                            hasForcedResolvers: this.localState.shouldForceResolvers(document),
                            hasNonreactiveDirective: utilities.hasDirectives([
                                "nonreactive"
                            ], document),
                            nonReactiveQuery: utilities.addNonReactiveToNamedFragments(document),
                            clientQuery: this.localState.clientQuery(document),
                            serverQuery: utilities.removeDirectivesFromDocument([
                                {
                                    name: "client",
                                    remove: true
                                },
                                {
                                    name: "connection"
                                },
                                {
                                    name: "nonreactive"
                                },
                                {
                                    name: "unmask"
                                }
                            ], document),
                            defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(document)),
                            asQuery: tslib.__assign(tslib.__assign({}, document), {
                                definitions: document.definitions.map(function(def) {
                                    if (def.kind === "OperationDefinition" && def.operation !== "query") {
                                        return tslib.__assign(tslib.__assign({}, def), {
                                            operation: "query"
                                        });
                                    }
                                    return def;
                                })
                            })
                        };
                        transformCache.set(document, cacheEntry);
                    }
                    return transformCache.get(document);
                };
                QueryManager.prototype.getVariables = function(document, variables) {
                    return tslib.__assign(tslib.__assign({}, this.getDocumentInfo(document).defaultVars), variables);
                };
                QueryManager.prototype.watchQuery = function(options) {
                    var query = this.transform(options.query);
                    options = tslib.__assign(tslib.__assign({}, options), {
                        variables: this.getVariables(query, options.variables)
                    });
                    if (typeof options.notifyOnNetworkStatusChange === "undefined") {
                        options.notifyOnNetworkStatusChange = false;
                    }
                    var queryInfo = new QueryInfo(this);
                    var observable = new ObservableQuery({
                        queryManager: this,
                        queryInfo: queryInfo,
                        options: options
                    });
                    observable["lastQuery"] = query;
                    if (!ObservableQuery["inactiveOnCreation"].getValue()) {
                        this.queries.set(observable.queryId, queryInfo);
                    }
                    queryInfo.init({
                        document: query,
                        observableQuery: observable,
                        variables: observable.variables
                    });
                    return observable;
                };
                QueryManager.prototype.query = function(options, queryId) {
                    var _this = this;
                    if (queryId === void 0) {
                        queryId = this.generateQueryId();
                    }
                    globals.invariant(options.query, 38);
                    globals.invariant(options.query.kind === "Document", 39);
                    globals.invariant(!options.returnPartialData, 40);
                    globals.invariant(!options.pollInterval, 41);
                    var query = this.transform(options.query);
                    return this.fetchQuery(queryId, tslib.__assign(tslib.__assign({}, options), {
                        query: query
                    })).then(function(result) {
                        return result && tslib.__assign(tslib.__assign({}, result), {
                            data: _this.maskOperation({
                                document: query,
                                data: result.data,
                                fetchPolicy: options.fetchPolicy,
                                id: queryId
                            })
                        });
                    }).finally(function() {
                        return _this.stopQuery(queryId);
                    });
                };
                QueryManager.prototype.generateQueryId = function() {
                    return String(this.queryIdCounter++);
                };
                QueryManager.prototype.generateRequestId = function() {
                    return this.requestIdCounter++;
                };
                QueryManager.prototype.generateMutationId = function() {
                    return String(this.mutationIdCounter++);
                };
                QueryManager.prototype.stopQueryInStore = function(queryId) {
                    this.stopQueryInStoreNoBroadcast(queryId);
                    this.broadcastQueries();
                };
                QueryManager.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
                    var queryInfo = this.queries.get(queryId);
                    if (queryInfo) queryInfo.stop();
                };
                QueryManager.prototype.clearStore = function(options) {
                    if (options === void 0) {
                        options = {
                            discardWatches: true
                        };
                    }
                    this.cancelPendingFetches(globals.newInvariantError(42));
                    this.queries.forEach(function(queryInfo) {
                        if (queryInfo.observableQuery) {
                            queryInfo.networkStatus = exports.NetworkStatus.loading;
                        } else {
                            queryInfo.stop();
                        }
                    });
                    if (this.mutationStore) {
                        this.mutationStore = Object.create(null);
                    }
                    return this.cache.reset(options);
                };
                QueryManager.prototype.getObservableQueries = function(include) {
                    var _this = this;
                    if (include === void 0) {
                        include = "active";
                    }
                    var queries = new Map();
                    var queryNames = new Map();
                    var queryNamesAndQueryStrings = new Map();
                    var legacyQueryOptions = new Set();
                    if (Array.isArray(include)) {
                        include.forEach(function(desc) {
                            if (typeof desc === "string") {
                                queryNames.set(desc, desc);
                                queryNamesAndQueryStrings.set(desc, false);
                            } else if (utilities.isDocumentNode(desc)) {
                                var queryString = utilities.print(_this.transform(desc));
                                queryNames.set(queryString, utilities.getOperationName(desc));
                                queryNamesAndQueryStrings.set(queryString, false);
                            } else if (utilities.isNonNullObject(desc) && desc.query) {
                                legacyQueryOptions.add(desc);
                            }
                        });
                    }
                    this.queries.forEach(function(_a, queryId) {
                        var oq = _a.observableQuery, document = _a.document;
                        if (oq) {
                            if (include === "all") {
                                queries.set(queryId, oq);
                                return;
                            }
                            var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
                            if (fetchPolicy === "standby" || (include === "active" && !oq.hasObservers())) {
                                return;
                            }
                            if (include === "active" || (queryName && queryNamesAndQueryStrings.has(queryName)) || (document && queryNamesAndQueryStrings.has(utilities.print(document)))) {
                                queries.set(queryId, oq);
                                if (queryName) queryNamesAndQueryStrings.set(queryName, true);
                                if (document) queryNamesAndQueryStrings.set(utilities.print(document), true);
                            }
                        }
                    });
                    if (legacyQueryOptions.size) {
                        legacyQueryOptions.forEach(function(options) {
                            var queryId = utilities.makeUniqueId("legacyOneTimeQuery");
                            var queryInfo = _this.getOrCreateQuery(queryId).init({
                                document: options.query,
                                variables: options.variables
                            });
                            var oq = new ObservableQuery({
                                queryManager: _this,
                                queryInfo: queryInfo,
                                options: tslib.__assign(tslib.__assign({}, options), {
                                    fetchPolicy: "network-only"
                                })
                            });
                            globals.invariant(oq.queryId === queryId);
                            queryInfo.setObservableQuery(oq);
                            queries.set(queryId, oq);
                        });
                    }
                    if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {
                        queryNamesAndQueryStrings.forEach(function(included, nameOrQueryString) {
                            if (!included) {
                                var queryName = queryNames.get(nameOrQueryString);
                                if (queryName) {
                                    globalThis.__DEV__ !== false && globals.invariant.warn(43, queryName);
                                } else {
                                    globalThis.__DEV__ !== false && globals.invariant.warn(44);
                                }
                            }
                        });
                    }
                    return queries;
                };
                QueryManager.prototype.reFetchObservableQueries = function(includeStandby) {
                    var _this = this;
                    if (includeStandby === void 0) {
                        includeStandby = false;
                    }
                    var observableQueryPromises = [];
                    this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
                        var fetchPolicy = observableQuery.options.fetchPolicy;
                        muteDeprecations("resetLastResults", function() {
                            return observableQuery.resetLastResults();
                        });
                        if (includeStandby || (fetchPolicy !== "standby" && fetchPolicy !== "cache-only")) {
                            observableQueryPromises.push(observableQuery.refetch());
                        }
                        (_this.queries.get(queryId) || observableQuery["queryInfo"]).setDiff(null);
                    });
                    this.broadcastQueries();
                    return Promise.all(observableQueryPromises);
                };
                QueryManager.prototype.startGraphQLSubscription = function(options) {
                    var _this = this;
                    var query = options.query, variables = options.variables;
                    var fetchPolicy = options.fetchPolicy, _a = options.errorPolicy, errorPolicy = _a === void 0 ? "none" : _a, _b = options.context, context = _b === void 0 ? {} : _b, _c = options.extensions, extensions = _c === void 0 ? {} : _c;
                    query = this.transform(query);
                    variables = this.getVariables(query, variables);
                    var makeObservable = function(variables) {
                        return _this.getObservableFromLink(query, context, variables, extensions).map(function(result) {
                            if (fetchPolicy !== "no-cache") {
                                if (shouldWriteResult(result, errorPolicy)) {
                                    _this.cache.write({
                                        query: query,
                                        result: result.data,
                                        dataId: "ROOT_SUBSCRIPTION",
                                        variables: variables
                                    });
                                }
                                _this.broadcastQueries();
                            }
                            var hasErrors = utilities.graphQLResultHasError(result);
                            var hasProtocolErrors = errors.graphQLResultHasProtocolErrors(result);
                            if (hasErrors || hasProtocolErrors) {
                                var errors$1 = {};
                                if (hasErrors) {
                                    errors$1.graphQLErrors = result.errors;
                                }
                                if (hasProtocolErrors) {
                                    errors$1.protocolErrors = result.extensions[errors.PROTOCOL_ERRORS_SYMBOL];
                                }
                                if (errorPolicy === "none" || hasProtocolErrors) {
                                    throw new errors.ApolloError(errors$1);
                                }
                            }
                            if (errorPolicy === "ignore") {
                                delete result.errors;
                            }
                            return result;
                        });
                    };
                    if (this.getDocumentInfo(query).hasClientExports) {
                        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
                        return new utilities.Observable(function(observer) {
                            var sub = null;
                            observablePromise_1.then(function(observable) {
                                return (sub = observable.subscribe(observer));
                            }, observer.error);
                            return function() {
                                return sub && sub.unsubscribe();
                            };
                        });
                    }
                    return makeObservable(variables);
                };
                QueryManager.prototype.stopQuery = function(queryId) {
                    this.stopQueryNoBroadcast(queryId);
                    this.broadcastQueries();
                };
                QueryManager.prototype.stopQueryNoBroadcast = function(queryId) {
                    this.stopQueryInStoreNoBroadcast(queryId);
                    this.removeQuery(queryId);
                };
                QueryManager.prototype.removeQuery = function(queryId) {
                    var _a;
                    this.fetchCancelFns.delete(queryId);
                    if (this.queries.has(queryId)) {
                        (_a = this.queries.get(queryId)) === null || _a === void 0 ? void 0 : _a.stop();
                        this.queries.delete(queryId);
                    }
                };
                QueryManager.prototype.broadcastQueries = function() {
                    if (this.onBroadcast) this.onBroadcast();
                    this.queries.forEach(function(info) {
                        var _a;
                        return (_a = info.observableQuery) === null || _a === void 0 ? void 0 : _a["notify"]();
                    });
                };
                QueryManager.prototype.getLocalState = function() {
                    return this.localState;
                };
                QueryManager.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
                    var _this = this;
                    var _a;
                    if (deduplication === void 0) {
                        deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;
                    }
                    var observable;
                    var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
                    if (serverQuery) {
                        var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
                        var operation = {
                            query: serverQuery,
                            variables: variables,
                            operationName: utilities.getOperationName(serverQuery) || void 0,
                            context: this.prepareContext(tslib.__assign(tslib.__assign({}, context), {
                                forceFetch: !deduplication
                            })),
                            extensions: extensions
                        };
                        context = operation.context;
                        if (deduplication) {
                            var printedServerQuery_1 = utilities.print(serverQuery);
                            var varJson_1 = cache.canonicalStringify(variables);
                            var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
                            observable = entry.observable;
                            if (!observable) {
                                var concast_1 = new utilities.Concast([
                                    core.execute(link, operation)
                                ]);
                                observable = entry.observable = concast_1;
                                concast_1.beforeNext(function cb(method, arg) {
                                    if (method === "next" && "hasNext" in arg && arg.hasNext) {
                                        concast_1.beforeNext(cb);
                                    } else {
                                        inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
                                    }
                                });
                            }
                        } else {
                            observable = new utilities.Concast([
                                core.execute(link, operation)
                            ]);
                        }
                    } else {
                        observable = new utilities.Concast([
                            utilities.Observable.of({
                                data: {}
                            })
                        ]);
                        context = this.prepareContext(context);
                    }
                    if (clientQuery) {
                        observable = utilities.asyncMap(observable, function(result) {
                            return _this.localState.runResolvers({
                                document: clientQuery,
                                remoteResult: result,
                                context: context,
                                variables: variables
                            });
                        });
                    }
                    return observable;
                };
                QueryManager.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
                    var requestId = (queryInfo.lastRequestId = this.generateRequestId());
                    var linkDocument = this.cache.transformForLink(options.query);
                    return utilities.asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {
                        var graphQLErrors = utilities.getGraphQLErrorsFromResult(result);
                        var hasErrors = graphQLErrors.length > 0;
                        var errorPolicy = options.errorPolicy;
                        if (requestId >= queryInfo.lastRequestId) {
                            if (hasErrors && errorPolicy === "none") {
                                throw queryInfo.markError(new errors.ApolloError({
                                    graphQLErrors: graphQLErrors
                                }));
                            }
                            queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);
                            queryInfo.markReady();
                        }
                        var aqr = {
                            data: result.data,
                            loading: false,
                            networkStatus: exports.NetworkStatus.ready
                        };
                        if (hasErrors && errorPolicy === "none") {
                            aqr.data = void 0;
                        }
                        if (hasErrors && errorPolicy !== "ignore") {
                            aqr.errors = graphQLErrors;
                            aqr.networkStatus = exports.NetworkStatus.error;
                        }
                        return aqr;
                    }, function(networkError) {
                        var error = errors.isApolloError(networkError) ? networkError : (new errors.ApolloError({
                            networkError: networkError
                        }));
                        if (requestId >= queryInfo.lastRequestId) {
                            queryInfo.markError(error);
                        }
                        throw error;
                    });
                };
                QueryManager.prototype.fetchConcastWithInfo = function(queryInfo, options, networkStatus, query) {
                    var _this = this;
                    if (networkStatus === void 0) {
                        networkStatus = exports.NetworkStatus.loading;
                    }
                    if (query === void 0) {
                        query = options.query;
                    }
                    var variables = this.getVariables(query, options.variables);
                    var defaults = this.defaultOptions.watchQuery;
                    var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? (defaults && defaults.fetchPolicy) || "cache-first" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? (defaults && defaults.errorPolicy) || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
                    var normalized = Object.assign({}, options, {
                        query: query,
                        variables: variables,
                        fetchPolicy: fetchPolicy,
                        errorPolicy: errorPolicy,
                        returnPartialData: returnPartialData,
                        notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,
                        context: context
                    });
                    var fromVariables = function(variables) {
                        normalized.variables = variables;
                        var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
                        if (normalized.fetchPolicy !== "standby" && sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {
                            queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
                        }
                        return sourcesWithInfo;
                    };
                    var cleanupCancelFn = function() {
                        return _this.fetchCancelFns.delete(queryInfo.queryId);
                    };
                    this.fetchCancelFns.set(queryInfo.queryId, function(reason) {
                        cleanupCancelFn();
                        setTimeout(function() {
                            return concast.cancel(reason);
                        });
                    });
                    var concast, containsDataFromLink;
                    if (this.getDocumentInfo(normalized.query).hasClientExports) {
                        concast = new utilities.Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo) {
                            return sourcesWithInfo.sources;
                        }));
                        containsDataFromLink = true;
                    } else {
                        var sourcesWithInfo = fromVariables(normalized.variables);
                        containsDataFromLink = sourcesWithInfo.fromLink;
                        concast = new utilities.Concast(sourcesWithInfo.sources);
                    }
                    concast.promise.then(cleanupCancelFn, cleanupCancelFn);
                    return {
                        concast: concast,
                        fromLink: containsDataFromLink
                    };
                };
                QueryManager.prototype.refetchQueries = function(_a) {
                    var _this = this;
                    var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;
                    var includedQueriesById = new Map();
                    if (include) {
                        this.getObservableQueries(include).forEach(function(oq, queryId) {
                            includedQueriesById.set(queryId, {
                                oq: oq,
                                lastDiff: (_this.queries.get(queryId) || oq["queryInfo"]).getDiff()
                            });
                        });
                    }
                    var results = new Map();
                    if (updateCache) {
                        this.cache.batch({
                            update: updateCache,
                            optimistic: (optimistic && removeOptimistic) || false,
                            removeOptimistic: removeOptimistic,
                            onWatchUpdated: function(watch, diff, lastDiff) {
                                var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
                                if (oq) {
                                    if (onQueryUpdated) {
                                        includedQueriesById.delete(oq.queryId);
                                        var result = onQueryUpdated(oq, diff, lastDiff);
                                        if (result === true) {
                                            result = oq.refetch();
                                        }
                                        if (result !== false) {
                                            results.set(oq, result);
                                        }
                                        return result;
                                    }
                                    if (onQueryUpdated !== null) {
                                        includedQueriesById.set(oq.queryId, {
                                            oq: oq,
                                            lastDiff: lastDiff,
                                            diff: diff
                                        });
                                    }
                                }
                            }
                        });
                    }
                    if (includedQueriesById.size) {
                        includedQueriesById.forEach(function(_a, queryId) {
                            var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;
                            var result;
                            if (onQueryUpdated) {
                                if (!diff) {
                                    diff = muteDeprecations("canonizeResults", function() {
                                        return _this.cache.diff(oq["queryInfo"]["getDiffOptions"]());
                                    });
                                }
                                result = onQueryUpdated(oq, diff, lastDiff);
                            }
                            if (!onQueryUpdated || result === true) {
                                result = oq.refetch();
                            }
                            if (result !== false) {
                                results.set(oq, result);
                            }
                            if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
                                _this.stopQueryNoBroadcast(queryId);
                            }
                        });
                    }
                    if (removeOptimistic) {
                        this.cache.removeOptimistic(removeOptimistic);
                    }
                    return results;
                };
                QueryManager.prototype.maskOperation = function(options) {
                    var _a, _b, _c;
                    var document = options.document, data = options.data;
                    if (globalThis.__DEV__ !== false) {
                        var fetchPolicy = options.fetchPolicy, id = options.id;
                        var operationType = (_a = utilities.getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation;
                        var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : "o") + id;
                        if (this.dataMasking && fetchPolicy === "no-cache" && !utilities.isFullyUnmaskedOperation(document) && !this.noCacheWarningsByQueryId.has(operationId)) {
                            this.noCacheWarningsByQueryId.add(operationId);
                            globalThis.__DEV__ !== false && globals.invariant.warn(45, (_c = utilities.getOperationName(document)) !== null && _c !== void 0 ? _c : "Unnamed ".concat(operationType !== null && operationType !== void 0 ? operationType : "operation"));
                        }
                    }
                    return (this.dataMasking ? masking.maskOperation(data, document, this.cache) : data);
                };
                QueryManager.prototype.maskFragment = function(options) {
                    var data = options.data, fragment = options.fragment, fragmentName = options.fragmentName;
                    return this.dataMasking ? masking.maskFragment(data, fragment, this.cache, fragmentName) : data;
                };
                QueryManager.prototype.fetchQueryByPolicy = function(queryInfo, _a, networkStatus) {
                    var _this = this;
                    var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;
                    var oldNetworkStatus = queryInfo.networkStatus;
                    queryInfo.init({
                        document: query,
                        variables: variables,
                        networkStatus: networkStatus
                    });
                    var readCache = function() {
                        return queryInfo.getDiff();
                    };
                    var resultsFromCache = function(diff, networkStatus) {
                        if (networkStatus === void 0) {
                            networkStatus = queryInfo.networkStatus || exports.NetworkStatus.loading;
                        }
                        var data = diff.result;
                        if (globalThis.__DEV__ !== false && !returnPartialData && !equal.equal(data, {})) {
                            logMissingFieldErrors(diff.missing);
                        }
                        var fromData = function(data) {
                            return utilities.Observable.of(tslib.__assign({
                                data: data,
                                loading: isNetworkRequestInFlight(networkStatus),
                                networkStatus: networkStatus
                            }, (diff.complete ? null : {
                                partial: true
                            })));
                        };
                        if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
                            return _this.localState.runResolvers({
                                document: query,
                                remoteResult: {
                                    data: data
                                },
                                context: context,
                                variables: variables,
                                onlyRunForcedResolvers: true
                            }).then(function(resolved) {
                                return fromData(resolved.data || void 0);
                            });
                        }
                        if (errorPolicy === "none" && networkStatus === exports.NetworkStatus.refetch && Array.isArray(diff.missing)) {
                            return fromData(void 0);
                        }
                        return fromData(data);
                    };
                    var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : (networkStatus === exports.NetworkStatus.refetch && refetchWritePolicy !== "merge") ? 1 : 2;
                    var resultsFromLink = function() {
                        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
                            query: query,
                            variables: variables,
                            context: context,
                            fetchPolicy: fetchPolicy,
                            errorPolicy: errorPolicy
                        });
                    };
                    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
                    switch(fetchPolicy){
                        default:
                        case "cache-first":
                            {
                                var diff = readCache();
                                if (diff.complete) {
                                    return {
                                        fromLink: false,
                                        sources: [
                                            resultsFromCache(diff, queryInfo.markReady())
                                        ]
                                    };
                                }
                                if (returnPartialData || shouldNotify) {
                                    return {
                                        fromLink: true,
                                        sources: [
                                            resultsFromCache(diff),
                                            resultsFromLink()
                                        ]
                                    };
                                }
                                return {
                                    fromLink: true,
                                    sources: [
                                        resultsFromLink()
                                    ]
                                };
                            }
                        case "cache-and-network":
                            {
                                var diff = readCache();
                                if (diff.complete || returnPartialData || shouldNotify) {
                                    return {
                                        fromLink: true,
                                        sources: [
                                            resultsFromCache(diff),
                                            resultsFromLink()
                                        ]
                                    };
                                }
                                return {
                                    fromLink: true,
                                    sources: [
                                        resultsFromLink()
                                    ]
                                };
                            }
                        case "cache-only":
                            return {
                                fromLink: false,
                                sources: [
                                    resultsFromCache(readCache(), queryInfo.markReady())
                                ]
                            };
                        case "network-only":
                            if (shouldNotify) {
                                return {
                                    fromLink: true,
                                    sources: [
                                        resultsFromCache(readCache()),
                                        resultsFromLink()
                                    ]
                                };
                            }
                            return {
                                fromLink: true,
                                sources: [
                                    resultsFromLink()
                                ]
                            };
                        case "no-cache":
                            if (shouldNotify) {
                                return {
                                    fromLink: true,
                                    sources: [
                                        resultsFromCache(queryInfo.getDiff()),
                                        resultsFromLink()
                                    ]
                                };
                            }
                            return {
                                fromLink: true,
                                sources: [
                                    resultsFromLink()
                                ]
                            };
                        case "standby":
                            return {
                                fromLink: false,
                                sources: []
                            };
                    }
                };
                QueryManager.prototype.getOrCreateQuery = function(queryId) {
                    if (queryId && !this.queries.has(queryId)) {
                        this.queries.set(queryId, new QueryInfo(this, queryId));
                    }
                    return this.queries.get(queryId);
                };
                QueryManager.prototype.prepareContext = function(context) {
                    if (context === void 0) {
                        context = {};
                    }
                    var newContext = this.localState.prepareContext(context);
                    return tslib.__assign(tslib.__assign(tslib.__assign({}, this.defaultContext), newContext), {
                        clientAwareness: this.clientAwareness
                    });
                };
                return QueryManager;
            }());
            var LocalState = (function() {
                function LocalState(_a) {
                    var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
                    this.selectionsToResolveCache = new WeakMap();
                    this.cache = cache;
                    if (client) {
                        this.client = client;
                    }
                    if (resolvers) {
                        this.addResolvers(resolvers);
                    }
                    if (fragmentMatcher) {
                        this.setFragmentMatcher(fragmentMatcher);
                    }
                }
                LocalState.prototype.addResolvers = function(resolvers) {
                    var _this = this;
                    this.resolvers = this.resolvers || {};
                    if (Array.isArray(resolvers)) {
                        resolvers.forEach(function(resolverGroup) {
                            _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);
                        });
                    } else {
                        this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);
                    }
                };
                LocalState.prototype.setResolvers = function(resolvers) {
                    this.resolvers = {};
                    this.addResolvers(resolvers);
                };
                LocalState.prototype.getResolvers = function() {
                    return this.resolvers || {};
                };
                LocalState.prototype.runResolvers = function(_a) {
                    return tslib.__awaiter(this, arguments, void 0, function(_b) {
                        var document = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
                        return tslib.__generator(this, function(_d) {
                            if (document) {
                                return [
                                    2,
                                    this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                                        return (tslib.__assign(tslib.__assign({}, remoteResult), {
                                            data: localResult.result
                                        }));
                                    })
                                ];
                            }
                            return [
                                2,
                                remoteResult
                            ];
                        });
                    });
                };
                LocalState.prototype.setFragmentMatcher = function(fragmentMatcher) {
                    this.fragmentMatcher = fragmentMatcher;
                };
                LocalState.prototype.getFragmentMatcher = function() {
                    return this.fragmentMatcher;
                };
                LocalState.prototype.clientQuery = function(document) {
                    if (utilities.hasDirectives([
                        "client"
                    ], document)) {
                        if (this.resolvers) {
                            return document;
                        }
                    }
                    return null;
                };
                LocalState.prototype.serverQuery = function(document) {
                    return utilities.removeClientSetsFromDocument(document);
                };
                LocalState.prototype.prepareContext = function(context) {
                    var cache = this.cache;
                    return tslib.__assign(tslib.__assign({}, context), {
                        cache: cache,
                        getCacheKey: function(obj) {
                            return cache.identify(obj);
                        }
                    });
                };
                LocalState.prototype.addExportedVariables = function(document_1) {
                    return tslib.__awaiter(this, arguments, void 0, function(document, variables, context) {
                        if (variables === void 0) {
                            variables = {};
                        }
                        if (context === void 0) {
                            context = {};
                        }
                        return tslib.__generator(this, function(_a) {
                            if (document) {
                                return [
                                    2,
                                    this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {
                                        return (tslib.__assign(tslib.__assign({}, variables), data.exportedVariables));
                                    })
                                ];
                            }
                            return [
                                2,
                                tslib.__assign({}, variables)
                            ];
                        });
                    });
                };
                LocalState.prototype.shouldForceResolvers = function(document) {
                    var forceResolvers = false;
                    graphql.visit(document, {
                        Directive: {
                            enter: function(node) {
                                if (node.name.value === "client" && node.arguments) {
                                    forceResolvers = node.arguments.some(function(arg) {
                                        return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                                    });
                                    if (forceResolvers) {
                                        return graphql.BREAK;
                                    }
                                }
                            }
                        }
                    });
                    return forceResolvers;
                };
                LocalState.prototype.buildRootValueFromCache = function(document, variables) {
                    return this.cache.diff({
                        query: utilities.buildQueryFromSelectionSet(document),
                        variables: variables,
                        returnPartialData: true,
                        optimistic: false
                    }).result;
                };
                LocalState.prototype.resolveDocument = function(document_1, rootValue_1) {
                    return tslib.__awaiter(this, arguments, void 0, function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
                        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;
                        if (context === void 0) {
                            context = {};
                        }
                        if (variables === void 0) {
                            variables = {};
                        }
                        if (fragmentMatcher === void 0) {
                            fragmentMatcher = function() {
                                return true;
                            };
                        }
                        if (onlyRunForcedResolvers === void 0) {
                            onlyRunForcedResolvers = false;
                        }
                        return tslib.__generator(this, function(_b) {
                            mainDefinition = utilities.getMainDefinition(document);
                            fragments = utilities.getFragmentDefinitions(document);
                            fragmentMap = utilities.createFragmentMap(fragments);
                            selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
                            definitionOperation = mainDefinition.operation;
                            defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
                            _a = this, cache = _a.cache, client = _a.client;
                            execContext = {
                                fragmentMap: fragmentMap,
                                context: tslib.__assign(tslib.__assign({}, context), {
                                    cache: cache,
                                    client: client
                                }),
                                variables: variables,
                                fragmentMatcher: fragmentMatcher,
                                defaultOperationType: defaultOperationType,
                                exportedVariables: {},
                                selectionsToResolve: selectionsToResolve,
                                onlyRunForcedResolvers: onlyRunForcedResolvers
                            };
                            isClientFieldDescendant = false;
                            return [
                                2,
                                this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {
                                    return ({
                                        result: result,
                                        exportedVariables: execContext.exportedVariables
                                    });
                                })
                            ];
                        });
                    });
                };
                LocalState.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
                    return tslib.__awaiter(this, void 0, void 0, function() {
                        var fragmentMap, context, variables, resultsToMerge, execute;
                        var _this = this;
                        return tslib.__generator(this, function(_a) {
                            fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
                            resultsToMerge = [
                                rootValue
                            ];
                            execute = function(selection) {
                                return tslib.__awaiter(_this, void 0, void 0, function() {
                                    var fragment, typeCondition;
                                    return tslib.__generator(this, function(_a) {
                                        if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                                            return [
                                                2
                                            ];
                                        }
                                        if (!utilities.shouldInclude(selection, variables)) {
                                            return [
                                                2
                                            ];
                                        }
                                        if (utilities.isField(selection)) {
                                            return [
                                                2,
                                                this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                                                    var _a;
                                                    if (typeof fieldResult !== "undefined") {
                                                        resultsToMerge.push((_a = {}, _a[utilities.resultKeyNameFromField(selection)] = fieldResult, _a));
                                                    }
                                                })
                                            ];
                                        }
                                        if (utilities.isInlineFragment(selection)) {
                                            fragment = selection;
                                        } else {
                                            fragment = fragmentMap[selection.name.value];
                                            globals.invariant(fragment, 21, selection.name.value);
                                        }
                                        if (fragment && fragment.typeCondition) {
                                            typeCondition = fragment.typeCondition.name.value;
                                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                                                return [
                                                    2,
                                                    this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                                                        resultsToMerge.push(fragmentResult);
                                                    })
                                                ];
                                            }
                                        }
                                        return [
                                            2
                                        ];
                                    });
                                });
                            };
                            return [
                                2,
                                Promise.all(selectionSet.selections.map(execute)).then(function() {
                                    return utilities.mergeDeepArray(resultsToMerge);
                                })
                            ];
                        });
                    });
                };
                LocalState.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
                    return tslib.__awaiter(this, void 0, void 0, function() {
                        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
                        var _this = this;
                        return tslib.__generator(this, function(_a) {
                            if (!rootValue) {
                                return [
                                    2,
                                    null
                                ];
                            }
                            variables = execContext.variables;
                            fieldName = field.name.value;
                            aliasedFieldName = utilities.resultKeyNameFromField(field);
                            aliasUsed = fieldName !== aliasedFieldName;
                            defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
                            resultPromise = Promise.resolve(defaultResult);
                            if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
                                resolverType = rootValue.__typename || execContext.defaultOperationType;
                                resolverMap = this.resolvers && this.resolvers[resolverType];
                                if (resolverMap) {
                                    resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                                    if (resolve) {
                                        resultPromise = Promise.resolve(cache.cacheSlot.withValue(this.cache, resolve, [
                                            rootValue,
                                            utilities.argumentsObjectFromField(field, variables),
                                            execContext.context,
                                            {
                                                field: field,
                                                fragmentMap: execContext.fragmentMap
                                            }
                                        ]));
                                    }
                                }
                            }
                            return [
                                2,
                                resultPromise.then(function(result) {
                                    var _a, _b;
                                    if (result === void 0) {
                                        result = defaultResult;
                                    }
                                    if (field.directives) {
                                        field.directives.forEach(function(directive) {
                                            if (directive.name.value === "export" && directive.arguments) {
                                                directive.arguments.forEach(function(arg) {
                                                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                                                        execContext.exportedVariables[arg.value.value] = result;
                                                    }
                                                });
                                            }
                                        });
                                    }
                                    if (!field.selectionSet) {
                                        return result;
                                    }
                                    if (result == null) {
                                        return result;
                                    }
                                    var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function(d) {
                                        return d.name.value === "client";
                                    })) !== null && _b !== void 0 ? _b : false;
                                    if (Array.isArray(result)) {
                                        return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);
                                    }
                                    if (field.selectionSet) {
                                        return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);
                                    }
                                })
                            ];
                        });
                    });
                };
                LocalState.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {
                    var _this = this;
                    return Promise.all(result.map(function(item) {
                        if (item === null) {
                            return null;
                        }
                        if (Array.isArray(item)) {
                            return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
                        }
                        if (field.selectionSet) {
                            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
                        }
                    }));
                };
                LocalState.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
                    var isSingleASTNode = function(node) {
                        return !Array.isArray(node);
                    };
                    var selectionsToResolveCache = this.selectionsToResolveCache;
                    function collectByDefinition(definitionNode) {
                        if (!selectionsToResolveCache.has(definitionNode)) {
                            var matches_1 = new Set();
                            selectionsToResolveCache.set(definitionNode, matches_1);
                            graphql.visit(definitionNode, {
                                Directive: function(node, _, __, ___, ancestors) {
                                    if (node.name.value === "client") {
                                        ancestors.forEach(function(node) {
                                            if (isSingleASTNode(node) && graphql.isSelectionNode(node)) {
                                                matches_1.add(node);
                                            }
                                        });
                                    }
                                },
                                FragmentSpread: function(spread, _, __, ___, ancestors) {
                                    var fragment = fragmentMap[spread.name.value];
                                    globals.invariant(fragment, 22, spread.name.value);
                                    var fragmentSelections = collectByDefinition(fragment);
                                    if (fragmentSelections.size > 0) {
                                        ancestors.forEach(function(node) {
                                            if (isSingleASTNode(node) && graphql.isSelectionNode(node)) {
                                                matches_1.add(node);
                                            }
                                        });
                                        matches_1.add(spread);
                                        fragmentSelections.forEach(function(selection) {
                                            matches_1.add(selection);
                                        });
                                    }
                                }
                            });
                        }
                        return selectionsToResolveCache.get(definitionNode);
                    }
                    return collectByDefinition(mainDefinition);
                };
                return LocalState;
            }());
            var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
            var cacheSizes = tslib.__assign({}, globals.global[cacheSizeSymbol]);
            var globalCaches = {};
            var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : undefined;
            function getCurrentCacheSizes() {
                var defaults = {
                    parser: 1000,
                    canonicalStringify: 1000,
                    print: 2000,
                    "documentTransform.cache": 2000,
                    "queryManager.getDocumentInfo": 2000,
                    "PersistedQueryLink.persistedQueryHashes": 2000,
                    "fragmentRegistry.transform": 2000,
                    "fragmentRegistry.lookup": 1000,
                    "fragmentRegistry.findFragmentSpreads": 4000,
                    "cache.fragmentQueryDocuments": 1000,
                    "removeTypenameFromVariables.getVariableDefinitions": 2000,
                    "inMemoryCache.maybeBroadcastWatch": 5000,
                    "inMemoryCache.executeSelectionSet": 50000,
                    "inMemoryCache.executeSubSelectedArray": 10000
                };
                return Object.fromEntries(Object.entries(defaults).map(function(_a) {
                    var k = _a[0], v = _a[1];
                    return [
                        k,
                        cacheSizes[k] || v
                    ];
                }));
            }
            function _getApolloClientMemoryInternals() {
                var _a, _b, _c, _d, _e;
                if (!(globalThis.__DEV__ !== false)) throw new Error("only supported in development mode");
                return {
                    limits: getCurrentCacheSizes(),
                    sizes: tslib.__assign({
                        print: (_a = globalCaches.print) === null || _a === void 0 ? void 0 : _a.call(globalCaches),
                        parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches),
                        canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches),
                        links: linkInfo(this.link),
                        queryManager: {
                            getDocumentInfo: this["queryManager"]["transformCache"].size,
                            documentTransforms: transformInfo(this["queryManager"].documentTransform)
                        }
                    }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
                };
            }
            function isWrapper(f) {
                return !!f && "dirtyKey" in f;
            }
            function getWrapperInformation(f) {
                return isWrapper(f) ? f.size : undefined;
            }
            function isDefined(value) {
                return value != null;
            }
            function transformInfo(transform) {
                return recurseTransformInfo(transform).map(function(cache) {
                    return ({
                        cache: cache
                    });
                });
            }
            function recurseTransformInfo(transform) {
                return transform ? tslib.__spreadArray(tslib.__spreadArray([
                    getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
                ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined) : [];
            }
            function linkInfo(link) {
                var _a;
                return link ? tslib.__spreadArray(tslib.__spreadArray([
                    (_a = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a === void 0 ? void 0 : _a.call(link)
                ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined) : [];
            }
            var hasSuggestedDevtools = false;
            var ApolloClient = (function() {
                function ApolloClient(options) {
                    var _this = this;
                    var _a, _b, _c;
                    this.resetStoreCallbacks = [];
                    this.clearStoreCallbacks = [];
                    if (!options.cache) {
                        throw globals.newInvariantError(16);
                    }
                    var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, documentTransform = options.documentTransform, _d = options.ssrMode, ssrMode = _d === void 0 ? false : _d, _e = options.ssrForceFetchDelay, ssrForceFetchDelay = _e === void 0 ? 0 : _e, connectToDevTools = options.connectToDevTools, _f = options.queryDeduplication, queryDeduplication = _f === void 0 ? true : _f, defaultOptions = options.defaultOptions, defaultContext = options.defaultContext, _g = options.assumeImmutableResults, assumeImmutableResults = _g === void 0 ? cache.assumeImmutableResults : _g, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwareness = options.clientAwareness, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools, dataMasking = options.dataMasking;
                    if (globalThis.__DEV__ !== false) {
                        warnRemovedOption(options, "connectToDevTools", "ApolloClient", "Please use `devtools.enabled` instead.");
                        warnRemovedOption(options, "uri", "ApolloClient", "Please initialize an instance of `HttpLink` with `uri` instead.");
                        warnRemovedOption(options, "credentials", "ApolloClient", "Please initialize an instance of `HttpLink` with `credentials` instead.");
                        warnRemovedOption(options, "headers", "ApolloClient", "Please initialize an instance of `HttpLink` with `headers` instead.");
                        warnRemovedOption(options, "name", "ApolloClient", "Please use the `clientAwareness.name` option instead.");
                        warnRemovedOption(options, "version", "ApolloClient", "Please use the `clientAwareness.version` option instead.");
                        warnRemovedOption(options, "typeDefs", "ApolloClient");
                        if (!options.link) {
                            globalThis.__DEV__ !== false && globals.invariant.warn(17);
                        }
                    }
                    var link = options.link;
                    if (!link) {
                        link = uri ? new http.HttpLink({
                            uri: uri,
                            credentials: credentials,
                            headers: headers
                        }) : core.ApolloLink.empty();
                    }
                    this.link = link;
                    this.cache = cache;
                    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
                    this.queryDeduplication = queryDeduplication;
                    this.defaultOptions = defaultOptions || Object.create(null);
                    this.typeDefs = typeDefs;
                    this.devtoolsConfig = tslib.__assign(tslib.__assign({}, devtools), {
                        enabled: (_a = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a !== void 0 ? _a : connectToDevTools
                    });
                    if (this.devtoolsConfig.enabled === undefined) {
                        this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
                    }
                    if (ssrForceFetchDelay) {
                        setTimeout(function() {
                            return (_this.disableNetworkFetches = false);
                        }, ssrForceFetchDelay);
                    }
                    this.watchQuery = this.watchQuery.bind(this);
                    this.query = this.query.bind(this);
                    this.mutate = this.mutate.bind(this);
                    this.watchFragment = this.watchFragment.bind(this);
                    this.resetStore = this.resetStore.bind(this);
                    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
                    this.version = version;
                    this.localState = new LocalState({
                        cache: cache,
                        client: this,
                        resolvers: resolvers,
                        fragmentMatcher: fragmentMatcher
                    });
                    this.queryManager = new QueryManager({
                        cache: this.cache,
                        link: this.link,
                        defaultOptions: this.defaultOptions,
                        defaultContext: defaultContext,
                        documentTransform: documentTransform,
                        queryDeduplication: queryDeduplication,
                        ssrMode: ssrMode,
                        dataMasking: !!dataMasking,
                        clientAwareness: {
                            name: (_b = clientAwareness === null || clientAwareness === void 0 ? void 0 : clientAwareness.name) !== null && _b !== void 0 ? _b : clientAwarenessName,
                            version: (_c = clientAwareness === null || clientAwareness === void 0 ? void 0 : clientAwareness.version) !== null && _c !== void 0 ? _c : clientAwarenessVersion
                        },
                        localState: this.localState,
                        assumeImmutableResults: assumeImmutableResults,
                        onBroadcast: this.devtoolsConfig.enabled ? function() {
                            if (_this.devToolsHookCb) {
                                _this.devToolsHookCb({
                                    action: {},
                                    state: {
                                        queries: _this.queryManager.getQueryStore(),
                                        mutations: _this.queryManager.mutationStore || {}
                                    },
                                    dataWithOptimisticResults: _this.cache.extract(true)
                                });
                            }
                        } : void 0
                    });
                    if (this.devtoolsConfig.enabled) this.connectToDevTools();
                }
                Object.defineProperty(ApolloClient.prototype, "prioritizeCacheValues", {
                    get: function() {
                        return this.disableNetworkFetches;
                    },
                    set: function(value) {
                        this.disableNetworkFetches = value;
                    },
                    enumerable: false,
                    configurable: true
                });
                ApolloClient.prototype.connectToDevTools = function() {
                    if (typeof window === "undefined") {
                        return;
                    }
                    var windowWithDevTools = window;
                    var devtoolsSymbol = Symbol.for("apollo.devtools");
                    (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
                    windowWithDevTools.__APOLLO_CLIENT__ = this;
                    if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
                        hasSuggestedDevtools = true;
                        if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
                            setTimeout(function() {
                                if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                                    var nav = window.navigator;
                                    var ua = nav && nav.userAgent;
                                    var url = void 0;
                                    if (typeof ua === "string") {
                                        if (ua.indexOf("Chrome/") > -1) {
                                            url = "https://chrome.google.com/webstore/detail/" + "apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                                        } else if (ua.indexOf("Firefox/") > -1) {
                                            url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                                        }
                                    }
                                    if (url) {
                                        globalThis.__DEV__ !== false && globals.invariant.log("Download the Apollo DevTools for a better development " + "experience: %s", url);
                                    }
                                }
                            }, 10000);
                        }
                    }
                };
                Object.defineProperty(ApolloClient.prototype, "documentTransform", {
                    get: function() {
                        return this.queryManager.documentTransform;
                    },
                    enumerable: false,
                    configurable: true
                });
                ApolloClient.prototype.stop = function() {
                    this.queryManager.stop();
                };
                ApolloClient.prototype.watchQuery = function(options) {
                    if (this.defaultOptions.watchQuery) {
                        options = utilities.mergeOptions(this.defaultOptions.watchQuery, options);
                    }
                    if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
                        options = tslib.__assign(tslib.__assign({}, options), {
                            fetchPolicy: "cache-first"
                        });
                    }
                    if (globalThis.__DEV__ !== false) {
                        warnRemovedOption(options, "canonizeResults", "client.watchQuery");
                        warnRemovedOption(options, "partialRefetch", "client.watchQuery");
                    }
                    return this.queryManager.watchQuery(options);
                };
                ApolloClient.prototype.query = function(options) {
                    if (this.defaultOptions.query) {
                        options = utilities.mergeOptions(this.defaultOptions.query, options);
                    }
                    globals.invariant(options.fetchPolicy !== "cache-and-network", 18);
                    if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
                        options = tslib.__assign(tslib.__assign({}, options), {
                            fetchPolicy: "cache-first"
                        });
                    }
                    if (globalThis.__DEV__ !== false) {
                        warnRemovedOption(options, "canonizeResults", "client.query");
                        warnRemovedOption(options, "notifyOnNetworkStatusChange", "client.query", "This option does not affect `client.query` and can be safely removed.");
                        if (options.fetchPolicy === "standby") {
                            globalThis.__DEV__ !== false && globals.invariant.warn(19);
                        }
                    }
                    return this.queryManager.query(options);
                };
                ApolloClient.prototype.mutate = function(options) {
                    if (this.defaultOptions.mutate) {
                        options = utilities.mergeOptions(this.defaultOptions.mutate, options);
                    }
                    return this.queryManager.mutate(options);
                };
                ApolloClient.prototype.subscribe = function(options) {
                    var _this = this;
                    var id = this.queryManager.generateQueryId();
                    return this.queryManager.startGraphQLSubscription(options).map(function(result) {
                        return (tslib.__assign(tslib.__assign({}, result), {
                            data: _this.queryManager.maskOperation({
                                document: options.query,
                                data: result.data,
                                fetchPolicy: options.fetchPolicy,
                                id: id
                            })
                        }));
                    });
                };
                ApolloClient.prototype.readQuery = function(options, optimistic) {
                    if (optimistic === void 0) {
                        optimistic = false;
                    }
                    return this.cache.readQuery(options, optimistic);
                };
                ApolloClient.prototype.watchFragment = function(options) {
                    var _a;
                    return this.cache.watchFragment(tslib.__assign(tslib.__assign({}, options), (_a = {}, _a[Symbol.for("apollo.dataMasking")] = this.queryManager.dataMasking, _a)));
                };
                ApolloClient.prototype.readFragment = function(options, optimistic) {
                    if (optimistic === void 0) {
                        optimistic = false;
                    }
                    return this.cache.readFragment(options, optimistic);
                };
                ApolloClient.prototype.writeQuery = function(options) {
                    var ref = this.cache.writeQuery(options);
                    if (options.broadcast !== false) {
                        this.queryManager.broadcastQueries();
                    }
                    return ref;
                };
                ApolloClient.prototype.writeFragment = function(options) {
                    var ref = this.cache.writeFragment(options);
                    if (options.broadcast !== false) {
                        this.queryManager.broadcastQueries();
                    }
                    return ref;
                };
                ApolloClient.prototype.__actionHookForDevTools = function(cb) {
                    this.devToolsHookCb = cb;
                };
                ApolloClient.prototype.__requestRaw = function(payload) {
                    return core.execute(this.link, payload);
                };
                ApolloClient.prototype.resetStore = function() {
                    var _this = this;
                    return Promise.resolve().then(function() {
                        return _this.queryManager.clearStore({
                            discardWatches: false
                        });
                    }).then(function() {
                        return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
                            return fn();
                        }));
                    }).then(function() {
                        return _this.reFetchObservableQueries();
                    });
                };
                ApolloClient.prototype.clearStore = function() {
                    var _this = this;
                    return Promise.resolve().then(function() {
                        return _this.queryManager.clearStore({
                            discardWatches: true
                        });
                    }).then(function() {
                        return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
                            return fn();
                        }));
                    });
                };
                ApolloClient.prototype.onResetStore = function(cb) {
                    var _this = this;
                    this.resetStoreCallbacks.push(cb);
                    return function() {
                        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
                            return c !== cb;
                        });
                    };
                };
                ApolloClient.prototype.onClearStore = function(cb) {
                    var _this = this;
                    this.clearStoreCallbacks.push(cb);
                    return function() {
                        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
                            return c !== cb;
                        });
                    };
                };
                ApolloClient.prototype.reFetchObservableQueries = function(includeStandby) {
                    return this.queryManager.reFetchObservableQueries(includeStandby);
                };
                ApolloClient.prototype.refetchQueries = function(options) {
                    var map = this.queryManager.refetchQueries(options);
                    var queries = [];
                    var results = [];
                    map.forEach(function(result, obsQuery) {
                        queries.push(obsQuery);
                        results.push(result);
                    });
                    var result = Promise.all(results);
                    result.queries = queries;
                    result.results = results;
                    result.catch(function(error) {
                        globalThis.__DEV__ !== false && globals.invariant.debug(20, error);
                    });
                    return result;
                };
                ApolloClient.prototype.getObservableQueries = function(include) {
                    if (include === void 0) {
                        include = "active";
                    }
                    return this.queryManager.getObservableQueries(include);
                };
                ApolloClient.prototype.extract = function(optimistic) {
                    return this.cache.extract(optimistic);
                };
                ApolloClient.prototype.restore = function(serializedState) {
                    return this.cache.restore(serializedState);
                };
                ApolloClient.prototype.addResolvers = function(resolvers) {
                    this.localState.addResolvers(resolvers);
                };
                ApolloClient.prototype.setResolvers = function(resolvers) {
                    this.localState.setResolvers(resolvers);
                };
                ApolloClient.prototype.getResolvers = function() {
                    return this.localState.getResolvers();
                };
                ApolloClient.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
                    this.localState.setFragmentMatcher(fragmentMatcher);
                };
                ApolloClient.prototype.setLink = function(newLink) {
                    this.link = this.queryManager.link = newLink;
                };
                Object.defineProperty(ApolloClient.prototype, "defaultContext", {
                    get: function() {
                        return this.queryManager.defaultContext;
                    },
                    enumerable: false,
                    configurable: true
                });
                return ApolloClient;
            }());
            if (globalThis.__DEV__ !== false) {
                ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
            }
            tsInvariant.setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");
            exports.DocumentTransform = utilities.DocumentTransform;
            exports.Observable = utilities.Observable;
            exports.isReference = utilities.isReference;
            exports.makeReference = utilities.makeReference;
            exports.mergeOptions = utilities.mergeOptions;
            exports.ApolloCache = cache.ApolloCache;
            exports.Cache = cache.Cache;
            exports.InMemoryCache = cache.InMemoryCache;
            exports.MissingFieldError = cache.MissingFieldError;
            exports.defaultDataIdFromObject = cache.defaultDataIdFromObject;
            exports.makeVar = cache.makeVar;
            exports.ApolloError = errors.ApolloError;
            exports.isApolloError = errors.isApolloError;
            exports.fromError = utils.fromError;
            exports.fromPromise = utils.fromPromise;
            exports.throwServerError = utils.throwServerError;
            exports.toPromise = utils.toPromise;
            exports.setLogVerbosity = tsInvariant.setVerbosity;
            exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
            exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
            exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
            exports.gql = graphqlTag.gql;
            exports.resetCaches = graphqlTag.resetCaches;
            exports.ApolloClient = ApolloClient;
            exports.ObservableQuery = ObservableQuery;
            exports.isNetworkRequestSettled = isNetworkRequestSettled;
            for(var k in core){
                if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = core[k];
            }
            for(var k in http){
                if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = http[k];
            }
        }(core$2));
        return core$2;
    }
    var coreExports$1 = requireCore$1();
    var core = {};
    var hasRequiredCore;
    function requireCore() {
        if (hasRequiredCore) return core;
        hasRequiredCore = 1;
        Object.defineProperty(core, '__esModule', {
            value: true
        });
        var globals = require$$0;
        var utilities = require$$1$1;
        var utils = require$$3;
        var optimism = require$$5;
        var muteAllDeprecations = Symbol.for("apollo.deprecations");
        var global = globals.global;
        var slot = new optimism.Slot();
        function isMuted(name) {
            return global[muteAllDeprecations] || (slot.getValue() || []).includes(name);
        }
        function warnDeprecated(name, cb) {
            if (!isMuted(name)) {
                cb();
            }
        }
        function passthrough(op, forward) {
            return (forward ? forward(op) : utilities.Observable.of());
        }
        function toLink(handler) {
            return typeof handler === "function" ? new ApolloLink(handler) : handler;
        }
        function isTerminating(link) {
            return link.request.length <= 1;
        }
        var ApolloLink = (function() {
            function ApolloLink(request) {
                if (request) this.request = request;
            }
            ApolloLink.empty = function() {
                return new ApolloLink(function() {
                    return utilities.Observable.of();
                });
            };
            ApolloLink.from = function(links) {
                if (links.length === 0) return ApolloLink.empty();
                return links.map(toLink).reduce(function(x, y) {
                    return x.concat(y);
                });
            };
            ApolloLink.split = function(test, left, right) {
                var leftLink = toLink(left);
                var rightLink = toLink(right || new ApolloLink(passthrough));
                var ret;
                if (isTerminating(leftLink) && isTerminating(rightLink)) {
                    ret = new ApolloLink(function(operation) {
                        return test(operation) ? leftLink.request(operation) || utilities.Observable.of() : rightLink.request(operation) || utilities.Observable.of();
                    });
                } else {
                    ret = new ApolloLink(function(operation, forward) {
                        return test(operation) ? leftLink.request(operation, forward) || utilities.Observable.of() : rightLink.request(operation, forward) || utilities.Observable.of();
                    });
                }
                return Object.assign(ret, {
                    left: leftLink,
                    right: rightLink
                });
            };
            ApolloLink.execute = function(link, operation) {
                return (link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of());
            };
            ApolloLink.concat = function(first, second) {
                var firstLink = toLink(first);
                if (isTerminating(firstLink)) {
                    globalThis.__DEV__ !== false && globals.invariant.warn(47, firstLink);
                    return firstLink;
                }
                var nextLink = toLink(second);
                var ret;
                if (isTerminating(nextLink)) {
                    ret = new ApolloLink(function(operation) {
                        return firstLink.request(operation, function(op) {
                            return nextLink.request(op) || utilities.Observable.of();
                        }) || utilities.Observable.of();
                    });
                } else {
                    ret = new ApolloLink(function(operation, forward) {
                        return (firstLink.request(operation, function(op) {
                            return nextLink.request(op, forward) || utilities.Observable.of();
                        }) || utilities.Observable.of());
                    });
                }
                return Object.assign(ret, {
                    left: firstLink,
                    right: nextLink
                });
            };
            ApolloLink.prototype.split = function(test, left, right) {
                return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough)));
            };
            ApolloLink.prototype.concat = function(next) {
                return ApolloLink.concat(this, next);
            };
            ApolloLink.prototype.request = function(operation, forward) {
                throw globals.newInvariantError(48);
            };
            ApolloLink.prototype.onError = function(error, observer) {
                if (globalThis.__DEV__ !== false) {
                    warnDeprecated("onError", function() {
                        globalThis.__DEV__ !== false && globals.invariant.warn(49);
                    });
                }
                if (observer && observer.error) {
                    observer.error(error);
                    return false;
                }
                throw error;
            };
            ApolloLink.prototype.setOnError = function(fn) {
                if (globalThis.__DEV__ !== false) {
                    globalThis.__DEV__ !== false && globals.invariant.warn(50);
                }
                this.onError = fn;
                return this;
            };
            return ApolloLink;
        }());
        var empty = ApolloLink.empty;
        var from = ApolloLink.from;
        var split = ApolloLink.split;
        var concat = ApolloLink.concat;
        var execute = ApolloLink.execute;
        core.ApolloLink = ApolloLink;
        core.concat = concat;
        core.empty = empty;
        core.execute = execute;
        core.from = from;
        core.split = split;
        return core;
    }
    var coreExports = requireCore();
    var http = {};
    var hasRequiredHttp;
    function requireHttp() {
        if (hasRequiredHttp) return http;
        hasRequiredHttp = 1;
        Object.defineProperty(http, '__esModule', {
            value: true
        });
        var globals = require$$0;
        var tslib = require$$0$1;
        var utilities = require$$1$1;
        var utils = require$$3;
        var errors = require$$3$1;
        var core = require$$2$1;
        function asyncIterator(source) {
            var _a;
            var iterator = source[Symbol.asyncIterator]();
            return _a = {
                next: function() {
                    return iterator.next();
                }
            }, _a[Symbol.asyncIterator] = function() {
                return this;
            }, _a;
        }
        function nodeStreamIterator(stream) {
            var cleanup = null;
            var error = null;
            var done = false;
            var data = [];
            var waiting = [];
            function onData(chunk) {
                if (error) return;
                if (waiting.length) {
                    var shiftedArr = waiting.shift();
                    if (Array.isArray(shiftedArr) && shiftedArr[0]) {
                        return shiftedArr[0]({
                            value: chunk,
                            done: false
                        });
                    }
                }
                data.push(chunk);
            }
            function onError(err) {
                error = err;
                var all = waiting.slice();
                all.forEach(function(pair) {
                    pair[1](err);
                });
                !cleanup || cleanup();
            }
            function onEnd() {
                done = true;
                var all = waiting.slice();
                all.forEach(function(pair) {
                    pair[0]({
                        value: undefined,
                        done: true
                    });
                });
                !cleanup || cleanup();
            }
            cleanup = function() {
                cleanup = null;
                stream.removeListener("data", onData);
                stream.removeListener("error", onError);
                stream.removeListener("end", onEnd);
                stream.removeListener("finish", onEnd);
                stream.removeListener("close", onEnd);
            };
            stream.on("data", onData);
            stream.on("error", onError);
            stream.on("end", onEnd);
            stream.on("finish", onEnd);
            stream.on("close", onEnd);
            function getNext() {
                return new Promise(function(resolve, reject) {
                    if (error) return reject(error);
                    if (data.length) return resolve({
                        value: data.shift(),
                        done: false
                    });
                    if (done) return resolve({
                        value: undefined,
                        done: true
                    });
                    waiting.push([
                        resolve,
                        reject
                    ]);
                });
            }
            var iterator = {
                next: function() {
                    return getNext();
                }
            };
            if (utilities.canUseAsyncIteratorSymbol) {
                iterator[Symbol.asyncIterator] = function() {
                    return this;
                };
            }
            return iterator;
        }
        function promiseIterator(promise) {
            var resolved = false;
            var iterator = {
                next: function() {
                    if (resolved) return Promise.resolve({
                        value: undefined,
                        done: true
                    });
                    resolved = true;
                    return new Promise(function(resolve, reject) {
                        promise.then(function(value) {
                            resolve({
                                value: value,
                                done: false
                            });
                        }).catch(reject);
                    });
                }
            };
            if (utilities.canUseAsyncIteratorSymbol) {
                iterator[Symbol.asyncIterator] = function() {
                    return this;
                };
            }
            return iterator;
        }
        function readerIterator(reader) {
            var iterator = {
                next: function() {
                    return reader.read();
                }
            };
            if (utilities.canUseAsyncIteratorSymbol) {
                iterator[Symbol.asyncIterator] = function() {
                    return this;
                };
            }
            return iterator;
        }
        function isNodeResponse(value) {
            return !!value.body;
        }
        function isReadableStream(value) {
            return !!value.getReader;
        }
        function isAsyncIterableIterator(value) {
            return !!(utilities.canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
        }
        function isStreamableBlob(value) {
            return !!value.stream;
        }
        function isBlob(value) {
            return !!value.arrayBuffer;
        }
        function isNodeReadableStream(value) {
            return !!value.pipe;
        }
        function responseIterator(response) {
            var body = response;
            if (isNodeResponse(response)) body = response.body;
            if (isAsyncIterableIterator(body)) return asyncIterator(body);
            if (isReadableStream(body)) return readerIterator(body.getReader());
            if (isStreamableBlob(body)) {
                return readerIterator(body.stream().getReader());
            }
            if (isBlob(body)) return promiseIterator(body.arrayBuffer());
            if (isNodeReadableStream(body)) return nodeStreamIterator(body);
            throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
        }
        function isNonNullObject(obj) {
            return obj !== null && typeof obj === "object";
        }
        function isApolloPayloadResult(value) {
            return isNonNullObject(value) && "payload" in value;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function readMultipartBody(response, nextValue) {
            return tslib.__awaiter(this, void 0, void 0, function() {
                var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;
                var _b, _c;
                var _d;
                return tslib.__generator(this, function(_e) {
                    switch(_e.label){
                        case 0:
                            if (TextDecoder === undefined) {
                                throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
                            }
                            decoder = new TextDecoder("utf-8");
                            contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
                            delimiter = "boundary=";
                            boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
                            boundary = "\r\n--".concat(boundaryVal);
                            buffer = "";
                            iterator = responseIterator(response);
                            running = true;
                            _e.label = 1;
                        case 1:
                            if (!running) return [
                                3,
                                3
                            ];
                            return [
                                4,
                                iterator.next()
                            ];
                        case 2:
                            _a = _e.sent(), value = _a.value, done = _a.done;
                            chunk = typeof value === "string" ? value : decoder.decode(value);
                            searchFrom = buffer.length - boundary.length + 1;
                            running = !done;
                            buffer += chunk;
                            bi = buffer.indexOf(boundary, searchFrom);
                            while(bi > -1){
                                message = void 0;
                                _b = [
                                    buffer.slice(0, bi),
                                    buffer.slice(bi + boundary.length)
                                ], message = _b[0], buffer = _b[1];
                                i = message.indexOf("\r\n\r\n");
                                headers = parseHeaders(message.slice(0, i));
                                contentType_1 = headers["content-type"];
                                if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                                    throw new Error("Unsupported patch content type: application/json is required.");
                                }
                                body = message.slice(i);
                                if (body) {
                                    result = parseJsonBody(response, body);
                                    if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result || "payload" in result) {
                                        if (isApolloPayloadResult(result)) {
                                            next = {};
                                            if ("payload" in result) {
                                                if (Object.keys(result).length === 1 && result.payload === null) {
                                                    return [
                                                        2
                                                    ];
                                                }
                                                next = tslib.__assign({}, result.payload);
                                            }
                                            if ("errors" in result) {
                                                next = tslib.__assign(tslib.__assign({}, next), {
                                                    extensions: tslib.__assign(tslib.__assign({}, ("extensions" in next ? next.extensions : null)), (_c = {}, _c[errors.PROTOCOL_ERRORS_SYMBOL] = result.errors, _c))
                                                });
                                            }
                                            nextValue(next);
                                        } else {
                                            nextValue(result);
                                        }
                                    } else if (Object.keys(result).length === 1 && "hasNext" in result && !result.hasNext) {
                                        return [
                                            2
                                        ];
                                    }
                                }
                                bi = buffer.indexOf(boundary);
                            }
                            return [
                                3,
                                1
                            ];
                        case 3:
                            return [
                                2
                            ];
                    }
                });
            });
        }
        function parseHeaders(headerText) {
            var headersInit = {};
            headerText.split("\n").forEach(function(line) {
                var i = line.indexOf(":");
                if (i > -1) {
                    var name_1 = line.slice(0, i).trim().toLowerCase();
                    var value = line.slice(i + 1).trim();
                    headersInit[name_1] = value;
                }
            });
            return headersInit;
        }
        function parseJsonBody(response, bodyText) {
            if (response.status >= 300) {
                var getResult = function() {
                    try {
                        return JSON.parse(bodyText);
                    } catch (err) {
                        return bodyText;
                    }
                };
                utils.throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
            }
            try {
                return JSON.parse(bodyText);
            } catch (err) {
                var parseError = err;
                parseError.name = "ServerParseError";
                parseError.response = response;
                parseError.statusCode = response.status;
                parseError.bodyText = bodyText;
                throw parseError;
            }
        }
        function handleError(err, observer) {
            if (err.result && err.result.errors && err.result.data) {
                observer.next(err.result);
            }
            observer.error(err);
        }
        function parseAndCheckHttpResponse(operations) {
            return function(response) {
                return response.text().then(function(bodyText) {
                    return parseJsonBody(response, bodyText);
                }).then(function(result) {
                    if (!Array.isArray(result) && !hasOwnProperty.call(result, "data") && !hasOwnProperty.call(result, "errors")) {
                        utils.throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
                            return op.operationName;
                        }) : operations.operationName, "'."));
                    }
                    return result;
                });
            };
        }
        var serializeFetchParameter = function(p, label) {
            var serialized;
            try {
                serialized = JSON.stringify(p);
            } catch (e) {
                var parseError = globals.newInvariantError(54, label, e.message);
                parseError.parseError = e;
                throw parseError;
            }
            return serialized;
        };
        var defaultHttpOptions = {
            includeQuery: true,
            includeExtensions: false,
            preserveHeaderCase: false
        };
        var defaultHeaders = {
            accept: "*/*",
            "content-type": "application/json"
        };
        var defaultOptions = {
            method: "POST"
        };
        var fallbackHttpConfig = {
            http: defaultHttpOptions,
            headers: defaultHeaders,
            options: defaultOptions
        };
        var defaultPrinter = function(ast, printer) {
            return printer(ast);
        };
        function selectHttpOptionsAndBody(operation, fallbackConfig) {
            var configs = [];
            for(var _i = 2; _i < arguments.length; _i++){
                configs[_i - 2] = arguments[_i];
            }
            configs.unshift(fallbackConfig);
            return selectHttpOptionsAndBodyInternal.apply(void 0, tslib.__spreadArray([
                operation,
                defaultPrinter
            ], configs, false));
        }
        function selectHttpOptionsAndBodyInternal(operation, printer) {
            var configs = [];
            for(var _i = 2; _i < arguments.length; _i++){
                configs[_i - 2] = arguments[_i];
            }
            var options = {};
            var http = {};
            configs.forEach(function(config) {
                options = tslib.__assign(tslib.__assign(tslib.__assign({}, options), config.options), {
                    headers: tslib.__assign(tslib.__assign({}, options.headers), config.headers)
                });
                if (config.credentials) {
                    options.credentials = config.credentials;
                }
                http = tslib.__assign(tslib.__assign({}, http), config.http);
            });
            if (options.headers) {
                options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
            }
            var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
            var body = {
                operationName: operationName,
                variables: variables
            };
            if (http.includeExtensions) body.extensions = extensions;
            if (http.includeQuery) body.query = printer(query, utilities.print);
            return {
                options: options,
                body: body
            };
        }
        function removeDuplicateHeaders(headers, preserveHeaderCase) {
            if (!preserveHeaderCase) {
                var normalizedHeaders_1 = {};
                Object.keys(Object(headers)).forEach(function(name) {
                    normalizedHeaders_1[name.toLowerCase()] = headers[name];
                });
                return normalizedHeaders_1;
            }
            var headerData = {};
            Object.keys(Object(headers)).forEach(function(name) {
                headerData[name.toLowerCase()] = {
                    originalName: name,
                    value: headers[name]
                };
            });
            var normalizedHeaders = {};
            Object.keys(headerData).forEach(function(name) {
                normalizedHeaders[headerData[name].originalName] = headerData[name].value;
            });
            return normalizedHeaders;
        }
        var checkFetcher = function(fetcher) {
            if (!fetcher && typeof fetch === "undefined") {
                throw globals.newInvariantError(51);
            }
        };
        var createSignalIfSupported = function() {
            if (typeof AbortController === "undefined") return {
                controller: false,
                signal: false
            };
            var controller = new AbortController();
            var signal = controller.signal;
            return {
                controller: controller,
                signal: signal
            };
        };
        var selectURI = function(operation, fallbackURI) {
            var context = operation.getContext();
            var contextURI = context.uri;
            if (contextURI) {
                return contextURI;
            } else if (typeof fallbackURI === "function") {
                return fallbackURI(operation);
            } else {
                return fallbackURI || "/graphql";
            }
        };
        function rewriteURIForGET(chosenURI, body) {
            var queryParams = [];
            var addQueryParam = function(key, value) {
                queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
            };
            if ("query" in body) {
                addQueryParam("query", body.query);
            }
            if (body.operationName) {
                addQueryParam("operationName", body.operationName);
            }
            if (body.variables) {
                var serializedVariables = void 0;
                try {
                    serializedVariables = serializeFetchParameter(body.variables, "Variables map");
                } catch (parseError) {
                    return {
                        parseError: parseError
                    };
                }
                addQueryParam("variables", serializedVariables);
            }
            if (body.extensions) {
                var serializedExtensions = void 0;
                try {
                    serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
                } catch (parseError) {
                    return {
                        parseError: parseError
                    };
                }
                addQueryParam("extensions", serializedExtensions);
            }
            var fragment = "", preFragment = chosenURI;
            var fragmentStart = chosenURI.indexOf("#");
            if (fragmentStart !== -1) {
                fragment = chosenURI.substr(fragmentStart);
                preFragment = chosenURI.substr(0, fragmentStart);
            }
            var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
            var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
            return {
                newURI: newURI
            };
        }
        var backupFetch = utilities.maybe(function() {
            return fetch;
        });
        var createHttpLink = function(linkOptions) {
            if (linkOptions === void 0) {
                linkOptions = {};
            }
            var _a = linkOptions.uri, uri = _a === void 0 ? "/graphql" : _a, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = tslib.__rest(linkOptions, [
                "uri",
                "fetch",
                "print",
                "includeExtensions",
                "preserveHeaderCase",
                "useGETForQueries",
                "includeUnusedVariables"
            ]);
            if (globalThis.__DEV__ !== false) {
                checkFetcher(preferredFetch || backupFetch);
            }
            var linkConfig = {
                http: {
                    includeExtensions: includeExtensions,
                    preserveHeaderCase: preserveHeaderCase
                },
                options: requestOptions.fetchOptions,
                credentials: requestOptions.credentials,
                headers: requestOptions.headers
            };
            return new core.ApolloLink(function(operation) {
                var chosenURI = selectURI(operation, uri);
                var context = operation.getContext();
                var clientAwarenessHeaders = {};
                if (context.clientAwareness) {
                    var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;
                    if (name_1) {
                        clientAwarenessHeaders["apollographql-client-name"] = name_1;
                    }
                    if (version) {
                        clientAwarenessHeaders["apollographql-client-version"] = version;
                    }
                }
                var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context.headers);
                var contextConfig = {
                    http: context.http,
                    options: context.fetchOptions,
                    credentials: context.credentials,
                    headers: contextHeaders
                };
                if (utilities.hasDirectives([
                    "client"
                ], operation.query)) {
                    if (globalThis.__DEV__ !== false) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(52);
                    }
                    var transformedQuery = utilities.removeClientSetsFromDocument(operation.query);
                    if (!transformedQuery) {
                        return utils.fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
                    }
                    operation.query = transformedQuery;
                }
                var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
                if (body.variables && !includeUnusedVariables) {
                    body.variables = utils.filterOperationVariables(body.variables, operation.query);
                }
                var controller;
                if (!options.signal && typeof AbortController !== "undefined") {
                    controller = new AbortController();
                    options.signal = controller.signal;
                }
                var definitionIsMutation = function(d) {
                    return d.kind === "OperationDefinition" && d.operation === "mutation";
                };
                var definitionIsSubscription = function(d) {
                    return d.kind === "OperationDefinition" && d.operation === "subscription";
                };
                var isSubscription = definitionIsSubscription(utilities.getMainDefinition(operation.query));
                var hasDefer = utilities.hasDirectives([
                    "defer"
                ], operation.query);
                if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
                    options.method = "GET";
                }
                if (hasDefer || isSubscription) {
                    options.headers = options.headers || {};
                    var acceptHeader = "multipart/mixed;";
                    if (isSubscription && hasDefer) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(53);
                    }
                    if (isSubscription) {
                        acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
                    } else if (hasDefer) {
                        acceptHeader += "deferSpec=20220824,application/json";
                    }
                    options.headers.accept = acceptHeader;
                }
                if (options.method === "GET") {
                    var _c = rewriteURIForGET(chosenURI, body), newURI = _c.newURI, parseError = _c.parseError;
                    if (parseError) {
                        return utils.fromError(parseError);
                    }
                    chosenURI = newURI;
                } else {
                    try {
                        options.body = serializeFetchParameter(body, "Payload");
                    } catch (parseError) {
                        return utils.fromError(parseError);
                    }
                }
                return new utilities.Observable(function(observer) {
                    var currentFetch = preferredFetch || utilities.maybe(function() {
                        return fetch;
                    }) || backupFetch;
                    var observerNext = observer.next.bind(observer);
                    currentFetch(chosenURI, options).then(function(response) {
                        var _a;
                        operation.setContext({
                            response: response
                        });
                        var ctype = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get("content-type");
                        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
                            return readMultipartBody(response, observerNext);
                        } else {
                            return parseAndCheckHttpResponse(operation)(response).then(observerNext);
                        }
                    }).then(function() {
                        controller = undefined;
                        observer.complete();
                    }).catch(function(err) {
                        controller = undefined;
                        handleError(err, observer);
                    });
                    return function() {
                        if (controller) controller.abort();
                    };
                });
            });
        };
        var HttpLink = (function(_super) {
            tslib.__extends(HttpLink, _super);
            function HttpLink(options) {
                if (options === void 0) {
                    options = {};
                }
                var _this = _super.call(this, createHttpLink(options).request) || this;
                _this.options = options;
                return _this;
            }
            return HttpLink;
        }(core.ApolloLink));
        http.HttpLink = HttpLink;
        http.checkFetcher = checkFetcher;
        http.createHttpLink = createHttpLink;
        http.createSignalIfSupported = createSignalIfSupported;
        http.defaultPrinter = defaultPrinter;
        http.fallbackHttpConfig = fallbackHttpConfig;
        http.parseAndCheckHttpResponse = parseAndCheckHttpResponse;
        http.rewriteURIForGET = rewriteURIForGET;
        http.selectHttpOptionsAndBody = selectHttpOptionsAndBody;
        http.selectHttpOptionsAndBodyInternal = selectHttpOptionsAndBodyInternal;
        http.selectURI = selectURI;
        http.serializeFetchParameter = serializeFetchParameter;
        return http;
    }
    var httpExports = requireHttp();
    var retry = {};
    var hasRequiredRetry;
    function requireRetry() {
        if (hasRequiredRetry) return retry;
        hasRequiredRetry = 1;
        Object.defineProperty(retry, '__esModule', {
            value: true
        });
        var tslib = require$$0$1;
        var core = require$$2$1;
        var utilities = require$$1$1;
        var errors = require$$3$1;
        function buildDelayFunction(delayOptions) {
            var _a = delayOptions || {}, _b = _a.initial, initial = _b === void 0 ? 300 : _b, _c = _a.jitter, jitter = _c === void 0 ? true : _c, _d = _a.max, max = _d === void 0 ? Infinity : _d;
            var baseDelay = jitter ? initial : initial / 2;
            return function delayFunction(count) {
                var delay = Math.min(max, baseDelay * Math.pow(2, count));
                if (jitter) {
                    delay = Math.random() * delay;
                }
                return delay;
            };
        }
        function buildRetryFunction(retryOptions) {
            var _a = retryOptions || {}, retryIf = _a.retryIf, _b = _a.max, max = _b === void 0 ? 5 : _b;
            return function retryFunction(count, operation, error) {
                if (count >= max) return false;
                return retryIf ? retryIf(error, operation) : !!error;
            };
        }
        var RetryableOperation = (function() {
            function RetryableOperation(observer, operation, forward, delayFor, retryIf) {
                var _this = this;
                this.observer = observer;
                this.operation = operation;
                this.forward = forward;
                this.delayFor = delayFor;
                this.retryIf = retryIf;
                this.retryCount = 0;
                this.currentSubscription = null;
                this.onError = function(error) {
                    return tslib.__awaiter(_this, void 0, void 0, function() {
                        var shouldRetry;
                        return tslib.__generator(this, function(_a) {
                            switch(_a.label){
                                case 0:
                                    this.retryCount += 1;
                                    return [
                                        4,
                                        this.retryIf(this.retryCount, this.operation, error)
                                    ];
                                case 1:
                                    shouldRetry = _a.sent();
                                    if (shouldRetry) {
                                        this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));
                                        return [
                                            2
                                        ];
                                    }
                                    this.observer.error(error);
                                    return [
                                        2
                                    ];
                            }
                        });
                    });
                };
                this.try();
            }
            RetryableOperation.prototype.cancel = function() {
                if (this.currentSubscription) {
                    this.currentSubscription.unsubscribe();
                }
                clearTimeout(this.timerId);
                this.timerId = undefined;
                this.currentSubscription = null;
            };
            RetryableOperation.prototype.try = function() {
                var _this = this;
                this.currentSubscription = this.forward(this.operation).subscribe({
                    next: function(result) {
                        var _a;
                        if (errors.graphQLResultHasProtocolErrors(result)) {
                            _this.onError(new errors.ApolloError({
                                protocolErrors: result.extensions[errors.PROTOCOL_ERRORS_SYMBOL]
                            }));
                            (_a = _this.currentSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
                            return;
                        }
                        _this.observer.next(result);
                    },
                    error: this.onError,
                    complete: this.observer.complete.bind(this.observer)
                });
            };
            RetryableOperation.prototype.scheduleRetry = function(delay) {
                var _this = this;
                if (this.timerId) {
                    throw new Error("RetryLink BUG! Encountered overlapping retries");
                }
                this.timerId = setTimeout(function() {
                    _this.timerId = undefined;
                    _this.try();
                }, delay);
            };
            return RetryableOperation;
        }());
        var RetryLink = (function(_super) {
            tslib.__extends(RetryLink, _super);
            function RetryLink(options) {
                var _this = _super.call(this) || this;
                var _a = options || {}, attempts = _a.attempts, delay = _a.delay;
                _this.delayFor = typeof delay === "function" ? delay : buildDelayFunction(delay);
                _this.retryIf = typeof attempts === "function" ? attempts : buildRetryFunction(attempts);
                return _this;
            }
            RetryLink.prototype.request = function(operation, nextLink) {
                var _this = this;
                return new utilities.Observable(function(observer) {
                    var retryable = new RetryableOperation(observer, operation, nextLink, _this.delayFor, _this.retryIf);
                    return function() {
                        retryable.cancel();
                    };
                });
            };
            return RetryLink;
        }(core.ApolloLink));
        retry.RetryLink = RetryLink;
        return retry;
    }
    var retryExports = requireRetry();
    var utilities = {};
    const require$$4 = getAugmentedNamespace(lib$3);
    const require$$6 = getAugmentedNamespace(module$1);
    var hasRequiredUtilities;
    function requireUtilities() {
        if (hasRequiredUtilities) return utilities;
        hasRequiredUtilities = 1;
        Object.defineProperty(utilities, '__esModule', {
            value: true
        });
        var globals = require$$0;
        var graphql = require$$1;
        var trie = require$$2;
        var tslib = require$$0$1;
        var caches = require$$4;
        var optimism = require$$5;
        var zenObservableTs = require$$6;
        function shouldInclude(_a, variables) {
            var directives = _a.directives;
            if (!directives || !directives.length) {
                return true;
            }
            return getInclusionDirectives(directives).every(function(_a) {
                var directive = _a.directive, ifArgument = _a.ifArgument;
                var evaledValue = false;
                if (ifArgument.value.kind === "Variable") {
                    evaledValue = variables && variables[ifArgument.value.name.value];
                    globals.invariant(evaledValue !== void 0, 106, directive.name.value);
                } else {
                    evaledValue = ifArgument.value.value;
                }
                return directive.name.value === "skip" ? !evaledValue : evaledValue;
            });
        }
        function getDirectiveNames(root) {
            var names = [];
            graphql.visit(root, {
                Directive: function(node) {
                    names.push(node.name.value);
                }
            });
            return names;
        }
        var hasAnyDirectives = function(names, root) {
            return hasDirectives(names, root, false);
        };
        var hasAllDirectives = function(names, root) {
            return hasDirectives(names, root, true);
        };
        function hasDirectives(names, root, all) {
            var nameSet = new Set(names);
            var uniqueCount = nameSet.size;
            graphql.visit(root, {
                Directive: function(node) {
                    if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
                        return graphql.BREAK;
                    }
                }
            });
            return all ? !nameSet.size : nameSet.size < uniqueCount;
        }
        function hasClientExports(document) {
            return document && hasDirectives([
                "client",
                "export"
            ], document, true);
        }
        function isInclusionDirective(_a) {
            var value = _a.name.value;
            return value === "skip" || value === "include";
        }
        function getInclusionDirectives(directives) {
            var result = [];
            if (directives && directives.length) {
                directives.forEach(function(directive) {
                    if (!isInclusionDirective(directive)) return;
                    var directiveArguments = directive.arguments;
                    var directiveName = directive.name.value;
                    globals.invariant(directiveArguments && directiveArguments.length === 1, 107, directiveName);
                    var ifArgument = directiveArguments[0];
                    globals.invariant(ifArgument.name && ifArgument.name.value === "if", 108, directiveName);
                    var ifValue = ifArgument.value;
                    globals.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 109, directiveName);
                    result.push({
                        directive: directive,
                        ifArgument: ifArgument
                    });
                });
            }
            return result;
        }
        function getFragmentMaskMode(fragment) {
            var _a, _b;
            var directive = (_a = fragment.directives) === null || _a === void 0 ? void 0 : _a.find(function(_a) {
                var name = _a.name;
                return name.value === "unmask";
            });
            if (!directive) {
                return "mask";
            }
            var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function(_a) {
                var name = _a.name;
                return name.value === "mode";
            });
            if (globalThis.__DEV__ !== false) {
                if (modeArg) {
                    if (modeArg.value.kind === graphql.Kind.VARIABLE) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(110);
                    } else if (modeArg.value.kind !== graphql.Kind.STRING) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(111);
                    } else if (modeArg.value.value !== "migrate") {
                        globalThis.__DEV__ !== false && globals.invariant.warn(112, modeArg.value.value);
                    }
                }
            }
            if (modeArg && "value" in modeArg.value && modeArg.value.value === "migrate") {
                return "migrate";
            }
            return "unmask";
        }
        var isReactNative = globals.maybe(function() {
            return navigator.product;
        }) == "ReactNative";
        var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !commonjsGlobal.HermesInternal);
        var canUseWeakSet = typeof WeakSet === "function";
        var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
        var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
        var canUseDOM = typeof globals.maybe(function() {
            return window.document.createElement;
        }) === "function";
        var usingJSDOM = globals.maybe(function() {
            return navigator.userAgent.indexOf("jsdom") >= 0;
        }) || false;
        var canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;
        function isNonNullObject(obj) {
            return obj !== null && typeof obj === "object";
        }
        function isPlainObject(obj) {
            return (obj !== null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null));
        }
        function getFragmentQueryDocument(document, fragmentName) {
            var actualFragmentName = fragmentName;
            var fragments = [];
            document.definitions.forEach(function(definition) {
                if (definition.kind === "OperationDefinition") {
                    throw globals.newInvariantError(113, definition.operation, definition.name ? " named '".concat(definition.name.value, "'") : "");
                }
                if (definition.kind === "FragmentDefinition") {
                    fragments.push(definition);
                }
            });
            if (typeof actualFragmentName === "undefined") {
                globals.invariant(fragments.length === 1, 114, fragments.length);
                actualFragmentName = fragments[0].name.value;
            }
            var query = tslib.__assign(tslib.__assign({}, document), {
                definitions: tslib.__spreadArray([
                    {
                        kind: "OperationDefinition",
                        operation: "query",
                        selectionSet: {
                            kind: "SelectionSet",
                            selections: [
                                {
                                    kind: "FragmentSpread",
                                    name: {
                                        kind: "Name",
                                        value: actualFragmentName
                                    }
                                }
                            ]
                        }
                    }
                ], document.definitions, true)
            });
            return query;
        }
        function createFragmentMap(fragments) {
            if (fragments === void 0) {
                fragments = [];
            }
            var symTable = {};
            fragments.forEach(function(fragment) {
                symTable[fragment.name.value] = fragment;
            });
            return symTable;
        }
        function getFragmentFromSelection(selection, fragmentMap) {
            switch(selection.kind){
                case "InlineFragment":
                    return selection;
                case "FragmentSpread":
                    {
                        var fragmentName = selection.name.value;
                        if (typeof fragmentMap === "function") {
                            return fragmentMap(fragmentName);
                        }
                        var fragment = fragmentMap && fragmentMap[fragmentName];
                        globals.invariant(fragment, 115, fragmentName);
                        return fragment || null;
                    }
                default:
                    return null;
            }
        }
        function isFullyUnmaskedOperation(document) {
            var isUnmasked = true;
            graphql.visit(document, {
                FragmentSpread: function(node) {
                    isUnmasked = !!node.directives && node.directives.some(function(directive) {
                        return directive.name.value === "unmask";
                    });
                    if (!isUnmasked) {
                        return graphql.BREAK;
                    }
                }
            });
            return isUnmasked;
        }
        var scheduledCleanup = new WeakSet();
        function schedule(cache) {
            if (cache.size <= (cache.max || -1)) {
                return;
            }
            if (!scheduledCleanup.has(cache)) {
                scheduledCleanup.add(cache);
                setTimeout(function() {
                    cache.clean();
                    scheduledCleanup.delete(cache);
                }, 100);
            }
        }
        var AutoCleanedWeakCache = function(max, dispose) {
            var cache = new caches.WeakCache(max, dispose);
            cache.set = function(key, value) {
                var ret = caches.WeakCache.prototype.set.call(this, key, value);
                schedule(this);
                return ret;
            };
            return cache;
        };
        var AutoCleanedStrongCache = function(max, dispose) {
            var cache = new caches.StrongCache(max, dispose);
            cache.set = function(key, value) {
                var ret = caches.StrongCache.prototype.set.call(this, key, value);
                schedule(this);
                return ret;
            };
            return cache;
        };
        var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
        var cacheSizes = tslib.__assign({}, globals.global[cacheSizeSymbol]);
        var globalCaches = {};
        function registerGlobalCache(name, getSize) {
            globalCaches[name] = getSize;
        }
        var canonicalStringify = Object.assign(function canonicalStringify(value) {
            return JSON.stringify(value, stableObjectReplacer);
        }, {
            reset: function() {
                sortingMap = new AutoCleanedStrongCache(cacheSizes.canonicalStringify || 1000);
            }
        });
        if (globalThis.__DEV__ !== false) {
            registerGlobalCache("canonicalStringify", function() {
                return sortingMap.size;
            });
        }
        var sortingMap;
        canonicalStringify.reset();
        function stableObjectReplacer(key, value) {
            if (value && typeof value === "object") {
                var proto = Object.getPrototypeOf(value);
                if (proto === Object.prototype || proto === null) {
                    var keys = Object.keys(value);
                    if (keys.every(everyKeyInOrder)) return value;
                    var unsortedKey = JSON.stringify(keys);
                    var sortedKeys = sortingMap.get(unsortedKey);
                    if (!sortedKeys) {
                        keys.sort();
                        var sortedKey = JSON.stringify(keys);
                        sortedKeys = sortingMap.get(sortedKey) || keys;
                        sortingMap.set(unsortedKey, sortedKeys);
                        sortingMap.set(sortedKey, sortedKeys);
                    }
                    var sortedObject_1 = Object.create(proto);
                    sortedKeys.forEach(function(key) {
                        sortedObject_1[key] = value[key];
                    });
                    return sortedObject_1;
                }
            }
            return value;
        }
        function everyKeyInOrder(key, i, keys) {
            return i === 0 || keys[i - 1] <= key;
        }
        function makeReference(id) {
            return {
                __ref: String(id)
            };
        }
        function isReference(obj) {
            return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
        }
        function isDocumentNode(value) {
            return (isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions));
        }
        function isStringValue(value) {
            return value.kind === "StringValue";
        }
        function isBooleanValue(value) {
            return value.kind === "BooleanValue";
        }
        function isIntValue(value) {
            return value.kind === "IntValue";
        }
        function isFloatValue(value) {
            return value.kind === "FloatValue";
        }
        function isVariable(value) {
            return value.kind === "Variable";
        }
        function isObjectValue(value) {
            return value.kind === "ObjectValue";
        }
        function isListValue(value) {
            return value.kind === "ListValue";
        }
        function isEnumValue(value) {
            return value.kind === "EnumValue";
        }
        function isNullValue(value) {
            return value.kind === "NullValue";
        }
        function valueToObjectRepresentation(argObj, name, value, variables) {
            if (isIntValue(value) || isFloatValue(value)) {
                argObj[name.value] = Number(value.value);
            } else if (isBooleanValue(value) || isStringValue(value)) {
                argObj[name.value] = value.value;
            } else if (isObjectValue(value)) {
                var nestedArgObj_1 = {};
                value.fields.map(function(obj) {
                    return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
                });
                argObj[name.value] = nestedArgObj_1;
            } else if (isVariable(value)) {
                var variableValue = (variables || {})[value.name.value];
                argObj[name.value] = variableValue;
            } else if (isListValue(value)) {
                argObj[name.value] = value.values.map(function(listValue) {
                    var nestedArgArrayObj = {};
                    valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
                    return nestedArgArrayObj[name.value];
                });
            } else if (isEnumValue(value)) {
                argObj[name.value] = value.value;
            } else if (isNullValue(value)) {
                argObj[name.value] = null;
            } else {
                throw globals.newInvariantError(124, name.value, value.kind);
            }
        }
        function storeKeyNameFromField(field, variables) {
            var directivesObj = null;
            if (field.directives) {
                directivesObj = {};
                field.directives.forEach(function(directive) {
                    directivesObj[directive.name.value] = {};
                    if (directive.arguments) {
                        directive.arguments.forEach(function(_a) {
                            var name = _a.name, value = _a.value;
                            return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                        });
                    }
                });
            }
            var argObj = null;
            if (field.arguments && field.arguments.length) {
                argObj = {};
                field.arguments.forEach(function(_a) {
                    var name = _a.name, value = _a.value;
                    return valueToObjectRepresentation(argObj, name, value, variables);
                });
            }
            return getStoreKeyName(field.name.value, argObj, directivesObj);
        }
        var KNOWN_DIRECTIVES = [
            "connection",
            "include",
            "skip",
            "client",
            "rest",
            "export",
            "nonreactive"
        ];
        var storeKeyNameStringify = canonicalStringify;
        var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
            if (args && directives && directives["connection"] && directives["connection"]["key"]) {
                if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
                    var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
                    filterKeys.sort();
                    var filteredArgs_1 = {};
                    filterKeys.forEach(function(key) {
                        filteredArgs_1[key] = args[key];
                    });
                    return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
                } else {
                    return directives["connection"]["key"];
                }
            }
            var completeFieldName = fieldName;
            if (args) {
                var stringifiedArgs = storeKeyNameStringify(args);
                completeFieldName += "(".concat(stringifiedArgs, ")");
            }
            if (directives) {
                Object.keys(directives).forEach(function(key) {
                    if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;
                    if (directives[key] && Object.keys(directives[key]).length) {
                        completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
                    } else {
                        completeFieldName += "@".concat(key);
                    }
                });
            }
            return completeFieldName;
        }, {
            setStringify: function(s) {
                var previous = storeKeyNameStringify;
                storeKeyNameStringify = s;
                return previous;
            }
        });
        function argumentsObjectFromField(field, variables) {
            if (field.arguments && field.arguments.length) {
                var argObj_1 = {};
                field.arguments.forEach(function(_a) {
                    var name = _a.name, value = _a.value;
                    return valueToObjectRepresentation(argObj_1, name, value, variables);
                });
                return argObj_1;
            }
            return null;
        }
        function resultKeyNameFromField(field) {
            return field.alias ? field.alias.value : field.name.value;
        }
        function getTypenameFromResult(result, selectionSet, fragmentMap) {
            var fragments;
            for(var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++){
                var selection = _a[_i];
                if (isField(selection)) {
                    if (selection.name.value === "__typename") {
                        return result[resultKeyNameFromField(selection)];
                    }
                } else if (fragments) {
                    fragments.push(selection);
                } else {
                    fragments = [
                        selection
                    ];
                }
            }
            if (typeof result.__typename === "string") {
                return result.__typename;
            }
            if (fragments) {
                for(var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++){
                    var selection = fragments_1[_b];
                    var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
                    if (typeof typename === "string") {
                        return typename;
                    }
                }
            }
        }
        function isField(selection) {
            return selection.kind === "Field";
        }
        function isInlineFragment(selection) {
            return selection.kind === "InlineFragment";
        }
        function checkDocument(doc) {
            globals.invariant(doc && doc.kind === "Document", 116);
            var operations = doc.definitions.filter(function(d) {
                return d.kind !== "FragmentDefinition";
            }).map(function(definition) {
                if (definition.kind !== "OperationDefinition") {
                    throw globals.newInvariantError(117, definition.kind);
                }
                return definition;
            });
            globals.invariant(operations.length <= 1, 118, operations.length);
            return doc;
        }
        function getOperationDefinition(doc) {
            checkDocument(doc);
            return doc.definitions.filter(function(definition) {
                return definition.kind === "OperationDefinition";
            })[0];
        }
        function getOperationName(doc) {
            return (doc.definitions.filter(function(definition) {
                return definition.kind === "OperationDefinition" && !!definition.name;
            }).map(function(x) {
                return x.name.value;
            })[0] || null);
        }
        function getFragmentDefinitions(doc) {
            return doc.definitions.filter(function(definition) {
                return definition.kind === "FragmentDefinition";
            });
        }
        function getQueryDefinition(doc) {
            var queryDef = getOperationDefinition(doc);
            globals.invariant(queryDef && queryDef.operation === "query", 119);
            return queryDef;
        }
        function getFragmentDefinition(doc) {
            globals.invariant(doc.kind === "Document", 120);
            globals.invariant(doc.definitions.length <= 1, 121);
            var fragmentDef = doc.definitions[0];
            globals.invariant(fragmentDef.kind === "FragmentDefinition", 122);
            return fragmentDef;
        }
        function getMainDefinition(queryDoc) {
            checkDocument(queryDoc);
            var fragmentDefinition;
            for(var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++){
                var definition = _a[_i];
                if (definition.kind === "OperationDefinition") {
                    var operation = definition.operation;
                    if (operation === "query" || operation === "mutation" || operation === "subscription") {
                        return definition;
                    }
                }
                if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
                    fragmentDefinition = definition;
                }
            }
            if (fragmentDefinition) {
                return fragmentDefinition;
            }
            throw globals.newInvariantError(123);
        }
        function getDefaultValues(definition) {
            var defaultValues = Object.create(null);
            var defs = definition && definition.variableDefinitions;
            if (defs && defs.length) {
                defs.forEach(function(def) {
                    if (def.defaultValue) {
                        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
                    }
                });
            }
            return defaultValues;
        }
        function identity(document) {
            return document;
        }
        var DocumentTransform = (function() {
            function DocumentTransform(transform, options) {
                if (options === void 0) {
                    options = Object.create(null);
                }
                this.resultCache = canUseWeakSet ? new WeakSet() : new Set();
                this.transform = transform;
                if (options.getCacheKey) {
                    this.getCacheKey = options.getCacheKey;
                }
                this.cached = options.cache !== false;
                this.resetCache();
            }
            DocumentTransform.prototype.getCacheKey = function(document) {
                return [
                    document
                ];
            };
            DocumentTransform.identity = function() {
                return new DocumentTransform(identity, {
                    cache: false
                });
            };
            DocumentTransform.split = function(predicate, left, right) {
                if (right === void 0) {
                    right = DocumentTransform.identity();
                }
                return Object.assign(new DocumentTransform(function(document) {
                    var documentTransform = predicate(document) ? left : right;
                    return documentTransform.transformDocument(document);
                }, {
                    cache: false
                }), {
                    left: left,
                    right: right
                });
            };
            DocumentTransform.prototype.resetCache = function() {
                var _this = this;
                if (this.cached) {
                    var stableCacheKeys_1 = new trie.Trie(canUseWeakMap);
                    this.performWork = optimism.wrap(DocumentTransform.prototype.performWork.bind(this), {
                        makeCacheKey: function(document) {
                            var cacheKeys = _this.getCacheKey(document);
                            if (cacheKeys) {
                                globals.invariant(Array.isArray(cacheKeys), 105);
                                return stableCacheKeys_1.lookupArray(cacheKeys);
                            }
                        },
                        max: cacheSizes["documentTransform.cache"],
                        cache: (caches.WeakCache)
                    });
                }
            };
            DocumentTransform.prototype.performWork = function(document) {
                checkDocument(document);
                return this.transform(document);
            };
            DocumentTransform.prototype.transformDocument = function(document) {
                if (this.resultCache.has(document)) {
                    return document;
                }
                var transformedDocument = this.performWork(document);
                this.resultCache.add(transformedDocument);
                return transformedDocument;
            };
            DocumentTransform.prototype.concat = function(otherTransform) {
                var _this = this;
                return Object.assign(new DocumentTransform(function(document) {
                    return otherTransform.transformDocument(_this.transformDocument(document));
                }, {
                    cache: false
                }), {
                    left: this,
                    right: otherTransform
                });
            };
            return DocumentTransform;
        }());
        var printCache;
        var print = Object.assign(function(ast) {
            var result = printCache.get(ast);
            if (!result) {
                result = graphql.print(ast);
                printCache.set(ast, result);
            }
            return result;
        }, {
            reset: function() {
                printCache = new AutoCleanedWeakCache(cacheSizes.print || 2000);
            }
        });
        print.reset();
        if (globalThis.__DEV__ !== false) {
            registerGlobalCache("print", function() {
                return (printCache ? printCache.size : 0);
            });
        }
        var isArray = Array.isArray;
        function isNonEmptyArray(value) {
            return Array.isArray(value) && value.length > 0;
        }
        var TYPENAME_FIELD = {
            kind: graphql.Kind.FIELD,
            name: {
                kind: graphql.Kind.NAME,
                value: "__typename"
            }
        };
        function isEmpty(op, fragmentMap) {
            return (!op || op.selectionSet.selections.every(function(selection) {
                return selection.kind === graphql.Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
            }));
        }
        function nullIfDocIsEmpty(doc) {
            return (isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))) ? null : doc;
        }
        function getDirectiveMatcher(configs) {
            var names = new Map();
            var tests = new Map();
            configs.forEach(function(directive) {
                if (directive) {
                    if (directive.name) {
                        names.set(directive.name, directive);
                    } else if (directive.test) {
                        tests.set(directive.test, directive);
                    }
                }
            });
            return function(directive) {
                var config = names.get(directive.name.value);
                if (!config && tests.size) {
                    tests.forEach(function(testConfig, test) {
                        if (test(directive)) {
                            config = testConfig;
                        }
                    });
                }
                return config;
            };
        }
        function makeInUseGetterFunction(defaultKey) {
            var map = new Map();
            return function inUseGetterFunction(key) {
                if (key === void 0) {
                    key = defaultKey;
                }
                var inUse = map.get(key);
                if (!inUse) {
                    map.set(key, (inUse = {
                        variables: new Set(),
                        fragmentSpreads: new Set()
                    }));
                }
                return inUse;
            };
        }
        function removeDirectivesFromDocument(directives, doc) {
            checkDocument(doc);
            var getInUseByOperationName = makeInUseGetterFunction("");
            var getInUseByFragmentName = makeInUseGetterFunction("");
            var getInUse = function(ancestors) {
                for(var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p){
                    if (isArray(ancestor)) continue;
                    if (ancestor.kind === graphql.Kind.OPERATION_DEFINITION) {
                        return getInUseByOperationName(ancestor.name && ancestor.name.value);
                    }
                    if (ancestor.kind === graphql.Kind.FRAGMENT_DEFINITION) {
                        return getInUseByFragmentName(ancestor.name.value);
                    }
                }
                globalThis.__DEV__ !== false && globals.invariant.error(125);
                return null;
            };
            var operationCount = 0;
            for(var i = doc.definitions.length - 1; i >= 0; --i){
                if (doc.definitions[i].kind === graphql.Kind.OPERATION_DEFINITION) {
                    ++operationCount;
                }
            }
            var directiveMatcher = getDirectiveMatcher(directives);
            var shouldRemoveField = function(nodeDirectives) {
                return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
                    return config && config.remove;
                });
            };
            var originalFragmentDefsByPath = new Map();
            var firstVisitMadeChanges = false;
            var fieldOrInlineFragmentVisitor = {
                enter: function(node) {
                    if (shouldRemoveField(node.directives)) {
                        firstVisitMadeChanges = true;
                        return null;
                    }
                }
            };
            var docWithoutDirectiveSubtrees = graphql.visit(doc, {
                Field: fieldOrInlineFragmentVisitor,
                InlineFragment: fieldOrInlineFragmentVisitor,
                VariableDefinition: {
                    enter: function() {
                        return false;
                    }
                },
                Variable: {
                    enter: function(node, _key, _parent, _path, ancestors) {
                        var inUse = getInUse(ancestors);
                        if (inUse) {
                            inUse.variables.add(node.name.value);
                        }
                    }
                },
                FragmentSpread: {
                    enter: function(node, _key, _parent, _path, ancestors) {
                        if (shouldRemoveField(node.directives)) {
                            firstVisitMadeChanges = true;
                            return null;
                        }
                        var inUse = getInUse(ancestors);
                        if (inUse) {
                            inUse.fragmentSpreads.add(node.name.value);
                        }
                    }
                },
                FragmentDefinition: {
                    enter: function(node, _key, _parent, path) {
                        originalFragmentDefsByPath.set(JSON.stringify(path), node);
                    },
                    leave: function(node, _key, _parent, path) {
                        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
                        if (node === originalNode) {
                            return node;
                        }
                        if (operationCount > 0 && node.selectionSet.selections.every(function(selection) {
                            return selection.kind === graphql.Kind.FIELD && selection.name.value === "__typename";
                        })) {
                            getInUseByFragmentName(node.name.value).removed = true;
                            firstVisitMadeChanges = true;
                            return null;
                        }
                    }
                },
                Directive: {
                    leave: function(node) {
                        if (directiveMatcher(node)) {
                            firstVisitMadeChanges = true;
                            return null;
                        }
                    }
                }
            });
            if (!firstVisitMadeChanges) {
                return doc;
            }
            var populateTransitiveVars = function(inUse) {
                if (!inUse.transitiveVars) {
                    inUse.transitiveVars = new Set(inUse.variables);
                    if (!inUse.removed) {
                        inUse.fragmentSpreads.forEach(function(childFragmentName) {
                            populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
                                inUse.transitiveVars.add(varName);
                            });
                        });
                    }
                }
                return inUse;
            };
            var allFragmentNamesUsed = new Set();
            docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
                if (def.kind === graphql.Kind.OPERATION_DEFINITION) {
                    populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
                        allFragmentNamesUsed.add(childFragmentName);
                    });
                } else if (def.kind === graphql.Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
                    allFragmentNamesUsed.add(def.name.value);
                }
            });
            allFragmentNamesUsed.forEach(function(fragmentName) {
                populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
                    allFragmentNamesUsed.add(childFragmentName);
                });
            });
            var fragmentWillBeRemoved = function(fragmentName) {
                return !!((!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed));
            };
            var enterVisitor = {
                enter: function(node) {
                    if (fragmentWillBeRemoved(node.name.value)) {
                        return null;
                    }
                }
            };
            return nullIfDocIsEmpty(graphql.visit(docWithoutDirectiveSubtrees, {
                FragmentSpread: enterVisitor,
                FragmentDefinition: enterVisitor,
                OperationDefinition: {
                    leave: function(node) {
                        if (node.variableDefinitions) {
                            var usedVariableNames_1 = populateTransitiveVars(getInUseByOperationName(node.name && node.name.value)).transitiveVars;
                            if (usedVariableNames_1.size < node.variableDefinitions.length) {
                                return tslib.__assign(tslib.__assign({}, node), {
                                    variableDefinitions: node.variableDefinitions.filter(function(varDef) {
                                        return usedVariableNames_1.has(varDef.variable.name.value);
                                    })
                                });
                            }
                        }
                    }
                }
            }));
        }
        var addTypenameToDocument = Object.assign(function(doc) {
            return graphql.visit(doc, {
                SelectionSet: {
                    enter: function(node, _key, parent) {
                        if (parent && parent.kind === graphql.Kind.OPERATION_DEFINITION) {
                            return;
                        }
                        var selections = node.selections;
                        if (!selections) {
                            return;
                        }
                        var skip = selections.some(function(selection) {
                            return (isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0));
                        });
                        if (skip) {
                            return;
                        }
                        var field = parent;
                        if (isField(field) && field.directives && field.directives.some(function(d) {
                            return d.name.value === "export";
                        })) {
                            return;
                        }
                        return tslib.__assign(tslib.__assign({}, node), {
                            selections: tslib.__spreadArray(tslib.__spreadArray([], selections, true), [
                                TYPENAME_FIELD
                            ], false)
                        });
                    }
                }
            });
        }, {
            added: function(field) {
                return field === TYPENAME_FIELD;
            }
        });
        var connectionRemoveConfig = {
            test: function(directive) {
                var willRemove = directive.name.value === "connection";
                if (willRemove) {
                    if (!directive.arguments || !directive.arguments.some(function(arg) {
                        return arg.name.value === "key";
                    })) {
                        globalThis.__DEV__ !== false && globals.invariant.warn(126);
                    }
                }
                return willRemove;
            }
        };
        function removeConnectionDirectiveFromDocument(doc) {
            return removeDirectivesFromDocument([
                connectionRemoveConfig
            ], checkDocument(doc));
        }
        function getArgumentMatcher(config) {
            return function argumentMatcher(argument) {
                return config.some(function(aConfig) {
                    return argument.value && argument.value.kind === graphql.Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || (aConfig.test && aConfig.test(argument)));
                });
            };
        }
        function removeArgumentsFromDocument(config, doc) {
            var argMatcher = getArgumentMatcher(config);
            return nullIfDocIsEmpty(graphql.visit(doc, {
                OperationDefinition: {
                    enter: function(node) {
                        return tslib.__assign(tslib.__assign({}, node), {
                            variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
                                return !config.some(function(arg) {
                                    return arg.name === varDef.variable.name.value;
                                });
                            }) : []
                        });
                    }
                },
                Field: {
                    enter: function(node) {
                        var shouldRemoveField = config.some(function(argConfig) {
                            return argConfig.remove;
                        });
                        if (shouldRemoveField) {
                            var argMatchCount_1 = 0;
                            if (node.arguments) {
                                node.arguments.forEach(function(arg) {
                                    if (argMatcher(arg)) {
                                        argMatchCount_1 += 1;
                                    }
                                });
                            }
                            if (argMatchCount_1 === 1) {
                                return null;
                            }
                        }
                    }
                },
                Argument: {
                    enter: function(node) {
                        if (argMatcher(node)) {
                            return null;
                        }
                    }
                }
            }));
        }
        function removeFragmentSpreadFromDocument(config, doc) {
            function enter(node) {
                if (config.some(function(def) {
                    return def.name === node.name.value;
                })) {
                    return null;
                }
            }
            return nullIfDocIsEmpty(graphql.visit(doc, {
                FragmentSpread: {
                    enter: enter
                },
                FragmentDefinition: {
                    enter: enter
                }
            }));
        }
        function buildQueryFromSelectionSet(document) {
            var definition = getMainDefinition(document);
            var definitionOperation = definition.operation;
            if (definitionOperation === "query") {
                return document;
            }
            var modifiedDoc = graphql.visit(document, {
                OperationDefinition: {
                    enter: function(node) {
                        return tslib.__assign(tslib.__assign({}, node), {
                            operation: "query"
                        });
                    }
                }
            });
            return modifiedDoc;
        }
        function removeClientSetsFromDocument(document) {
            checkDocument(document);
            var modifiedDoc = removeDirectivesFromDocument([
                {
                    test: function(directive) {
                        return directive.name.value === "client";
                    },
                    remove: true
                }
            ], document);
            return modifiedDoc;
        }
        function addNonReactiveToNamedFragments(document) {
            checkDocument(document);
            return graphql.visit(document, {
                FragmentSpread: function(node) {
                    var _a;
                    if ((_a = node.directives) === null || _a === void 0 ? void 0 : _a.some(function(directive) {
                        return directive.name.value === "unmask";
                    })) {
                        return;
                    }
                    return tslib.__assign(tslib.__assign({}, node), {
                        directives: tslib.__spreadArray(tslib.__spreadArray([], (node.directives || []), true), [
                            {
                                kind: graphql.Kind.DIRECTIVE,
                                name: {
                                    kind: graphql.Kind.NAME,
                                    value: "nonreactive"
                                }
                            }
                        ], false)
                    });
                }
            });
        }
        function isOperation(document, operation) {
            var _a;
            return ((_a = getOperationDefinition(document)) === null || _a === void 0 ? void 0 : _a.operation) === operation;
        }
        function isMutationOperation(document) {
            return isOperation(document, "mutation");
        }
        function isQueryOperation(document) {
            return isOperation(document, "query");
        }
        function isSubscriptionOperation(document) {
            return isOperation(document, "subscription");
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function mergeDeep() {
            var sources = [];
            for(var _i = 0; _i < arguments.length; _i++){
                sources[_i] = arguments[_i];
            }
            return mergeDeepArray(sources);
        }
        function mergeDeepArray(sources) {
            var target = sources[0] || {};
            var count = sources.length;
            if (count > 1) {
                var merger = new DeepMerger();
                for(var i = 1; i < count; ++i){
                    target = merger.merge(target, sources[i]);
                }
            }
            return target;
        }
        var defaultReconciler = function(target, source, property) {
            return this.merge(target[property], source[property]);
        };
        var DeepMerger = (function() {
            function DeepMerger(reconciler) {
                if (reconciler === void 0) {
                    reconciler = defaultReconciler;
                }
                this.reconciler = reconciler;
                this.isObject = isNonNullObject;
                this.pastCopies = new Set();
            }
            DeepMerger.prototype.merge = function(target, source) {
                var _this = this;
                var context = [];
                for(var _i = 2; _i < arguments.length; _i++){
                    context[_i - 2] = arguments[_i];
                }
                if (isNonNullObject(source) && isNonNullObject(target)) {
                    Object.keys(source).forEach(function(sourceKey) {
                        if (hasOwnProperty.call(target, sourceKey)) {
                            var targetValue = target[sourceKey];
                            if (source[sourceKey] !== targetValue) {
                                var result = _this.reconciler.apply(_this, tslib.__spreadArray([
                                    target,
                                    source,
                                    sourceKey
                                ], context, false));
                                if (result !== targetValue) {
                                    target = _this.shallowCopyForMerge(target);
                                    target[sourceKey] = result;
                                }
                            }
                        } else {
                            target = _this.shallowCopyForMerge(target);
                            target[sourceKey] = source[sourceKey];
                        }
                    });
                    return target;
                }
                return source;
            };
            DeepMerger.prototype.shallowCopyForMerge = function(value) {
                if (isNonNullObject(value)) {
                    if (!this.pastCopies.has(value)) {
                        if (Array.isArray(value)) {
                            value = value.slice(0);
                        } else {
                            value = tslib.__assign({
                                __proto__: Object.getPrototypeOf(value)
                            }, value);
                        }
                        this.pastCopies.add(value);
                    }
                }
                return value;
            };
            return DeepMerger;
        }());
        function concatPagination(keyArgs) {
            if (keyArgs === void 0) {
                keyArgs = false;
            }
            return {
                keyArgs: keyArgs,
                merge: function(existing, incoming) {
                    return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing, true), incoming, true) : incoming;
                }
            };
        }
        function offsetLimitPagination(keyArgs) {
            if (keyArgs === void 0) {
                keyArgs = false;
            }
            return {
                keyArgs: keyArgs,
                merge: function(existing, incoming, _a) {
                    var args = _a.args;
                    var merged = existing ? existing.slice(0) : [];
                    if (incoming) {
                        if (args) {
                            var _b = args.offset, offset = _b === void 0 ? 0 : _b;
                            for(var i = 0; i < incoming.length; ++i){
                                merged[offset + i] = incoming[i];
                            }
                        } else {
                            merged.push.apply(merged, incoming);
                        }
                    }
                    return merged;
                }
            };
        }
        function relayStylePagination(keyArgs) {
            if (keyArgs === void 0) {
                keyArgs = false;
            }
            return {
                keyArgs: keyArgs,
                read: function(existing, _a) {
                    var canRead = _a.canRead, readField = _a.readField;
                    if (!existing) return existing;
                    var edges = [];
                    var firstEdgeCursor = "";
                    var lastEdgeCursor = "";
                    existing.edges.forEach(function(edge) {
                        if (canRead(readField("node", edge))) {
                            edges.push(edge);
                            if (edge.cursor) {
                                firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
                                lastEdgeCursor = edge.cursor || lastEdgeCursor;
                            }
                        }
                    });
                    if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {
                        firstEdgeCursor = "";
                    }
                    var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;
                    return tslib.__assign(tslib.__assign({}, getExtras(existing)), {
                        edges: edges,
                        pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), {
                            startCursor: startCursor || firstEdgeCursor,
                            endCursor: endCursor || lastEdgeCursor
                        })
                    });
                },
                merge: function(existing, incoming, _a) {
                    var args = _a.args, isReference = _a.isReference, readField = _a.readField;
                    if (!existing) {
                        existing = makeEmptyData();
                    }
                    if (!incoming) {
                        return existing;
                    }
                    var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
                        if (isReference((edge = tslib.__assign({}, edge)))) {
                            edge.cursor = readField("cursor", edge);
                        }
                        return edge;
                    }) : [];
                    if (incoming.pageInfo) {
                        var pageInfo_1 = incoming.pageInfo;
                        var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
                        var firstEdge = incomingEdges[0];
                        var lastEdge = incomingEdges[incomingEdges.length - 1];
                        if (firstEdge && startCursor) {
                            firstEdge.cursor = startCursor;
                        }
                        if (lastEdge && endCursor) {
                            lastEdge.cursor = endCursor;
                        }
                        var firstCursor = firstEdge && firstEdge.cursor;
                        if (firstCursor && !startCursor) {
                            incoming = mergeDeep(incoming, {
                                pageInfo: {
                                    startCursor: firstCursor
                                }
                            });
                        }
                        var lastCursor = lastEdge && lastEdge.cursor;
                        if (lastCursor && !endCursor) {
                            incoming = mergeDeep(incoming, {
                                pageInfo: {
                                    endCursor: lastCursor
                                }
                            });
                        }
                    }
                    var prefix = existing.edges;
                    var suffix = [];
                    if (args && args.after) {
                        var index = prefix.findIndex(function(edge) {
                            return edge.cursor === args.after;
                        });
                        if (index >= 0) {
                            prefix = prefix.slice(0, index + 1);
                        }
                    } else if (args && args.before) {
                        var index = prefix.findIndex(function(edge) {
                            return edge.cursor === args.before;
                        });
                        suffix = index < 0 ? prefix : prefix.slice(index);
                        prefix = [];
                    } else if (incoming.edges) {
                        prefix = [];
                    }
                    var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
                    var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);
                    if (incoming.pageInfo) {
                        var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = tslib.__rest(_b, [
                            "hasPreviousPage",
                            "hasNextPage",
                            "startCursor",
                            "endCursor"
                        ]);
                        Object.assign(pageInfo, extras);
                        if (!prefix.length) {
                            if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;
                            if (void 0 !== startCursor) pageInfo.startCursor = startCursor;
                        }
                        if (!suffix.length) {
                            if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;
                            if (void 0 !== endCursor) pageInfo.endCursor = endCursor;
                        }
                    }
                    return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), {
                        edges: edges,
                        pageInfo: pageInfo
                    });
                }
            };
        }
        var getExtras = function(obj) {
            return tslib.__rest(obj, notExtras);
        };
        var notExtras = [
            "edges",
            "pageInfo"
        ];
        function makeEmptyData() {
            return {
                edges: [],
                pageInfo: {
                    hasPreviousPage: false,
                    hasNextPage: true,
                    startCursor: "",
                    endCursor: ""
                }
            };
        }
        function createFulfilledPromise(value) {
            var promise = Promise.resolve(value);
            promise.status = "fulfilled";
            promise.value = value;
            return promise;
        }
        function createRejectedPromise(reason) {
            var promise = Promise.reject(reason);
            promise.catch(function() {});
            promise.status = "rejected";
            promise.reason = reason;
            return promise;
        }
        function isStatefulPromise(promise) {
            return "status" in promise;
        }
        function wrapPromiseWithState(promise) {
            if (isStatefulPromise(promise)) {
                return promise;
            }
            var pendingPromise = promise;
            pendingPromise.status = "pending";
            pendingPromise.then(function(value) {
                if (pendingPromise.status === "pending") {
                    var fulfilledPromise = pendingPromise;
                    fulfilledPromise.status = "fulfilled";
                    fulfilledPromise.value = value;
                }
            }, function(reason) {
                if (pendingPromise.status === "pending") {
                    var rejectedPromise = pendingPromise;
                    rejectedPromise.status = "rejected";
                    rejectedPromise.reason = reason;
                }
            });
            return promise;
        }
        function preventUnhandledRejection(promise) {
            promise.catch(function() {});
            return promise;
        }
        var toString = Object.prototype.toString;
        function cloneDeep(value) {
            return cloneDeepHelper(value);
        }
        function cloneDeepHelper(val, seen) {
            switch(toString.call(val)){
                case "[object Array]":
                    {
                        seen = seen || new Map();
                        if (seen.has(val)) return seen.get(val);
                        var copy_1 = val.slice(0);
                        seen.set(val, copy_1);
                        copy_1.forEach(function(child, i) {
                            copy_1[i] = cloneDeepHelper(child, seen);
                        });
                        return copy_1;
                    }
                case "[object Object]":
                    {
                        seen = seen || new Map();
                        if (seen.has(val)) return seen.get(val);
                        var copy_2 = Object.create(Object.getPrototypeOf(val));
                        seen.set(val, copy_2);
                        Object.keys(val).forEach(function(key) {
                            copy_2[key] = cloneDeepHelper(val[key], seen);
                        });
                        return copy_2;
                    }
                default:
                    return val;
            }
        }
        function deepFreeze(value) {
            var workSet = new Set([
                value
            ]);
            workSet.forEach(function(obj) {
                if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
                    Object.getOwnPropertyNames(obj).forEach(function(name) {
                        if (isNonNullObject(obj[name])) workSet.add(obj[name]);
                    });
                }
            });
            return value;
        }
        function shallowFreeze(obj) {
            if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
                try {
                    Object.freeze(obj);
                } catch (e) {
                    if (e instanceof TypeError) return null;
                    throw e;
                }
            }
            return obj;
        }
        function maybeDeepFreeze(obj) {
            if (globalThis.__DEV__ !== false) {
                deepFreeze(obj);
            }
            return obj;
        }
        function iterateObserversSafely(observers, method, argument) {
            var observersWithMethod = [];
            observers.forEach(function(obs) {
                return obs[method] && observersWithMethod.push(obs);
            });
            observersWithMethod.forEach(function(obs) {
                return obs[method](argument);
            });
        }
        function asyncMap(observable, mapFn, catchFn) {
            return new zenObservableTs.Observable(function(observer) {
                var promiseQueue = {
                    then: function(callback) {
                        return new Promise(function(resolve) {
                            return resolve(callback());
                        });
                    }
                };
                function makeCallback(examiner, key) {
                    return function(arg) {
                        if (examiner) {
                            var both = function() {
                                return observer.closed ? 0 : examiner(arg);
                            };
                            promiseQueue = promiseQueue.then(both, both).then(function(result) {
                                return observer.next(result);
                            }, function(error) {
                                return observer.error(error);
                            });
                        } else {
                            observer[key](arg);
                        }
                    };
                }
                var handler = {
                    next: makeCallback(mapFn, "next"),
                    error: makeCallback(catchFn, "error"),
                    complete: function() {
                        promiseQueue.then(function() {
                            return observer.complete();
                        });
                    }
                };
                var sub = observable.subscribe(handler);
                return function() {
                    return sub.unsubscribe();
                };
            });
        }
        function fixObservableSubclass(subclass) {
            function set(key) {
                Object.defineProperty(subclass, key, {
                    value: zenObservableTs.Observable
                });
            }
            if (canUseSymbol && Symbol.species) {
                set(Symbol.species);
            }
            set("@@species");
            return subclass;
        }
        function isPromiseLike(value) {
            return value && typeof value.then === "function";
        }
        var Concast = (function(_super) {
            tslib.__extends(Concast, _super);
            function Concast(sources) {
                var _this = _super.call(this, function(observer) {
                    _this.addObserver(observer);
                    return function() {
                        return _this.removeObserver(observer);
                    };
                }) || this;
                _this.observers = new Set();
                _this.promise = new Promise(function(resolve, reject) {
                    _this.resolve = resolve;
                    _this.reject = reject;
                });
                _this.handlers = {
                    next: function(result) {
                        if (_this.sub !== null) {
                            _this.latest = [
                                "next",
                                result
                            ];
                            _this.notify("next", result);
                            iterateObserversSafely(_this.observers, "next", result);
                        }
                    },
                    error: function(error) {
                        var sub = _this.sub;
                        if (sub !== null) {
                            if (sub) setTimeout(function() {
                                return sub.unsubscribe();
                            });
                            _this.sub = null;
                            _this.latest = [
                                "error",
                                error
                            ];
                            _this.reject(error);
                            _this.notify("error", error);
                            iterateObserversSafely(_this.observers, "error", error);
                        }
                    },
                    complete: function() {
                        var _a = _this, sub = _a.sub, _b = _a.sources, sources = _b === void 0 ? [] : _b;
                        if (sub !== null) {
                            var value = sources.shift();
                            if (!value) {
                                if (sub) setTimeout(function() {
                                    return sub.unsubscribe();
                                });
                                _this.sub = null;
                                if (_this.latest && _this.latest[0] === "next") {
                                    _this.resolve(_this.latest[1]);
                                } else {
                                    _this.resolve();
                                }
                                _this.notify("complete");
                                iterateObserversSafely(_this.observers, "complete");
                            } else if (isPromiseLike(value)) {
                                value.then(function(obs) {
                                    return (_this.sub = obs.subscribe(_this.handlers));
                                }, _this.handlers.error);
                            } else {
                                _this.sub = value.subscribe(_this.handlers);
                            }
                        }
                    }
                };
                _this.nextResultListeners = new Set();
                _this.cancel = function(reason) {
                    _this.reject(reason);
                    _this.sources = [];
                    _this.handlers.error(reason);
                };
                _this.promise.catch(function(_) {});
                if (typeof sources === "function") {
                    sources = [
                        new zenObservableTs.Observable(sources)
                    ];
                }
                if (isPromiseLike(sources)) {
                    sources.then(function(iterable) {
                        return _this.start(iterable);
                    }, _this.handlers.error);
                } else {
                    _this.start(sources);
                }
                return _this;
            }
            Concast.prototype.start = function(sources) {
                if (this.sub !== void 0) return;
                this.sources = Array.from(sources);
                this.handlers.complete();
            };
            Concast.prototype.deliverLastMessage = function(observer) {
                if (this.latest) {
                    var nextOrError = this.latest[0];
                    var method = observer[nextOrError];
                    if (method) {
                        method.call(observer, this.latest[1]);
                    }
                    if (this.sub === null && nextOrError === "next" && observer.complete) {
                        observer.complete();
                    }
                }
            };
            Concast.prototype.addObserver = function(observer) {
                if (!this.observers.has(observer)) {
                    this.deliverLastMessage(observer);
                    this.observers.add(observer);
                }
            };
            Concast.prototype.removeObserver = function(observer) {
                if (this.observers.delete(observer) && this.observers.size < 1) {
                    this.handlers.complete();
                }
            };
            Concast.prototype.notify = function(method, arg) {
                var nextResultListeners = this.nextResultListeners;
                if (nextResultListeners.size) {
                    this.nextResultListeners = new Set();
                    nextResultListeners.forEach(function(listener) {
                        return listener(method, arg);
                    });
                }
            };
            Concast.prototype.beforeNext = function(callback) {
                var called = false;
                this.nextResultListeners.add(function(method, arg) {
                    if (!called) {
                        called = true;
                        callback(method, arg);
                    }
                });
            };
            return Concast;
        }(zenObservableTs.Observable));
        fixObservableSubclass(Concast);
        function isExecutionPatchIncrementalResult(value) {
            return "incremental" in value;
        }
        function isExecutionPatchInitialResult(value) {
            return "hasNext" in value && "data" in value;
        }
        function isExecutionPatchResult(value) {
            return (isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value));
        }
        function isApolloPayloadResult(value) {
            return isNonNullObject(value) && "payload" in value;
        }
        function mergeIncrementalData(prevResult, result) {
            var mergedData = prevResult;
            var merger = new DeepMerger();
            if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
                result.incremental.forEach(function(_a) {
                    var data = _a.data, path = _a.path;
                    for(var i = path.length - 1; i >= 0; --i){
                        var key = path[i];
                        var isNumericKey = !isNaN(+key);
                        var parent_1 = isNumericKey ? [] : {};
                        parent_1[key] = data;
                        data = parent_1;
                    }
                    mergedData = merger.merge(mergedData, data);
                });
            }
            return mergedData;
        }
        function graphQLResultHasError(result) {
            var errors = getGraphQLErrorsFromResult(result);
            return isNonEmptyArray(errors);
        }
        function getGraphQLErrorsFromResult(result) {
            var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
            if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
                result.incremental.forEach(function(incrementalResult) {
                    if (incrementalResult.errors) {
                        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
                    }
                });
            }
            return graphQLErrors;
        }
        function compact() {
            var objects = [];
            for(var _i = 0; _i < arguments.length; _i++){
                objects[_i] = arguments[_i];
            }
            var result = Object.create(null);
            objects.forEach(function(obj) {
                if (!obj) return;
                Object.keys(obj).forEach(function(key) {
                    var value = obj[key];
                    if (value !== void 0) {
                        result[key] = value;
                    }
                });
            });
            return result;
        }
        var prefixCounts = new Map();
        function makeUniqueId(prefix) {
            var count = prefixCounts.get(prefix) || 1;
            prefixCounts.set(prefix, count + 1);
            return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
        }
        function stringifyForDisplay(value, space) {
            if (space === void 0) {
                space = 0;
            }
            var undefId = makeUniqueId("stringifyForDisplay");
            return JSON.stringify(value, function(key, value) {
                return value === void 0 ? undefId : value;
            }, space).split(JSON.stringify(undefId)).join("<undefined>");
        }
        function mergeOptions(defaults, options) {
            return compact(defaults, options, options.variables && {
                variables: compact(tslib.__assign(tslib.__assign({}, (defaults && defaults.variables)), options.variables))
            });
        }
        function omitDeep(value, key) {
            return __omitDeep(value, key);
        }
        function __omitDeep(value, key, known) {
            if (known === void 0) {
                known = new Map();
            }
            if (known.has(value)) {
                return known.get(value);
            }
            var modified = false;
            if (Array.isArray(value)) {
                var array_1 = [];
                known.set(value, array_1);
                value.forEach(function(value, index) {
                    var result = __omitDeep(value, key, known);
                    modified || (modified = result !== value);
                    array_1[index] = result;
                });
                if (modified) {
                    return array_1;
                }
            } else if (isPlainObject(value)) {
                var obj_1 = Object.create(Object.getPrototypeOf(value));
                known.set(value, obj_1);
                Object.keys(value).forEach(function(k) {
                    if (k === key) {
                        modified = true;
                        return;
                    }
                    var result = __omitDeep(value[k], key, known);
                    modified || (modified = result !== value[k]);
                    obj_1[k] = result;
                });
                if (modified) {
                    return obj_1;
                }
            }
            return value;
        }
        function stripTypename(value) {
            return omitDeep(value, "__typename");
        }
        utilities.DEV = globals.DEV;
        utilities.maybe = globals.maybe;
        utilities.Observable = zenObservableTs.Observable;
        utilities.AutoCleanedStrongCache = AutoCleanedStrongCache;
        utilities.AutoCleanedWeakCache = AutoCleanedWeakCache;
        utilities.Concast = Concast;
        utilities.DeepMerger = DeepMerger;
        utilities.DocumentTransform = DocumentTransform;
        utilities.addNonReactiveToNamedFragments = addNonReactiveToNamedFragments;
        utilities.addTypenameToDocument = addTypenameToDocument;
        utilities.argumentsObjectFromField = argumentsObjectFromField;
        utilities.asyncMap = asyncMap;
        utilities.buildQueryFromSelectionSet = buildQueryFromSelectionSet;
        utilities.cacheSizes = cacheSizes;
        utilities.canUseAsyncIteratorSymbol = canUseAsyncIteratorSymbol;
        utilities.canUseDOM = canUseDOM;
        utilities.canUseLayoutEffect = canUseLayoutEffect;
        utilities.canUseSymbol = canUseSymbol;
        utilities.canUseWeakMap = canUseWeakMap;
        utilities.canUseWeakSet = canUseWeakSet;
        utilities.canonicalStringify = canonicalStringify;
        utilities.checkDocument = checkDocument;
        utilities.cloneDeep = cloneDeep;
        utilities.compact = compact;
        utilities.concatPagination = concatPagination;
        utilities.createFragmentMap = createFragmentMap;
        utilities.createFulfilledPromise = createFulfilledPromise;
        utilities.createRejectedPromise = createRejectedPromise;
        utilities.fixObservableSubclass = fixObservableSubclass;
        utilities.getDefaultValues = getDefaultValues;
        utilities.getDirectiveNames = getDirectiveNames;
        utilities.getFragmentDefinition = getFragmentDefinition;
        utilities.getFragmentDefinitions = getFragmentDefinitions;
        utilities.getFragmentFromSelection = getFragmentFromSelection;
        utilities.getFragmentMaskMode = getFragmentMaskMode;
        utilities.getFragmentQueryDocument = getFragmentQueryDocument;
        utilities.getGraphQLErrorsFromResult = getGraphQLErrorsFromResult;
        utilities.getInclusionDirectives = getInclusionDirectives;
        utilities.getMainDefinition = getMainDefinition;
        utilities.getOperationDefinition = getOperationDefinition;
        utilities.getOperationName = getOperationName;
        utilities.getQueryDefinition = getQueryDefinition;
        utilities.getStoreKeyName = getStoreKeyName;
        utilities.getTypenameFromResult = getTypenameFromResult;
        utilities.graphQLResultHasError = graphQLResultHasError;
        utilities.hasAllDirectives = hasAllDirectives;
        utilities.hasAnyDirectives = hasAnyDirectives;
        utilities.hasClientExports = hasClientExports;
        utilities.hasDirectives = hasDirectives;
        utilities.isApolloPayloadResult = isApolloPayloadResult;
        utilities.isArray = isArray;
        utilities.isDocumentNode = isDocumentNode;
        utilities.isExecutionPatchIncrementalResult = isExecutionPatchIncrementalResult;
        utilities.isExecutionPatchInitialResult = isExecutionPatchInitialResult;
        utilities.isExecutionPatchResult = isExecutionPatchResult;
        utilities.isField = isField;
        utilities.isFullyUnmaskedOperation = isFullyUnmaskedOperation;
        utilities.isInlineFragment = isInlineFragment;
        utilities.isMutationOperation = isMutationOperation;
        utilities.isNonEmptyArray = isNonEmptyArray;
        utilities.isNonNullObject = isNonNullObject;
        utilities.isPlainObject = isPlainObject;
        utilities.isQueryOperation = isQueryOperation;
        utilities.isReference = isReference;
        utilities.isStatefulPromise = isStatefulPromise;
        utilities.isSubscriptionOperation = isSubscriptionOperation;
        utilities.iterateObserversSafely = iterateObserversSafely;
        utilities.makeReference = makeReference;
        utilities.makeUniqueId = makeUniqueId;
        utilities.maybeDeepFreeze = maybeDeepFreeze;
        utilities.mergeDeep = mergeDeep;
        utilities.mergeDeepArray = mergeDeepArray;
        utilities.mergeIncrementalData = mergeIncrementalData;
        utilities.mergeOptions = mergeOptions;
        utilities.offsetLimitPagination = offsetLimitPagination;
        utilities.omitDeep = omitDeep;
        utilities.preventUnhandledRejection = preventUnhandledRejection;
        utilities.print = print;
        utilities.relayStylePagination = relayStylePagination;
        utilities.removeArgumentsFromDocument = removeArgumentsFromDocument;
        utilities.removeClientSetsFromDocument = removeClientSetsFromDocument;
        utilities.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
        utilities.removeDirectivesFromDocument = removeDirectivesFromDocument;
        utilities.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;
        utilities.resultKeyNameFromField = resultKeyNameFromField;
        utilities.shouldInclude = shouldInclude;
        utilities.storeKeyNameFromField = storeKeyNameFromField;
        utilities.stringifyForDisplay = stringifyForDisplay;
        utilities.stripTypename = stripTypename;
        utilities.valueToObjectRepresentation = valueToObjectRepresentation;
        utilities.wrapPromiseWithState = wrapPromiseWithState;
        return utilities;
    }
    var utilitiesExports = requireUtilities();
    var subscriptions = {};
    var hasRequiredSubscriptions;
    function requireSubscriptions() {
        if (hasRequiredSubscriptions) return subscriptions;
        hasRequiredSubscriptions = 1;
        Object.defineProperty(subscriptions, '__esModule', {
            value: true
        });
        var tslib = require$$0$1;
        var utilities = require$$1$1;
        var core = require$$2$1;
        var errors = require$$3$1;
        function isLikeCloseEvent(val) {
            return utilities.isNonNullObject(val) && "code" in val && "reason" in val;
        }
        function isLikeErrorEvent(err) {
            var _a;
            return utilities.isNonNullObject(err) && ((_a = err.target) === null || _a === void 0 ? void 0 : _a.readyState) === WebSocket.CLOSED;
        }
        var GraphQLWsLink = (function(_super) {
            tslib.__extends(GraphQLWsLink, _super);
            function GraphQLWsLink(client) {
                var _this = _super.call(this) || this;
                _this.client = client;
                return _this;
            }
            GraphQLWsLink.prototype.request = function(operation) {
                var _this = this;
                return new utilities.Observable(function(observer) {
                    return _this.client.subscribe(tslib.__assign(tslib.__assign({}, operation), {
                        query: utilities.print(operation.query)
                    }), {
                        next: observer.next.bind(observer),
                        complete: observer.complete.bind(observer),
                        error: function(err) {
                            if (err instanceof Error) {
                                return observer.error(err);
                            }
                            var likeClose = isLikeCloseEvent(err);
                            if (likeClose || isLikeErrorEvent(err)) {
                                return observer.error(new Error("Socket closed".concat(likeClose ? " with event ".concat(err.code) : "").concat(likeClose ? " ".concat(err.reason) : "")));
                            }
                            return observer.error(new errors.ApolloError({
                                graphQLErrors: Array.isArray(err) ? err : [
                                    err
                                ]
                            }));
                        }
                    });
                });
            };
            return GraphQLWsLink;
        }(core.ApolloLink));
        subscriptions.GraphQLWsLink = GraphQLWsLink;
        return subscriptions;
    }
    var subscriptionsExports = requireSubscriptions();
    function extendedTypeof(val) {
        if (val === null) {
            return "null";
        }
        if (Array.isArray(val)) {
            return "array";
        }
        return typeof val;
    }
    function isObject(val) {
        return extendedTypeof(val) === "object";
    }
    function areGraphQLFormattedErrors(obj) {
        return Array.isArray(obj) && obj.length > 0 && obj.every((ob)=>"message" in ob);
    }
    function limitCloseReason(reason, whenTooLong) {
        return reason.length < 124 ? reason : whenTooLong;
    }
    const GRAPHQL_TRANSPORT_WS_PROTOCOL = "graphql-transport-ws";
    var CloseCode = ((CloseCode2)=>{
        CloseCode2[CloseCode2["InternalServerError"] = 4500] = "InternalServerError";
        CloseCode2[CloseCode2["InternalClientError"] = 4005] = "InternalClientError";
        CloseCode2[CloseCode2["BadRequest"] = 4400] = "BadRequest";
        CloseCode2[CloseCode2["BadResponse"] = 4004] = "BadResponse";
        CloseCode2[CloseCode2["Unauthorized"] = 4401] = "Unauthorized";
        CloseCode2[CloseCode2["Forbidden"] = 4403] = "Forbidden";
        CloseCode2[CloseCode2["SubprotocolNotAcceptable"] = 4406] = "SubprotocolNotAcceptable";
        CloseCode2[CloseCode2["ConnectionInitialisationTimeout"] = 4408] = "ConnectionInitialisationTimeout";
        CloseCode2[CloseCode2["ConnectionAcknowledgementTimeout"] = 4504] = "ConnectionAcknowledgementTimeout";
        CloseCode2[CloseCode2["SubscriberAlreadyExists"] = 4409] = "SubscriberAlreadyExists";
        CloseCode2[CloseCode2["TooManyInitialisationRequests"] = 4429] = "TooManyInitialisationRequests";
        return CloseCode2;
    })(CloseCode || {});
    var MessageType = ((MessageType2)=>{
        MessageType2["ConnectionInit"] = "connection_init";
        MessageType2["ConnectionAck"] = "connection_ack";
        MessageType2["Ping"] = "ping";
        MessageType2["Pong"] = "pong";
        MessageType2["Subscribe"] = "subscribe";
        MessageType2["Next"] = "next";
        MessageType2["Error"] = "error";
        MessageType2["Complete"] = "complete";
        return MessageType2;
    })(MessageType || {});
    function validateMessage(val) {
        if (!isObject(val)) {
            throw new Error(`Message is expected to be an object, but got ${extendedTypeof(val)}`);
        }
        if (!val.type) {
            throw new Error(`Message is missing the 'type' property`);
        }
        if (typeof val.type !== "string") {
            throw new Error(`Message is expects the 'type' property to be a string, but got ${extendedTypeof(val.type)}`);
        }
        switch(val.type){
            case "connection_init":
            case "connection_ack":
            case "ping":
            case "pong":
                {
                    if (val.payload != null && !isObject(val.payload)) {
                        throw new Error(`"${val.type}" message expects the 'payload' property to be an object or nullish or missing, but got "${val.payload}"`);
                    }
                    break;
                }
            case "subscribe":
                {
                    if (typeof val.id !== "string") {
                        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
                    }
                    if (!val.id) {
                        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
                    }
                    if (!isObject(val.payload)) {
                        throw new Error(`"${val.type}" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);
                    }
                    if (typeof val.payload.query !== "string") {
                        throw new Error(`"${val.type}" message payload expects the 'query' property to be a string, but got ${extendedTypeof(val.payload.query)}`);
                    }
                    if (val.payload.variables != null && !isObject(val.payload.variables)) {
                        throw new Error(`"${val.type}" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.variables)}`);
                    }
                    if (val.payload.operationName != null && extendedTypeof(val.payload.operationName) !== "string") {
                        throw new Error(`"${val.type}" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${extendedTypeof(val.payload.operationName)}`);
                    }
                    if (val.payload.extensions != null && !isObject(val.payload.extensions)) {
                        throw new Error(`"${val.type}" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${extendedTypeof(val.payload.extensions)}`);
                    }
                    break;
                }
            case "next":
                {
                    if (typeof val.id !== "string") {
                        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
                    }
                    if (!val.id) {
                        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
                    }
                    if (!isObject(val.payload)) {
                        throw new Error(`"${val.type}" message expects the 'payload' property to be an object, but got ${extendedTypeof(val.payload)}`);
                    }
                    break;
                }
            case "error":
                {
                    if (typeof val.id !== "string") {
                        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
                    }
                    if (!val.id) {
                        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
                    }
                    if (!areGraphQLFormattedErrors(val.payload)) {
                        throw new Error(`"${val.type}" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);
                    }
                    break;
                }
            case "complete":
                {
                    if (typeof val.id !== "string") {
                        throw new Error(`"${val.type}" message expects the 'id' property to be a string, but got ${extendedTypeof(val.id)}`);
                    }
                    if (!val.id) {
                        throw new Error(`"${val.type}" message requires a non-empty 'id' property`);
                    }
                    break;
                }
            default:
                throw new Error(`Invalid message 'type' property "${val.type}"`);
        }
        return val;
    }
    function parseMessage(data, reviver) {
        return validateMessage(typeof data === "string" ? JSON.parse(data, reviver) : data);
    }
    function stringifyMessage(msg, replacer) {
        validateMessage(msg);
        return JSON.stringify(msg, replacer);
    }
    function createClient(options) {
        const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries2) {
            const retryDelaySeconds = Math.pow(2, retries2);
            await new Promise((resolve)=>setTimeout(resolve, retryDelaySeconds * 1e3 + Math.floor(Math.random() * (3e3 - 300) + 300)));
        }, shouldRetry = isLikeCloseEvent, on, webSocketImpl, generateID = function generateUUID() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c)=>{
                const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
                return v.toString(16);
            });
        }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver } = options;
        let ws;
        if (webSocketImpl) {
            if (!isWebSocket(webSocketImpl)) {
                throw new Error("Invalid WebSocket implementation provided");
            }
            ws = webSocketImpl;
        } else if (typeof WebSocket !== "undefined") {
            ws = WebSocket;
        } else if (typeof global !== "undefined") {
            ws = global.WebSocket || global.MozWebSocket;
        } else if (typeof window !== "undefined") {
            ws = window.WebSocket || window.MozWebSocket;
        }
        if (!ws) throw new Error("WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`");
        const WebSocketImpl = ws;
        const emitter = (()=>{
            const message = (()=>{
                const listeners2 = {};
                return {
                    on (id, listener) {
                        listeners2[id] = listener;
                        return ()=>{
                            delete listeners2[id];
                        };
                    },
                    emit (message2) {
                        if ("id" in message2) listeners2[message2.id]?.(message2);
                    }
                };
            })();
            const listeners = {
                connecting: on?.connecting ? [
                    on.connecting
                ] : [],
                opened: on?.opened ? [
                    on.opened
                ] : [],
                connected: on?.connected ? [
                    on.connected
                ] : [],
                ping: on?.ping ? [
                    on.ping
                ] : [],
                pong: on?.pong ? [
                    on.pong
                ] : [],
                message: on?.message ? [
                    message.emit,
                    on.message
                ] : [
                    message.emit
                ],
                closed: on?.closed ? [
                    on.closed
                ] : [],
                error: on?.error ? [
                    on.error
                ] : []
            };
            return {
                onMessage: message.on,
                on (event, listener) {
                    const l = listeners[event];
                    l.push(listener);
                    return ()=>{
                        l.splice(l.indexOf(listener), 1);
                    };
                },
                emit (event, ...args) {
                    for (const listener of [
                        ...listeners[event]
                    ]){
                        listener(...args);
                    }
                }
            };
        })();
        function errorOrClosed(cb) {
            const listening = [
                emitter.on("error", (err)=>{
                    listening.forEach((unlisten)=>unlisten());
                    cb(err);
                }),
                emitter.on("closed", (event)=>{
                    listening.forEach((unlisten)=>unlisten());
                    cb(event);
                })
            ];
        }
        let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;
        async function connect() {
            clearTimeout(lazyCloseTimeout);
            const [socket, throwOnClose] = await (connecting ?? (connecting = new Promise((connected, denied)=>(async ()=>{
                    if (retrying) {
                        await retryWait(retries);
                        if (!locks) {
                            connecting = void 0;
                            return denied({
                                code: 1e3,
                                reason: "All Subscriptions Gone"
                            });
                        }
                        retries++;
                    }
                    emitter.emit("connecting", retrying);
                    const socket2 = new WebSocketImpl(typeof url === "function" ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);
                    let connectionAckTimeout, queuedPing;
                    function enqueuePing() {
                        if (isFinite(keepAlive) && keepAlive > 0) {
                            clearTimeout(queuedPing);
                            queuedPing = setTimeout(()=>{
                                if (socket2.readyState === WebSocketImpl.OPEN) {
                                    socket2.send(stringifyMessage({
                                        type: MessageType.Ping
                                    }));
                                    emitter.emit("ping", false, void 0);
                                }
                            }, keepAlive);
                        }
                    }
                    errorOrClosed((errOrEvent)=>{
                        connecting = void 0;
                        clearTimeout(connectionAckTimeout);
                        clearTimeout(queuedPing);
                        denied(errOrEvent);
                        if (errOrEvent instanceof TerminatedCloseEvent) {
                            socket2.close(4499, "Terminated");
                            socket2.onerror = null;
                            socket2.onclose = null;
                        }
                    });
                    socket2.onerror = (err)=>emitter.emit("error", err);
                    socket2.onclose = (event)=>emitter.emit("closed", event);
                    socket2.onopen = async ()=>{
                        try {
                            emitter.emit("opened", socket2);
                            const payload = typeof connectionParams === "function" ? await connectionParams() : connectionParams;
                            if (socket2.readyState !== WebSocketImpl.OPEN) return;
                            socket2.send(stringifyMessage(payload ? {
                                type: MessageType.ConnectionInit,
                                payload
                            } : {
                                type: MessageType.ConnectionInit
                            }, replacer));
                            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {
                                connectionAckTimeout = setTimeout(()=>{
                                    socket2.close(CloseCode.ConnectionAcknowledgementTimeout, "Connection acknowledgement timeout");
                                }, connectionAckWaitTimeout);
                            }
                            enqueuePing();
                        } catch (err) {
                            emitter.emit("error", err);
                            socket2.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : String(err), "Internal client error"));
                        }
                    };
                    let acknowledged = false;
                    socket2.onmessage = ({ data })=>{
                        try {
                            const message = parseMessage(data, reviver);
                            emitter.emit("message", message);
                            if (message.type === "ping" || message.type === "pong") {
                                emitter.emit(message.type, true, message.payload);
                                if (message.type === "pong") {
                                    enqueuePing();
                                } else if (!disablePong) {
                                    socket2.send(stringifyMessage(message.payload ? {
                                        type: MessageType.Pong,
                                        payload: message.payload
                                    } : {
                                        type: MessageType.Pong
                                    }));
                                    emitter.emit("pong", false, message.payload);
                                }
                                return;
                            }
                            if (acknowledged) return;
                            if (message.type !== MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);
                            clearTimeout(connectionAckTimeout);
                            acknowledged = true;
                            emitter.emit("connected", socket2, message.payload, retrying);
                            retrying = false;
                            retries = 0;
                            connected([
                                socket2,
                                new Promise((_, reject)=>errorOrClosed(reject))
                            ]);
                        } catch (err) {
                            socket2.onmessage = null;
                            emitter.emit("error", err);
                            socket2.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : String(err), "Bad response"));
                        }
                    };
                })())));
            if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;
            let release = ()=>{};
            const released = new Promise((resolve)=>release = resolve);
            return [
                socket,
                release,
                Promise.race([
                    released.then(()=>{
                        if (!locks) {
                            const complete = ()=>socket.close(1e3, "Normal Closure");
                            if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {
                                lazyCloseTimeout = setTimeout(()=>{
                                    if (socket.readyState === WebSocketImpl.OPEN) complete();
                                }, lazyCloseTimeoutMs);
                            } else {
                                complete();
                            }
                        }
                    }),
                    throwOnClose
                ])
            ];
        }
        function shouldRetryConnectOrThrow(errOrCloseEvent) {
            if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [
                CloseCode.InternalServerError,
                CloseCode.InternalClientError,
                CloseCode.BadRequest,
                CloseCode.BadResponse,
                CloseCode.Unauthorized,
                CloseCode.SubprotocolNotAcceptable,
                CloseCode.SubscriberAlreadyExists,
                CloseCode.TooManyInitialisationRequests
            ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;
            if (disposed) return false;
            if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3) return locks > 0;
            if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;
            if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;
            return retrying = true;
        }
        if (!lazy) {
            (async ()=>{
                locks++;
                for(;;){
                    try {
                        const [, , throwOnClose] = await connect();
                        await throwOnClose;
                    } catch (errOrCloseEvent) {
                        try {
                            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;
                        } catch (errOrCloseEvent2) {
                            return onNonLazyError?.(errOrCloseEvent2);
                        }
                    }
                }
            })();
        }
        function subscribe(payload, sink) {
            const id = generateID(payload);
            let done = false, errored = false, releaser = ()=>{
                locks--;
                done = true;
            };
            (async ()=>{
                locks++;
                for(;;){
                    try {
                        const [socket, release, waitForReleaseOrThrowOnClose] = await connect();
                        if (done) return release();
                        const unlisten = emitter.onMessage(id, (message)=>{
                            switch(message.type){
                                case MessageType.Next:
                                    {
                                        sink.next(message.payload);
                                        return;
                                    }
                                case MessageType.Error:
                                    {
                                        errored = true, done = true;
                                        sink.error(message.payload);
                                        releaser();
                                        return;
                                    }
                                case MessageType.Complete:
                                    {
                                        done = true;
                                        releaser();
                                        return;
                                    }
                            }
                        });
                        socket.send(stringifyMessage({
                            id,
                            type: MessageType.Subscribe,
                            payload
                        }, replacer));
                        releaser = ()=>{
                            if (!done && socket.readyState === WebSocketImpl.OPEN) socket.send(stringifyMessage({
                                id,
                                type: MessageType.Complete
                            }, replacer));
                            locks--;
                            done = true;
                            release();
                        };
                        await waitForReleaseOrThrowOnClose.finally(unlisten);
                        return;
                    } catch (errOrCloseEvent) {
                        if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;
                    }
                }
            })().then(()=>{
                if (!errored) sink.complete();
            }).catch((err)=>{
                sink.error(err);
            });
            return ()=>{
                if (!done) releaser();
            };
        }
        return {
            on: emitter.on,
            subscribe,
            iterate (request) {
                const pending = [];
                const deferred = {
                    done: false,
                    error: null,
                    resolve: ()=>{}
                };
                const dispose = subscribe(request, {
                    next (val) {
                        pending.push(val);
                        deferred.resolve();
                    },
                    error (err) {
                        deferred.done = true;
                        deferred.error = err;
                        deferred.resolve();
                    },
                    complete () {
                        deferred.done = true;
                        deferred.resolve();
                    }
                });
                const iterator = async function* iterator2() {
                    for(;;){
                        if (!pending.length) {
                            await new Promise((resolve)=>deferred.resolve = resolve);
                        }
                        while(pending.length){
                            yield pending.shift();
                        }
                        if (deferred.error) {
                            throw deferred.error;
                        }
                        if (deferred.done) {
                            return;
                        }
                    }
                }();
                iterator.throw = async (err)=>{
                    if (!deferred.done) {
                        deferred.done = true;
                        deferred.error = err;
                        deferred.resolve();
                    }
                    return {
                        done: true,
                        value: void 0
                    };
                };
                iterator.return = async ()=>{
                    dispose();
                    return {
                        done: true,
                        value: void 0
                    };
                };
                return iterator;
            },
            async dispose () {
                disposed = true;
                if (connecting) {
                    const [socket] = await connecting;
                    socket.close(1e3, "Normal Closure");
                }
            },
            terminate () {
                if (connecting) {
                    emitter.emit("closed", new TerminatedCloseEvent());
                }
            }
        };
    }
    class TerminatedCloseEvent extends Error {
        name = "TerminatedCloseEvent";
        message = "4499: Terminated";
        code = 4499;
        reason = "Terminated";
        wasClean = false;
    }
    function isLikeCloseEvent(val) {
        return isObject(val) && "code" in val && "reason" in val;
    }
    function isFatalInternalCloseCode(code) {
        if ([
            1e3,
            1001,
            1006,
            1005,
            1012,
            1013,
            1014
        ].includes(code)) return false;
        return code >= 1e3 && code <= 1999;
    }
    function isWebSocket(val) {
        return typeof val === "function" && "constructor" in val && "CLOSED" in val && "CLOSING" in val && "CONNECTING" in val && "OPEN" in val;
    }
    if (typeof WebSocket !== 'undefined') ;
    else if (typeof MozWebSocket !== 'undefined') {
        MozWebSocket;
    } else ;
    const __vite__wasmUrl = "/assets/midnight_zswap_wasm_bg-B513wwf3.wasm";
    let wasm$1;
    function __wbg_set_wasm(val) {
        wasm$1 = val;
    }
    let WASM_VECTOR_LEN = 0;
    let cachedUint8ArrayMemory0 = null;
    function getUint8ArrayMemory0() {
        if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
            cachedUint8ArrayMemory0 = new Uint8Array(wasm$1.memory.buffer);
        }
        return cachedUint8ArrayMemory0;
    }
    const lTextEncoder = typeof TextEncoder === 'undefined' ? (commonjsRequire)('util').TextEncoder : TextEncoder;
    let cachedTextEncoder = new lTextEncoder('utf-8');
    const encodeString = (typeof cachedTextEncoder.encodeInto === 'function' ? function(arg, view) {
        return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
        const buf = cachedTextEncoder.encode(arg);
        view.set(buf);
        return {
            read: arg.length,
            written: buf.length
        };
    });
    function passStringToWasm0(arg, malloc, realloc) {
        if (realloc === undefined) {
            const buf = cachedTextEncoder.encode(arg);
            const ptr = malloc(buf.length, 1) >>> 0;
            getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
            WASM_VECTOR_LEN = buf.length;
            return ptr;
        }
        let len = arg.length;
        let ptr = malloc(len, 1) >>> 0;
        const mem = getUint8ArrayMemory0();
        let offset = 0;
        for(; offset < len; offset++){
            const code = arg.charCodeAt(offset);
            if (code > 0x7F) break;
            mem[ptr + offset] = code;
        }
        if (offset !== len) {
            if (offset !== 0) {
                arg = arg.slice(offset);
            }
            ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
            const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
            const ret = encodeString(arg, view);
            offset += ret.written;
            ptr = realloc(ptr, len, offset, 1) >>> 0;
        }
        WASM_VECTOR_LEN = offset;
        return ptr;
    }
    let cachedDataViewMemory0 = null;
    function getDataViewMemory0() {
        if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm$1.memory.buffer)) {
            cachedDataViewMemory0 = new DataView(wasm$1.memory.buffer);
        }
        return cachedDataViewMemory0;
    }
    function addToExternrefTable0(obj) {
        const idx = wasm$1.__externref_table_alloc();
        wasm$1.__wbindgen_export_4.set(idx, obj);
        return idx;
    }
    function handleError(f, args) {
        try {
            return f.apply(this, args);
        } catch (e) {
            const idx = addToExternrefTable0(e);
            wasm$1.__wbindgen_exn_store(idx);
        }
    }
    function isLikeNone(x) {
        return x === undefined || x === null;
    }
    const lTextDecoder = typeof TextDecoder === 'undefined' ? (commonjsRequire)('util').TextDecoder : TextDecoder;
    let cachedTextDecoder = new lTextDecoder('utf-8', {
        ignoreBOM: true,
        fatal: true
    });
    cachedTextDecoder.decode();
    function getStringFromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
    }
    const CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((state)=>{
        wasm$1.__wbindgen_export_5.get(state.dtor)(state.a, state.b);
    });
    function makeMutClosure(arg0, arg1, dtor, f) {
        const state = {
            a: arg0,
            b: arg1,
            cnt: 1,
            dtor
        };
        const real = (...args)=>{
            state.cnt++;
            const a = state.a;
            state.a = 0;
            try {
                return f(a, state.b, ...args);
            } finally{
                if (--state.cnt === 0) {
                    wasm$1.__wbindgen_export_5.get(state.dtor)(a, state.b);
                    CLOSURE_DTORS.unregister(state);
                } else {
                    state.a = a;
                }
            }
        };
        real.original = state;
        CLOSURE_DTORS.register(real, state, state);
        return real;
    }
    function debugString(val) {
        const type = typeof val;
        if (type == 'number' || type == 'boolean' || val == null) {
            return `${val}`;
        }
        if (type == 'string') {
            return `"${val}"`;
        }
        if (type == 'symbol') {
            const description = val.description;
            if (description == null) {
                return 'Symbol';
            } else {
                return `Symbol(${description})`;
            }
        }
        if (type == 'function') {
            const name = val.name;
            if (typeof name == 'string' && name.length > 0) {
                return `Function(${name})`;
            } else {
                return 'Function';
            }
        }
        if (Array.isArray(val)) {
            const length = val.length;
            let debug = '[';
            if (length > 0) {
                debug += debugString(val[0]);
            }
            for(let i = 1; i < length; i++){
                debug += ', ' + debugString(val[i]);
            }
            debug += ']';
            return debug;
        }
        const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
        let className;
        if (builtInMatches && builtInMatches.length > 1) {
            className = builtInMatches[1];
        } else {
            return toString.call(val);
        }
        if (className == 'Object') {
            try {
                return 'Object(' + JSON.stringify(val) + ')';
            } catch (_) {
                return 'Object';
            }
        }
        if (val instanceof Error) {
            return `${val.name}: ${val.message}\n${val.stack}`;
        }
        return className;
    }
    function takeFromExternrefTable0(idx) {
        const value = wasm$1.__wbindgen_export_4.get(idx);
        wasm$1.__externref_table_dealloc(idx);
        return value;
    }
    function _assertClass(instance, klass) {
        if (!(instance instanceof klass)) {
            throw new Error(`expected instance of ${klass.name}`);
        }
    }
    function getArrayU8FromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
    }
    function passArray8ToWasm0(arg, malloc) {
        const ptr = malloc(arg.length * 1, 1) >>> 0;
        getUint8ArrayMemory0().set(arg, ptr / 1);
        WASM_VECTOR_LEN = arg.length;
        return ptr;
    }
    function getArrayJsValueFromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        const mem = getDataViewMemory0();
        const result = [];
        for(let i = ptr; i < ptr + 4 * len; i += 4){
            result.push(wasm$1.__wbindgen_export_4.get(mem.getUint32(i, true)));
        }
        wasm$1.__externref_drop_slice(ptr, len);
        return result;
    }
    function __wbg_adapter_56(arg0, arg1, arg2) {
        wasm$1.closure648_externref_shim(arg0, arg1, arg2);
    }
    function __wbg_adapter_389(arg0, arg1, arg2, arg3, arg4) {
        wasm$1.closure684_externref_shim(arg0, arg1, arg2, arg3, arg4);
    }
    function __wbg_adapter_394(arg0, arg1, arg2, arg3) {
        wasm$1.closure688_externref_shim(arg0, arg1, arg2, arg3);
    }
    const AuthorizedMintFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_authorizedmint_free(ptr >>> 0, 1));
    class AuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(AuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            AuthorizedMintFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            AuthorizedMintFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_authorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.authorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            AuthorizedMintFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.authorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.authorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return AuthorizedMint.__wrap(ret[0]);
        }
        eraseProof() {
            const ret = wasm$1.authorizedmint_eraseProof(this.__wbg_ptr);
            return ProofErasedAuthorizedMint.__wrap(ret);
        }
        get coin() {
            const ret = wasm$1.authorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.authorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.authorizedmint_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const CoinSecretKeyFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_coinsecretkey_free(ptr >>> 0, 1));
    class CoinSecretKey {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(CoinSecretKey.prototype);
            obj.__wbg_ptr = ptr;
            CoinSecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            CoinSecretKeyFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_coinsecretkey_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.coinsecretkey_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            CoinSecretKeyFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        yesIKnowTheSecurityImplicationsOfThis_serialize(netid) {
            const ret = wasm$1.coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
    }
    const ContractAddressFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_contractaddress_free(ptr >>> 0, 1));
    class ContractAddress {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ContractAddress.prototype);
            obj.__wbg_ptr = ptr;
            ContractAddressFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ContractAddressFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_contractaddress_free(ptr, 0);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0(raw, wasm$1.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.contractaddress_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ContractAddress.__wrap(ret[0]);
        }
    }
    const EncryptionSecretKeyFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_encryptionsecretkey_free(ptr >>> 0, 1));
    class EncryptionSecretKey {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(EncryptionSecretKey.prototype);
            obj.__wbg_ptr = ptr;
            EncryptionSecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            EncryptionSecretKeyFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_encryptionsecretkey_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.encryptionsecretkey_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            EncryptionSecretKeyFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        test(offer) {
            _assertClass(offer, Offer);
            const ret = wasm$1.encryptionsecretkey_test(this.__wbg_ptr, offer.__wbg_ptr);
            return ret !== 0;
        }
        yesIKnowTheSecurityImplicationsOfThis_serialize(netid) {
            const ret = wasm$1.encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.encryptionsecretkey_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return EncryptionSecretKey.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0(raw, wasm$1.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.encryptionsecretkey_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return EncryptionSecretKey.__wrap(ret[0]);
        }
    }
    const InputFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_input_free(ptr >>> 0, 1));
    class Input {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Input.prototype);
            obj.__wbg_ptr = ptr;
            InputFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            InputFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_input_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.input_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            InputFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.input_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.input_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Input.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.input_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.input_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.input_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$1.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$1.__wbg_intounderlyingsink_free(ptr >>> 0, 1));
    (typeof FinalizationRegistry === 'undefined') ? {} : new FinalizationRegistry((ptr)=>wasm$1.__wbg_intounderlyingsource_free(ptr >>> 0, 1));
    const LedgerParametersFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_ledgerparameters_free(ptr >>> 0, 1));
    class LedgerParameters {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(LedgerParameters.prototype);
            obj.__wbg_ptr = ptr;
            LedgerParametersFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            LedgerParametersFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_ledgerparameters_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.ledgerparameters_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            LedgerParametersFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static dummyParameters() {
            const ret = wasm$1.ledgerparameters_dummyParameters();
            return LedgerParameters.__wrap(ret);
        }
        get transactionCostModel() {
            const ret = wasm$1.ledgerparameters_transactionCostModel(this.__wbg_ptr);
            return TransactionCostModel.__wrap(ret);
        }
        serialize(netid) {
            const ret = wasm$1.ledgerparameters_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.ledgerparameters_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return LedgerParameters.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.ledgerparameters_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const LocalStateFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_localstate_free(ptr >>> 0, 1));
    class LocalState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(LocalState.prototype);
            obj.__wbg_ptr = ptr;
            LocalStateFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            LocalStateFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_localstate_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.localstate_new();
            this.__wbg_ptr = ret >>> 0;
            LocalStateFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        authorizeMint(secret_keys, coin) {
            _assertClass(secret_keys, SecretKeys);
            const ret = wasm$1.localstate_authorizeMint(this.__wbg_ptr, secret_keys.__wbg_ptr, coin);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenAuthorizedMint.__wrap(ret[0]);
        }
        get firstFree() {
            const ret = wasm$1.localstate_firstFree(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        get coins() {
            const ret = wasm$1.localstate_coins(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        get pendingSpends() {
            const ret = wasm$1.localstate_pendingSpends(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        get pendingOutputs() {
            const ret = wasm$1.localstate_pendingOutputs(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        applyMint(secret_keys, mint) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(mint, AuthorizedMint);
            const ret = wasm$1.localstate_applyMint(this.__wbg_ptr, secret_keys.__wbg_ptr, mint.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyProofErasedMint(secret_keys, mint) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(mint, ProofErasedAuthorizedMint);
            const ret = wasm$1.localstate_applyProofErasedMint(this.__wbg_ptr, secret_keys.__wbg_ptr, mint.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyFailed(offer) {
            _assertClass(offer, Offer);
            const ret = wasm$1.localstate_applyFailed(this.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyFailedProofErased(offer) {
            _assertClass(offer, ProofErasedOffer);
            const ret = wasm$1.localstate_applyFailedProofErased(this.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        apply(secret_keys, offer) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(offer, Offer);
            const ret = wasm$1.localstate_apply(this.__wbg_ptr, secret_keys.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyProofErased(secret_keys, offer) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(offer, ProofErasedOffer);
            const ret = wasm$1.localstate_applyProofErased(this.__wbg_ptr, secret_keys.__wbg_ptr, offer.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyTx(secret_keys, tx, res) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(tx, Transaction);
            const ptr0 = passStringToWasm0(res, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.localstate_applyTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        applyProofErasedTx(secret_keys, tx, res) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(tx, ProofErasedTransaction);
            const ptr0 = passStringToWasm0(res, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.localstate_applyProofErasedTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        applySystemTx(secret_keys, tx) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(tx, SystemTransaction);
            const ret = wasm$1.localstate_applySystemTx(this.__wbg_ptr, secret_keys.__wbg_ptr, tx.__wbg_ptr);
            return LocalState.__wrap(ret);
        }
        applyCollapsedUpdate(update) {
            _assertClass(update, MerkleTreeCollapsedUpdate);
            const ret = wasm$1.localstate_applyCollapsedUpdate(this.__wbg_ptr, update.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        spend(secret_keys, coin, segment) {
            _assertClass(secret_keys, SecretKeys);
            const ret = wasm$1.localstate_spend(this.__wbg_ptr, secret_keys.__wbg_ptr, coin, segment);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        spendFromOutput(secret_keys, coin, segment, output) {
            _assertClass(secret_keys, SecretKeys);
            _assertClass(output, UnprovenOutput);
            const ret = wasm$1.localstate_spendFromOutput(this.__wbg_ptr, secret_keys.__wbg_ptr, coin, segment, output.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        watchFor(coin_public_key, coin) {
            const ptr0 = passStringToWasm0(coin_public_key, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.localstate_watchFor(this.__wbg_ptr, ptr0, len0, coin);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.localstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.localstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return LocalState.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.localstate_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const MerkleTreeCollapsedUpdateFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_merkletreecollapsedupdate_free(ptr >>> 0, 1));
    class MerkleTreeCollapsedUpdate {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(MerkleTreeCollapsedUpdate.prototype);
            obj.__wbg_ptr = ptr;
            MerkleTreeCollapsedUpdateFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            MerkleTreeCollapsedUpdateFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_merkletreecollapsedupdate_free(ptr, 0);
        }
        constructor(state, start, end){
            _assertClass(state, ZswapChainState);
            const ret = wasm$1.merkletreecollapsedupdate_new(state.__wbg_ptr, start, end);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            MerkleTreeCollapsedUpdateFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static new_raw(state, start, end) {
            _assertClass(state, ZswapChainState);
            const ret = wasm$1.merkletreecollapsedupdate_new_raw(state.__wbg_ptr, start, end);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return MerkleTreeCollapsedUpdate.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.merkletreecollapsedupdate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        serialize_raw(netid) {
            const ret = wasm$1.merkletreecollapsedupdate_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.merkletreecollapsedupdate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return MerkleTreeCollapsedUpdate.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.merkletreecollapsedupdate_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const OfferFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_offer_free(ptr >>> 0, 1));
    class Offer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Offer.prototype);
            obj.__wbg_ptr = ptr;
            OfferFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            OfferFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_offer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.offer_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            OfferFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        merge(other) {
            _assertClass(other, Offer);
            const ret = wasm$1.offer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.offer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        serialize_raw(netid) {
            const ret = wasm$1.offer_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.offer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0(raw, wasm$1.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.offer_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Offer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$1.offer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$1.offer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$1.offer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$1.offer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.offer_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const OutputFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_output_free(ptr >>> 0, 1));
    class Output {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Output.prototype);
            obj.__wbg_ptr = ptr;
            OutputFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            OutputFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_output_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.output_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            OutputFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.output_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.output_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Output.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.output_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.output_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.output_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ProofErasedAuthorizedMintFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_prooferasedauthorizedmint_free(ptr >>> 0, 1));
    class ProofErasedAuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedAuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedAuthorizedMintFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedAuthorizedMintFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_prooferasedauthorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.prooferasedauthorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedAuthorizedMintFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.prooferasedauthorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.prooferasedauthorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedAuthorizedMint.__wrap(ret[0]);
        }
        get coin() {
            const ret = wasm$1.prooferasedauthorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.prooferasedauthorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.prooferasedauthorizedmint_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ProofErasedInputFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_prooferasedinput_free(ptr >>> 0, 1));
    class ProofErasedInput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedInput.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedInputFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedInputFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_prooferasedinput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.prooferasedinput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedInputFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.prooferasedinput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.prooferasedinput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedInput.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.prooferasedinput_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.prooferasedinput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.prooferasedinput_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ProofErasedOfferFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_prooferasedoffer_free(ptr >>> 0, 1));
    class ProofErasedOffer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedOffer.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedOfferFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedOfferFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_prooferasedoffer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.prooferasedoffer_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedOfferFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        merge(other) {
            _assertClass(other, ProofErasedOffer);
            const ret = wasm$1.prooferasedoffer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedOffer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.prooferasedoffer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.prooferasedoffer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedOffer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$1.prooferasedoffer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$1.prooferasedoffer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$1.prooferasedoffer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$1.prooferasedoffer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.prooferasedoffer_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ProofErasedOutputFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_prooferasedoutput_free(ptr >>> 0, 1));
    class ProofErasedOutput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedOutput.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedOutputFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedOutputFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_prooferasedoutput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.prooferasedoutput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedOutputFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.prooferasedoutput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.prooferasedoutput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedOutput.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.prooferasedoutput_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.prooferasedoutput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.prooferasedoutput_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ProofErasedTransactionFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_prooferasedtransaction_free(ptr >>> 0, 1));
    class ProofErasedTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedTransaction.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedTransactionFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedTransactionFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_prooferasedtransaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.prooferasedtransaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedTransactionFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get mint() {
            const ret = wasm$1.prooferasedtransaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedAuthorizedMint.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$1.prooferasedtransaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedOffer.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$1.prooferasedtransaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : ProofErasedOffer.__wrap(ret);
        }
        identifiers() {
            const ret = wasm$1.prooferasedtransaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass(other, ProofErasedTransaction);
            const ret = wasm$1.prooferasedtransaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedTransaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.prooferasedtransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.prooferasedtransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedTransaction.__wrap(ret[0]);
        }
        imbalances(guaranteed, fees) {
            const ret = wasm$1.prooferasedtransaction_imbalances(this.__wbg_ptr, guaranteed, !isLikeNone(fees), isLikeNone(fees) ? BigInt(0) : fees);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        fees(params) {
            _assertClass(params, LedgerParameters);
            const ret = wasm$1.prooferasedtransaction_fees(this.__wbg_ptr, params.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.prooferasedtransaction_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ProofErasedTransientFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_prooferasedtransient_free(ptr >>> 0, 1));
    class ProofErasedTransient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ProofErasedTransient.prototype);
            obj.__wbg_ptr = ptr;
            ProofErasedTransientFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ProofErasedTransientFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_prooferasedtransient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.prooferasedtransient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            ProofErasedTransientFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.prooferasedtransient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.prooferasedtransient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ProofErasedTransient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.prooferasedtransient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.prooferasedtransient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.prooferasedtransient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.prooferasedtransient_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const SecretKeysFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_secretkeys_free(ptr >>> 0, 1));
    class SecretKeys {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(SecretKeys.prototype);
            obj.__wbg_ptr = ptr;
            SecretKeysFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            SecretKeysFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_secretkeys_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.secretkeys_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            SecretKeysFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromSeed(seed) {
            const ret = wasm$1.secretkeys_fromSeed(seed);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return SecretKeys.__wrap(ret[0]);
        }
        static fromSeedRng(seed) {
            const ret = wasm$1.secretkeys_fromSeedRng(seed);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return SecretKeys.__wrap(ret[0]);
        }
        get coinPublicKey() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.secretkeys_coinPublicKey(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get encryptionPublicKey() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.secretkeys_encryptionPublicKey(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get encryptionSecretKey() {
            const ret = wasm$1.secretkeys_encryptionSecretKey(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return EncryptionSecretKey.__wrap(ret[0]);
        }
        get coinSecretKey() {
            const ret = wasm$1.secretkeys_coinSecretKey(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return CoinSecretKey.__wrap(ret[0]);
        }
    }
    const SystemTransactionFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_systemtransaction_free(ptr >>> 0, 1));
    class SystemTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(SystemTransaction.prototype);
            obj.__wbg_ptr = ptr;
            SystemTransactionFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            SystemTransactionFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_systemtransaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.systemtransaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            SystemTransactionFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.systemtransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.systemtransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return SystemTransaction.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.systemtransaction_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const TransactionFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_transaction_free(ptr >>> 0, 1));
    class Transaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Transaction.prototype);
            obj.__wbg_ptr = ptr;
            TransactionFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_transaction_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.transaction_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromUnproven(prove, unproven) {
            _assertClass(unproven, UnprovenTransaction);
            const ret = wasm$1.transaction_fromUnproven(prove, unproven.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        eraseProofs() {
            const ret = wasm$1.transaction_eraseProofs(this.__wbg_ptr);
            return ProofErasedTransaction.__wrap(ret);
        }
        get mint() {
            const ret = wasm$1.transaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : AuthorizedMint.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$1.transaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : Offer.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$1.transaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : Offer.__wrap(ret);
        }
        transactionHash() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.transaction_transactionHash(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        identifiers() {
            const ret = wasm$1.transaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass(other, Transaction);
            const ret = wasm$1.transaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Transaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.transaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.transaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Transaction.__wrap(ret[0]);
        }
        imbalances(guaranteed, fees) {
            const ret = wasm$1.transaction_imbalances(this.__wbg_ptr, guaranteed, isLikeNone(fees) ? 0 : addToExternrefTable0(fees));
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        fees(params) {
            _assertClass(params, LedgerParameters);
            const ret = wasm$1.transaction_fees(this.__wbg_ptr, params.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.transaction_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const TransactionCostModelFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_transactioncostmodel_free(ptr >>> 0, 1));
    class TransactionCostModel {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(TransactionCostModel.prototype);
            obj.__wbg_ptr = ptr;
            TransactionCostModelFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransactionCostModelFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_transactioncostmodel_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.transactioncostmodel_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransactionCostModelFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static dummyTransactionCostModel() {
            const ret = wasm$1.transactioncostmodel_dummyTransactionCostModel();
            return TransactionCostModel.__wrap(ret);
        }
        get inputFeeOverhead() {
            const ret = wasm$1.transactioncostmodel_inputFeeOverhead(this.__wbg_ptr);
            return ret;
        }
        get outputFeeOverhead() {
            const ret = wasm$1.transactioncostmodel_outputFeeOverhead(this.__wbg_ptr);
            return ret;
        }
        serialize(netid) {
            const ret = wasm$1.transactioncostmodel_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.transactioncostmodel_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return TransactionCostModel.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.transactioncostmodel_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const TransientFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_transient_free(ptr >>> 0, 1));
    class Transient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(Transient.prototype);
            obj.__wbg_ptr = ptr;
            TransientFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            TransientFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_transient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.transient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            TransientFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.transient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.transient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return Transient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.transient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.transient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.transient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.transient_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const UnprovenAuthorizedMintFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_unprovenauthorizedmint_free(ptr >>> 0, 1));
    class UnprovenAuthorizedMint {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenAuthorizedMint.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenAuthorizedMintFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenAuthorizedMintFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_unprovenauthorizedmint_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.unprovenauthorizedmint_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenAuthorizedMintFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        serialize(netid) {
            const ret = wasm$1.unprovenauthorizedmint_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.unprovenauthorizedmint_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenAuthorizedMint.__wrap(ret[0]);
        }
        eraseProof() {
            const ret = wasm$1.authorizedmint_eraseProof(this.__wbg_ptr);
            return ProofErasedAuthorizedMint.__wrap(ret);
        }
        get coin() {
            const ret = wasm$1.unprovenauthorizedmint_coin(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        get recipient() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.unprovenauthorizedmint_recipient(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.unprovenauthorizedmint_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const UnprovenInputFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_unproveninput_free(ptr >>> 0, 1));
    class UnprovenInput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenInput.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenInputFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenInputFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_unproveninput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.unproveninput_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenInputFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static newContractOwned(coin, segment, contract, state) {
            const ptr0 = passStringToWasm0(contract, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(state, ZswapChainState);
            const ret = wasm$1.unproveninput_newContractOwned(coin, segment, ptr0, len0, state.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenInput.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.unproveninput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.unproveninput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenInput.__wrap(ret[0]);
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.unproveninput_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.unproveninput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.unproveninput_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const UnprovenOfferFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_unprovenoffer_free(ptr >>> 0, 1));
    class UnprovenOffer {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenOffer.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenOfferFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenOfferFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_unprovenoffer_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.unprovenoffer_new();
            this.__wbg_ptr = ret >>> 0;
            UnprovenOfferFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromInput(input, type_, value) {
            _assertClass(input, UnprovenInput);
            const ptr0 = passStringToWasm0(type_, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.unprovenoffer_fromInput(input.__wbg_ptr, ptr0, len0, value);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        static fromOutput(output, type_, value) {
            _assertClass(output, UnprovenOutput);
            const ptr0 = passStringToWasm0(type_, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.unprovenoffer_fromOutput(output.__wbg_ptr, ptr0, len0, value);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        static fromTransient(transient) {
            _assertClass(transient, UnprovenTransient);
            const ret = wasm$1.unprovenoffer_fromTransient(transient.__wbg_ptr);
            return UnprovenOffer.__wrap(ret);
        }
        merge(other) {
            _assertClass(other, UnprovenOffer);
            const ret = wasm$1.unprovenoffer_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.unprovenoffer_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.unprovenoffer_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenOffer.__wrap(ret[0]);
        }
        get inputs() {
            const ret = wasm$1.unprovenoffer_inputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get outputs() {
            const ret = wasm$1.unprovenoffer_outputs(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get transient() {
            const ret = wasm$1.unprovenoffer_transient(this.__wbg_ptr);
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        get deltas() {
            const ret = wasm$1.unprovenoffer_deltas(this.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.unprovenoffer_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const UnprovenOutputFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_unprovenoutput_free(ptr >>> 0, 1));
    class UnprovenOutput {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenOutput.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenOutputFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenOutputFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_unprovenoutput_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.unprovenoutput_construct();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenOutputFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static new(coin, segment, target_cpk, target_epk) {
            const ptr0 = passStringToWasm0(target_cpk, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(target_epk, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            const ret = wasm$1.unprovenoutput_new(coin, segment, ptr0, len0, ptr1, len1);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        static newContractOwned(coin, segment, contract) {
            const ptr0 = passStringToWasm0(contract, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.unprovenoutput_newContractOwned(coin, segment, ptr0, len0);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.unprovenoutput_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.unprovenoutput_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenOutput.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.unprovenoutput_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.unprovenoutput_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.unprovenoutput_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const UnprovenTransactionFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_unproventransaction_free(ptr >>> 0, 1));
    class UnprovenTransaction {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenTransaction.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenTransactionFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenTransactionFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_unproventransaction_free(ptr, 0);
        }
        constructor(guaranteed, fallible){
            _assertClass(guaranteed, UnprovenOffer);
            const ret = wasm$1.unproventransaction_new(guaranteed.__wbg_ptr, fallible);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenTransactionFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static fromMint(mint) {
            _assertClass(mint, UnprovenAuthorizedMint);
            const ret = wasm$1.unproventransaction_fromMint(mint.__wbg_ptr);
            return UnprovenTransaction.__wrap(ret);
        }
        eraseProofs() {
            const ret = wasm$1.unproventransaction_eraseProofs(this.__wbg_ptr);
            return ProofErasedTransaction.__wrap(ret);
        }
        get mint() {
            const ret = wasm$1.unproventransaction_mint(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenAuthorizedMint.__wrap(ret);
        }
        get guaranteedCoins() {
            const ret = wasm$1.unproventransaction_guaranteedCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenOffer.__wrap(ret);
        }
        get fallibleCoins() {
            const ret = wasm$1.unproventransaction_fallibleCoins(this.__wbg_ptr);
            return ret === 0 ? undefined : UnprovenOffer.__wrap(ret);
        }
        identifiers() {
            const ret = wasm$1.unproventransaction_identifiers(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 4, 4);
            return v1;
        }
        merge(other) {
            _assertClass(other, UnprovenTransaction);
            const ret = wasm$1.unproventransaction_merge(this.__wbg_ptr, other.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenTransaction.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.unproventransaction_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.unproventransaction_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenTransaction.__wrap(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.unproventransaction_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const UnprovenTransientFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_unproventransient_free(ptr >>> 0, 1));
    class UnprovenTransient {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(UnprovenTransient.prototype);
            obj.__wbg_ptr = ptr;
            UnprovenTransientFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            UnprovenTransientFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_unproventransient_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.unproventransient_new();
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            this.__wbg_ptr = ret[0] >>> 0;
            UnprovenTransientFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        static newFromContractOwnedOutput(coin, segment, output) {
            _assertClass(output, UnprovenOutput);
            const ret = wasm$1.unproventransient_newFromContractOwnedOutput(coin, segment, output.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenTransient.__wrap(ret[0]);
        }
        serialize(netid) {
            const ret = wasm$1.unproventransient_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.unproventransient_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return UnprovenTransient.__wrap(ret[0]);
        }
        get commitment() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.unproventransient_commitment(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get nullifier() {
            let deferred2_0;
            let deferred2_1;
            try {
                const ret = wasm$1.unproventransient_nullifier(this.__wbg_ptr);
                var ptr1 = ret[0];
                var len1 = ret[1];
                if (ret[3]) {
                    ptr1 = 0;
                    len1 = 0;
                    throw takeFromExternrefTable0(ret[2]);
                }
                deferred2_0 = ptr1;
                deferred2_1 = len1;
                return getStringFromWasm0(ptr1, len1);
            } finally{
                wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
            }
        }
        get contractAddress() {
            const ret = wasm$1.unproventransient_contractAddress(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            let v1;
            if (ret[0] !== 0) {
                v1 = getStringFromWasm0(ret[0], ret[1]).slice();
                wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            }
            return v1;
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.unproventransient_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    const ZswapChainStateFinalization = (typeof FinalizationRegistry === 'undefined') ? {
        register: ()=>{},
        unregister: ()=>{}
    } : new FinalizationRegistry((ptr)=>wasm$1.__wbg_zswapchainstate_free(ptr >>> 0, 1));
    class ZswapChainState {
        static __wrap(ptr) {
            ptr = ptr >>> 0;
            const obj = Object.create(ZswapChainState.prototype);
            obj.__wbg_ptr = ptr;
            ZswapChainStateFinalization.register(obj, obj.__wbg_ptr, obj);
            return obj;
        }
        __destroy_into_raw() {
            const ptr = this.__wbg_ptr;
            this.__wbg_ptr = 0;
            ZswapChainStateFinalization.unregister(this);
            return ptr;
        }
        free() {
            const ptr = this.__destroy_into_raw();
            wasm$1.__wbg_zswapchainstate_free(ptr, 0);
        }
        constructor(){
            const ret = wasm$1.zswapchainstate_new();
            this.__wbg_ptr = ret >>> 0;
            ZswapChainStateFinalization.register(this, this.__wbg_ptr, this);
            return this;
        }
        get firstFree() {
            const ret = wasm$1.localstate_firstFree(this.__wbg_ptr);
            return BigInt.asUintN(64, ret);
        }
        serialize_raw(netid) {
            const ret = wasm$1.zswapchainstate_serialize_raw(this.__wbg_ptr, netid);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        filter(contract_address) {
            _assertClass(contract_address, ContractAddress);
            var ptr0 = contract_address.__destroy_into_raw();
            const ret = wasm$1.zswapchainstate_filter(this.__wbg_ptr, ptr0);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        merkle_tree_root() {
            const ret = wasm$1.zswapchainstate_merkle_tree_root(this.__wbg_ptr);
            if (ret[3]) {
                throw takeFromExternrefTable0(ret[2]);
            }
            var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
            wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
            return v1;
        }
        serialize(netid) {
            const ret = wasm$1.zswapchainstate_serialize(this.__wbg_ptr, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        static deserialize(raw, netid) {
            const ret = wasm$1.zswapchainstate_deserialize(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        static deserialize_raw(raw, netid) {
            const ptr0 = passArray8ToWasm0(raw, wasm$1.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ret = wasm$1.zswapchainstate_deserialize_raw(ptr0, len0, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        static deserializeFromLedgerState(raw, netid) {
            const ret = wasm$1.zswapchainstate_deserializeFromLedgerState(raw, netid);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        tryApply(offer, whitelist) {
            _assertClass(offer, Offer);
            const ret = wasm$1.zswapchainstate_tryApply(this.__wbg_ptr, offer.__wbg_ptr, whitelist);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        tryApplyWithoutWhitelist(offer) {
            _assertClass(offer, Offer);
            const ret = wasm$1.zswapchainstate_tryApplyWithoutWhitelist(this.__wbg_ptr, offer.__wbg_ptr);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return ZswapChainState.__wrap(ret[0]);
        }
        tryApplyProofErased(offer, whitelist) {
            _assertClass(offer, ProofErasedOffer);
            const ret = wasm$1.zswapchainstate_tryApplyProofErased(this.__wbg_ptr, offer.__wbg_ptr, whitelist);
            if (ret[2]) {
                throw takeFromExternrefTable0(ret[1]);
            }
            return takeFromExternrefTable0(ret[0]);
        }
        toString(compact) {
            let deferred1_0;
            let deferred1_1;
            try {
                const ret = wasm$1.zswapchainstate_toString(this.__wbg_ptr, isLikeNone(compact) ? 0xFFFFFF : compact ? 1 : 0);
                deferred1_0 = ret[0];
                deferred1_1 = ret[1];
                return getStringFromWasm0(ret[0], ret[1]);
            } finally{
                wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
            }
        }
    }
    function __wbg_String_fed4d24b68977888(arg0, arg1) {
        const ret = String(arg1);
        const ptr1 = passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbg_add_883d9432f9188ef2(arg0, arg1) {
        const ret = arg0.add(arg1);
        return ret;
    }
    function __wbg_apply_36be6a55257c99bf() {
        return handleError(function(arg0, arg1, arg2) {
            const ret = arg0.apply(arg1, arg2);
            return ret;
        }, arguments);
    }
    function __wbg_buffer_09165b52af8c5237(arg0) {
        const ret = arg0.buffer;
        return ret;
    }
    function __wbg_buffer_609cc3eee51ed158(arg0) {
        const ret = arg0.buffer;
        return ret;
    }
    function __wbg_byobRequest_77d9adf63337edfb(arg0) {
        const ret = arg0.byobRequest;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }
    function __wbg_byteLength_e674b853d9c77e1d(arg0) {
        const ret = arg0.byteLength;
        return ret;
    }
    function __wbg_byteOffset_fd862df290ef848d(arg0) {
        const ret = arg0.byteOffset;
        return ret;
    }
    function __wbg_call_672a4d21634d4a24() {
        return handleError(function(arg0, arg1) {
            const ret = arg0.call(arg1);
            return ret;
        }, arguments);
    }
    function __wbg_call_7cccdd69e0791ae2() {
        return handleError(function(arg0, arg1, arg2) {
            const ret = arg0.call(arg1, arg2);
            return ret;
        }, arguments);
    }
    function __wbg_close_304cc1fef3466669() {
        return handleError(function(arg0) {
            arg0.close();
        }, arguments);
    }
    function __wbg_close_5ce03e29be453811() {
        return handleError(function(arg0) {
            arg0.close();
        }, arguments);
    }
    function __wbg_crypto_574e78ad8b13b65f(arg0) {
        const ret = arg0.crypto;
        return ret;
    }
    function __wbg_enqueue_bb16ba72f537dc9e() {
        return handleError(function(arg0, arg1) {
            arg0.enqueue(arg1);
        }, arguments);
    }
    function __wbg_forEach_432d981ecbee7d69(arg0, arg1, arg2) {
        try {
            var state0 = {
                a: arg1,
                b: arg2
            };
            var cb0 = (arg0, arg1, arg2)=>{
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_389(a, state0.b, arg0, arg1, arg2);
                } finally{
                    state0.a = a;
                }
            };
            arg0.forEach(cb0);
        } finally{
            state0.a = state0.b = 0;
        }
    }
    function __wbg_getPrototypeOf_08aaacea7e300a38() {
        return handleError(function(arg0) {
            const ret = Reflect.getPrototypeOf(arg0);
            return ret;
        }, arguments);
    }
    function __wbg_getRandomValues_b8f5dbd5f3995a9e() {
        return handleError(function(arg0, arg1) {
            arg0.getRandomValues(arg1);
        }, arguments);
    }
    function __wbg_get_67b2ba62fc30de12() {
        return handleError(function(arg0, arg1) {
            const ret = Reflect.get(arg0, arg1);
            return ret;
        }, arguments);
    }
    function __wbg_getwithrefkey_bb8f74a92cb2e784(arg0, arg1) {
        const ret = arg0[arg1];
        return ret;
    }
    function __wbg_input_new(arg0) {
        const ret = Input.__wrap(arg0);
        return ret;
    }
    function __wbg_instanceof_ArrayBuffer_e14585432e3737fc(arg0) {
        let result;
        try {
            result = arg0 instanceof ArrayBuffer;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_instanceof_Set_f48781e4bf8ffb09(arg0) {
        let result;
        try {
            result = arg0 instanceof Set;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_instanceof_Uint8Array_17156bcf118086a9(arg0) {
        let result;
        try {
            result = arg0 instanceof Uint8Array;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    }
    function __wbg_isSafeInteger_343e2beeeece1bb0(arg0) {
        const ret = Number.isSafeInteger(arg0);
        return ret;
    }
    function __wbg_length_a446193dc22c12f8(arg0) {
        const ret = arg0.length;
        return ret;
    }
    function __wbg_localstate_new(arg0) {
        const ret = LocalState.__wrap(arg0);
        return ret;
    }
    function __wbg_msCrypto_a61aeb35a24c1329(arg0) {
        const ret = arg0.msCrypto;
        return ret;
    }
    function __wbg_new_23a2665fac83c611(arg0, arg1) {
        try {
            var state0 = {
                a: arg0,
                b: arg1
            };
            var cb0 = (arg0, arg1)=>{
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_394(a, state0.b, arg0, arg1);
                } finally{
                    state0.a = a;
                }
            };
            const ret = new Promise(cb0);
            return ret;
        } finally{
            state0.a = state0.b = 0;
        }
    }
    function __wbg_new_405e22f390576ce2() {
        const ret = new Object();
        return ret;
    }
    function __wbg_new_5e0be73521bc8c17() {
        const ret = new Map();
        return ret;
    }
    function __wbg_new_78feb108b6472713() {
        const ret = new Array();
        return ret;
    }
    function __wbg_new_a12002a7f91c75be(arg0) {
        const ret = new Uint8Array(arg0);
        return ret;
    }
    function __wbg_new_a239edaa1dc2968f(arg0) {
        const ret = new Set(arg0);
        return ret;
    }
    function __wbg_new_c68d7209be747379(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return ret;
    }
    function __wbg_newnoargs_105ed471475aaf50(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return ret;
    }
    function __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a(arg0, arg1, arg2) {
        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
        return ret;
    }
    function __wbg_newwithlength_a381634e90c276d4(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return ret;
    }
    function __wbg_node_905d3e251edff8a2(arg0) {
        const ret = arg0.node;
        return ret;
    }
    function __wbg_output_new(arg0) {
        const ret = Output.__wrap(arg0);
        return ret;
    }
    function __wbg_process_dc0fbacc7c1c06f7(arg0) {
        const ret = arg0.process;
        return ret;
    }
    function __wbg_prooferasedinput_new(arg0) {
        const ret = ProofErasedInput.__wrap(arg0);
        return ret;
    }
    function __wbg_prooferasedoutput_new(arg0) {
        const ret = ProofErasedOutput.__wrap(arg0);
        return ret;
    }
    function __wbg_prooferasedtransient_new(arg0) {
        const ret = ProofErasedTransient.__wrap(arg0);
        return ret;
    }
    function __wbg_push_737cfc8c1432c2c6(arg0, arg1) {
        const ret = arg0.push(arg1);
        return ret;
    }
    function __wbg_queueMicrotask_97d92b4fcc8a61c5(arg0) {
        queueMicrotask(arg0);
    }
    function __wbg_queueMicrotask_d3219def82552485(arg0) {
        const ret = arg0.queueMicrotask;
        return ret;
    }
    function __wbg_randomFillSync_ac0988aba3254290() {
        return handleError(function(arg0, arg1) {
            arg0.randomFillSync(arg1);
        }, arguments);
    }
    function __wbg_require_60cc747a6bc5215a() {
        return handleError(function() {
            const ret = commonjsRequire;
            return ret;
        }, arguments);
    }
    function __wbg_resolve_4851785c9c5f573d(arg0) {
        const ret = Promise.resolve(arg0);
        return ret;
    }
    function __wbg_respond_1f279fa9f8edcb1c() {
        return handleError(function(arg0, arg1) {
            arg0.respond(arg1 >>> 0);
        }, arguments);
    }
    function __wbg_set_3fda3bac07393de4(arg0, arg1, arg2) {
        arg0[arg1] = arg2;
    }
    function __wbg_set_65595bdd868b3009(arg0, arg1, arg2) {
        arg0.set(arg1, arg2 >>> 0);
    }
    function __wbg_set_8fc6bf8a5b1071d1(arg0, arg1, arg2) {
        const ret = arg0.set(arg1, arg2);
        return ret;
    }
    function __wbg_static_accessor_GLOBAL_88a902d13a557d07() {
        const ret = typeof global === 'undefined' ? null : global;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }
    function __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }
    function __wbg_static_accessor_SELF_37c5d418e4bf5819() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }
    function __wbg_static_accessor_WINDOW_5de37043a91a9c40() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }
    function __wbg_subarray_aa9065fa9dc5df96(arg0, arg1, arg2) {
        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
        return ret;
    }
    function __wbg_then_44b73946d2fb3e7d(arg0, arg1) {
        const ret = arg0.then(arg1);
        return ret;
    }
    function __wbg_transient_new(arg0) {
        const ret = Transient.__wrap(arg0);
        return ret;
    }
    function __wbg_unproveninput_new(arg0) {
        const ret = UnprovenInput.__wrap(arg0);
        return ret;
    }
    function __wbg_unprovenoutput_new(arg0) {
        const ret = UnprovenOutput.__wrap(arg0);
        return ret;
    }
    function __wbg_unproventransaction_new(arg0) {
        const ret = UnprovenTransaction.__wrap(arg0);
        return ret;
    }
    function __wbg_unproventransient_new(arg0) {
        const ret = UnprovenTransient.__wrap(arg0);
        return ret;
    }
    function __wbg_versions_c01dfd4722a88165(arg0) {
        const ret = arg0.versions;
        return ret;
    }
    function __wbg_view_fd8a56e8983f448d(arg0) {
        const ret = arg0.view;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }
    function __wbg_zswapchainstate_new(arg0) {
        const ret = ZswapChainState.__wrap(arg0);
        return ret;
    }
    function __wbindgen_bigint_from_i128(arg0, arg1) {
        const ret = arg0 << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    }
    function __wbindgen_bigint_from_u128(arg0, arg1) {
        const ret = BigInt.asUintN(64, arg0) << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    }
    function __wbindgen_bigint_from_u64(arg0) {
        const ret = BigInt.asUintN(64, arg0);
        return ret;
    }
    function __wbindgen_bigint_get_as_i64(arg0, arg1) {
        const v = arg1;
        const ret = typeof (v) === 'bigint' ? v : undefined;
        getDataViewMemory0().setBigInt64(arg0 + 8 * 1, isLikeNone(ret) ? BigInt(0) : ret, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
    }
    function __wbindgen_boolean_get(arg0) {
        const v = arg0;
        const ret = typeof (v) === 'boolean' ? (v ? 1 : 0) : 2;
        return ret;
    }
    function __wbindgen_cb_drop(arg0) {
        const obj = arg0.original;
        if (obj.cnt-- == 1) {
            obj.a = 0;
            return true;
        }
        const ret = false;
        return ret;
    }
    function __wbindgen_closure_wrapper3626(arg0, arg1, arg2) {
        const ret = makeMutClosure(arg0, arg1, 649, __wbg_adapter_56);
        return ret;
    }
    function __wbindgen_debug_string(arg0, arg1) {
        const ret = debugString(arg1);
        const ptr1 = passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbindgen_error_new(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return ret;
    }
    function __wbindgen_in(arg0, arg1) {
        const ret = arg0 in arg1;
        return ret;
    }
    function __wbindgen_init_externref_table() {
        const table = wasm$1.__wbindgen_export_4;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
    }
    function __wbindgen_is_bigint(arg0) {
        const ret = typeof (arg0) === 'bigint';
        return ret;
    }
    function __wbindgen_is_function(arg0) {
        const ret = typeof (arg0) === 'function';
        return ret;
    }
    function __wbindgen_is_null(arg0) {
        const ret = arg0 === null;
        return ret;
    }
    function __wbindgen_is_object(arg0) {
        const val = arg0;
        const ret = typeof (val) === 'object' && val !== null;
        return ret;
    }
    function __wbindgen_is_string(arg0) {
        const ret = typeof (arg0) === 'string';
        return ret;
    }
    function __wbindgen_is_undefined(arg0) {
        const ret = arg0 === undefined;
        return ret;
    }
    function __wbindgen_jsval_eq(arg0, arg1) {
        const ret = arg0 === arg1;
        return ret;
    }
    function __wbindgen_jsval_loose_eq(arg0, arg1) {
        const ret = arg0 == arg1;
        return ret;
    }
    function __wbindgen_memory() {
        const ret = wasm$1.memory;
        return ret;
    }
    function __wbindgen_number_get(arg0, arg1) {
        const obj = arg1;
        const ret = typeof (obj) === 'number' ? obj : undefined;
        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
    }
    function __wbindgen_number_new(arg0) {
        const ret = arg0;
        return ret;
    }
    function __wbindgen_shr(arg0, arg1) {
        const ret = arg0 >> arg1;
        return ret;
    }
    function __wbindgen_string_get(arg0, arg1) {
        const obj = arg1;
        const ret = typeof (obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }
    function __wbindgen_string_new(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return ret;
    }
    function __wbindgen_throw(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    }
    function UnprovenOffer_() {
        return UnprovenOffer;
    }
    URL = globalThis.URL;
    const __vite__wasmModule = await __vite__initWasm({
        "./midnight_zswap_wasm_bg.js": {
            "__wbg_unprovenoutput_new": __wbg_unprovenoutput_new,
            "__wbg_unproveninput_new": __wbg_unproveninput_new,
            "__wbg_unproventransient_new": __wbg_unproventransient_new,
            "__wbindgen_number_new": __wbindgen_number_new,
            "__wbg_localstate_new": __wbg_localstate_new,
            "__wbg_input_new": __wbg_input_new,
            "__wbg_prooferasedtransient_new": __wbg_prooferasedtransient_new,
            "__wbg_unproventransaction_new": __wbg_unproventransaction_new,
            "__wbg_prooferasedoutput_new": __wbg_prooferasedoutput_new,
            "__wbg_zswapchainstate_new": __wbg_zswapchainstate_new,
            "__wbg_output_new": __wbg_output_new,
            "__wbg_prooferasedinput_new": __wbg_prooferasedinput_new,
            "__wbg_transient_new": __wbg_transient_new,
            "__wbindgen_bigint_from_u64": __wbindgen_bigint_from_u64,
            "__wbindgen_shr": __wbindgen_shr,
            "__wbindgen_jsval_eq": __wbindgen_jsval_eq,
            "__wbindgen_is_bigint": __wbindgen_is_bigint,
            "__wbindgen_error_new": __wbindgen_error_new,
            "__wbindgen_is_object": __wbindgen_is_object,
            "__wbindgen_is_undefined": __wbindgen_is_undefined,
            "__wbindgen_in": __wbindgen_in,
            "__wbindgen_string_get": __wbindgen_string_get,
            "__wbindgen_string_new": __wbindgen_string_new,
            "__wbindgen_number_get": __wbindgen_number_get,
            "__wbindgen_bigint_from_u128": __wbindgen_bigint_from_u128,
            "__wbindgen_is_null": __wbindgen_is_null,
            "__wbindgen_is_string": __wbindgen_is_string,
            "__wbindgen_jsval_loose_eq": __wbindgen_jsval_loose_eq,
            "__wbindgen_boolean_get": __wbindgen_boolean_get,
            "__wbg_String_fed4d24b68977888": __wbg_String_fed4d24b68977888,
            "__wbindgen_bigint_from_i128": __wbindgen_bigint_from_i128,
            "__wbg_getwithrefkey_bb8f74a92cb2e784": __wbg_getwithrefkey_bb8f74a92cb2e784,
            "__wbg_set_3fda3bac07393de4": __wbg_set_3fda3bac07393de4,
            "__wbindgen_cb_drop": __wbindgen_cb_drop,
            "__wbg_queueMicrotask_d3219def82552485": __wbg_queueMicrotask_d3219def82552485,
            "__wbindgen_is_function": __wbindgen_is_function,
            "__wbg_queueMicrotask_97d92b4fcc8a61c5": __wbg_queueMicrotask_97d92b4fcc8a61c5,
            "__wbg_view_fd8a56e8983f448d": __wbg_view_fd8a56e8983f448d,
            "__wbg_respond_1f279fa9f8edcb1c": __wbg_respond_1f279fa9f8edcb1c,
            "__wbg_close_304cc1fef3466669": __wbg_close_304cc1fef3466669,
            "__wbg_enqueue_bb16ba72f537dc9e": __wbg_enqueue_bb16ba72f537dc9e,
            "__wbg_byobRequest_77d9adf63337edfb": __wbg_byobRequest_77d9adf63337edfb,
            "__wbg_close_5ce03e29be453811": __wbg_close_5ce03e29be453811,
            "__wbg_crypto_574e78ad8b13b65f": __wbg_crypto_574e78ad8b13b65f,
            "__wbg_process_dc0fbacc7c1c06f7": __wbg_process_dc0fbacc7c1c06f7,
            "__wbg_versions_c01dfd4722a88165": __wbg_versions_c01dfd4722a88165,
            "__wbg_node_905d3e251edff8a2": __wbg_node_905d3e251edff8a2,
            "__wbg_require_60cc747a6bc5215a": __wbg_require_60cc747a6bc5215a,
            "__wbg_msCrypto_a61aeb35a24c1329": __wbg_msCrypto_a61aeb35a24c1329,
            "__wbg_randomFillSync_ac0988aba3254290": __wbg_randomFillSync_ac0988aba3254290,
            "__wbg_getRandomValues_b8f5dbd5f3995a9e": __wbg_getRandomValues_b8f5dbd5f3995a9e,
            "__wbg_new_78feb108b6472713": __wbg_new_78feb108b6472713,
            "__wbg_newnoargs_105ed471475aaf50": __wbg_newnoargs_105ed471475aaf50,
            "__wbg_new_5e0be73521bc8c17": __wbg_new_5e0be73521bc8c17,
            "__wbg_get_67b2ba62fc30de12": __wbg_get_67b2ba62fc30de12,
            "__wbg_call_672a4d21634d4a24": __wbg_call_672a4d21634d4a24,
            "__wbg_new_405e22f390576ce2": __wbg_new_405e22f390576ce2,
            "__wbg_new_a239edaa1dc2968f": __wbg_new_a239edaa1dc2968f,
            "__wbg_push_737cfc8c1432c2c6": __wbg_push_737cfc8c1432c2c6,
            "__wbg_instanceof_ArrayBuffer_e14585432e3737fc": __wbg_instanceof_ArrayBuffer_e14585432e3737fc,
            "__wbg_new_c68d7209be747379": __wbg_new_c68d7209be747379,
            "__wbg_apply_36be6a55257c99bf": __wbg_apply_36be6a55257c99bf,
            "__wbg_call_7cccdd69e0791ae2": __wbg_call_7cccdd69e0791ae2,
            "__wbg_set_8fc6bf8a5b1071d1": __wbg_set_8fc6bf8a5b1071d1,
            "__wbg_isSafeInteger_343e2beeeece1bb0": __wbg_isSafeInteger_343e2beeeece1bb0,
            "__wbg_instanceof_Set_f48781e4bf8ffb09": __wbg_instanceof_Set_f48781e4bf8ffb09,
            "__wbg_add_883d9432f9188ef2": __wbg_add_883d9432f9188ef2,
            "__wbg_forEach_432d981ecbee7d69": __wbg_forEach_432d981ecbee7d69,
            "__wbg_new_23a2665fac83c611": __wbg_new_23a2665fac83c611,
            "__wbg_resolve_4851785c9c5f573d": __wbg_resolve_4851785c9c5f573d,
            "__wbg_then_44b73946d2fb3e7d": __wbg_then_44b73946d2fb3e7d,
            "__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0": __wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0,
            "__wbg_static_accessor_SELF_37c5d418e4bf5819": __wbg_static_accessor_SELF_37c5d418e4bf5819,
            "__wbg_static_accessor_WINDOW_5de37043a91a9c40": __wbg_static_accessor_WINDOW_5de37043a91a9c40,
            "__wbg_static_accessor_GLOBAL_88a902d13a557d07": __wbg_static_accessor_GLOBAL_88a902d13a557d07,
            "__wbg_buffer_609cc3eee51ed158": __wbg_buffer_609cc3eee51ed158,
            "__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a": __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a,
            "__wbg_new_a12002a7f91c75be": __wbg_new_a12002a7f91c75be,
            "__wbg_set_65595bdd868b3009": __wbg_set_65595bdd868b3009,
            "__wbg_length_a446193dc22c12f8": __wbg_length_a446193dc22c12f8,
            "__wbg_instanceof_Uint8Array_17156bcf118086a9": __wbg_instanceof_Uint8Array_17156bcf118086a9,
            "__wbg_newwithlength_a381634e90c276d4": __wbg_newwithlength_a381634e90c276d4,
            "__wbg_buffer_09165b52af8c5237": __wbg_buffer_09165b52af8c5237,
            "__wbg_subarray_aa9065fa9dc5df96": __wbg_subarray_aa9065fa9dc5df96,
            "__wbg_byteLength_e674b853d9c77e1d": __wbg_byteLength_e674b853d9c77e1d,
            "__wbg_byteOffset_fd862df290ef848d": __wbg_byteOffset_fd862df290ef848d,
            "__wbg_getPrototypeOf_08aaacea7e300a38": __wbg_getPrototypeOf_08aaacea7e300a38,
            "__wbindgen_bigint_get_as_i64": __wbindgen_bigint_get_as_i64,
            "__wbindgen_debug_string": __wbindgen_debug_string,
            "__wbindgen_throw": __wbindgen_throw,
            "__wbindgen_memory": __wbindgen_memory,
            "__wbindgen_closure_wrapper3626": __wbindgen_closure_wrapper3626,
            "__wbindgen_init_externref_table": __wbindgen_init_externref_table
        },
        "./snippets/midnight-zswap-wasm-41bcd0561f7a9007/inline0.js": {
            "UnprovenOffer_": UnprovenOffer_
        }
    }, __vite__wasmUrl);
    const memory = __vite__wasmModule.memory;
    const __wbg_systemtransaction_free = __vite__wasmModule.__wbg_systemtransaction_free;
    const systemtransaction_new = __vite__wasmModule.systemtransaction_new;
    const systemtransaction_serialize = __vite__wasmModule.systemtransaction_serialize;
    const systemtransaction_deserialize = __vite__wasmModule.systemtransaction_deserialize;
    const systemtransaction_toString = __vite__wasmModule.systemtransaction_toString;
    const __wbg_ledgerparameters_free = __vite__wasmModule.__wbg_ledgerparameters_free;
    const ledgerparameters_new = __vite__wasmModule.ledgerparameters_new;
    const ledgerparameters_dummyParameters = __vite__wasmModule.ledgerparameters_dummyParameters;
    const ledgerparameters_transactionCostModel = __vite__wasmModule.ledgerparameters_transactionCostModel;
    const ledgerparameters_serialize = __vite__wasmModule.ledgerparameters_serialize;
    const ledgerparameters_deserialize = __vite__wasmModule.ledgerparameters_deserialize;
    const ledgerparameters_toString = __vite__wasmModule.ledgerparameters_toString;
    const __wbg_authorizedmint_free = __vite__wasmModule.__wbg_authorizedmint_free;
    const authorizedmint_new = __vite__wasmModule.authorizedmint_new;
    const authorizedmint_serialize = __vite__wasmModule.authorizedmint_serialize;
    const authorizedmint_deserialize = __vite__wasmModule.authorizedmint_deserialize;
    const authorizedmint_eraseProof = __vite__wasmModule.authorizedmint_eraseProof;
    const authorizedmint_coin = __vite__wasmModule.authorizedmint_coin;
    const authorizedmint_recipient = __vite__wasmModule.authorizedmint_recipient;
    const authorizedmint_toString = __vite__wasmModule.authorizedmint_toString;
    const __wbg_unprovenauthorizedmint_free = __vite__wasmModule.__wbg_unprovenauthorizedmint_free;
    const unprovenauthorizedmint_new = __vite__wasmModule.unprovenauthorizedmint_new;
    const unprovenauthorizedmint_serialize = __vite__wasmModule.unprovenauthorizedmint_serialize;
    const unprovenauthorizedmint_deserialize = __vite__wasmModule.unprovenauthorizedmint_deserialize;
    const unprovenauthorizedmint_coin = __vite__wasmModule.unprovenauthorizedmint_coin;
    const unprovenauthorizedmint_recipient = __vite__wasmModule.unprovenauthorizedmint_recipient;
    const unprovenauthorizedmint_toString = __vite__wasmModule.unprovenauthorizedmint_toString;
    const __wbg_prooferasedauthorizedmint_free = __vite__wasmModule.__wbg_prooferasedauthorizedmint_free;
    const prooferasedauthorizedmint_new = __vite__wasmModule.prooferasedauthorizedmint_new;
    const prooferasedauthorizedmint_serialize = __vite__wasmModule.prooferasedauthorizedmint_serialize;
    const prooferasedauthorizedmint_deserialize = __vite__wasmModule.prooferasedauthorizedmint_deserialize;
    const prooferasedauthorizedmint_coin = __vite__wasmModule.prooferasedauthorizedmint_coin;
    const prooferasedauthorizedmint_recipient = __vite__wasmModule.prooferasedauthorizedmint_recipient;
    const prooferasedauthorizedmint_toString = __vite__wasmModule.prooferasedauthorizedmint_toString;
    const __wbg_offer_free = __vite__wasmModule.__wbg_offer_free;
    const offer_new = __vite__wasmModule.offer_new;
    const offer_merge = __vite__wasmModule.offer_merge;
    const offer_serialize = __vite__wasmModule.offer_serialize;
    const offer_serialize_raw = __vite__wasmModule.offer_serialize_raw;
    const offer_deserialize = __vite__wasmModule.offer_deserialize;
    const offer_deserialize_raw = __vite__wasmModule.offer_deserialize_raw;
    const offer_inputs = __vite__wasmModule.offer_inputs;
    const offer_outputs = __vite__wasmModule.offer_outputs;
    const offer_transient = __vite__wasmModule.offer_transient;
    const offer_deltas = __vite__wasmModule.offer_deltas;
    const offer_toString = __vite__wasmModule.offer_toString;
    const __wbg_prooferasedoffer_free = __vite__wasmModule.__wbg_prooferasedoffer_free;
    const prooferasedoffer_new = __vite__wasmModule.prooferasedoffer_new;
    const prooferasedoffer_merge = __vite__wasmModule.prooferasedoffer_merge;
    const prooferasedoffer_serialize = __vite__wasmModule.prooferasedoffer_serialize;
    const prooferasedoffer_deserialize = __vite__wasmModule.prooferasedoffer_deserialize;
    const prooferasedoffer_inputs = __vite__wasmModule.prooferasedoffer_inputs;
    const prooferasedoffer_outputs = __vite__wasmModule.prooferasedoffer_outputs;
    const prooferasedoffer_transient = __vite__wasmModule.prooferasedoffer_transient;
    const prooferasedoffer_deltas = __vite__wasmModule.prooferasedoffer_deltas;
    const prooferasedoffer_toString = __vite__wasmModule.prooferasedoffer_toString;
    const __wbg_unprovenoffer_free = __vite__wasmModule.__wbg_unprovenoffer_free;
    const unprovenoffer_new = __vite__wasmModule.unprovenoffer_new;
    const unprovenoffer_fromInput = __vite__wasmModule.unprovenoffer_fromInput;
    const unprovenoffer_fromOutput = __vite__wasmModule.unprovenoffer_fromOutput;
    const unprovenoffer_fromTransient = __vite__wasmModule.unprovenoffer_fromTransient;
    const unprovenoffer_merge = __vite__wasmModule.unprovenoffer_merge;
    const unprovenoffer_serialize = __vite__wasmModule.unprovenoffer_serialize;
    const unprovenoffer_deserialize = __vite__wasmModule.unprovenoffer_deserialize;
    const unprovenoffer_inputs = __vite__wasmModule.unprovenoffer_inputs;
    const unprovenoffer_outputs = __vite__wasmModule.unprovenoffer_outputs;
    const unprovenoffer_transient = __vite__wasmModule.unprovenoffer_transient;
    const unprovenoffer_deltas = __vite__wasmModule.unprovenoffer_deltas;
    const unprovenoffer_toString = __vite__wasmModule.unprovenoffer_toString;
    const __wbg_input_free = __vite__wasmModule.__wbg_input_free;
    const input_new = __vite__wasmModule.input_new;
    const input_serialize = __vite__wasmModule.input_serialize;
    const input_deserialize = __vite__wasmModule.input_deserialize;
    const input_nullifier = __vite__wasmModule.input_nullifier;
    const input_contractAddress = __vite__wasmModule.input_contractAddress;
    const input_toString = __vite__wasmModule.input_toString;
    const __wbg_prooferasedinput_free = __vite__wasmModule.__wbg_prooferasedinput_free;
    const prooferasedinput_new = __vite__wasmModule.prooferasedinput_new;
    const prooferasedinput_serialize = __vite__wasmModule.prooferasedinput_serialize;
    const prooferasedinput_deserialize = __vite__wasmModule.prooferasedinput_deserialize;
    const prooferasedinput_nullifier = __vite__wasmModule.prooferasedinput_nullifier;
    const prooferasedinput_contractAddress = __vite__wasmModule.prooferasedinput_contractAddress;
    const prooferasedinput_toString = __vite__wasmModule.prooferasedinput_toString;
    const __wbg_unproveninput_free = __vite__wasmModule.__wbg_unproveninput_free;
    const unproveninput_new = __vite__wasmModule.unproveninput_new;
    const unproveninput_newContractOwned = __vite__wasmModule.unproveninput_newContractOwned;
    const unproveninput_serialize = __vite__wasmModule.unproveninput_serialize;
    const unproveninput_deserialize = __vite__wasmModule.unproveninput_deserialize;
    const unproveninput_nullifier = __vite__wasmModule.unproveninput_nullifier;
    const unproveninput_contractAddress = __vite__wasmModule.unproveninput_contractAddress;
    const unproveninput_toString = __vite__wasmModule.unproveninput_toString;
    const __wbg_output_free = __vite__wasmModule.__wbg_output_free;
    const output_new = __vite__wasmModule.output_new;
    const output_serialize = __vite__wasmModule.output_serialize;
    const output_deserialize = __vite__wasmModule.output_deserialize;
    const output_commitment = __vite__wasmModule.output_commitment;
    const output_contractAddress = __vite__wasmModule.output_contractAddress;
    const output_toString = __vite__wasmModule.output_toString;
    const __wbg_prooferasedoutput_free = __vite__wasmModule.__wbg_prooferasedoutput_free;
    const prooferasedoutput_new = __vite__wasmModule.prooferasedoutput_new;
    const prooferasedoutput_serialize = __vite__wasmModule.prooferasedoutput_serialize;
    const prooferasedoutput_deserialize = __vite__wasmModule.prooferasedoutput_deserialize;
    const prooferasedoutput_commitment = __vite__wasmModule.prooferasedoutput_commitment;
    const prooferasedoutput_contractAddress = __vite__wasmModule.prooferasedoutput_contractAddress;
    const prooferasedoutput_toString = __vite__wasmModule.prooferasedoutput_toString;
    const __wbg_unprovenoutput_free = __vite__wasmModule.__wbg_unprovenoutput_free;
    const unprovenoutput_construct = __vite__wasmModule.unprovenoutput_construct;
    const unprovenoutput_new = __vite__wasmModule.unprovenoutput_new;
    const unprovenoutput_newContractOwned = __vite__wasmModule.unprovenoutput_newContractOwned;
    const unprovenoutput_serialize = __vite__wasmModule.unprovenoutput_serialize;
    const unprovenoutput_deserialize = __vite__wasmModule.unprovenoutput_deserialize;
    const unprovenoutput_commitment = __vite__wasmModule.unprovenoutput_commitment;
    const unprovenoutput_contractAddress = __vite__wasmModule.unprovenoutput_contractAddress;
    const unprovenoutput_toString = __vite__wasmModule.unprovenoutput_toString;
    const __wbg_transient_free = __vite__wasmModule.__wbg_transient_free;
    const transient_new = __vite__wasmModule.transient_new;
    const transient_serialize = __vite__wasmModule.transient_serialize;
    const transient_deserialize = __vite__wasmModule.transient_deserialize;
    const transient_commitment = __vite__wasmModule.transient_commitment;
    const transient_nullifier = __vite__wasmModule.transient_nullifier;
    const transient_contractAddress = __vite__wasmModule.transient_contractAddress;
    const transient_toString = __vite__wasmModule.transient_toString;
    const __wbg_prooferasedtransient_free = __vite__wasmModule.__wbg_prooferasedtransient_free;
    const prooferasedtransient_new = __vite__wasmModule.prooferasedtransient_new;
    const prooferasedtransient_serialize = __vite__wasmModule.prooferasedtransient_serialize;
    const prooferasedtransient_deserialize = __vite__wasmModule.prooferasedtransient_deserialize;
    const prooferasedtransient_commitment = __vite__wasmModule.prooferasedtransient_commitment;
    const prooferasedtransient_nullifier = __vite__wasmModule.prooferasedtransient_nullifier;
    const prooferasedtransient_contractAddress = __vite__wasmModule.prooferasedtransient_contractAddress;
    const prooferasedtransient_toString = __vite__wasmModule.prooferasedtransient_toString;
    const __wbg_unproventransient_free = __vite__wasmModule.__wbg_unproventransient_free;
    const unproventransient_new = __vite__wasmModule.unproventransient_new;
    const unproventransient_newFromContractOwnedOutput = __vite__wasmModule.unproventransient_newFromContractOwnedOutput;
    const unproventransient_serialize = __vite__wasmModule.unproventransient_serialize;
    const unproventransient_deserialize = __vite__wasmModule.unproventransient_deserialize;
    const unproventransient_commitment = __vite__wasmModule.unproventransient_commitment;
    const unproventransient_nullifier = __vite__wasmModule.unproventransient_nullifier;
    const unproventransient_contractAddress = __vite__wasmModule.unproventransient_contractAddress;
    const unproventransient_toString = __vite__wasmModule.unproventransient_toString;
    const __wbg_transaction_free = __vite__wasmModule.__wbg_transaction_free;
    const transaction_new = __vite__wasmModule.transaction_new;
    const transaction_fromUnproven = __vite__wasmModule.transaction_fromUnproven;
    const transaction_eraseProofs = __vite__wasmModule.transaction_eraseProofs;
    const transaction_mint = __vite__wasmModule.transaction_mint;
    const transaction_guaranteedCoins = __vite__wasmModule.transaction_guaranteedCoins;
    const transaction_fallibleCoins = __vite__wasmModule.transaction_fallibleCoins;
    const transaction_transactionHash = __vite__wasmModule.transaction_transactionHash;
    const transaction_identifiers = __vite__wasmModule.transaction_identifiers;
    const transaction_merge = __vite__wasmModule.transaction_merge;
    const transaction_serialize = __vite__wasmModule.transaction_serialize;
    const transaction_deserialize = __vite__wasmModule.transaction_deserialize;
    const transaction_imbalances = __vite__wasmModule.transaction_imbalances;
    const transaction_fees = __vite__wasmModule.transaction_fees;
    const transaction_toString = __vite__wasmModule.transaction_toString;
    const __wbg_prooferasedtransaction_free = __vite__wasmModule.__wbg_prooferasedtransaction_free;
    const prooferasedtransaction_new = __vite__wasmModule.prooferasedtransaction_new;
    const prooferasedtransaction_mint = __vite__wasmModule.prooferasedtransaction_mint;
    const prooferasedtransaction_guaranteedCoins = __vite__wasmModule.prooferasedtransaction_guaranteedCoins;
    const prooferasedtransaction_fallibleCoins = __vite__wasmModule.prooferasedtransaction_fallibleCoins;
    const prooferasedtransaction_identifiers = __vite__wasmModule.prooferasedtransaction_identifiers;
    const prooferasedtransaction_merge = __vite__wasmModule.prooferasedtransaction_merge;
    const prooferasedtransaction_serialize = __vite__wasmModule.prooferasedtransaction_serialize;
    const prooferasedtransaction_deserialize = __vite__wasmModule.prooferasedtransaction_deserialize;
    const prooferasedtransaction_imbalances = __vite__wasmModule.prooferasedtransaction_imbalances;
    const prooferasedtransaction_fees = __vite__wasmModule.prooferasedtransaction_fees;
    const prooferasedtransaction_toString = __vite__wasmModule.prooferasedtransaction_toString;
    const __wbg_unproventransaction_free = __vite__wasmModule.__wbg_unproventransaction_free;
    const unproventransaction_new = __vite__wasmModule.unproventransaction_new;
    const unproventransaction_fromMint = __vite__wasmModule.unproventransaction_fromMint;
    const unproventransaction_eraseProofs = __vite__wasmModule.unproventransaction_eraseProofs;
    const unproventransaction_mint = __vite__wasmModule.unproventransaction_mint;
    const unproventransaction_guaranteedCoins = __vite__wasmModule.unproventransaction_guaranteedCoins;
    const unproventransaction_fallibleCoins = __vite__wasmModule.unproventransaction_fallibleCoins;
    const unproventransaction_identifiers = __vite__wasmModule.unproventransaction_identifiers;
    const unproventransaction_merge = __vite__wasmModule.unproventransaction_merge;
    const unproventransaction_serialize = __vite__wasmModule.unproventransaction_serialize;
    const unproventransaction_deserialize = __vite__wasmModule.unproventransaction_deserialize;
    const unproventransaction_toString = __vite__wasmModule.unproventransaction_toString;
    const __wbg_transactioncostmodel_free = __vite__wasmModule.__wbg_transactioncostmodel_free;
    const transactioncostmodel_new = __vite__wasmModule.transactioncostmodel_new;
    const transactioncostmodel_dummyTransactionCostModel = __vite__wasmModule.transactioncostmodel_dummyTransactionCostModel;
    const transactioncostmodel_inputFeeOverhead = __vite__wasmModule.transactioncostmodel_inputFeeOverhead;
    const transactioncostmodel_outputFeeOverhead = __vite__wasmModule.transactioncostmodel_outputFeeOverhead;
    const transactioncostmodel_serialize = __vite__wasmModule.transactioncostmodel_serialize;
    const transactioncostmodel_deserialize = __vite__wasmModule.transactioncostmodel_deserialize;
    const transactioncostmodel_toString = __vite__wasmModule.transactioncostmodel_toString;
    const unprovenauthorizedmint_eraseProof = __vite__wasmModule.unprovenauthorizedmint_eraseProof;
    const __wbg_secretkeys_free = __vite__wasmModule.__wbg_secretkeys_free;
    const secretkeys_new = __vite__wasmModule.secretkeys_new;
    const secretkeys_fromSeed = __vite__wasmModule.secretkeys_fromSeed;
    const secretkeys_fromSeedRng = __vite__wasmModule.secretkeys_fromSeedRng;
    const secretkeys_coinPublicKey = __vite__wasmModule.secretkeys_coinPublicKey;
    const secretkeys_encryptionPublicKey = __vite__wasmModule.secretkeys_encryptionPublicKey;
    const secretkeys_encryptionSecretKey = __vite__wasmModule.secretkeys_encryptionSecretKey;
    const secretkeys_coinSecretKey = __vite__wasmModule.secretkeys_coinSecretKey;
    const __wbg_coinsecretkey_free = __vite__wasmModule.__wbg_coinsecretkey_free;
    const coinsecretkey_new = __vite__wasmModule.coinsecretkey_new;
    const coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize = __vite__wasmModule.coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize;
    const __wbg_encryptionsecretkey_free = __vite__wasmModule.__wbg_encryptionsecretkey_free;
    const encryptionsecretkey_new = __vite__wasmModule.encryptionsecretkey_new;
    const encryptionsecretkey_test = __vite__wasmModule.encryptionsecretkey_test;
    const encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize = __vite__wasmModule.encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize;
    const encryptionsecretkey_deserialize = __vite__wasmModule.encryptionsecretkey_deserialize;
    const encryptionsecretkey_deserialize_raw = __vite__wasmModule.encryptionsecretkey_deserialize_raw;
    const createCoinInfo = __vite__wasmModule.createCoinInfo;
    const nativeToken = __vite__wasmModule.nativeToken;
    const __wbg_merkletreecollapsedupdate_free = __vite__wasmModule.__wbg_merkletreecollapsedupdate_free;
    const merkletreecollapsedupdate_new = __vite__wasmModule.merkletreecollapsedupdate_new;
    const merkletreecollapsedupdate_new_raw = __vite__wasmModule.merkletreecollapsedupdate_new_raw;
    const merkletreecollapsedupdate_serialize = __vite__wasmModule.merkletreecollapsedupdate_serialize;
    const merkletreecollapsedupdate_serialize_raw = __vite__wasmModule.merkletreecollapsedupdate_serialize_raw;
    const merkletreecollapsedupdate_deserialize = __vite__wasmModule.merkletreecollapsedupdate_deserialize;
    const merkletreecollapsedupdate_toString = __vite__wasmModule.merkletreecollapsedupdate_toString;
    const __wbg_localstate_free = __vite__wasmModule.__wbg_localstate_free;
    const localstate_new = __vite__wasmModule.localstate_new;
    const localstate_authorizeMint = __vite__wasmModule.localstate_authorizeMint;
    const localstate_firstFree = __vite__wasmModule.localstate_firstFree;
    const localstate_coins = __vite__wasmModule.localstate_coins;
    const localstate_pendingSpends = __vite__wasmModule.localstate_pendingSpends;
    const localstate_pendingOutputs = __vite__wasmModule.localstate_pendingOutputs;
    const localstate_applyMint = __vite__wasmModule.localstate_applyMint;
    const localstate_applyProofErasedMint = __vite__wasmModule.localstate_applyProofErasedMint;
    const localstate_applyFailed = __vite__wasmModule.localstate_applyFailed;
    const localstate_applyFailedProofErased = __vite__wasmModule.localstate_applyFailedProofErased;
    const localstate_apply = __vite__wasmModule.localstate_apply;
    const localstate_applyProofErased = __vite__wasmModule.localstate_applyProofErased;
    const localstate_applyTx = __vite__wasmModule.localstate_applyTx;
    const localstate_applyProofErasedTx = __vite__wasmModule.localstate_applyProofErasedTx;
    const localstate_applySystemTx = __vite__wasmModule.localstate_applySystemTx;
    const localstate_applyCollapsedUpdate = __vite__wasmModule.localstate_applyCollapsedUpdate;
    const localstate_spend = __vite__wasmModule.localstate_spend;
    const localstate_spendFromOutput = __vite__wasmModule.localstate_spendFromOutput;
    const localstate_watchFor = __vite__wasmModule.localstate_watchFor;
    const localstate_serialize = __vite__wasmModule.localstate_serialize;
    const localstate_deserialize = __vite__wasmModule.localstate_deserialize;
    const localstate_toString = __vite__wasmModule.localstate_toString;
    const __wbg_zswapchainstate_free = __vite__wasmModule.__wbg_zswapchainstate_free;
    const __wbg_contractaddress_free = __vite__wasmModule.__wbg_contractaddress_free;
    const contractaddress_deserialize_raw = __vite__wasmModule.contractaddress_deserialize_raw;
    const zswapchainstate_new = __vite__wasmModule.zswapchainstate_new;
    const zswapchainstate_serialize_raw = __vite__wasmModule.zswapchainstate_serialize_raw;
    const zswapchainstate_filter = __vite__wasmModule.zswapchainstate_filter;
    const zswapchainstate_merkle_tree_root = __vite__wasmModule.zswapchainstate_merkle_tree_root;
    const zswapchainstate_serialize = __vite__wasmModule.zswapchainstate_serialize;
    const zswapchainstate_deserialize = __vite__wasmModule.zswapchainstate_deserialize;
    const zswapchainstate_deserialize_raw = __vite__wasmModule.zswapchainstate_deserialize_raw;
    const zswapchainstate_deserializeFromLedgerState = __vite__wasmModule.zswapchainstate_deserializeFromLedgerState;
    const zswapchainstate_tryApply = __vite__wasmModule.zswapchainstate_tryApply;
    const zswapchainstate_tryApplyWithoutWhitelist = __vite__wasmModule.zswapchainstate_tryApplyWithoutWhitelist;
    const zswapchainstate_tryApplyProofErased = __vite__wasmModule.zswapchainstate_tryApplyProofErased;
    const zswapchainstate_toString = __vite__wasmModule.zswapchainstate_toString;
    const sampleContractAddress = __vite__wasmModule.sampleContractAddress;
    const sampleTokenType = __vite__wasmModule.sampleTokenType;
    const sampleCoinPublicKey = __vite__wasmModule.sampleCoinPublicKey;
    const sampleEncryptionPublicKey = __vite__wasmModule.sampleEncryptionPublicKey;
    const coin_nullifier = __vite__wasmModule.coin_nullifier;
    const coin_commitment = __vite__wasmModule.coin_commitment;
    const zswapchainstate_firstFree = __vite__wasmModule.zswapchainstate_firstFree;
    const __wbg_intounderlyingbytesource_free = __vite__wasmModule.__wbg_intounderlyingbytesource_free;
    const intounderlyingbytesource_type = __vite__wasmModule.intounderlyingbytesource_type;
    const intounderlyingbytesource_autoAllocateChunkSize = __vite__wasmModule.intounderlyingbytesource_autoAllocateChunkSize;
    const intounderlyingbytesource_start = __vite__wasmModule.intounderlyingbytesource_start;
    const intounderlyingbytesource_pull = __vite__wasmModule.intounderlyingbytesource_pull;
    const intounderlyingbytesource_cancel = __vite__wasmModule.intounderlyingbytesource_cancel;
    const __wbg_intounderlyingsource_free = __vite__wasmModule.__wbg_intounderlyingsource_free;
    const intounderlyingsource_pull = __vite__wasmModule.intounderlyingsource_pull;
    const intounderlyingsource_cancel = __vite__wasmModule.intounderlyingsource_cancel;
    const __wbg_intounderlyingsink_free = __vite__wasmModule.__wbg_intounderlyingsink_free;
    const intounderlyingsink_write = __vite__wasmModule.intounderlyingsink_write;
    const intounderlyingsink_close = __vite__wasmModule.intounderlyingsink_close;
    const intounderlyingsink_abort = __vite__wasmModule.intounderlyingsink_abort;
    const __wbindgen_malloc = __vite__wasmModule.__wbindgen_malloc;
    const __wbindgen_realloc = __vite__wasmModule.__wbindgen_realloc;
    const __wbindgen_exn_store = __vite__wasmModule.__wbindgen_exn_store;
    const __externref_table_alloc = __vite__wasmModule.__externref_table_alloc;
    const __wbindgen_export_4 = __vite__wasmModule.__wbindgen_export_4;
    const __wbindgen_export_5 = __vite__wasmModule.__wbindgen_export_5;
    const __externref_table_dealloc = __vite__wasmModule.__externref_table_dealloc;
    const __wbindgen_free = __vite__wasmModule.__wbindgen_free;
    const __externref_drop_slice = __vite__wasmModule.__externref_drop_slice;
    const closure648_externref_shim = __vite__wasmModule.closure648_externref_shim;
    const closure684_externref_shim = __vite__wasmModule.closure684_externref_shim;
    const closure688_externref_shim = __vite__wasmModule.closure688_externref_shim;
    const __wbindgen_start = __vite__wasmModule.__wbindgen_start;
    const wasm = Object.freeze(Object.defineProperty({
        __proto__: null,
        __externref_drop_slice,
        __externref_table_alloc,
        __externref_table_dealloc,
        __wbg_authorizedmint_free,
        __wbg_coinsecretkey_free,
        __wbg_contractaddress_free,
        __wbg_encryptionsecretkey_free,
        __wbg_input_free,
        __wbg_intounderlyingbytesource_free,
        __wbg_intounderlyingsink_free,
        __wbg_intounderlyingsource_free,
        __wbg_ledgerparameters_free,
        __wbg_localstate_free,
        __wbg_merkletreecollapsedupdate_free,
        __wbg_offer_free,
        __wbg_output_free,
        __wbg_prooferasedauthorizedmint_free,
        __wbg_prooferasedinput_free,
        __wbg_prooferasedoffer_free,
        __wbg_prooferasedoutput_free,
        __wbg_prooferasedtransaction_free,
        __wbg_prooferasedtransient_free,
        __wbg_secretkeys_free,
        __wbg_systemtransaction_free,
        __wbg_transaction_free,
        __wbg_transactioncostmodel_free,
        __wbg_transient_free,
        __wbg_unprovenauthorizedmint_free,
        __wbg_unproveninput_free,
        __wbg_unprovenoffer_free,
        __wbg_unprovenoutput_free,
        __wbg_unproventransaction_free,
        __wbg_unproventransient_free,
        __wbg_zswapchainstate_free,
        __wbindgen_exn_store,
        __wbindgen_export_4,
        __wbindgen_export_5,
        __wbindgen_free,
        __wbindgen_malloc,
        __wbindgen_realloc,
        __wbindgen_start,
        authorizedmint_coin,
        authorizedmint_deserialize,
        authorizedmint_eraseProof,
        authorizedmint_new,
        authorizedmint_recipient,
        authorizedmint_serialize,
        authorizedmint_toString,
        closure648_externref_shim,
        closure684_externref_shim,
        closure688_externref_shim,
        coin_commitment,
        coin_nullifier,
        coinsecretkey_new,
        coinsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize,
        contractaddress_deserialize_raw,
        createCoinInfo,
        encryptionsecretkey_deserialize,
        encryptionsecretkey_deserialize_raw,
        encryptionsecretkey_new,
        encryptionsecretkey_test,
        encryptionsecretkey_yesIKnowTheSecurityImplicationsOfThis_serialize,
        input_contractAddress,
        input_deserialize,
        input_new,
        input_nullifier,
        input_serialize,
        input_toString,
        intounderlyingbytesource_autoAllocateChunkSize,
        intounderlyingbytesource_cancel,
        intounderlyingbytesource_pull,
        intounderlyingbytesource_start,
        intounderlyingbytesource_type,
        intounderlyingsink_abort,
        intounderlyingsink_close,
        intounderlyingsink_write,
        intounderlyingsource_cancel,
        intounderlyingsource_pull,
        ledgerparameters_deserialize,
        ledgerparameters_dummyParameters,
        ledgerparameters_new,
        ledgerparameters_serialize,
        ledgerparameters_toString,
        ledgerparameters_transactionCostModel,
        localstate_apply,
        localstate_applyCollapsedUpdate,
        localstate_applyFailed,
        localstate_applyFailedProofErased,
        localstate_applyMint,
        localstate_applyProofErased,
        localstate_applyProofErasedMint,
        localstate_applyProofErasedTx,
        localstate_applySystemTx,
        localstate_applyTx,
        localstate_authorizeMint,
        localstate_coins,
        localstate_deserialize,
        localstate_firstFree,
        localstate_new,
        localstate_pendingOutputs,
        localstate_pendingSpends,
        localstate_serialize,
        localstate_spend,
        localstate_spendFromOutput,
        localstate_toString,
        localstate_watchFor,
        memory,
        merkletreecollapsedupdate_deserialize,
        merkletreecollapsedupdate_new,
        merkletreecollapsedupdate_new_raw,
        merkletreecollapsedupdate_serialize,
        merkletreecollapsedupdate_serialize_raw,
        merkletreecollapsedupdate_toString,
        nativeToken,
        offer_deltas,
        offer_deserialize,
        offer_deserialize_raw,
        offer_inputs,
        offer_merge,
        offer_new,
        offer_outputs,
        offer_serialize,
        offer_serialize_raw,
        offer_toString,
        offer_transient,
        output_commitment,
        output_contractAddress,
        output_deserialize,
        output_new,
        output_serialize,
        output_toString,
        prooferasedauthorizedmint_coin,
        prooferasedauthorizedmint_deserialize,
        prooferasedauthorizedmint_new,
        prooferasedauthorizedmint_recipient,
        prooferasedauthorizedmint_serialize,
        prooferasedauthorizedmint_toString,
        prooferasedinput_contractAddress,
        prooferasedinput_deserialize,
        prooferasedinput_new,
        prooferasedinput_nullifier,
        prooferasedinput_serialize,
        prooferasedinput_toString,
        prooferasedoffer_deltas,
        prooferasedoffer_deserialize,
        prooferasedoffer_inputs,
        prooferasedoffer_merge,
        prooferasedoffer_new,
        prooferasedoffer_outputs,
        prooferasedoffer_serialize,
        prooferasedoffer_toString,
        prooferasedoffer_transient,
        prooferasedoutput_commitment,
        prooferasedoutput_contractAddress,
        prooferasedoutput_deserialize,
        prooferasedoutput_new,
        prooferasedoutput_serialize,
        prooferasedoutput_toString,
        prooferasedtransaction_deserialize,
        prooferasedtransaction_fallibleCoins,
        prooferasedtransaction_fees,
        prooferasedtransaction_guaranteedCoins,
        prooferasedtransaction_identifiers,
        prooferasedtransaction_imbalances,
        prooferasedtransaction_merge,
        prooferasedtransaction_mint,
        prooferasedtransaction_new,
        prooferasedtransaction_serialize,
        prooferasedtransaction_toString,
        prooferasedtransient_commitment,
        prooferasedtransient_contractAddress,
        prooferasedtransient_deserialize,
        prooferasedtransient_new,
        prooferasedtransient_nullifier,
        prooferasedtransient_serialize,
        prooferasedtransient_toString,
        sampleCoinPublicKey,
        sampleContractAddress,
        sampleEncryptionPublicKey,
        sampleTokenType,
        secretkeys_coinPublicKey,
        secretkeys_coinSecretKey,
        secretkeys_encryptionPublicKey,
        secretkeys_encryptionSecretKey,
        secretkeys_fromSeed,
        secretkeys_fromSeedRng,
        secretkeys_new,
        systemtransaction_deserialize,
        systemtransaction_new,
        systemtransaction_serialize,
        systemtransaction_toString,
        transaction_deserialize,
        transaction_eraseProofs,
        transaction_fallibleCoins,
        transaction_fees,
        transaction_fromUnproven,
        transaction_guaranteedCoins,
        transaction_identifiers,
        transaction_imbalances,
        transaction_merge,
        transaction_mint,
        transaction_new,
        transaction_serialize,
        transaction_toString,
        transaction_transactionHash,
        transactioncostmodel_deserialize,
        transactioncostmodel_dummyTransactionCostModel,
        transactioncostmodel_inputFeeOverhead,
        transactioncostmodel_new,
        transactioncostmodel_outputFeeOverhead,
        transactioncostmodel_serialize,
        transactioncostmodel_toString,
        transient_commitment,
        transient_contractAddress,
        transient_deserialize,
        transient_new,
        transient_nullifier,
        transient_serialize,
        transient_toString,
        unprovenauthorizedmint_coin,
        unprovenauthorizedmint_deserialize,
        unprovenauthorizedmint_eraseProof,
        unprovenauthorizedmint_new,
        unprovenauthorizedmint_recipient,
        unprovenauthorizedmint_serialize,
        unprovenauthorizedmint_toString,
        unproveninput_contractAddress,
        unproveninput_deserialize,
        unproveninput_new,
        unproveninput_newContractOwned,
        unproveninput_nullifier,
        unproveninput_serialize,
        unproveninput_toString,
        unprovenoffer_deltas,
        unprovenoffer_deserialize,
        unprovenoffer_fromInput,
        unprovenoffer_fromOutput,
        unprovenoffer_fromTransient,
        unprovenoffer_inputs,
        unprovenoffer_merge,
        unprovenoffer_new,
        unprovenoffer_outputs,
        unprovenoffer_serialize,
        unprovenoffer_toString,
        unprovenoffer_transient,
        unprovenoutput_commitment,
        unprovenoutput_construct,
        unprovenoutput_contractAddress,
        unprovenoutput_deserialize,
        unprovenoutput_new,
        unprovenoutput_newContractOwned,
        unprovenoutput_serialize,
        unprovenoutput_toString,
        unproventransaction_deserialize,
        unproventransaction_eraseProofs,
        unproventransaction_fallibleCoins,
        unproventransaction_fromMint,
        unproventransaction_guaranteedCoins,
        unproventransaction_identifiers,
        unproventransaction_merge,
        unproventransaction_mint,
        unproventransaction_new,
        unproventransaction_serialize,
        unproventransaction_toString,
        unproventransient_commitment,
        unproventransient_contractAddress,
        unproventransient_deserialize,
        unproventransient_new,
        unproventransient_newFromContractOwnedOutput,
        unproventransient_nullifier,
        unproventransient_serialize,
        unproventransient_toString,
        zswapchainstate_deserialize,
        zswapchainstate_deserializeFromLedgerState,
        zswapchainstate_deserialize_raw,
        zswapchainstate_filter,
        zswapchainstate_firstFree,
        zswapchainstate_merkle_tree_root,
        zswapchainstate_new,
        zswapchainstate_serialize,
        zswapchainstate_serialize_raw,
        zswapchainstate_toString,
        zswapchainstate_tryApply,
        zswapchainstate_tryApplyProofErased,
        zswapchainstate_tryApplyWithoutWhitelist
    }, Symbol.toStringTag, {
        value: 'Module'
    }));
    __wbg_set_wasm(wasm);
    __wbindgen_start();
    const HEX_STRING_REGEXP = /^(?<prefix>(0x)?)(?<byteChars>([0-9A-Fa-f]{2})*)(?<incompleteChars>.*)$/;
    const parseHex = (source)=>{
        const groups = HEX_STRING_REGEXP.exec(source)?.groups;
        return {
            hasPrefix: groups.prefix === '0x',
            byteChars: groups.byteChars,
            incompleteChars: groups.incompleteChars
        };
    };
    function assertIsHex(source, byteLen) {
        if (!source) {
            throw new TypeError('Input string must have non-zero length.');
        }
        const parsedHex = parseHex(source);
        if (parsedHex.incompleteChars) {
            if (parsedHex.incompleteChars.length % 2 > 0) {
                throw new TypeError(`The last byte of input string '${source}' is incomplete.`);
            }
            const invalidCharPos = parsedHex.byteChars.length + (parsedHex.hasPrefix ? 2 : 0);
            throw new TypeError(`Invalid hex-digit '${source[invalidCharPos]}' found in input string at index ${invalidCharPos}.`);
        }
        if (!parsedHex.byteChars) {
            throw new TypeError(`Input string '${source}' is not a valid hex-string.`);
        }
        {
            const actualByteLen = parsedHex.byteChars.length / 2;
            if (byteLen !== actualByteLen) {
                throw new TypeError(`Expected an input string with byte length of ${byteLen}, got ${actualByteLen}.`);
            }
        }
    }
    function assertIsContractAddress(contractAddress) {
        const CONTRACT_ADDRESS_BYTE_LENGTH = 34;
        assertIsHex(contractAddress, CONTRACT_ADDRESS_BYTE_LENGTH);
        const parsedHex = parseHex(contractAddress);
        if (parsedHex.hasPrefix) {
            throw new TypeError(`Unexpected '0x' prefix in contract address '${contractAddress}'`);
        }
    }
    const BlockHashQueryDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "query",
                "name": {
                    "kind": "Name",
                    "value": "BLOCK_HASH_QUERY"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "offset"
                            }
                        },
                        "type": {
                            "kind": "NamedType",
                            "name": {
                                "kind": "Name",
                                "value": "BlockOffset"
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "block"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "offset"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "offset"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "height"
                                        }
                                    },
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "hash"
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const TxIdQueryDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "query",
                "name": {
                    "kind": "Name",
                    "value": "TX_ID_QUERY"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "offset"
                            }
                        },
                        "type": {
                            "kind": "NonNullType",
                            "type": {
                                "kind": "NamedType",
                                "name": {
                                    "kind": "Name",
                                    "value": "TransactionOffset"
                                }
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "transactions"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "offset"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "offset"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "raw"
                                        }
                                    },
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "applyStage"
                                        }
                                    },
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "hash"
                                        }
                                    },
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "block"
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "height"
                                                    }
                                                },
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "hash"
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const DeployTxQueryDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "query",
                "name": {
                    "kind": "Name",
                    "value": "DEPLOY_TX_QUERY"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "address"
                            }
                        },
                        "type": {
                            "kind": "NonNullType",
                            "type": {
                                "kind": "NamedType",
                                "name": {
                                    "kind": "Name",
                                    "value": "HexEncoded"
                                }
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "contractAction"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "address"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "address"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "InlineFragment",
                                        "typeCondition": {
                                            "kind": "NamedType",
                                            "name": {
                                                "kind": "Name",
                                                "value": "ContractDeploy"
                                            }
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "transaction"
                                                    },
                                                    "selectionSet": {
                                                        "kind": "SelectionSet",
                                                        "selections": [
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "raw"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "applyStage"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "hash"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "identifiers"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "contractActions"
                                                                },
                                                                "selectionSet": {
                                                                    "kind": "SelectionSet",
                                                                    "selections": [
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "address"
                                                                            }
                                                                        }
                                                                    ]
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "block"
                                                                },
                                                                "selectionSet": {
                                                                    "kind": "SelectionSet",
                                                                    "selections": [
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "height"
                                                                            }
                                                                        },
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "hash"
                                                                            }
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    }
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "kind": "InlineFragment",
                                        "typeCondition": {
                                            "kind": "NamedType",
                                            "name": {
                                                "kind": "Name",
                                                "value": "ContractUpdate"
                                            }
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "transaction"
                                                    },
                                                    "selectionSet": {
                                                        "kind": "SelectionSet",
                                                        "selections": [
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "raw"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "applyStage"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "hash"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "identifiers"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "contractActions"
                                                                },
                                                                "selectionSet": {
                                                                    "kind": "SelectionSet",
                                                                    "selections": [
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "address"
                                                                            }
                                                                        }
                                                                    ]
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "block"
                                                                },
                                                                "selectionSet": {
                                                                    "kind": "SelectionSet",
                                                                    "selections": [
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "height"
                                                                            }
                                                                        },
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "hash"
                                                                            }
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    }
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "kind": "InlineFragment",
                                        "typeCondition": {
                                            "kind": "NamedType",
                                            "name": {
                                                "kind": "Name",
                                                "value": "ContractCall"
                                            }
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "deploy"
                                                    },
                                                    "selectionSet": {
                                                        "kind": "SelectionSet",
                                                        "selections": [
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "transaction"
                                                                },
                                                                "selectionSet": {
                                                                    "kind": "SelectionSet",
                                                                    "selections": [
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "raw"
                                                                            }
                                                                        },
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "applyStage"
                                                                            }
                                                                        },
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "hash"
                                                                            }
                                                                        },
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "identifiers"
                                                                            }
                                                                        },
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "contractActions"
                                                                            },
                                                                            "selectionSet": {
                                                                                "kind": "SelectionSet",
                                                                                "selections": [
                                                                                    {
                                                                                        "kind": "Field",
                                                                                        "name": {
                                                                                            "kind": "Name",
                                                                                            "value": "address"
                                                                                        }
                                                                                    }
                                                                                ]
                                                                            }
                                                                        },
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "block"
                                                                            },
                                                                            "selectionSet": {
                                                                                "kind": "SelectionSet",
                                                                                "selections": [
                                                                                    {
                                                                                        "kind": "Field",
                                                                                        "name": {
                                                                                            "kind": "Name",
                                                                                            "value": "height"
                                                                                        }
                                                                                    },
                                                                                    {
                                                                                        "kind": "Field",
                                                                                        "name": {
                                                                                            "kind": "Name",
                                                                                            "value": "hash"
                                                                                        }
                                                                                    }
                                                                                ]
                                                                            }
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const DeployContractStateTxQueryDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "query",
                "name": {
                    "kind": "Name",
                    "value": "DEPLOY_CONTRACT_STATE_TX_QUERY"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "address"
                            }
                        },
                        "type": {
                            "kind": "NonNullType",
                            "type": {
                                "kind": "NamedType",
                                "name": {
                                    "kind": "Name",
                                    "value": "HexEncoded"
                                }
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "contractAction"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "address"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "address"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "InlineFragment",
                                        "typeCondition": {
                                            "kind": "NamedType",
                                            "name": {
                                                "kind": "Name",
                                                "value": "ContractDeploy"
                                            }
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "state"
                                                    }
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "kind": "InlineFragment",
                                        "typeCondition": {
                                            "kind": "NamedType",
                                            "name": {
                                                "kind": "Name",
                                                "value": "ContractUpdate"
                                            }
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "state"
                                                    }
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        "kind": "InlineFragment",
                                        "typeCondition": {
                                            "kind": "NamedType",
                                            "name": {
                                                "kind": "Name",
                                                "value": "ContractCall"
                                            }
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "deploy"
                                                    },
                                                    "selectionSet": {
                                                        "kind": "SelectionSet",
                                                        "selections": [
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "transaction"
                                                                },
                                                                "selectionSet": {
                                                                    "kind": "SelectionSet",
                                                                    "selections": [
                                                                        {
                                                                            "kind": "Field",
                                                                            "name": {
                                                                                "kind": "Name",
                                                                                "value": "contractActions"
                                                                            },
                                                                            "selectionSet": {
                                                                                "kind": "SelectionSet",
                                                                                "selections": [
                                                                                    {
                                                                                        "kind": "Field",
                                                                                        "name": {
                                                                                            "kind": "Name",
                                                                                            "value": "address"
                                                                                        }
                                                                                    },
                                                                                    {
                                                                                        "kind": "Field",
                                                                                        "name": {
                                                                                            "kind": "Name",
                                                                                            "value": "state"
                                                                                        }
                                                                                    }
                                                                                ]
                                                                            }
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const LatestContractTxBlockHeightQueryDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "query",
                "name": {
                    "kind": "Name",
                    "value": "LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "address"
                            }
                        },
                        "type": {
                            "kind": "NonNullType",
                            "type": {
                                "kind": "NamedType",
                                "name": {
                                    "kind": "Name",
                                    "value": "HexEncoded"
                                }
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "contractAction"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "address"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "address"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "transaction"
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "block"
                                                    },
                                                    "selectionSet": {
                                                        "kind": "SelectionSet",
                                                        "selections": [
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "height"
                                                                }
                                                            }
                                                        ]
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const TxsFromBlockSubDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "subscription",
                "name": {
                    "kind": "Name",
                    "value": "TXS_FROM_BLOCK_SUB"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "offset"
                            }
                        },
                        "type": {
                            "kind": "NamedType",
                            "name": {
                                "kind": "Name",
                                "value": "BlockOffset"
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "blocks"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "offset"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "offset"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "hash"
                                        }
                                    },
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "height"
                                        }
                                    },
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "transactions"
                                        },
                                        "selectionSet": {
                                            "kind": "SelectionSet",
                                            "selections": [
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "hash"
                                                    }
                                                },
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "identifiers"
                                                    }
                                                },
                                                {
                                                    "kind": "Field",
                                                    "name": {
                                                        "kind": "Name",
                                                        "value": "contractActions"
                                                    },
                                                    "selectionSet": {
                                                        "kind": "SelectionSet",
                                                        "selections": [
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "state"
                                                                }
                                                            },
                                                            {
                                                                "kind": "Field",
                                                                "name": {
                                                                    "kind": "Name",
                                                                    "value": "address"
                                                                }
                                                            }
                                                        ]
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const ContractStateQueryDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "query",
                "name": {
                    "kind": "Name",
                    "value": "CONTRACT_STATE_QUERY"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "address"
                            }
                        },
                        "type": {
                            "kind": "NonNullType",
                            "type": {
                                "kind": "NamedType",
                                "name": {
                                    "kind": "Name",
                                    "value": "HexEncoded"
                                }
                            }
                        }
                    },
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "offset"
                            }
                        },
                        "type": {
                            "kind": "NamedType",
                            "name": {
                                "kind": "Name",
                                "value": "ContractActionOffset"
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "contractAction"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "address"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "address"
                                        }
                                    }
                                },
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "offset"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "offset"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "state"
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const ContractStateSubDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "subscription",
                "name": {
                    "kind": "Name",
                    "value": "CONTRACT_STATE_SUB"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "address"
                            }
                        },
                        "type": {
                            "kind": "NonNullType",
                            "type": {
                                "kind": "NamedType",
                                "name": {
                                    "kind": "Name",
                                    "value": "HexEncoded"
                                }
                            }
                        }
                    },
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "offset"
                            }
                        },
                        "type": {
                            "kind": "NamedType",
                            "name": {
                                "kind": "Name",
                                "value": "BlockOffset"
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "contractActions"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "address"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "address"
                                        }
                                    }
                                },
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "offset"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "offset"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "state"
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const BothStateQueryDocument = {
        "kind": "Document",
        "definitions": [
            {
                "kind": "OperationDefinition",
                "operation": "query",
                "name": {
                    "kind": "Name",
                    "value": "BOTH_STATE_QUERY"
                },
                "variableDefinitions": [
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "address"
                            }
                        },
                        "type": {
                            "kind": "NonNullType",
                            "type": {
                                "kind": "NamedType",
                                "name": {
                                    "kind": "Name",
                                    "value": "HexEncoded"
                                }
                            }
                        }
                    },
                    {
                        "kind": "VariableDefinition",
                        "variable": {
                            "kind": "Variable",
                            "name": {
                                "kind": "Name",
                                "value": "offset"
                            }
                        },
                        "type": {
                            "kind": "NamedType",
                            "name": {
                                "kind": "Name",
                                "value": "ContractActionOffset"
                            }
                        }
                    }
                ],
                "selectionSet": {
                    "kind": "SelectionSet",
                    "selections": [
                        {
                            "kind": "Field",
                            "name": {
                                "kind": "Name",
                                "value": "contractAction"
                            },
                            "arguments": [
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "address"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "address"
                                        }
                                    }
                                },
                                {
                                    "kind": "Argument",
                                    "name": {
                                        "kind": "Name",
                                        "value": "offset"
                                    },
                                    "value": {
                                        "kind": "Variable",
                                        "name": {
                                            "kind": "Name",
                                            "value": "offset"
                                        }
                                    }
                                }
                            ],
                            "selectionSet": {
                                "kind": "SelectionSet",
                                "selections": [
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "state"
                                        }
                                    },
                                    {
                                        "kind": "Field",
                                        "name": {
                                            "kind": "Name",
                                            "value": "chainState"
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                }
            }
        ]
    };
    const documents = {
        "\n  query BLOCK_HASH_QUERY($offset: BlockOffset) {\n    block(offset: $offset) {\n      height\n      hash\n    }\n  }": BlockHashQueryDocument,
        "\n  query TX_ID_QUERY($offset: TransactionOffset!) {\n    transactions(offset: $offset) {\n      raw\n      applyStage\n      hash\n      block {\n        height\n        hash\n      }\n    }\n  }": TxIdQueryDocument,
        "\n  query DEPLOY_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        transaction {\n\t        raw\n          applyStage\n          hash\n          identifiers\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n          }\n        }\n      }\n      ... on ContractUpdate {\n        transaction {\n\t        raw\n          applyStage\n          hash\n          identifiers\n          contractActions {\n            address\n          }\n          block {\n            height\n            hash\n          }\n        }\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n\t          raw\n            applyStage\n            hash\n            identifiers\n            contractActions {\n              address\n            }\n            block {\n              height\n              hash\n            }\n          }\n        }\n      }\n    }\n  }": DeployTxQueryDocument,
        "\n  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      ... on ContractDeploy {\n        state\n      }\n      ... on ContractUpdate {\n        state\n      }\n      ... on ContractCall {\n        deploy {\n          transaction {\n            contractActions {\n              address\n              state\n            }\n          }\n        }\n      }\n    }\n  }": DeployContractStateTxQueryDocument,
        "\n  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {\n    contractAction(address: $address) {\n      transaction {\n        block {\n          height\n        }\n      }\n    }\n  }": LatestContractTxBlockHeightQueryDocument,
        "\n  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {\n    blocks(offset: $offset) {\n      hash,\n      height,\n      transactions {\n        hash\n        identifiers\n        contractActions {\n          state\n          address\n        }\n      }\n    }\n  }": TxsFromBlockSubDocument,
        "\n  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n    }\n  }": ContractStateQueryDocument,
        "\n  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {\n    contractActions(address: $address, offset: $offset) {\n      state\n    }\n  }": ContractStateSubDocument,
        "\n  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {\n    contractAction(address: $address, offset: $offset) {\n      state\n      chainState\n    }\n  }": BothStateQueryDocument
    };
    function gql(source) {
        return documents[source] ?? {};
    }
    const BLOCK_QUERY = gql(`
  query BLOCK_HASH_QUERY($offset: BlockOffset) {
    block(offset: $offset) {
      height
      hash
    }
  }`);
    const TX_ID_QUERY = gql(`
  query TX_ID_QUERY($offset: TransactionOffset!) {
    transactions(offset: $offset) {
      raw
      applyStage
      hash
      block {
        height
        hash
      }
    }
  }`);
    const DEPLOY_TX_QUERY = gql(`
  query DEPLOY_TX_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      ... on ContractDeploy {
        transaction {
	        raw
          applyStage
          hash
          identifiers
          contractActions {
            address
          }
          block {
            height
            hash
          }
        }
      }
      ... on ContractUpdate {
        transaction {
	        raw
          applyStage
          hash
          identifiers
          contractActions {
            address
          }
          block {
            height
            hash
          }
        }
      }
      ... on ContractCall {
        deploy {
          transaction {
	          raw
            applyStage
            hash
            identifiers
            contractActions {
              address
            }
            block {
              height
              hash
            }
          }
        }
      }
    }
  }`);
    const DEPLOY_CONTRACT_STATE_TX_QUERY = gql(`
  query DEPLOY_CONTRACT_STATE_TX_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      ... on ContractDeploy {
        state
      }
      ... on ContractUpdate {
        state
      }
      ... on ContractCall {
        deploy {
          transaction {
            contractActions {
              address
              state
            }
          }
        }
      }
    }
  }`);
    const LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY = gql(`
  query LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY($address: HexEncoded!) {
    contractAction(address: $address) {
      transaction {
        block {
          height
        }
      }
    }
  }`);
    const TXS_FROM_BLOCK_SUB = gql(`
  subscription TXS_FROM_BLOCK_SUB($offset: BlockOffset) {
    blocks(offset: $offset) {
      hash,
      height,
      transactions {
        hash
        identifiers
        contractActions {
          state
          address
        }
      }
    }
  }`);
    const CONTRACT_STATE_QUERY = gql(`
  query CONTRACT_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {
    contractAction(address: $address, offset: $offset) {
      state
    }
  }`);
    const CONTRACT_STATE_SUB = gql(`
  subscription CONTRACT_STATE_SUB($address: HexEncoded!, $offset: BlockOffset) {
    contractActions(address: $address, offset: $offset) {
      state
    }
  }`);
    const CONTRACT_AND_ZSWAP_STATE_QUERY = gql(`
  query BOTH_STATE_QUERY($address: HexEncoded!, $offset: ContractActionOffset) {
    contractAction(address: $address, offset: $offset) {
      state
      chainState
    }
  }`);
    class IndexerFormattedError extends Error {
        cause;
        constructor(cause){
            super(`Indexer GraphQL error(s):\n${cause.reduce((acc, c, idx)=>`${idx + 1}. ${c.message}:\n\t${acc}`, '')}`);
            this.cause = cause;
        }
    }
    const maybeThrowGraphQLErrors = (result)=>{
        if (result.errors && result.errors.length > 0) {
            throw new IndexerFormattedError(result.errors);
        }
        return result;
    };
    const maybeThrowApolloError = (result)=>{
        if (result.error) {
            throw new Error(result.error.message);
        }
        return result;
    };
    const maybeThrowErrors = (queryResult)=>{
        maybeThrowApolloError(queryResult);
        return maybeThrowGraphQLErrors(queryResult);
    };
    const toByteArray = (s)=>bufferExports.Buffer.from(s, 'hex');
    const deserializeContractState = (s)=>runtimeExports.ContractState.deserialize(toByteArray(s), getRuntimeNetworkId());
    const deserializeZswapState = (s)=>ZswapChainState$2.deserialize(toByteArray(s), getLedgerNetworkId());
    const deserializeTransaction = (s)=>Transaction$2.deserialize(toByteArray(s), getLedgerNetworkId());
    const prependNetworkIdHex = (contractAddress)=>`${networkIdToHex(getNetworkId())}${contractAddress}`;
    const zenToRx = (zenObservable)=>new Observable$1((subscriber)=>zenObservable.subscribe(subscriber));
    const DEFAULT_POLL_INTERVAL = 1000;
    const blockOffsetToBlock$ = (apolloClient)=>(offset)=>zenToRx(apolloClient.subscribe({
                query: TXS_FROM_BLOCK_SUB,
                variables: {
                    offset
                },
                fetchPolicy: 'no-cache'
            }).map(maybeThrowGraphQLErrors).map((fetchResult)=>fetchResult.data.blocks));
    const transactionIdToTransaction$ = (apolloClient)=>(identifier)=>zenToRx(apolloClient.watchQuery({
                query: TX_ID_QUERY,
                variables: {
                    offset: {
                        identifier
                    }
                },
                pollInterval: DEFAULT_POLL_INTERVAL,
                fetchPolicy: 'no-cache',
                initialFetchPolicy: 'no-cache',
                nextFetchPolicy: 'no-cache'
            }).map(maybeThrowErrors).filter((maybeQueryResult)=>maybeQueryResult.data.transactions.length !== 0).map((maybeQueryResult)=>({
                    height: maybeQueryResult.data.transactions[0].block.height
                }))).pipe(concatMap(blockOffsetToBlock$(apolloClient)), concatMap(({ transactions })=>from$1(transactions)));
    const transactionToContractState$ = (transactionId)=>({ identifiers, contractActions })=>zip(identifiers, contractActions).pipe(skipWhile((pair)=>pair[0] !== transactionId), map((pair)=>deserializeContractState(pair[1].state)));
    const toTxStatus = (applyStage)=>{
        if (applyStage === FailEntirely || applyStage === FailFallible || applyStage === SucceedEntirely) {
            return applyStage;
        }
        throw new Error(`Unexpected 'applyStage' value ${applyStage}`);
    };
    const blockToContractState$ = (contractAddress)=>(block)=>from$1(block.transactions).pipe(concatMap(({ contractActions })=>from$1(contractActions)), filter((call)=>call.address === contractAddress), map((call)=>deserializeContractState(call.state)));
    const contractAddressToLatestBlockOffset$ = (apolloClient)=>(contractAddress)=>zenToRx(apolloClient.watchQuery({
                query: LATEST_CONTRACT_TX_BLOCK_HEIGHT_QUERY,
                variables: {
                    address: contractAddress
                },
                pollInterval: DEFAULT_POLL_INTERVAL,
                fetchPolicy: 'no-cache',
                initialFetchPolicy: 'no-cache',
                nextFetchPolicy: 'no-cache'
            }).map(maybeThrowErrors).filter((maybeQueryResult)=>maybeQueryResult.data.contractAction !== null).map((queryResult)=>{
                const contract = queryResult.data.contractAction;
                return contract.transaction.block.height;
            })).pipe(take(1), map((height)=>({
                    height
                })));
    const blockOffsetToContractState$ = (apolloClient)=>(contractAddress)=>(offset)=>zenToRx(apolloClient.subscribe({
                    query: CONTRACT_STATE_SUB,
                    variables: {
                        address: contractAddress,
                        offset
                    },
                    fetchPolicy: 'no-cache'
                }).map(maybeThrowGraphQLErrors).map((queryResult)=>queryResult.data.contractActions.state).map(deserializeContractState));
    const waitForContractToAppear = (apolloClient)=>(contractAddress)=>(offset)=>zenToRx(apolloClient.watchQuery({
                    query: CONTRACT_STATE_QUERY,
                    variables: {
                        address: contractAddress,
                        offset
                    },
                    pollInterval: DEFAULT_POLL_INTERVAL,
                    fetchPolicy: 'no-cache',
                    initialFetchPolicy: 'no-cache',
                    nextFetchPolicy: 'no-cache'
                }).map(maybeThrowErrors).filter((maybeQueryResult)=>maybeQueryResult.data.contractAction !== null).map((queryResult)=>queryResult.data.contractAction.state)).pipe(take(1));
    const waitForBlockToAppear = (apolloClient)=>(offset)=>zenToRx(apolloClient.watchQuery({
                query: BLOCK_QUERY,
                variables: {
                    offset
                },
                pollInterval: DEFAULT_POLL_INTERVAL,
                fetchPolicy: 'no-cache',
                initialFetchPolicy: 'no-cache',
                nextFetchPolicy: 'no-cache'
            }).map(maybeThrowErrors).filter((fetchResult)=>fetchResult.data.block !== null)).pipe(take(1));
    const indexerPublicDataProviderInternal = (queryURL, subscriptionURL, webSocketImpl = undefined)=>{
        const queryURLObj = new URL(queryURL);
        if (queryURLObj.protocol !== 'http:' && queryURLObj.protocol !== 'https:') {
            throw new InvalidProtocolSchemeError(queryURLObj.protocol, [
                'http:',
                'https:'
            ]);
        }
        const subscriptionURLObj = new URL(subscriptionURL);
        if (subscriptionURLObj.protocol !== 'ws:' && subscriptionURLObj.protocol !== 'wss:') {
            throw new InvalidProtocolSchemeError(subscriptionURLObj.protocol, [
                'ws:',
                'wss:'
            ]);
        }
        const link = httpExports.createHttpLink({
            fetch: fetch$1,
            uri: queryURL
        });
        const retryLink = new retryExports.RetryLink({
            delay: {
                initial: 1000,
                max: 10000,
                jitter: true
            },
            attempts: {
                max: 5
            }
        });
        const apolloLink = coreExports.from([
            retryLink,
            link
        ]);
        const apolloClient = new coreExports$1.ApolloClient({
            link: coreExports.split(({ query })=>{
                const definition = utilitiesExports.getMainDefinition(query);
                return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
            }, new subscriptionsExports.GraphQLWsLink(createClient({
                url: subscriptionURL,
                webSocketImpl
            })), apolloLink),
            cache: new coreExports$1.InMemoryCache()
        });
        return {
            async queryContractState (address, config) {
                let offset;
                if (config) {
                    offset = {
                        blockOffset: config.type === 'blockHeight' ? {
                            height: config.blockHeight
                        } : {
                            hash: config.blockHash
                        }
                    };
                } else {
                    offset = null;
                }
                const maybeContractState = await apolloClient.query({
                    query: CONTRACT_STATE_QUERY,
                    variables: {
                        address,
                        offset
                    },
                    fetchPolicy: 'no-cache'
                }).then(maybeThrowErrors).then((queryResult)=>queryResult.data?.contractAction?.state ?? null);
                return maybeContractState ? deserializeContractState(maybeContractState) : null;
            },
            async queryZSwapAndContractState (address, config) {
                let offset;
                if (config) {
                    offset = {
                        blockOffset: config.type === 'blockHeight' ? {
                            height: config.blockHeight
                        } : {
                            hash: config.blockHash
                        }
                    };
                } else {
                    offset = null;
                }
                const maybeContractStates = await apolloClient.query({
                    query: CONTRACT_AND_ZSWAP_STATE_QUERY,
                    variables: {
                        address,
                        offset
                    },
                    fetchPolicy: 'no-cache'
                }).then(maybeThrowErrors).then((queryResult)=>queryResult.data.contractAction);
                return maybeContractStates ? [
                    deserializeZswapState(maybeContractStates.chainState),
                    deserializeContractState(maybeContractStates.state)
                ] : null;
            },
            async queryDeployContractState (contractAddress) {
                return apolloClient.query({
                    query: DEPLOY_CONTRACT_STATE_TX_QUERY,
                    variables: {
                        address: contractAddress
                    },
                    fetchPolicy: 'no-cache'
                }).then((queryResult)=>{
                    if (queryResult.data.contractAction) {
                        const contract = queryResult.data.contractAction;
                        return 'deploy' in contract ? contract.deploy.transaction.contractActions.find(({ address })=>address === contractAddress).state : contract.state;
                    }
                    return null;
                }).then((maybeContractState)=>maybeContractState ? deserializeContractState(maybeContractState) : null);
            },
            async watchForContractState (contractAddress) {
                return firstValueFrom(waitForContractToAppear(apolloClient)(contractAddress)(null).pipe(map(deserializeContractState)));
            },
            async watchForDeployTxData (contractAddress) {
                return firstValueFrom(zenToRx(apolloClient.watchQuery({
                    query: DEPLOY_TX_QUERY,
                    variables: {
                        address: contractAddress
                    },
                    pollInterval: DEFAULT_POLL_INTERVAL,
                    fetchPolicy: 'no-cache',
                    initialFetchPolicy: 'no-cache',
                    nextFetchPolicy: 'no-cache'
                }).filter((maybeQueryResult)=>maybeQueryResult.data.contractAction !== null).map(maybeThrowErrors).map((queryResults)=>{
                    const contract = queryResults.data.contractAction;
                    return 'deploy' in contract ? contract.deploy.transaction : contract.transaction;
                }).map((transaction)=>({
                        tx: deserializeTransaction(transaction.raw),
                        status: toTxStatus(transaction.applyStage),
                        txId: transaction.identifiers[transaction.contractActions.findIndex(({ address })=>address === contractAddress)],
                        txHash: transaction.hash,
                        blockHeight: transaction.block.height,
                        blockHash: transaction.block.hash
                    }))));
            },
            async watchForTxData (txId) {
                return firstValueFrom(zenToRx(apolloClient.watchQuery({
                    query: TX_ID_QUERY,
                    variables: {
                        offset: {
                            identifier: txId
                        }
                    },
                    pollInterval: DEFAULT_POLL_INTERVAL,
                    fetchPolicy: 'no-cache',
                    initialFetchPolicy: 'no-cache',
                    nextFetchPolicy: 'no-cache'
                }).map(maybeThrowErrors).filter((maybeQueryResult)=>maybeQueryResult.data.transactions.length !== 0).map((queryResult)=>queryResult.data.transactions[0]).map((transaction)=>({
                        tx: deserializeTransaction(transaction.raw),
                        status: toTxStatus(transaction.applyStage),
                        txId,
                        txHash: transaction.hash,
                        blockHeight: transaction.block.height,
                        blockHash: transaction.block.hash
                    }))));
            },
            contractStateObservable (contractAddress, config = {
                type: 'latest'
            }) {
                if (config.type === 'txId') {
                    const contractStates = transactionIdToTransaction$(apolloClient)(config.txId).pipe(concatMap(transactionToContractState$(config.txId)));
                    return (config.inclusive ?? true) ? contractStates : contractStates.pipe(skip(1));
                }
                if (config.type === 'latest') {
                    return contractAddressToLatestBlockOffset$(apolloClient)(contractAddress).pipe(concatMap(blockOffsetToBlock$(apolloClient)), concatMap(blockToContractState$(contractAddress)));
                }
                if (config.type === 'all') {
                    return waitForContractToAppear(apolloClient)(contractAddress)(null).pipe(concatMap(()=>blockOffsetToContractState$(apolloClient)(contractAddress)(null)));
                }
                const offset = config.type === 'blockHash' ? {
                    hash: config.blockHash
                } : {
                    height: config.blockHeight
                };
                const blocks = waitForBlockToAppear(apolloClient)(offset).pipe(concatMap(()=>blockOffsetToBlock$(apolloClient)(offset)));
                const maybeShortenedBlocks = config.type === 'blockHeight' || config.type === 'blockHash' ? iif(()=>config.inclusive ?? true, blocks, blocks.pipe(skip(1))) : blocks;
                return maybeShortenedBlocks.pipe(concatMap(blockToContractState$(contractAddress)));
            }
        };
    };
    const indexerPublicDataProvider = (queryURL, subscriptionURL, webSocketImpl = undefined)=>{
        const publicDataProvider = indexerPublicDataProviderInternal(queryURL, subscriptionURL, webSocketImpl);
        return {
            contractStateObservable (contractAddress, config) {
                assertIsContractAddress(contractAddress);
                return publicDataProvider.contractStateObservable(prependNetworkIdHex(contractAddress), config);
            },
            queryContractState (contractAddress, config) {
                assertIsContractAddress(contractAddress);
                return publicDataProvider.queryContractState(prependNetworkIdHex(contractAddress), config);
            },
            queryDeployContractState (contractAddress) {
                assertIsContractAddress(contractAddress);
                return publicDataProvider.queryDeployContractState(prependNetworkIdHex(contractAddress));
            },
            queryZSwapAndContractState (contractAddress, config) {
                assertIsContractAddress(contractAddress);
                return publicDataProvider.queryZSwapAndContractState(prependNetworkIdHex(contractAddress), config);
            },
            watchForContractState (contractAddress) {
                assertIsContractAddress(contractAddress);
                return publicDataProvider.watchForContractState(prependNetworkIdHex(contractAddress));
            },
            watchForDeployTxData (contractAddress) {
                assertIsContractAddress(contractAddress);
                return publicDataProvider.watchForDeployTxData(prependNetworkIdHex(contractAddress));
            },
            watchForTxData (txId) {
                return publicDataProvider.watchForTxData(txId);
            }
        };
    };
    var semver$1 = {
        exports: {}
    };
    var hasRequiredSemver;
    function requireSemver() {
        if (hasRequiredSemver) return semver$1.exports;
        hasRequiredSemver = 1;
        (function(module, exports) {
            var define_process_env_default = {};
            exports = module.exports = SemVer;
            var debug;
            if (typeof process === "object" && define_process_env_default && define_process_env_default.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default.NODE_DEBUG)) {
                debug = function() {
                    var args = Array.prototype.slice.call(arguments, 0);
                    args.unshift("SEMVER");
                    console.log.apply(console, args);
                };
            } else {
                debug = function() {};
            }
            exports.SEMVER_SPEC_VERSION = "2.0.0";
            var MAX_LENGTH = 256;
            var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
            var MAX_SAFE_COMPONENT_LENGTH = 16;
            var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
            var re = exports.re = [];
            var safeRe = exports.safeRe = [];
            var src = exports.src = [];
            var t = exports.tokens = {};
            var R = 0;
            function tok(n) {
                t[n] = R++;
            }
            var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
            var safeRegexReplacements = [
                [
                    "\\s",
                    1
                ],
                [
                    "\\d",
                    MAX_LENGTH
                ],
                [
                    LETTERDASHNUMBER,
                    MAX_SAFE_BUILD_LENGTH
                ]
            ];
            function makeSafeRe(value) {
                for(var i2 = 0; i2 < safeRegexReplacements.length; i2++){
                    var token = safeRegexReplacements[i2][0];
                    var max = safeRegexReplacements[i2][1];
                    value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
                }
                return value;
            }
            tok("NUMERICIDENTIFIER");
            src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
            tok("NUMERICIDENTIFIERLOOSE");
            src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
            tok("NONNUMERICIDENTIFIER");
            src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
            tok("MAINVERSION");
            src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
            tok("MAINVERSIONLOOSE");
            src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
            tok("PRERELEASEIDENTIFIER");
            src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
            tok("PRERELEASEIDENTIFIERLOOSE");
            src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
            tok("PRERELEASE");
            src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
            tok("PRERELEASELOOSE");
            src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
            tok("BUILDIDENTIFIER");
            src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
            tok("BUILD");
            src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
            tok("FULL");
            tok("FULLPLAIN");
            src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
            src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
            tok("LOOSEPLAIN");
            src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
            tok("LOOSE");
            src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
            tok("GTLT");
            src[t.GTLT] = "((?:<|>)?=?)";
            tok("XRANGEIDENTIFIERLOOSE");
            src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
            tok("XRANGEIDENTIFIER");
            src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
            tok("XRANGEPLAIN");
            src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
            tok("XRANGEPLAINLOOSE");
            src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
            tok("XRANGE");
            src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
            tok("XRANGELOOSE");
            src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
            tok("COERCE");
            src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
            tok("COERCERTL");
            re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
            safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
            tok("LONETILDE");
            src[t.LONETILDE] = "(?:~>?)";
            tok("TILDETRIM");
            src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
            re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
            safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
            var tildeTrimReplace = "$1~";
            tok("TILDE");
            src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
            tok("TILDELOOSE");
            src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
            tok("LONECARET");
            src[t.LONECARET] = "(?:\\^)";
            tok("CARETTRIM");
            src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
            re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
            safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
            var caretTrimReplace = "$1^";
            tok("CARET");
            src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
            tok("CARETLOOSE");
            src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
            tok("COMPARATORLOOSE");
            src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
            tok("COMPARATOR");
            src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
            tok("COMPARATORTRIM");
            src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
            re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
            safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
            var comparatorTrimReplace = "$1$2$3";
            tok("HYPHENRANGE");
            src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
            tok("HYPHENRANGELOOSE");
            src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
            tok("STAR");
            src[t.STAR] = "(<|>)?=?\\s*\\*";
            for(var i = 0; i < R; i++){
                debug(i, src[i]);
                if (!re[i]) {
                    re[i] = new RegExp(src[i]);
                    safeRe[i] = new RegExp(makeSafeRe(src[i]));
                }
            }
            exports.parse = parse;
            function parse(version, options) {
                if (!options || typeof options !== "object") {
                    options = {
                        loose: !!options,
                        includePrerelease: false
                    };
                }
                if (version instanceof SemVer) {
                    return version;
                }
                if (typeof version !== "string") {
                    return null;
                }
                if (version.length > MAX_LENGTH) {
                    return null;
                }
                var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
                if (!r.test(version)) {
                    return null;
                }
                try {
                    return new SemVer(version, options);
                } catch (er) {
                    return null;
                }
            }
            exports.valid = valid;
            function valid(version, options) {
                var v = parse(version, options);
                return v ? v.version : null;
            }
            exports.clean = clean;
            function clean(version, options) {
                var s = parse(version.trim().replace(/^[=v]+/, ""), options);
                return s ? s.version : null;
            }
            exports.SemVer = SemVer;
            function SemVer(version, options) {
                if (!options || typeof options !== "object") {
                    options = {
                        loose: !!options,
                        includePrerelease: false
                    };
                }
                if (version instanceof SemVer) {
                    if (version.loose === options.loose) {
                        return version;
                    } else {
                        version = version.version;
                    }
                } else if (typeof version !== "string") {
                    throw new TypeError("Invalid Version: " + version);
                }
                if (version.length > MAX_LENGTH) {
                    throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
                }
                if (!(this instanceof SemVer)) {
                    return new SemVer(version, options);
                }
                debug("SemVer", version, options);
                this.options = options;
                this.loose = !!options.loose;
                var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
                if (!m) {
                    throw new TypeError("Invalid Version: " + version);
                }
                this.raw = version;
                this.major = +m[1];
                this.minor = +m[2];
                this.patch = +m[3];
                if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
                    throw new TypeError("Invalid major version");
                }
                if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
                    throw new TypeError("Invalid minor version");
                }
                if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
                    throw new TypeError("Invalid patch version");
                }
                if (!m[4]) {
                    this.prerelease = [];
                } else {
                    this.prerelease = m[4].split(".").map(function(id) {
                        if (/^[0-9]+$/.test(id)) {
                            var num = +id;
                            if (num >= 0 && num < MAX_SAFE_INTEGER) {
                                return num;
                            }
                        }
                        return id;
                    });
                }
                this.build = m[5] ? m[5].split(".") : [];
                this.format();
            }
            SemVer.prototype.format = function() {
                this.version = this.major + "." + this.minor + "." + this.patch;
                if (this.prerelease.length) {
                    this.version += "-" + this.prerelease.join(".");
                }
                return this.version;
            };
            SemVer.prototype.toString = function() {
                return this.version;
            };
            SemVer.prototype.compare = function(other) {
                debug("SemVer.compare", this.version, this.options, other);
                if (!(other instanceof SemVer)) {
                    other = new SemVer(other, this.options);
                }
                return this.compareMain(other) || this.comparePre(other);
            };
            SemVer.prototype.compareMain = function(other) {
                if (!(other instanceof SemVer)) {
                    other = new SemVer(other, this.options);
                }
                return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
            };
            SemVer.prototype.comparePre = function(other) {
                if (!(other instanceof SemVer)) {
                    other = new SemVer(other, this.options);
                }
                if (this.prerelease.length && !other.prerelease.length) {
                    return -1;
                } else if (!this.prerelease.length && other.prerelease.length) {
                    return 1;
                } else if (!this.prerelease.length && !other.prerelease.length) {
                    return 0;
                }
                var i2 = 0;
                do {
                    var a = this.prerelease[i2];
                    var b = other.prerelease[i2];
                    debug("prerelease compare", i2, a, b);
                    if (a === void 0 && b === void 0) {
                        return 0;
                    } else if (b === void 0) {
                        return 1;
                    } else if (a === void 0) {
                        return -1;
                    } else if (a === b) {
                        continue;
                    } else {
                        return compareIdentifiers(a, b);
                    }
                }while (++i2);
            };
            SemVer.prototype.compareBuild = function(other) {
                if (!(other instanceof SemVer)) {
                    other = new SemVer(other, this.options);
                }
                var i2 = 0;
                do {
                    var a = this.build[i2];
                    var b = other.build[i2];
                    debug("prerelease compare", i2, a, b);
                    if (a === void 0 && b === void 0) {
                        return 0;
                    } else if (b === void 0) {
                        return 1;
                    } else if (a === void 0) {
                        return -1;
                    } else if (a === b) {
                        continue;
                    } else {
                        return compareIdentifiers(a, b);
                    }
                }while (++i2);
            };
            SemVer.prototype.inc = function(release, identifier) {
                switch(release){
                    case "premajor":
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor = 0;
                        this.major++;
                        this.inc("pre", identifier);
                        break;
                    case "preminor":
                        this.prerelease.length = 0;
                        this.patch = 0;
                        this.minor++;
                        this.inc("pre", identifier);
                        break;
                    case "prepatch":
                        this.prerelease.length = 0;
                        this.inc("patch", identifier);
                        this.inc("pre", identifier);
                        break;
                    case "prerelease":
                        if (this.prerelease.length === 0) {
                            this.inc("patch", identifier);
                        }
                        this.inc("pre", identifier);
                        break;
                    case "major":
                        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                            this.major++;
                        }
                        this.minor = 0;
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case "minor":
                        if (this.patch !== 0 || this.prerelease.length === 0) {
                            this.minor++;
                        }
                        this.patch = 0;
                        this.prerelease = [];
                        break;
                    case "patch":
                        if (this.prerelease.length === 0) {
                            this.patch++;
                        }
                        this.prerelease = [];
                        break;
                    case "pre":
                        if (this.prerelease.length === 0) {
                            this.prerelease = [
                                0
                            ];
                        } else {
                            var i2 = this.prerelease.length;
                            while(--i2 >= 0){
                                if (typeof this.prerelease[i2] === "number") {
                                    this.prerelease[i2]++;
                                    i2 = -2;
                                }
                            }
                            if (i2 === -1) {
                                this.prerelease.push(0);
                            }
                        }
                        if (identifier) {
                            if (this.prerelease[0] === identifier) {
                                if (isNaN(this.prerelease[1])) {
                                    this.prerelease = [
                                        identifier,
                                        0
                                    ];
                                }
                            } else {
                                this.prerelease = [
                                    identifier,
                                    0
                                ];
                            }
                        }
                        break;
                    default:
                        throw new Error("invalid increment argument: " + release);
                }
                this.format();
                this.raw = this.version;
                return this;
            };
            exports.inc = inc;
            function inc(version, release, loose, identifier) {
                if (typeof loose === "string") {
                    identifier = loose;
                    loose = void 0;
                }
                try {
                    return new SemVer(version, loose).inc(release, identifier).version;
                } catch (er) {
                    return null;
                }
            }
            exports.diff = diff;
            function diff(version1, version2) {
                if (eq(version1, version2)) {
                    return null;
                } else {
                    var v1 = parse(version1);
                    var v2 = parse(version2);
                    var prefix = "";
                    if (v1.prerelease.length || v2.prerelease.length) {
                        prefix = "pre";
                        var defaultResult = "prerelease";
                    }
                    for(var key in v1){
                        if (key === "major" || key === "minor" || key === "patch") {
                            if (v1[key] !== v2[key]) {
                                return prefix + key;
                            }
                        }
                    }
                    return defaultResult;
                }
            }
            exports.compareIdentifiers = compareIdentifiers;
            var numeric = /^[0-9]+$/;
            function compareIdentifiers(a, b) {
                var anum = numeric.test(a);
                var bnum = numeric.test(b);
                if (anum && bnum) {
                    a = +a;
                    b = +b;
                }
                return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
            }
            exports.rcompareIdentifiers = rcompareIdentifiers;
            function rcompareIdentifiers(a, b) {
                return compareIdentifiers(b, a);
            }
            exports.major = major;
            function major(a, loose) {
                return new SemVer(a, loose).major;
            }
            exports.minor = minor;
            function minor(a, loose) {
                return new SemVer(a, loose).minor;
            }
            exports.patch = patch;
            function patch(a, loose) {
                return new SemVer(a, loose).patch;
            }
            exports.compare = compare;
            function compare(a, b, loose) {
                return new SemVer(a, loose).compare(new SemVer(b, loose));
            }
            exports.compareLoose = compareLoose;
            function compareLoose(a, b) {
                return compare(a, b, true);
            }
            exports.compareBuild = compareBuild;
            function compareBuild(a, b, loose) {
                var versionA = new SemVer(a, loose);
                var versionB = new SemVer(b, loose);
                return versionA.compare(versionB) || versionA.compareBuild(versionB);
            }
            exports.rcompare = rcompare;
            function rcompare(a, b, loose) {
                return compare(b, a, loose);
            }
            exports.sort = sort;
            function sort(list, loose) {
                return list.sort(function(a, b) {
                    return exports.compareBuild(a, b, loose);
                });
            }
            exports.rsort = rsort;
            function rsort(list, loose) {
                return list.sort(function(a, b) {
                    return exports.compareBuild(b, a, loose);
                });
            }
            exports.gt = gt;
            function gt(a, b, loose) {
                return compare(a, b, loose) > 0;
            }
            exports.lt = lt;
            function lt(a, b, loose) {
                return compare(a, b, loose) < 0;
            }
            exports.eq = eq;
            function eq(a, b, loose) {
                return compare(a, b, loose) === 0;
            }
            exports.neq = neq;
            function neq(a, b, loose) {
                return compare(a, b, loose) !== 0;
            }
            exports.gte = gte;
            function gte(a, b, loose) {
                return compare(a, b, loose) >= 0;
            }
            exports.lte = lte;
            function lte(a, b, loose) {
                return compare(a, b, loose) <= 0;
            }
            exports.cmp = cmp;
            function cmp(a, op, b, loose) {
                switch(op){
                    case "===":
                        if (typeof a === "object") a = a.version;
                        if (typeof b === "object") b = b.version;
                        return a === b;
                    case "!==":
                        if (typeof a === "object") a = a.version;
                        if (typeof b === "object") b = b.version;
                        return a !== b;
                    case "":
                    case "=":
                    case "==":
                        return eq(a, b, loose);
                    case "!=":
                        return neq(a, b, loose);
                    case ">":
                        return gt(a, b, loose);
                    case ">=":
                        return gte(a, b, loose);
                    case "<":
                        return lt(a, b, loose);
                    case "<=":
                        return lte(a, b, loose);
                    default:
                        throw new TypeError("Invalid operator: " + op);
                }
            }
            exports.Comparator = Comparator;
            function Comparator(comp, options) {
                if (!options || typeof options !== "object") {
                    options = {
                        loose: !!options,
                        includePrerelease: false
                    };
                }
                if (comp instanceof Comparator) {
                    if (comp.loose === !!options.loose) {
                        return comp;
                    } else {
                        comp = comp.value;
                    }
                }
                if (!(this instanceof Comparator)) {
                    return new Comparator(comp, options);
                }
                comp = comp.trim().split(/\s+/).join(" ");
                debug("comparator", comp, options);
                this.options = options;
                this.loose = !!options.loose;
                this.parse(comp);
                if (this.semver === ANY) {
                    this.value = "";
                } else {
                    this.value = this.operator + this.semver.version;
                }
                debug("comp", this);
            }
            var ANY = {};
            Comparator.prototype.parse = function(comp) {
                var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
                var m = comp.match(r);
                if (!m) {
                    throw new TypeError("Invalid comparator: " + comp);
                }
                this.operator = m[1] !== void 0 ? m[1] : "";
                if (this.operator === "=") {
                    this.operator = "";
                }
                if (!m[2]) {
                    this.semver = ANY;
                } else {
                    this.semver = new SemVer(m[2], this.options.loose);
                }
            };
            Comparator.prototype.toString = function() {
                return this.value;
            };
            Comparator.prototype.test = function(version) {
                debug("Comparator.test", version, this.options.loose);
                if (this.semver === ANY || version === ANY) {
                    return true;
                }
                if (typeof version === "string") {
                    try {
                        version = new SemVer(version, this.options);
                    } catch (er) {
                        return false;
                    }
                }
                return cmp(version, this.operator, this.semver, this.options);
            };
            Comparator.prototype.intersects = function(comp, options) {
                if (!(comp instanceof Comparator)) {
                    throw new TypeError("a Comparator is required");
                }
                if (!options || typeof options !== "object") {
                    options = {
                        loose: !!options,
                        includePrerelease: false
                    };
                }
                var rangeTmp;
                if (this.operator === "") {
                    if (this.value === "") {
                        return true;
                    }
                    rangeTmp = new Range(comp.value, options);
                    return satisfies(this.value, rangeTmp, options);
                } else if (comp.operator === "") {
                    if (comp.value === "") {
                        return true;
                    }
                    rangeTmp = new Range(this.value, options);
                    return satisfies(comp.semver, rangeTmp, options);
                }
                var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
                var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
                var sameSemVer = this.semver.version === comp.semver.version;
                var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
                var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
                var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
                return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
            };
            exports.Range = Range;
            function Range(range, options) {
                if (!options || typeof options !== "object") {
                    options = {
                        loose: !!options,
                        includePrerelease: false
                    };
                }
                if (range instanceof Range) {
                    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                        return range;
                    } else {
                        return new Range(range.raw, options);
                    }
                }
                if (range instanceof Comparator) {
                    return new Range(range.value, options);
                }
                if (!(this instanceof Range)) {
                    return new Range(range, options);
                }
                this.options = options;
                this.loose = !!options.loose;
                this.includePrerelease = !!options.includePrerelease;
                this.raw = range.trim().split(/\s+/).join(" ");
                this.set = this.raw.split("||").map(function(range2) {
                    return this.parseRange(range2.trim());
                }, this).filter(function(c) {
                    return c.length;
                });
                if (!this.set.length) {
                    throw new TypeError("Invalid SemVer Range: " + this.raw);
                }
                this.format();
            }
            Range.prototype.format = function() {
                this.range = this.set.map(function(comps) {
                    return comps.join(" ").trim();
                }).join("||").trim();
                return this.range;
            };
            Range.prototype.toString = function() {
                return this.range;
            };
            Range.prototype.parseRange = function(range) {
                var loose = this.options.loose;
                var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
                range = range.replace(hr, hyphenReplace);
                debug("hyphen replace", range);
                range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
                debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
                range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
                range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
                range = range.split(/\s+/).join(" ");
                var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
                var set = range.split(" ").map(function(comp) {
                    return parseComparator(comp, this.options);
                }, this).join(" ").split(/\s+/);
                if (this.options.loose) {
                    set = set.filter(function(comp) {
                        return !!comp.match(compRe);
                    });
                }
                set = set.map(function(comp) {
                    return new Comparator(comp, this.options);
                }, this);
                return set;
            };
            Range.prototype.intersects = function(range, options) {
                if (!(range instanceof Range)) {
                    throw new TypeError("a Range is required");
                }
                return this.set.some(function(thisComparators) {
                    return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
                        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
                            return rangeComparators.every(function(rangeComparator) {
                                return thisComparator.intersects(rangeComparator, options);
                            });
                        });
                    });
                });
            };
            function isSatisfiable(comparators, options) {
                var result = true;
                var remainingComparators = comparators.slice();
                var testComparator = remainingComparators.pop();
                while(result && remainingComparators.length){
                    result = remainingComparators.every(function(otherComparator) {
                        return testComparator.intersects(otherComparator, options);
                    });
                    testComparator = remainingComparators.pop();
                }
                return result;
            }
            exports.toComparators = toComparators;
            function toComparators(range, options) {
                return new Range(range, options).set.map(function(comp) {
                    return comp.map(function(c) {
                        return c.value;
                    }).join(" ").trim().split(" ");
                });
            }
            function parseComparator(comp, options) {
                debug("comp", comp, options);
                comp = replaceCarets(comp, options);
                debug("caret", comp);
                comp = replaceTildes(comp, options);
                debug("tildes", comp);
                comp = replaceXRanges(comp, options);
                debug("xrange", comp);
                comp = replaceStars(comp, options);
                debug("stars", comp);
                return comp;
            }
            function isX(id) {
                return !id || id.toLowerCase() === "x" || id === "*";
            }
            function replaceTildes(comp, options) {
                return comp.trim().split(/\s+/).map(function(comp2) {
                    return replaceTilde(comp2, options);
                }).join(" ");
            }
            function replaceTilde(comp, options) {
                var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
                return comp.replace(r, function(_, M, m, p, pr) {
                    debug("tilde", comp, _, M, m, p, pr);
                    var ret;
                    if (isX(M)) {
                        ret = "";
                    } else if (isX(m)) {
                        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
                    } else if (isX(p)) {
                        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
                    } else if (pr) {
                        debug("replaceTilde pr", pr);
                        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
                    } else {
                        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
                    }
                    debug("tilde return", ret);
                    return ret;
                });
            }
            function replaceCarets(comp, options) {
                return comp.trim().split(/\s+/).map(function(comp2) {
                    return replaceCaret(comp2, options);
                }).join(" ");
            }
            function replaceCaret(comp, options) {
                debug("caret", comp, options);
                var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
                return comp.replace(r, function(_, M, m, p, pr) {
                    debug("caret", comp, _, M, m, p, pr);
                    var ret;
                    if (isX(M)) {
                        ret = "";
                    } else if (isX(m)) {
                        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
                    } else if (isX(p)) {
                        if (M === "0") {
                            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
                        } else {
                            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
                        }
                    } else if (pr) {
                        debug("replaceCaret pr", pr);
                        if (M === "0") {
                            if (m === "0") {
                                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
                            } else {
                                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
                            }
                        } else {
                            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
                        }
                    } else {
                        debug("no pr");
                        if (M === "0") {
                            if (m === "0") {
                                ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
                            } else {
                                ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
                            }
                        } else {
                            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
                        }
                    }
                    debug("caret return", ret);
                    return ret;
                });
            }
            function replaceXRanges(comp, options) {
                debug("replaceXRanges", comp, options);
                return comp.split(/\s+/).map(function(comp2) {
                    return replaceXRange(comp2, options);
                }).join(" ");
            }
            function replaceXRange(comp, options) {
                comp = comp.trim();
                var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
                return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
                    debug("xRange", comp, ret, gtlt, M, m, p, pr);
                    var xM = isX(M);
                    var xm = xM || isX(m);
                    var xp = xm || isX(p);
                    var anyX = xp;
                    if (gtlt === "=" && anyX) {
                        gtlt = "";
                    }
                    pr = options.includePrerelease ? "-0" : "";
                    if (xM) {
                        if (gtlt === ">" || gtlt === "<") {
                            ret = "<0.0.0-0";
                        } else {
                            ret = "*";
                        }
                    } else if (gtlt && anyX) {
                        if (xm) {
                            m = 0;
                        }
                        p = 0;
                        if (gtlt === ">") {
                            gtlt = ">=";
                            if (xm) {
                                M = +M + 1;
                                m = 0;
                                p = 0;
                            } else {
                                m = +m + 1;
                                p = 0;
                            }
                        } else if (gtlt === "<=") {
                            gtlt = "<";
                            if (xm) {
                                M = +M + 1;
                            } else {
                                m = +m + 1;
                            }
                        }
                        ret = gtlt + M + "." + m + "." + p + pr;
                    } else if (xm) {
                        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
                    } else if (xp) {
                        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
                    }
                    debug("xRange return", ret);
                    return ret;
                });
            }
            function replaceStars(comp, options) {
                debug("replaceStars", comp, options);
                return comp.trim().replace(safeRe[t.STAR], "");
            }
            function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
                if (isX(fM)) {
                    from = "";
                } else if (isX(fm)) {
                    from = ">=" + fM + ".0.0";
                } else if (isX(fp)) {
                    from = ">=" + fM + "." + fm + ".0";
                } else {
                    from = ">=" + from;
                }
                if (isX(tM)) {
                    to = "";
                } else if (isX(tm)) {
                    to = "<" + (+tM + 1) + ".0.0";
                } else if (isX(tp)) {
                    to = "<" + tM + "." + (+tm + 1) + ".0";
                } else if (tpr) {
                    to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
                } else {
                    to = "<=" + to;
                }
                return (from + " " + to).trim();
            }
            Range.prototype.test = function(version) {
                if (!version) {
                    return false;
                }
                if (typeof version === "string") {
                    try {
                        version = new SemVer(version, this.options);
                    } catch (er) {
                        return false;
                    }
                }
                for(var i2 = 0; i2 < this.set.length; i2++){
                    if (testSet(this.set[i2], version, this.options)) {
                        return true;
                    }
                }
                return false;
            };
            function testSet(set, version, options) {
                for(var i2 = 0; i2 < set.length; i2++){
                    if (!set[i2].test(version)) {
                        return false;
                    }
                }
                if (version.prerelease.length && !options.includePrerelease) {
                    for(i2 = 0; i2 < set.length; i2++){
                        debug(set[i2].semver);
                        if (set[i2].semver === ANY) {
                            continue;
                        }
                        if (set[i2].semver.prerelease.length > 0) {
                            var allowed = set[i2].semver;
                            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                return true;
            }
            exports.satisfies = satisfies;
            function satisfies(version, range, options) {
                try {
                    range = new Range(range, options);
                } catch (er) {
                    return false;
                }
                return range.test(version);
            }
            exports.maxSatisfying = maxSatisfying;
            function maxSatisfying(versions, range, options) {
                var max = null;
                var maxSV = null;
                try {
                    var rangeObj = new Range(range, options);
                } catch (er) {
                    return null;
                }
                versions.forEach(function(v) {
                    if (rangeObj.test(v)) {
                        if (!max || maxSV.compare(v) === -1) {
                            max = v;
                            maxSV = new SemVer(max, options);
                        }
                    }
                });
                return max;
            }
            exports.minSatisfying = minSatisfying;
            function minSatisfying(versions, range, options) {
                var min = null;
                var minSV = null;
                try {
                    var rangeObj = new Range(range, options);
                } catch (er) {
                    return null;
                }
                versions.forEach(function(v) {
                    if (rangeObj.test(v)) {
                        if (!min || minSV.compare(v) === 1) {
                            min = v;
                            minSV = new SemVer(min, options);
                        }
                    }
                });
                return min;
            }
            exports.minVersion = minVersion;
            function minVersion(range, loose) {
                range = new Range(range, loose);
                var minver = new SemVer("0.0.0");
                if (range.test(minver)) {
                    return minver;
                }
                minver = new SemVer("0.0.0-0");
                if (range.test(minver)) {
                    return minver;
                }
                minver = null;
                for(var i2 = 0; i2 < range.set.length; ++i2){
                    var comparators = range.set[i2];
                    comparators.forEach(function(comparator) {
                        var compver = new SemVer(comparator.semver.version);
                        switch(comparator.operator){
                            case ">":
                                if (compver.prerelease.length === 0) {
                                    compver.patch++;
                                } else {
                                    compver.prerelease.push(0);
                                }
                                compver.raw = compver.format();
                            case "":
                            case ">=":
                                if (!minver || gt(minver, compver)) {
                                    minver = compver;
                                }
                                break;
                            case "<":
                            case "<=":
                                break;
                            default:
                                throw new Error("Unexpected operation: " + comparator.operator);
                        }
                    });
                }
                if (minver && range.test(minver)) {
                    return minver;
                }
                return null;
            }
            exports.validRange = validRange;
            function validRange(range, options) {
                try {
                    return new Range(range, options).range || "*";
                } catch (er) {
                    return null;
                }
            }
            exports.ltr = ltr;
            function ltr(version, range, options) {
                return outside(version, range, "<", options);
            }
            exports.gtr = gtr;
            function gtr(version, range, options) {
                return outside(version, range, ">", options);
            }
            exports.outside = outside;
            function outside(version, range, hilo, options) {
                version = new SemVer(version, options);
                range = new Range(range, options);
                var gtfn, ltefn, ltfn, comp, ecomp;
                switch(hilo){
                    case ">":
                        gtfn = gt;
                        ltefn = lte;
                        ltfn = lt;
                        comp = ">";
                        ecomp = ">=";
                        break;
                    case "<":
                        gtfn = lt;
                        ltefn = gte;
                        ltfn = gt;
                        comp = "<";
                        ecomp = "<=";
                        break;
                    default:
                        throw new TypeError('Must provide a hilo val of "<" or ">"');
                }
                if (satisfies(version, range, options)) {
                    return false;
                }
                for(var i2 = 0; i2 < range.set.length; ++i2){
                    var comparators = range.set[i2];
                    var high = null;
                    var low = null;
                    comparators.forEach(function(comparator) {
                        if (comparator.semver === ANY) {
                            comparator = new Comparator(">=0.0.0");
                        }
                        high = high || comparator;
                        low = low || comparator;
                        if (gtfn(comparator.semver, high.semver, options)) {
                            high = comparator;
                        } else if (ltfn(comparator.semver, low.semver, options)) {
                            low = comparator;
                        }
                    });
                    if (high.operator === comp || high.operator === ecomp) {
                        return false;
                    }
                    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
                        return false;
                    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
                        return false;
                    }
                }
                return true;
            }
            exports.prerelease = prerelease;
            function prerelease(version, options) {
                var parsed = parse(version, options);
                return parsed && parsed.prerelease.length ? parsed.prerelease : null;
            }
            exports.intersects = intersects;
            function intersects(r1, r2, options) {
                r1 = new Range(r1, options);
                r2 = new Range(r2, options);
                return r1.intersects(r2);
            }
            exports.coerce = coerce;
            function coerce(version, options) {
                if (version instanceof SemVer) {
                    return version;
                }
                if (typeof version === "number") {
                    version = String(version);
                }
                if (typeof version !== "string") {
                    return null;
                }
                options = options || {};
                var match = null;
                if (!options.rtl) {
                    match = version.match(safeRe[t.COERCE]);
                } else {
                    var next;
                    while((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)){
                        if (!match || next.index + next[0].length !== match.index + match[0].length) {
                            match = next;
                        }
                        safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
                    }
                    safeRe[t.COERCERTL].lastIndex = -1;
                }
                if (match === null) {
                    return null;
                }
                return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
            }
        }(semver$1, semver$1.exports));
        return semver$1.exports;
    }
    var semverExports = requireSemver();
    const semver = getDefaultExportFromCjs(semverExports);
    class AuctionAPI {
        static async deploy(_providers, _logger) {
            return new AuctionAPI();
        }
        static async join(_providers, _contractAddress, _logger) {
            return new AuctionAPI();
        }
        state$ = {
            subscribe: (_observer)=>({
                    unsubscribe: ()=>{}
                })
        };
        deployedContractAddress = "mock-address";
        async submitBid(bidAmount) {
            console.log("Mock: Submitting bid:", bidAmount);
        }
        async revealBid(bidAmount, nonce) {
            console.log("Mock: Revealing bid:", {
                bidAmount,
                nonce
            });
        }
        async refreshState() {
            console.log("Mock: Refreshing state");
        }
        async createAuction(productName, productDescription, minimumBid) {
            console.log("Mock: Creating auction:", {
                productName,
                productDescription,
                minimumBid
            });
        }
        async closeBidding() {
            console.log("Mock: Closing bidding");
        }
        async startRevealing() {
            console.log("Mock: Starting revealing");
        }
        async finishAuction() {
            console.log("Mock: Finishing auction");
        }
    }
    class BrowserDeployedAuctionManager {
        constructor(logger){
            this.logger = logger;
            this.auctionDeployments$ = new BehaviorSubject(this.#auctionDeployments.map((deployment)=>deployment.asObservable()));
        }
        auctionDeployments$;
        #initializedProviders;
        #auctionDeployments = [];
        resolve(contractAddress) {
            const deployment = new BehaviorSubject({
                tag: "undeployed"
            });
            this.#auctionDeployments.push(deployment);
            this.auctionDeployments$.next(this.#auctionDeployments.map((d)=>d.asObservable()));
            if (contractAddress) {
                this.joinDeployment(deployment, contractAddress).catch((error)=>{
                    this.logger.error({
                        error
                    }, "Failed to join auction deployment");
                });
            } else {
                this.deployDeployment(deployment).catch((error)=>{
                    this.logger.error({
                        error
                    }, "Failed to deploy auction");
                });
            }
            return deployment;
        }
        getProviders() {
            return this.#initializedProviders ?? (this.#initializedProviders = initializeProviders(this.logger));
        }
        async deployDeployment(deployment) {
            try {
                deployment.next({
                    tag: "deploying"
                });
                const providers = await this.getProviders();
                const api = await AuctionAPI.deploy(providers, this.logger);
                deployment.next({
                    tag: "deployed",
                    api
                });
            } catch (error) {
                deployment.next({
                    tag: "error",
                    error: error instanceof Error ? error : new Error(String(error))
                });
            }
        }
        async joinDeployment(deployment, contractAddress) {
            try {
                deployment.next({
                    tag: "joining",
                    contractAddress
                });
                const providers = await this.getProviders();
                const api = await AuctionAPI.join(providers, contractAddress, this.logger);
                deployment.next({
                    tag: "deployed",
                    api
                });
            } catch (error) {
                deployment.next({
                    tag: "error",
                    error: error instanceof Error ? error : new Error(String(error))
                });
            }
        }
    }
    const initializeProviders = async (logger)=>{
        const { wallet, uris } = await connectToWallet(logger);
        console.log("********* wallet", wallet);
        const walletState = await wallet.state();
        const zkConfigPath = window.location.origin;
        console.log(`Connecting to wallet with network ID: ${getLedgerNetworkId()}`);
        return {
            privateStateProvider: levelPrivateStateProvider({
                privateStateStoreName: "auction-private-state"
            }),
            zkConfigProvider: new FetchZkConfigProvider(zkConfigPath, fetch.bind(window)),
            proofProvider: httpClientProofProvider(uris.proverServerUri),
            publicDataProvider: indexerPublicDataProvider(uris.indexerUri, uris.indexerWsUri),
            walletProvider: {
                coinPublicKey: walletState.coinPublicKey,
                encryptionPublicKey: walletState.encryptionPublicKey,
                balanceTx (tx, newCoins) {
                    return wallet.balanceAndProveTransaction(Transaction$1.deserialize(tx.serialize(getLedgerNetworkId()), getZswapNetworkId()), newCoins).then((zswapTx)=>Transaction$2.deserialize(zswapTx.serialize(getZswapNetworkId()), getLedgerNetworkId())).then(createBalancedTx);
                }
            },
            midnightProvider: {
                submitTx (tx) {
                    return wallet.submitTransaction(tx);
                }
            }
        };
    };
    const connectToWallet = (logger)=>{
        const COMPATIBLE_CONNECTOR_API_VERSION = "1.x";
        return firstValueFrom(pipe(interval(100), map(()=>window.midnight?.mnLace), tap((connectorAPI)=>{
            logger.info(connectorAPI, "Check for wallet connector API");
        }), filter((connectorAPI)=>!!connectorAPI), concatMap((connectorAPI)=>semver.satisfies(connectorAPI.apiVersion, COMPATIBLE_CONNECTOR_API_VERSION) ? of(connectorAPI) : throwError(()=>{
                logger.error({
                    expected: COMPATIBLE_CONNECTOR_API_VERSION,
                    actual: connectorAPI.apiVersion
                }, "Incompatible version of wallet connector API");
                return new Error(`Incompatible version of Midnight Lace wallet found. Require '${COMPATIBLE_CONNECTOR_API_VERSION}', got '${connectorAPI.apiVersion}'.`);
            })), tap((connectorAPI)=>{
            logger.info(connectorAPI, "Compatible wallet connector API found. Connecting.");
        }), take(1), timeout({
            first: 1e3,
            with: ()=>throwError(()=>{
                    logger.error("Could not find wallet connector API");
                    return new Error("Could not find Midnight Lace wallet. Extension installed?");
                })
        }), concatMap(async (connectorAPI)=>{
            const isEnabled = await connectorAPI.isEnabled();
            logger.info(isEnabled, "Wallet connector API enabled status");
            return connectorAPI;
        }), timeout({
            first: 5e3,
            with: ()=>throwError(()=>{
                    logger.error("Wallet connector API has failed to respond");
                    return new Error("Midnight Lace wallet has failed to respond. Extension enabled?");
                })
        }), concatMap(async (connectorAPI)=>({
                walletConnectorAPI: await connectorAPI.enable(),
                connectorAPI
            })), catchError((error, apis)=>error ? throwError(()=>{
                logger.error("Unable to enable connector API");
                return new Error("Application is not authorized");
            }) : apis), concatMap(async ({ walletConnectorAPI, connectorAPI })=>{
            const uris = await connectorAPI.serviceUriConfig();
            logger.info("Connected to wallet connector API and retrieved service configuration");
            return {
                wallet: walletConnectorAPI,
                uris
            };
        })));
    };
    const DeployedAuctionContext = reactExports.createContext(void 0);
    const DeployedAuctionProvider = ({ logger, children })=>jsxRuntimeExports.jsx(DeployedAuctionContext.Provider, {
            value: new BrowserDeployedAuctionManager(logger),
            children
        });
    const useDeployedAuctionContext = ()=>{
        const context = reactExports.useContext(DeployedAuctionContext);
        if (!context) {
            throw new Error("useDeployedAuctionContext must be used within a DeployedAuctionProvider");
        }
        return context;
    };
    const HybridAuctionContext = reactExports.createContext(void 0);
    const HybridAuctionProvider = ({ children })=>{
        const auctionApiProvider = useDeployedAuctionContext();
        const [loading, setLoading] = reactExports.useState(false);
        const [error, setError] = reactExports.useState(null);
        const [auctionState, setAuctionState] = reactExports.useState(null);
        const [currentDeployment, setCurrentDeployment] = reactExports.useState();
        const deployNewAuction = reactExports.useCallback(async (productName, productDescription, minimumBidValue)=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Deploying auction with real providers:", {
                    productName,
                    productDescription,
                    minimumBidValue
                });
                const deployment$ = auctionApiProvider.resolve();
                return new Promise((resolve, reject)=>{
                    const subscription = deployment$.subscribe({
                        next: (deployment)=>{
                            console.log("Deployment status:", deployment.tag);
                            setCurrentDeployment(deployment);
                            if (deployment.tag === "deployed") {
                                console.log("Auction deployed successfully with real providers");
                                setLoading(false);
                                subscription.unsubscribe();
                                resolve();
                            } else if (deployment.tag === "error") {
                                console.error("Deployment error:", deployment.error.message);
                                setError(deployment.error.message);
                                setLoading(false);
                                subscription.unsubscribe();
                                reject(deployment.error);
                            }
                        },
                        error: (err)=>{
                            console.error("Deployment subscription error:", err);
                            setError(err instanceof Error ? err.message : "Error creating auction");
                            setLoading(false);
                            subscription.unsubscribe();
                            reject(err);
                        }
                    });
                    setTimeout(()=>{
                        subscription.unsubscribe();
                        if (loading) {
                            setLoading(false);
                            reject(new Error("Deployment timeout"));
                        }
                    }, 3e4);
                });
            } catch (err) {
                console.error("Deploy auction error:", err);
                const errorMessage = err instanceof Error ? err.message : "Error creating auction";
                setError(errorMessage);
                setLoading(false);
                throw new Error(errorMessage);
            }
        }, [
            auctionApiProvider,
            loading
        ]);
        const joinExistingAuction = reactExports.useCallback(async (contractAddress, role)=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Joining auction with real providers:", {
                    contractAddress,
                    role
                });
                const deployment$ = auctionApiProvider.resolve(contractAddress);
                return new Promise((resolve, reject)=>{
                    const subscription = deployment$.subscribe({
                        next: (deployment)=>{
                            console.log("Join status:", deployment.tag);
                            setCurrentDeployment(deployment);
                            if (deployment.tag === "deployed") {
                                console.log("Joined auction successfully with real providers");
                                setLoading(false);
                                subscription.unsubscribe();
                                resolve();
                            } else if (deployment.tag === "error") {
                                console.error("Join error:", deployment.error.message);
                                setError(deployment.error.message);
                                setLoading(false);
                                subscription.unsubscribe();
                                reject(deployment.error);
                            }
                        },
                        error: (err)=>{
                            console.error("Join subscription error:", err);
                            setError(err instanceof Error ? err.message : "Error joining auction");
                            setLoading(false);
                            subscription.unsubscribe();
                            reject(err);
                        }
                    });
                    setTimeout(()=>{
                        subscription.unsubscribe();
                        if (loading) {
                            setLoading(false);
                            reject(new Error("Join timeout"));
                        }
                    }, 3e4);
                });
            } catch (err) {
                console.error("Join auction error:", err);
                const errorMessage = err instanceof Error ? err.message : "Error joining auction";
                setError(errorMessage);
                setLoading(false);
                throw new Error(errorMessage);
            }
        }, [
            auctionApiProvider,
            loading
        ]);
        const submitBid = reactExports.useCallback(async (amount)=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Submitting bid with real providers:", amount);
                if (currentDeployment && currentDeployment.tag === "deployed") {
                    const auctionAPI = currentDeployment.api;
                    await auctionAPI.submitBid(BigInt(amount * 100));
                    console.log("Bid submitted successfully with real providers");
                    if (auctionState) {
                        setAuctionState({
                            ...auctionState,
                            currentUserBid: {
                                bidAmount: amount * 100,
                                nonce: Array.from(new Uint8Array(32)).map((b)=>b.toString(16).padStart(2, "0")).join(""),
                                commitment: Array.from(new Uint8Array(32)).map((b)=>b.toString(16).padStart(2, "0")).join("")
                            }
                        });
                    }
                } else {
                    throw new Error("No auction deployment available");
                }
                setLoading(false);
            } catch (err) {
                console.error("Submit bid error:", err);
                setError(err instanceof Error ? err.message : "Error submitting bid");
                setLoading(false);
                throw err;
            }
        }, [
            auctionState,
            currentDeployment
        ]);
        const refreshAuctionData = reactExports.useCallback(async ()=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Refreshing auction data with real providers");
                if (currentDeployment && currentDeployment.tag === "deployed") {
                    const auctionAPI = currentDeployment.api;
                    await auctionAPI.refreshState();
                    console.log("Auction data refreshed successfully with real providers");
                } else {
                    console.log("No deployment available for refresh");
                }
                setLoading(false);
            } catch (err) {
                console.error("Refresh data error:", err);
                setError(err instanceof Error ? err.message : "Error refreshing data");
                setLoading(false);
                throw err;
            }
        }, [
            currentDeployment
        ]);
        reactExports.useEffect(()=>{
            if (currentDeployment && currentDeployment.tag === "deployed" && !auctionState) {
                console.log("Initializing auction state from real deployment");
                const subscription = currentDeployment.api.state$.subscribe({
                    next: (apiState)=>{
                        console.log("Received real auction state:", apiState);
                        setAuctionState({
                            auction: {
                                productName: apiState.publicState.productName,
                                productDescription: apiState.publicState.productDescription,
                                minimumBidValue: Number(apiState.publicState.minimumBidValue),
                                auctioneerPublicKey: Array.from(apiState.publicState.auctioneerPublicKey).map((b)=>b.toString(16).padStart(2, "0")).join(""),
                                currentRound: apiState.publicState.currentPhase === "bidding" ? AuctionRound.BIDDING : apiState.publicState.currentPhase === "revealing" ? AuctionRound.REVEALING : AuctionRound.FINISHED,
                                totalBids: Number(apiState.publicState.totalBids),
                                revealedBids: apiState.publicState.revealedBids.map((bid)=>({
                                        participantId: bid.participantId,
                                        bidAmount: Number(bid.bidAmount),
                                        timestamp: Number(bid.timestamp)
                                    }))
                            },
                            currentUserBid: apiState.myCurrentBid ? {
                                bidAmount: Number(apiState.myCurrentBid.bidAmount),
                                nonce: Array.from(apiState.myCurrentBid.commitment || new Uint8Array()).map((b)=>b.toString(16).padStart(2, "0")).join(""),
                                commitment: Array.from(apiState.myCurrentBid.commitment || new Uint8Array()).map((b)=>b.toString(16).padStart(2, "0")).join("")
                            } : void 0,
                            isParticipant: apiState.hasSubmittedBid,
                            canSubmitBid: apiState.canSubmitBid,
                            canRevealBid: apiState.canRevealBid
                        });
                    },
                    error: (err)=>{
                        console.error("Error in auction state stream:", err);
                    }
                });
                return ()=>subscription.unsubscribe();
            } else if (!auctionState && !currentDeployment) {
                console.log("No auction deployment available yet, waiting for deployment or join");
            }
        }, [
            currentDeployment,
            auctionState
        ]);
        const startBiddingPhase = reactExports.useCallback(async ()=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Starting bidding phase with real providers");
                if (currentDeployment && currentDeployment.tag === "deployed") {
                    const auctionAPI = currentDeployment.api;
                    await auctionAPI.createAuction("Product", "Description", BigInt(1e3));
                    console.log("Bidding phase started successfully");
                } else {
                    throw new Error("No auction deployment available");
                }
                setLoading(false);
            } catch (err) {
                console.error("Start bidding phase error:", err);
                setError(err instanceof Error ? err.message : "Error starting bidding phase");
                setLoading(false);
                throw err;
            }
        }, [
            currentDeployment
        ]);
        const closeBidding = reactExports.useCallback(async ()=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Closing bidding phase with real providers");
                if (currentDeployment && currentDeployment.tag === "deployed") {
                    const auctionAPI = currentDeployment.api;
                    await auctionAPI.closeBidding();
                    console.log("Bidding phase closed successfully");
                } else {
                    throw new Error("No auction deployment available");
                }
                setLoading(false);
            } catch (err) {
                console.error("Close bidding error:", err);
                setError(err instanceof Error ? err.message : "Error closing bidding");
                setLoading(false);
                throw err;
            }
        }, [
            currentDeployment
        ]);
        const startRevealingPhase = reactExports.useCallback(async ()=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Starting revealing phase with real providers");
                if (currentDeployment && currentDeployment.tag === "deployed") {
                    const auctionAPI = currentDeployment.api;
                    await auctionAPI.startRevealing();
                    console.log("Revealing phase started successfully");
                } else {
                    throw new Error("No auction deployment available");
                }
                setLoading(false);
            } catch (err) {
                console.error("Start revealing phase error:", err);
                setError(err instanceof Error ? err.message : "Error starting revealing phase");
                setLoading(false);
                throw err;
            }
        }, [
            currentDeployment
        ]);
        const finishAuction = reactExports.useCallback(async ()=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Finishing auction with real providers");
                if (currentDeployment && currentDeployment.tag === "deployed") {
                    const auctionAPI = currentDeployment.api;
                    await auctionAPI.finishAuction();
                    console.log("Auction finished successfully");
                } else {
                    throw new Error("No auction deployment available");
                }
                setLoading(false);
            } catch (err) {
                console.error("Finish auction error:", err);
                setError(err instanceof Error ? err.message : "Error finishing auction");
                setLoading(false);
                throw err;
            }
        }, [
            currentDeployment
        ]);
        const revealSpecificBid = reactExports.useCallback(async (participantId, bidAmount)=>{
            setLoading(true);
            setError(null);
            try {
                console.log("Revealing specific bid with real providers:", {
                    participantId,
                    bidAmount
                });
                if (currentDeployment && currentDeployment.tag === "deployed") {
                    console.log("Bid reveal requested for participant:", participantId, "amount:", bidAmount);
                } else {
                    throw new Error("No auction deployment available");
                }
                setLoading(false);
            } catch (err) {
                console.error("Reveal specific bid error:", err);
                setError(err instanceof Error ? err.message : "Error revealing bid");
                setLoading(false);
                throw err;
            }
        }, [
            currentDeployment
        ]);
        const value = {
            deployNewAuction,
            joinExistingAuction,
            submitBid,
            refreshAuctionData,
            startBiddingPhase,
            closeBidding,
            startRevealingPhase,
            finishAuction,
            revealSpecificBid,
            auctionState,
            loading,
            error
        };
        return jsxRuntimeExports.jsx(HybridAuctionContext.Provider, {
            value,
            children
        });
    };
    const useHybridAuction = ()=>{
        const context = reactExports.useContext(HybridAuctionContext);
        if (!context) {
            throw new Error("useHybridAuction must be used within a HybridAuctionProvider");
        }
        return context;
    };
    function AuctionInfo({ auction, canSubmitBid = false, canRevealBid = false, onSubmitBid, onRevealBid }) {
        const timeRemaining = "Active";
        return jsxRuntimeExports.jsxs(Box, {
            sx: {
                display: "grid",
                gridTemplateColumns: {
                    xs: "1fr",
                    md: "2fr 1fr"
                },
                gap: 2
            },
            children: [
                jsxRuntimeExports.jsxs(Box, {
                    children: [
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h6",
                            gutterBottom: true,
                            children: "Auction Details"
                        }),
                        jsxRuntimeExports.jsxs(Box, {
                            sx: {
                                display: "grid",
                                gridTemplateColumns: {
                                    xs: "1fr",
                                    sm: "1fr 1fr"
                                },
                                gap: 2
                            },
                            children: [
                                jsxRuntimeExports.jsxs(Box, {
                                    children: [
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "text.secondary",
                                            children: "Product Name"
                                        }),
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body1",
                                            children: auction.productName
                                        })
                                    ]
                                }),
                                jsxRuntimeExports.jsxs(Box, {
                                    children: [
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "text.secondary",
                                            children: "Description"
                                        }),
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body1",
                                            children: auction.productDescription
                                        })
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                jsxRuntimeExports.jsxs(Box, {
                    children: [
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h6",
                            gutterBottom: true,
                            children: "Current Status"
                        }),
                        jsxRuntimeExports.jsxs(Box, {
                            sx: {
                                display: "grid",
                                gridTemplateColumns: {
                                    xs: "1fr",
                                    sm: "1fr 1fr"
                                },
                                gap: 2
                            },
                            children: [
                                jsxRuntimeExports.jsxs(Box, {
                                    children: [
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "text.secondary",
                                            children: "Phase"
                                        }),
                                        jsxRuntimeExports.jsx(Chip, {
                                            label: auction.currentRound,
                                            color: auction.currentRound === "bidding" ? "primary" : auction.currentRound === "revealing" ? "warning" : "success",
                                            size: "small"
                                        })
                                    ]
                                }),
                                jsxRuntimeExports.jsxs(Box, {
                                    children: [
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "text.secondary",
                                            children: "Total Bids"
                                        }),
                                        jsxRuntimeExports.jsx(Typography, {
                                            variant: "body1",
                                            children: auction.totalBids
                                        })
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                jsxRuntimeExports.jsx(Divider, {
                    sx: {
                        my: 2
                    }
                }),
                jsxRuntimeExports.jsxs(Box, {
                    sx: {
                        display: "grid",
                        gridTemplateColumns: {
                            xs: "1fr",
                            md: "1fr 1fr 1fr"
                        },
                        gap: 2
                    },
                    children: [
                        jsxRuntimeExports.jsxs(Box, {
                            children: [
                                jsxRuntimeExports.jsx(Typography, {
                                    variant: "h6",
                                    gutterBottom: true,
                                    children: "Bidding Information"
                                }),
                                jsxRuntimeExports.jsxs(Box, {
                                    sx: {
                                        display: "grid",
                                        gridTemplateColumns: "1fr",
                                        gap: 1
                                    },
                                    children: [
                                        jsxRuntimeExports.jsxs(Box, {
                                            children: [
                                                jsxRuntimeExports.jsx(Typography, {
                                                    variant: "body2",
                                                    color: "text.secondary",
                                                    children: "Minimum Bid"
                                                }),
                                                jsxRuntimeExports.jsxs(Typography, {
                                                    variant: "body1",
                                                    sx: {
                                                        display: "flex",
                                                        alignItems: "center",
                                                        gap: 1
                                                    },
                                                    children: [
                                                        jsxRuntimeExports.jsx(AttachMoney, {}),
                                                        auction.minimumBidValue
                                                    ]
                                                })
                                            ]
                                        }),
                                        jsxRuntimeExports.jsxs(Box, {
                                            children: [
                                                jsxRuntimeExports.jsx(Typography, {
                                                    variant: "body2",
                                                    color: "text.secondary",
                                                    children: "Time Remaining"
                                                }),
                                                jsxRuntimeExports.jsxs(Typography, {
                                                    variant: "body1",
                                                    sx: {
                                                        display: "flex",
                                                        alignItems: "center",
                                                        gap: 1
                                                    },
                                                    children: [
                                                        jsxRuntimeExports.jsx(Timer, {}),
                                                        timeRemaining
                                                    ]
                                                })
                                            ]
                                        })
                                    ]
                                })
                            ]
                        }),
                        jsxRuntimeExports.jsxs(Box, {
                            children: [
                                jsxRuntimeExports.jsx(Typography, {
                                    variant: "h6",
                                    gutterBottom: true,
                                    children: "Auctioneer"
                                }),
                                jsxRuntimeExports.jsx(Box, {
                                    sx: {
                                        display: "grid",
                                        gridTemplateColumns: "1fr",
                                        gap: 1
                                    },
                                    children: jsxRuntimeExports.jsxs(Box, {
                                        children: [
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "body2",
                                                color: "text.secondary",
                                                children: "Public Key"
                                            }),
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "body1",
                                                sx: {
                                                    fontFamily: "monospace",
                                                    fontSize: "0.8rem"
                                                },
                                                children: auction.auctioneerPublicKey
                                            })
                                        ]
                                    })
                                })
                            ]
                        }),
                        jsxRuntimeExports.jsxs(Box, {
                            children: [
                                jsxRuntimeExports.jsx(Typography, {
                                    variant: "h6",
                                    gutterBottom: true,
                                    children: "Actions"
                                }),
                                jsxRuntimeExports.jsxs(Box, {
                                    sx: {
                                        display: "grid",
                                        gridTemplateColumns: "1fr",
                                        gap: 1
                                    },
                                    children: [
                                        canSubmitBid && onSubmitBid && jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "primary",
                                            children: "✓ Can submit bid"
                                        }),
                                        canRevealBid && onRevealBid && jsxRuntimeExports.jsx(Typography, {
                                            variant: "body2",
                                            color: "secondary",
                                            children: "✓ Can reveal bid"
                                        })
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                auction.revealedBids && auction.revealedBids.length > 0 && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [
                        jsxRuntimeExports.jsx(Divider, {
                            sx: {
                                my: 2
                            }
                        }),
                        jsxRuntimeExports.jsxs(Box, {
                            children: [
                                jsxRuntimeExports.jsx(Typography, {
                                    variant: "h6",
                                    gutterBottom: true,
                                    children: "Revealed Bids"
                                }),
                                jsxRuntimeExports.jsx(Box, {
                                    sx: {
                                        display: "grid",
                                        gridTemplateColumns: "1fr",
                                        gap: 1
                                    },
                                    children: auction.revealedBids.map((bid, index)=>jsxRuntimeExports.jsx(Box, {
                                            sx: {
                                                p: 1,
                                                border: "1px solid",
                                                borderColor: "divider",
                                                borderRadius: 1
                                            },
                                            children: jsxRuntimeExports.jsxs(Typography, {
                                                variant: "body2",
                                                children: [
                                                    "Bid #",
                                                    index + 1,
                                                    ": $",
                                                    bid.bidAmount
                                                ]
                                            })
                                        }, index))
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    }
    function BidForm({ minimumBidValue, canSubmitBid, hasSubmittedBid, isParticipant, onSubmitBid, loading = false, error = null }) {
        const [bidAmount, setBidAmount] = reactExports.useState("");
        const [localError, setLocalError] = reactExports.useState(null);
        const handleSubmit = async (e)=>{
            e.preventDefault();
            setLocalError(null);
            if (!bidAmount || isNaN(Number(bidAmount))) {
                setLocalError("Please enter a valid bid amount");
                return;
            }
            const amount = Number(bidAmount);
            if (amount < minimumBidValue) {
                setLocalError(`Bid must be at least ${minimumBidValue}`);
                return;
            }
            try {
                await onSubmitBid(amount);
                setBidAmount("");
            } catch (err) {
                setLocalError(err instanceof Error ? err.message : "Failed to submit bid");
            }
        };
        if (!isParticipant) {
            return null;
        }
        if (hasSubmittedBid) {
            return jsxRuntimeExports.jsx(Card, {
                children: jsxRuntimeExports.jsxs(CardContent, {
                    children: [
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h6",
                            gutterBottom: true,
                            children: "Bid Submitted"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "body2",
                            color: "text.secondary",
                            children: "You have already submitted a bid for this auction."
                        })
                    ]
                })
            });
        }
        if (!canSubmitBid) {
            return jsxRuntimeExports.jsx(Card, {
                children: jsxRuntimeExports.jsxs(CardContent, {
                    children: [
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h6",
                            gutterBottom: true,
                            children: "Bidding Closed"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "body2",
                            color: "text.secondary",
                            children: "Bidding is not currently open for this auction."
                        })
                    ]
                })
            });
        }
        return jsxRuntimeExports.jsx(Card, {
            children: jsxRuntimeExports.jsxs(CardContent, {
                children: [
                    jsxRuntimeExports.jsx(Typography, {
                        variant: "h6",
                        gutterBottom: true,
                        children: "Submit Your Bid"
                    }),
                    jsxRuntimeExports.jsx(Typography, {
                        variant: "body2",
                        color: "text.secondary",
                        paragraph: true,
                        children: "Enter your bid amount. Your bid will be kept private until the revealing phase."
                    }),
                    (error || localError) && jsxRuntimeExports.jsx(Alert, {
                        severity: "error",
                        sx: {
                            mb: 2
                        },
                        children: error || localError
                    }),
                    jsxRuntimeExports.jsxs(Box, {
                        component: "form",
                        onSubmit: handleSubmit,
                        sx: {
                            display: "grid",
                            gap: 2
                        },
                        children: [
                            jsxRuntimeExports.jsx(TextField, {
                                fullWidth: true,
                                label: "Bid Amount (USD)",
                                type: "number",
                                value: bidAmount,
                                onChange: (e)=>setBidAmount(e.target.value),
                                required: true,
                                inputProps: {
                                    min: minimumBidValue,
                                    step: 0.01
                                },
                                InputProps: {
                                    startAdornment: jsxRuntimeExports.jsx(AttachMoney, {
                                        sx: {
                                            mr: 1
                                        }
                                    })
                                },
                                helperText: `Minimum bid: $${minimumBidValue}`
                            }),
                            jsxRuntimeExports.jsx(Button, {
                                type: "submit",
                                variant: "contained",
                                color: "primary",
                                disabled: loading || !bidAmount,
                                startIcon: loading ? jsxRuntimeExports.jsx(CircularProgress, {
                                    size: 20
                                }) : jsxRuntimeExports.jsx(Lock, {}),
                                fullWidth: true,
                                children: loading ? "Submitting..." : "Submit Private Bid"
                            })
                        ]
                    })
                ]
            })
        });
    }
    function JoinParticipantPage() {
        const navigate = useNavigate();
        const { joinExistingAuction, loading, error } = useHybridAuction();
        const [contractAddress, setContractAddress] = reactExports.useState("");
        const [localError, setLocalError] = reactExports.useState(null);
        const handleJoinAuction = async ()=>{
            if (!contractAddress.trim()) {
                setLocalError("Please enter the contract address");
                return;
            }
            if (!contractAddress.startsWith("0x")) {
                setLocalError("The contract address must have the correct format (0x...)");
                return;
            }
            setLocalError(null);
            try {
                await joinExistingAuction(contractAddress, "participant");
                navigate(`/auction/${contractAddress}?role=participant`);
            } catch (err) {
                setLocalError(err instanceof Error ? err.message : "Error joining auction");
            }
        };
        const handleBack = ()=>{
            navigate("/");
        };
        const handleAddressChange = (event)=>{
            setContractAddress(event.target.value);
            if (localError) setLocalError(null);
        };
        return jsxRuntimeExports.jsxs(Container, {
            maxWidth: "md",
            sx: {
                mt: 4,
                mb: 4
            },
            children: [
                jsxRuntimeExports.jsxs(Box, {
                    mb: 4,
                    children: [
                        jsxRuntimeExports.jsx(Button, {
                            startIcon: jsxRuntimeExports.jsx(ArrowBack, {}),
                            onClick: handleBack,
                            sx: {
                                mb: 2
                            },
                            children: "Back to Home"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h4",
                            component: "h1",
                            gutterBottom: true,
                            children: "Join as Participant"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "body1",
                            color: "text.secondary",
                            children: "Enter the auction contract address to participate"
                        })
                    ]
                }),
                jsxRuntimeExports.jsx(Card, {
                    children: jsxRuntimeExports.jsxs(CardContent, {
                        sx: {
                            p: 4
                        },
                        children: [
                            (error || localError) && jsxRuntimeExports.jsx(Alert, {
                                severity: "error",
                                sx: {
                                    mb: 3
                                },
                                children: error || localError
                            }),
                            jsxRuntimeExports.jsx(Box, {
                                mb: 3,
                                children: jsxRuntimeExports.jsx(TextField, {
                                    fullWidth: true,
                                    label: "Contract Address",
                                    value: contractAddress,
                                    onChange: handleAddressChange,
                                    placeholder: "0x1234567890abcdef1234567890abcdef12345678",
                                    variant: "outlined",
                                    InputProps: {
                                        startAdornment: jsxRuntimeExports.jsx(InputAdornment, {
                                            position: "start",
                                            children: jsxRuntimeExports.jsx(Search, {})
                                        })
                                    },
                                    helperText: "Paste here the auction contract address provided by the auctioneer"
                                })
                            }),
                            jsxRuntimeExports.jsxs(Box, {
                                display: "flex",
                                justifyContent: "space-between",
                                children: [
                                    jsxRuntimeExports.jsx(Button, {
                                        variant: "outlined",
                                        onClick: handleBack,
                                        size: "large",
                                        children: "Cancel"
                                    }),
                                    jsxRuntimeExports.jsx(Button, {
                                        variant: "contained",
                                        color: "secondary",
                                        onClick: handleJoinAuction,
                                        disabled: !contractAddress.trim() || loading,
                                        startIcon: jsxRuntimeExports.jsx(PersonAdd, {}),
                                        size: "large",
                                        children: loading ? "Connecting..." : "Join Auction"
                                    })
                                ]
                            })
                        ]
                    })
                }),
                jsxRuntimeExports.jsx(Box, {
                    mt: 4,
                    children: jsxRuntimeExports.jsx(Alert, {
                        severity: "info",
                        children: jsxRuntimeExports.jsxs(Typography, {
                            variant: "body2",
                            children: [
                                jsxRuntimeExports.jsx("strong", {
                                    children: "How to participate?"
                                }),
                                jsxRuntimeExports.jsx("br", {}),
                                "1. Get the contract address from the auctioneer",
                                jsxRuntimeExports.jsx("br", {}),
                                "2. Paste it in the field above",
                                jsxRuntimeExports.jsx("br", {}),
                                "3. Once connected, you can submit private bids",
                                jsxRuntimeExports.jsx("br", {}),
                                "4. The auctioneer will reveal the bids at the end of the auction"
                            ]
                        })
                    })
                }),
                jsxRuntimeExports.jsx(Box, {
                    mt: 3,
                    children: jsxRuntimeExports.jsx(Alert, {
                        severity: "warning",
                        children: jsxRuntimeExports.jsxs(Typography, {
                            variant: "body2",
                            children: [
                                jsxRuntimeExports.jsx("strong", {
                                    children: "Important:"
                                }),
                                " You can only participate if the auction is in the bidding phase. Once the bids are closed, you won't be able to join."
                            ]
                        })
                    })
                })
            ]
        });
    }
    function JoinAuctioneerPage() {
        const navigate = useNavigate();
        const { joinExistingAuction, loading, error } = useHybridAuction();
        const [contractAddress, setContractAddress] = reactExports.useState("");
        const [localError, setLocalError] = reactExports.useState(null);
        const handleAccessAuction = async ()=>{
            if (!contractAddress.trim()) {
                setLocalError("Please enter the contract address");
                return;
            }
            if (!contractAddress.startsWith("0x")) {
                setLocalError("The contract address must have the correct format (0x...)");
                return;
            }
            setLocalError(null);
            try {
                await joinExistingAuction(contractAddress, "auctioneer");
                navigate(`/auction/${contractAddress}?role=auctioneer`);
            } catch (err) {
                setLocalError(err instanceof Error ? err.message : "Error accessing auction");
            }
        };
        const handleBack = ()=>{
            navigate("/");
        };
        const handleAddressChange = (event)=>{
            setContractAddress(event.target.value);
            if (localError) setLocalError(null);
        };
        return jsxRuntimeExports.jsxs(Container, {
            maxWidth: "md",
            sx: {
                mt: 4,
                mb: 4
            },
            children: [
                jsxRuntimeExports.jsxs(Box, {
                    mb: 4,
                    children: [
                        jsxRuntimeExports.jsx(Button, {
                            startIcon: jsxRuntimeExports.jsx(ArrowBack, {}),
                            onClick: handleBack,
                            sx: {
                                mb: 2
                            },
                            children: "Back to Home"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "h4",
                            component: "h1",
                            gutterBottom: true,
                            children: "Access as Auctioneer"
                        }),
                        jsxRuntimeExports.jsx(Typography, {
                            variant: "body1",
                            color: "text.secondary",
                            children: "Enter your auction contract address to manage it"
                        })
                    ]
                }),
                jsxRuntimeExports.jsx(Card, {
                    children: jsxRuntimeExports.jsxs(CardContent, {
                        sx: {
                            p: 4
                        },
                        children: [
                            (error || localError) && jsxRuntimeExports.jsx(Alert, {
                                severity: "error",
                                sx: {
                                    mb: 3
                                },
                                children: error || localError
                            }),
                            jsxRuntimeExports.jsx(Box, {
                                mb: 3,
                                children: jsxRuntimeExports.jsx(TextField, {
                                    fullWidth: true,
                                    label: "Contract Address",
                                    value: contractAddress,
                                    onChange: handleAddressChange,
                                    placeholder: "0x1234567890abcdef1234567890abcdef12345678",
                                    variant: "outlined",
                                    InputProps: {
                                        startAdornment: jsxRuntimeExports.jsx(InputAdornment, {
                                            position: "start",
                                            children: jsxRuntimeExports.jsx(Search, {})
                                        })
                                    },
                                    helperText: "Enter the contract address of the auction you created"
                                })
                            }),
                            jsxRuntimeExports.jsxs(Box, {
                                display: "flex",
                                justifyContent: "space-between",
                                children: [
                                    jsxRuntimeExports.jsx(Button, {
                                        variant: "outlined",
                                        onClick: handleBack,
                                        size: "large",
                                        children: "Cancel"
                                    }),
                                    jsxRuntimeExports.jsx(Button, {
                                        variant: "contained",
                                        color: "success",
                                        onClick: handleAccessAuction,
                                        disabled: !contractAddress.trim() || loading,
                                        startIcon: jsxRuntimeExports.jsx(Gavel, {}),
                                        size: "large",
                                        children: loading ? "Verifying..." : "Access as Auctioneer"
                                    })
                                ]
                            })
                        ]
                    })
                }),
                jsxRuntimeExports.jsx(Box, {
                    mt: 4,
                    children: jsxRuntimeExports.jsx(Alert, {
                        severity: "info",
                        children: jsxRuntimeExports.jsxs(Typography, {
                            variant: "body2",
                            children: [
                                jsxRuntimeExports.jsx("strong", {
                                    children: "Auctioneer Panel"
                                }),
                                jsxRuntimeExports.jsx("br", {}),
                                "As an auctioneer you will have access to:",
                                jsxRuntimeExports.jsx("br", {}),
                                "• View all private bids received",
                                jsxRuntimeExports.jsx("br", {}),
                                "• Control auction phases",
                                jsxRuntimeExports.jsx("br", {}),
                                "• Reveal bids when you decide",
                                jsxRuntimeExports.jsx("br", {}),
                                "• Manage the complete auction process"
                            ]
                        })
                    })
                }),
                jsxRuntimeExports.jsx(Box, {
                    mt: 3,
                    children: jsxRuntimeExports.jsx(Alert, {
                        severity: "warning",
                        children: jsxRuntimeExports.jsxs(Typography, {
                            variant: "body2",
                            children: [
                                jsxRuntimeExports.jsx("strong", {
                                    children: "Security:"
                                }),
                                " Only the original creator of the auction can access as an auctioneer. The system will verify your permissions automatically."
                            ]
                        })
                    })
                })
            ]
        });
    }
    function AuctioneerPanel({ currentRound, canSubmitBid, totalBids, revealedBidsCount }) {
        const { closeBidding, startRevealingPhase, finishAuction, revealSpecificBid, loading, error } = useHybridAuction();
        const [revealDialogOpen, setRevealDialogOpen] = reactExports.useState(false);
        const [participantId, setParticipantId] = reactExports.useState("");
        const [bidAmount, setBidAmount] = reactExports.useState("");
        const handleCloseBidding = async ()=>{
            try {
                await closeBidding();
            } catch (error2) {
                console.error("Failed to close bidding:", error2);
            }
        };
        const handleStartRevealing = async ()=>{
            try {
                await startRevealingPhase();
            } catch (error2) {
                console.error("Failed to start revealing:", error2);
            }
        };
        const handleFinishAuction = async ()=>{
            try {
                await finishAuction();
            } catch (error2) {
                console.error("Failed to finish auction:", error2);
            }
        };
        const handleRevealBid = async ()=>{
            if (!participantId || !bidAmount) {
                return;
            }
            const amount = parseFloat(bidAmount);
            if (isNaN(amount)) {
                return;
            }
            try {
                await revealSpecificBid(participantId, amount);
                setRevealDialogOpen(false);
                setParticipantId("");
                setBidAmount("");
            } catch (err) {
                console.error("Error revealing bid:", err);
            }
        };
        const getRoundStatus = ()=>{
            switch(currentRound){
                case AuctionRound.BIDDING:
                    return {
                        label: "Bidding Round",
                        color: "primary",
                        description: canSubmitBid ? "Bids are open" : "Bids are closed"
                    };
                case AuctionRound.REVEALING:
                    return {
                        label: "Revelation Phase",
                        color: "warning",
                        description: "You can reveal bids manually"
                    };
                case AuctionRound.FINISHED:
                    return {
                        label: "Auction Finished",
                        color: "success",
                        description: "The auction has ended"
                    };
                default:
                    return {
                        label: "Unknown Status",
                        color: "default",
                        description: ""
                    };
            }
        };
        const status = getRoundStatus();
        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx(Card, {
                    children: jsxRuntimeExports.jsxs(CardContent, {
                        children: [
                            jsxRuntimeExports.jsx(Typography, {
                                variant: "h6",
                                gutterBottom: true,
                                children: "🔨 Auctioneer Control Panel"
                            }),
                            error && jsxRuntimeExports.jsx(Alert, {
                                severity: "error",
                                sx: {
                                    mb: 2
                                },
                                children: error
                            }),
                            jsxRuntimeExports.jsxs(Box, {
                                mb: 3,
                                children: [
                                    jsxRuntimeExports.jsxs(Box, {
                                        display: "flex",
                                        alignItems: "center",
                                        mb: 1,
                                        children: [
                                            jsxRuntimeExports.jsx(Chip, {
                                                label: status.label,
                                                color: status.color,
                                                sx: {
                                                    mr: 2
                                                }
                                            }),
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "body2",
                                                color: "text.secondary",
                                                children: status.description
                                            })
                                        ]
                                    }),
                                    jsxRuntimeExports.jsxs(Typography, {
                                        variant: "body2",
                                        color: "text.secondary",
                                        children: [
                                            "Bids received: ",
                                            totalBids,
                                            " | Bids revealed: ",
                                            revealedBidsCount
                                        ]
                                    })
                                ]
                            }),
                            jsxRuntimeExports.jsxs(Box, {
                                mb: 3,
                                children: [
                                    jsxRuntimeExports.jsx(Typography, {
                                        variant: "subtitle2",
                                        gutterBottom: true,
                                        children: "Auction Progress"
                                    }),
                                    jsxRuntimeExports.jsxs(Box, {
                                        display: "flex",
                                        alignItems: "center",
                                        gap: 1,
                                        children: [
                                            jsxRuntimeExports.jsx(Box, {
                                                sx: {
                                                    width: 20,
                                                    height: 20,
                                                    borderRadius: "50%",
                                                    backgroundColor: currentRound === AuctionRound.BIDDING ? "primary.main" : "success.main",
                                                    display: "flex",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    color: "white",
                                                    fontSize: "12px",
                                                    fontWeight: "bold"
                                                },
                                                children: "1"
                                            }),
                                            jsxRuntimeExports.jsx(Box, {
                                                sx: {
                                                    flex: 1,
                                                    height: 2,
                                                    backgroundColor: currentRound === AuctionRound.BIDDING ? "grey.300" : "success.main"
                                                }
                                            }),
                                            jsxRuntimeExports.jsx(Box, {
                                                sx: {
                                                    width: 20,
                                                    height: 20,
                                                    borderRadius: "50%",
                                                    backgroundColor: currentRound === AuctionRound.REVEALING ? "warning.main" : currentRound === AuctionRound.FINISHED ? "success.main" : "grey.300",
                                                    display: "flex",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    color: "white",
                                                    fontSize: "12px",
                                                    fontWeight: "bold"
                                                },
                                                children: "2"
                                            }),
                                            jsxRuntimeExports.jsx(Box, {
                                                sx: {
                                                    flex: 1,
                                                    height: 2,
                                                    backgroundColor: currentRound === AuctionRound.FINISHED ? "success.main" : "grey.300"
                                                }
                                            }),
                                            jsxRuntimeExports.jsx(Box, {
                                                sx: {
                                                    width: 20,
                                                    height: 20,
                                                    borderRadius: "50%",
                                                    backgroundColor: currentRound === AuctionRound.FINISHED ? "success.main" : "grey.300",
                                                    display: "flex",
                                                    alignItems: "center",
                                                    justifyContent: "center",
                                                    color: "white",
                                                    fontSize: "12px",
                                                    fontWeight: "bold"
                                                },
                                                children: "3"
                                            })
                                        ]
                                    }),
                                    jsxRuntimeExports.jsxs(Box, {
                                        display: "flex",
                                        justifyContent: "space-between",
                                        mt: 1,
                                        children: [
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "caption",
                                                color: "text.secondary",
                                                children: "Bidding"
                                            }),
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "caption",
                                                color: "text.secondary",
                                                children: "Revelation"
                                            }),
                                            jsxRuntimeExports.jsx(Typography, {
                                                variant: "caption",
                                                color: "text.secondary",
                                                children: "Finished"
                                            })
                                        ]
                                    })
                                ]
                            }),
                            jsxRuntimeExports.jsx(Divider, {
                                sx: {
                                    mb: 3
                                }
                            }),
                            jsxRuntimeExports.jsx(Typography, {
                                variant: "h6",
                                gutterBottom: true,
                                children: "Phase Control"
                            }),
                            jsxRuntimeExports.jsxs(Box, {
                                sx: {
                                    display: "grid",
                                    gridTemplateColumns: {
                                        xs: "1fr",
                                        md: "1fr 1fr"
                                    },
                                    gap: 2
                                },
                                children: [
                                    jsxRuntimeExports.jsx(Card, {
                                        children: jsxRuntimeExports.jsxs(CardContent, {
                                            children: [
                                                jsxRuntimeExports.jsx(Typography, {
                                                    variant: "h6",
                                                    gutterBottom: true,
                                                    children: "Bidding Phase"
                                                }),
                                                jsxRuntimeExports.jsxs(Typography, {
                                                    variant: "body2",
                                                    color: "text.secondary",
                                                    paragraph: true,
                                                    children: [
                                                        "Current phase: ",
                                                        currentRound
                                                    ]
                                                }),
                                                jsxRuntimeExports.jsx(Button, {
                                                    variant: "contained",
                                                    color: "primary",
                                                    onClick: handleCloseBidding,
                                                    disabled: currentRound !== AuctionRound.BIDDING,
                                                    fullWidth: true,
                                                    children: "Close Bidding"
                                                })
                                            ]
                                        })
                                    }),
                                    jsxRuntimeExports.jsx(Card, {
                                        children: jsxRuntimeExports.jsxs(CardContent, {
                                            children: [
                                                jsxRuntimeExports.jsx(Typography, {
                                                    variant: "h6",
                                                    gutterBottom: true,
                                                    children: "Revealing Phase"
                                                }),
                                                jsxRuntimeExports.jsx(Typography, {
                                                    variant: "body2",
                                                    color: "text.secondary",
                                                    paragraph: true,
                                                    children: "Reveal all submitted bids"
                                                }),
                                                jsxRuntimeExports.jsx(Button, {
                                                    variant: "contained",
                                                    color: "secondary",
                                                    onClick: handleStartRevealing,
                                                    disabled: currentRound !== AuctionRound.BIDDING,
                                                    fullWidth: true,
                                                    children: "Start Revealing"
                                                })
                                            ]
                                        })
                                    }),
                                    jsxRuntimeExports.jsx(Card, {
                                        sx: {
                                            gridColumn: {
                                                xs: "1",
                                                md: "1 / -1"
                                            }
                                        },
                                        children: jsxRuntimeExports.jsxs(CardContent, {
                                            children: [
                                                jsxRuntimeExports.jsx(Typography, {
                                                    variant: "h6",
                                                    gutterBottom: true,
                                                    children: "Auction Results"
                                                }),
                                                jsxRuntimeExports.jsx(Typography, {
                                                    variant: "body2",
                                                    color: "text.secondary",
                                                    paragraph: true,
                                                    children: "View final results and determine winner"
                                                }),
                                                jsxRuntimeExports.jsx(Button, {
                                                    variant: "contained",
                                                    color: "success",
                                                    onClick: handleFinishAuction,
                                                    disabled: currentRound !== AuctionRound.REVEALING,
                                                    fullWidth: true,
                                                    children: "Finish Auction"
                                                })
                                            ]
                                        })
                                    })
                                ]
                            }),
                            jsxRuntimeExports.jsx(Divider, {
                                sx: {
                                    mt: 3,
                                    mb: 3
                                }
                            }),
                            currentRound === AuctionRound.REVEALING && jsxRuntimeExports.jsxs(Box, {
                                children: [
                                    jsxRuntimeExports.jsx(Typography, {
                                        variant: "h6",
                                        gutterBottom: true,
                                        children: "Reveal Bids"
                                    }),
                                    jsxRuntimeExports.jsx(Button, {
                                        variant: "contained",
                                        color: "warning",
                                        onClick: ()=>setRevealDialogOpen(true),
                                        disabled: loading,
                                        startIcon: jsxRuntimeExports.jsx(Flag, {}),
                                        fullWidth: true,
                                        children: "Reveal Specific Bid"
                                    })
                                ]
                            })
                        ]
                    })
                }),
                jsxRuntimeExports.jsxs(Dialog, {
                    open: revealDialogOpen,
                    onClose: ()=>setRevealDialogOpen(false),
                    children: [
                        jsxRuntimeExports.jsx(DialogTitle, {
                            children: "Reveal Bid"
                        }),
                        jsxRuntimeExports.jsx(DialogContent, {
                            children: jsxRuntimeExports.jsxs(Box, {
                                sx: {
                                    pt: 1
                                },
                                children: [
                                    jsxRuntimeExports.jsx(TextField, {
                                        fullWidth: true,
                                        label: "Participant ID",
                                        value: participantId,
                                        onChange: (e)=>setParticipantId(e.target.value),
                                        placeholder: "user123",
                                        sx: {
                                            mb: 2
                                        }
                                    }),
                                    jsxRuntimeExports.jsx(TextField, {
                                        fullWidth: true,
                                        label: "Bid Amount",
                                        type: "number",
                                        value: bidAmount,
                                        onChange: (e)=>setBidAmount(e.target.value),
                                        placeholder: "2500"
                                    })
                                ]
                            })
                        }),
                        jsxRuntimeExports.jsxs(DialogActions, {
                            children: [
                                jsxRuntimeExports.jsx(Button, {
                                    onClick: ()=>setRevealDialogOpen(false),
                                    children: "Cancel"
                                }),
                                jsxRuntimeExports.jsx(Button, {
                                    onClick: handleRevealBid,
                                    disabled: !participantId || !bidAmount || loading,
                                    variant: "contained",
                                    children: "Reveal Bid"
                                })
                            ]
                        })
                    ]
                })
            ]
        });
    }
    function AuctionApp() {
        const { contractAddress } = useParams();
        const [searchParams] = useSearchParams();
        const location = useLocation();
        const navigate = useNavigate();
        const role = searchParams.get("role") || "participant";
        const { auctionState, submitBid, refreshAuctionData, joinExistingAuction, loading, error } = useHybridAuction();
        const auctionData = location.state?.auctionData;
        React.useEffect(()=>{
            if (contractAddress && !auctionState && !loading) {
                console.log("Auto-joining auction:", contractAddress, "with role:", role);
                joinExistingAuction(contractAddress, role).catch((err)=>{
                    console.error("Failed to auto-join auction:", err);
                });
            }
        }, [
            contractAddress,
            role,
            auctionState,
            loading,
            joinExistingAuction
        ]);
        const handleSubmitBid = async (amount)=>{
            try {
                await submitBid(amount);
            } catch (err) {
                console.error("Error submitting bid:", err);
                throw err;
            }
        };
        const handleRefresh = async ()=>{
            try {
                await refreshAuctionData();
            } catch (err) {
                console.error("Error refreshing data:", err);
            }
        };
        const handleBack = ()=>{
            navigate("/");
        };
        const getRoleLabel = ()=>{
            switch(role){
                case "auctioneer":
                    return {
                        label: "Auctioneer",
                        color: "success"
                    };
                case "participant":
                    return {
                        label: "Participant",
                        color: "secondary"
                    };
                default:
                    return {
                        label: "Observer",
                        color: "default"
                    };
            }
        };
        const roleInfo = getRoleLabel();
        if (!auctionState) {
            return jsxRuntimeExports.jsxs(ThemeProvider, {
                theme,
                children: [
                    jsxRuntimeExports.jsx(CssBaseline, {}),
                    jsxRuntimeExports.jsx(Box, {
                        sx: {
                            display: "flex",
                            justifyContent: "center",
                            alignItems: "center",
                            height: "100vh"
                        },
                        children: jsxRuntimeExports.jsx("div", {
                            children: "Loading auction..."
                        })
                    })
                ]
            });
        }
        console.log("auctionState", auctionState);
        return jsxRuntimeExports.jsxs(MainLayout, {
            isParticipant: auctionState.isParticipant,
            userRole: role,
            children: [
                jsxRuntimeExports.jsxs(Box, {
                    sx: {
                        display: "flex",
                        flexDirection: "column",
                        gap: 3
                    },
                    children: [
                        jsxRuntimeExports.jsxs(Box, {
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center",
                            mb: 2,
                            children: [
                                jsxRuntimeExports.jsxs(Box, {
                                    children: [
                                        jsxRuntimeExports.jsx(Chip, {
                                            label: `Role: ${roleInfo.label}`,
                                            color: roleInfo.color,
                                            sx: {
                                                mr: 2
                                            }
                                        }),
                                        jsxRuntimeExports.jsx(Chip, {
                                            label: `Contract: ${contractAddress?.substring(0, 10)}...`,
                                            variant: "outlined"
                                        })
                                    ]
                                }),
                                jsxRuntimeExports.jsx(Fab, {
                                    size: "small",
                                    onClick: handleBack,
                                    sx: {
                                        backgroundColor: "grey.700"
                                    },
                                    children: jsxRuntimeExports.jsx(ArrowBack, {})
                                })
                            ]
                        }),
                        jsxRuntimeExports.jsx(AuctionInfo, {
                            auction: auctionData ? {
                                ...auctionState.auction,
                                ...auctionData
                            } : auctionState.auction
                        }),
                        role === "participant" && jsxRuntimeExports.jsx(BidForm, {
                            minimumBidValue: auctionState.auction.minimumBidValue,
                            canSubmitBid: auctionState.canSubmitBid,
                            hasSubmittedBid: !!auctionState.currentUserBid,
                            isParticipant: auctionState.isParticipant,
                            onSubmitBid: handleSubmitBid,
                            loading,
                            error
                        }),
                        role === "auctioneer" && jsxRuntimeExports.jsx(AuctioneerPanel, {
                            currentRound: auctionState.auction.currentRound,
                            canSubmitBid: auctionState.canSubmitBid,
                            totalBids: auctionState.auction.totalBids,
                            revealedBidsCount: auctionState.auction.revealedBids.length
                        })
                    ]
                }),
                jsxRuntimeExports.jsx(Fab, {
                    color: "primary",
                    "aria-label": "refresh",
                    onClick: handleRefresh,
                    disabled: loading,
                    sx: {
                        position: "fixed",
                        bottom: 16,
                        right: 16
                    },
                    children: jsxRuntimeExports.jsx(Refresh, {})
                })
            ]
        });
    }
    function AuctionPage() {
        return jsxRuntimeExports.jsxs(ThemeProvider, {
            theme,
            children: [
                jsxRuntimeExports.jsx(CssBaseline, {}),
                jsxRuntimeExports.jsx(HybridAuctionProvider, {
                    children: jsxRuntimeExports.jsx(AuctionApp, {})
                })
            ]
        });
    }
    function App() {
        return jsxRuntimeExports.jsxs(ThemeProvider, {
            theme,
            children: [
                jsxRuntimeExports.jsx(CssBaseline, {}),
                jsxRuntimeExports.jsx(AuctionProvider, {
                    children: jsxRuntimeExports.jsx(BrowserRouter, {
                        children: jsxRuntimeExports.jsx(MainLayout, {
                            isParticipant: false,
                            userRole: "participant",
                            children: jsxRuntimeExports.jsxs(Routes, {
                                children: [
                                    jsxRuntimeExports.jsx(Route, {
                                        path: "/",
                                        element: jsxRuntimeExports.jsx(HomePage, {})
                                    }),
                                    jsxRuntimeExports.jsx(Route, {
                                        path: "/create-auction",
                                        element: jsxRuntimeExports.jsx(CreateAuctionPage, {})
                                    }),
                                    jsxRuntimeExports.jsx(Route, {
                                        path: "/join-participant",
                                        element: jsxRuntimeExports.jsx(JoinParticipantPage, {})
                                    }),
                                    jsxRuntimeExports.jsx(Route, {
                                        path: "/join-auctioneer",
                                        element: jsxRuntimeExports.jsx(JoinAuctioneerPage, {})
                                    }),
                                    jsxRuntimeExports.jsx(Route, {
                                        path: "/auction/:contractAddress",
                                        element: jsxRuntimeExports.jsx(AuctionPage, {})
                                    })
                                ]
                            })
                        })
                    })
                })
            ]
        });
    }
    const logger = {
        trace: (message, ...args)=>console.log(message, ...args),
        info: (message, ...args)=>console.log(message, ...args),
        error: (message, ...args)=>console.error(message, ...args),
        warn: (message, ...args)=>console.warn(message, ...args),
        debug: (message, ...args)=>console.log(message, ...args),
        fatal: (message, ...args)=>console.error(message, ...args),
        level: "info"
    };
    const networkId = "TestNet";
    logger.trace("networkId = ", String(networkId));
    clientExports.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(reactExports.StrictMode, {
        children: jsxRuntimeExports.jsx(DeployedAuctionProvider, {
            logger,
            children: jsxRuntimeExports.jsx(App, {})
        })
    }));
});
