{
  "version": 3,
  "sources": ["../../node_modules/fetch-retry/dist/fetch-retry.umd.js", "../../node_modules/@protobufjs/utf8/index.js", "../../node_modules/@protobufjs/float/index.js", "../../node_modules/@dao-xyz/borsh/src/error.ts", "../../node_modules/@dao-xyz/borsh/src/bigint.ts", "../../node_modules/@dao-xyz/borsh/src/binary.ts", "../../node_modules/@dao-xyz/borsh/src/index.ts", "../../node_modules/@midnight-ntwrk/midnight-js-http-client-proof-provider/src/http-client-proof-provider.ts"],
  "sourcesContent": ["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.fetchRetry = factory());\n})(this, (function () { 'use strict';\n\n  var fetchRetry = function (fetch, defaults) {\n    defaults = defaults || {};\n    if (typeof fetch !== 'function') {\n      throw new ArgumentError('fetch must be a function');\n    }\n\n    if (typeof defaults !== 'object') {\n      throw new ArgumentError('defaults must be an object');\n    }\n\n    if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) {\n      throw new ArgumentError('retries must be a positive integer');\n    }\n\n    if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') {\n      throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n    }\n\n    if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') {\n      throw new ArgumentError('retryOn property expects an array or function');\n    }\n\n    var baseDefaults = {\n      retries: 3,\n      retryDelay: 1000,\n      retryOn: [],\n    };\n\n    defaults = Object.assign(baseDefaults, defaults);\n\n    return function fetchRetry(input, init) {\n      var retries = defaults.retries;\n      var retryDelay = defaults.retryDelay;\n      var retryOn = defaults.retryOn;\n\n      if (init && init.retries !== undefined) {\n        if (isPositiveInteger(init.retries)) {\n          retries = init.retries;\n        } else {\n          throw new ArgumentError('retries must be a positive integer');\n        }\n      }\n\n      if (init && init.retryDelay !== undefined) {\n        if (isPositiveInteger(init.retryDelay) || (typeof init.retryDelay === 'function')) {\n          retryDelay = init.retryDelay;\n        } else {\n          throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n        }\n      }\n\n      if (init && init.retryOn) {\n        if (Array.isArray(init.retryOn) || (typeof init.retryOn === 'function')) {\n          retryOn = init.retryOn;\n        } else {\n          throw new ArgumentError('retryOn property expects an array or function');\n        }\n      }\n\n      // eslint-disable-next-line no-undef\n      return new Promise(function (resolve, reject) {\n        var wrappedFetch = function (attempt) {\n          // As of node 18, this is no longer needed since node comes with native support for fetch:\n          /* istanbul ignore next */\n          var _input =\n            typeof Request !== 'undefined' && input instanceof Request\n              ? input.clone()\n              : input;\n          fetch(_input, init)\n            .then(function (response) {\n              if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {\n                resolve(response);\n              } else if (typeof retryOn === 'function') {\n                try {\n                  // eslint-disable-next-line no-undef\n                  return Promise.resolve(retryOn(attempt, null, response))\n                    .then(function (retryOnResponse) {\n                      if(retryOnResponse) {\n                        retry(attempt, null, response);\n                      } else {\n                        resolve(response);\n                      }\n                    }).catch(reject);\n                } catch (error) {\n                  reject(error);\n                }\n              } else {\n                if (attempt < retries) {\n                  retry(attempt, null, response);\n                } else {\n                  resolve(response);\n                }\n              }\n            })\n            .catch(function (error) {\n              if (typeof retryOn === 'function') {\n                try {\n                  // eslint-disable-next-line no-undef\n                  Promise.resolve(retryOn(attempt, error, null))\n                    .then(function (retryOnResponse) {\n                      if(retryOnResponse) {\n                        retry(attempt, error, null);\n                      } else {\n                        reject(error);\n                      }\n                    })\n                    .catch(function(error) {\n                      reject(error);\n                    });\n                } catch(error) {\n                  reject(error);\n                }\n              } else if (attempt < retries) {\n                retry(attempt, error, null);\n              } else {\n                reject(error);\n              }\n            });\n        };\n\n        function retry(attempt, error, response) {\n          var delay = (typeof retryDelay === 'function') ?\n            retryDelay(attempt, error, response) : retryDelay;\n          setTimeout(function () {\n            wrappedFetch(++attempt);\n          }, delay);\n        }\n\n        wrappedFetch(0);\n      });\n    };\n  };\n\n  function isPositiveInteger(value) {\n    return Number.isInteger(value) && value >= 0;\n  }\n\n  function ArgumentError(message) {\n    this.name = 'ArgumentError';\n    this.message = message;\n  }\n\n  return fetchRetry;\n\n}));\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n", "\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n", "export class BorshError extends Error {\n  originalMessage: string;\n  fieldPath: string[] = [];\n\n  constructor(message: string) {\n    super(message);\n    this.originalMessage = message;\n  }\n\n  addToFieldPath(fieldName: string) {\n    this.fieldPath.splice(0, 0, fieldName);\n    this.message = this.originalMessage + \". Error originated at field path: \" + this.fieldPath.join(\".\");\n  }\n}\n", "function arrayToHex(arr: Uint8Array, reverse: boolean = false): string {\n    return [...(reverse ? new Uint8Array(arr).reverse() : new Uint8Array(arr))]\n        .map(b => b.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n}\n\nexport function toBigIntLE(buf: Uint8Array): bigint {\n    const hex = arrayToHex(buf, true);\n    if (hex.length === 0) {\n        return BigInt(0);\n    }\n    return BigInt(`0x${hex}`);\n}\n\nexport function writeBufferLEBigInt(num: bigint | number, width: number, buffer: Uint8Array, offset: number) {\n    const hex = num.toString(16);\n    const padded = hex.padStart(width * 2, '0').slice(0, width * 2);\n    for (const [ix, value] of padded.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)).entries()) {\n        buffer[offset + width - 1 - ix] = value;\n    }\n}\n\nexport function writeUInt32LE(value: number, buf: Uint8Array, offset: number) {\n    checkInt(value, 0, 0xffffffff, 3);\n    buf[offset] = value;\n    buf[offset + 1] = value >>> 8;\n    buf[offset + 2] = value >>> 16;\n    buf[offset + 3] = value >>> 24;\n}\n\n\nexport function writeUInt16LE(value: number, buf: Uint8Array, offset: number) {\n    checkInt(value, 0, 0xffff, 1);\n    buf[offset] = value;\n    buf[offset + 1] = (value >>> 8);\n}\n\nexport const writeBigUint64Le = (bigIntOrNumber: bigint | number, buf: Uint8Array, offset: number) => {\n    let lo, hi;\n    if (typeof bigIntOrNumber === 'bigint') {\n        if (bigIntOrNumber <= Number.MAX_SAFE_INTEGER) {\n            if (bigIntOrNumber < 0) {\n                throw new Error(\"u64 value can not negative, got \" + bigIntOrNumber)\n            }\n            bigIntOrNumber = Number(bigIntOrNumber)\n            lo = bigIntOrNumber >>> 0;\n            hi = (bigIntOrNumber - lo) / 4294967296;\n        }\n        else {\n            if (bigIntOrNumber > 18446744073709551615n) {\n                throw new Error(\"u64 value can exceed mav value got \" + bigIntOrNumber)\n            }\n            lo = Number(bigIntOrNumber & 4294967295n);\n            hi = Number(bigIntOrNumber >> 32n & 4294967295n);\n        }\n\n    }\n    else {\n        if (bigIntOrNumber < 0 || bigIntOrNumber > 18446744073709551615n) {\n            throw new Error(\"u64 value can not negative, got \" + bigIntOrNumber)\n        }\n        // We don't need upper bound check because number can not exceed 18446744073709551615\n        lo = bigIntOrNumber >>> 0;\n        hi = (bigIntOrNumber - lo) / 4294967296;\n    }\n\n    buf[offset] = lo;\n    buf[offset + 1] = lo >>> 8;\n    buf[offset + 2] = lo >>> 16;\n    buf[offset + 3] = lo >>> 24;\n    buf[offset + 4] = hi;\n    buf[offset + 5] = hi >>> 8;\n    buf[offset + 6] = hi >>> 16;\n    buf[offset + 7] = hi >>> 24;\n\n}\n\nexport const readBigUInt64LE = (buf: Uint8Array, offset: number) => {\n    const first = buf[offset];\n    const last = buf[offset + 7];\n    if (first === undefined || last === undefined)\n        throw new Error('Out of bounds');\n\n    let lo = (first | buf[offset + 1] << 8 | buf[offset + 2] << 16 | buf[offset + 3] << 24) >>> 0;\n    let hi = (buf[offset + 4] | buf[offset + 5] << 8 | buf[offset + 6] << 16 | last << 24) >>> 0;\n    if (hi > 0) {\n        return BigInt(lo) + (BigInt(hi) << 32n);\n    }\n    return BigInt(lo)\n}\n\nexport function readUIntLE(buf: Uint8Array, offset: number, width: number): bigint {\n    const hex = arrayToHex(buf.subarray(offset, offset + width), true);\n    if (hex.length === 0) {\n        return BigInt(0);\n    }\n    return BigInt(`0x${hex}`);\n}\n\n\n\n\nexport const readUInt32LE = (buffer: Uint8Array, offset: number) => {\n    const first = buffer[offset];\n    const last = buffer[offset + 3];\n    if (first === undefined || last === undefined)\n        throw new Error('Out of bounds');\n\n    return first +\n        buffer[offset + 1] * 2 ** 8 +\n        buffer[offset + 2] * 2 ** 16 +\n        last * 2 ** 24;\n}\n\n\nexport const readUInt16LE = (buffer: Uint8Array, offset: number) => {\n    const first = buffer[offset];\n    const last = buffer[offset + 1];\n    if (first === undefined || last === undefined)\n        throw new Error('Out of bounds');\n\n    return first + last * 2 ** 8;\n}\n\n\n\nexport const checkInt = (value: number | bigint, min: number | bigint, max: number | bigint, byteLength: number) => {\n    if (value > max || value < min) {\n        const n = typeof min === 'bigint' ? 'n' : '';\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === 0n) {\n                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            } else {\n                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                    `${(byteLength + 1) * 8 - 1}${n}`;\n            }\n        } else {\n            range = `>= ${min}${n} and <= ${max}${n}`;\n        }\n        throw new Error(\"Out of range value: \" + range + \", \" + value);\n    }\n}", "import { toBigIntLE, writeBufferLEBigInt, writeUInt32LE, readUInt32LE, readUInt16LE, writeUInt16LE, readBigUInt64LE, readUIntLE, checkInt, writeBigUint64Le } from './bigint.js';\nimport { BorshError } from \"./error.js\";\nimport utf8 from '@protobufjs/utf8';\nimport { PrimitiveType, SmallIntegerType } from './types.js';\nimport { readFloatLE, writeFloatLE, readDoubleLE, writeDoubleLE } from '@protobufjs/float'\n\nconst allocUnsafeFn = (): (len: number) => Uint8Array => {\n  if ((globalThis as any).Buffer) {\n    return (globalThis as any).Buffer.allocUnsafe\n  }\n  return (len) => new Uint8Array(len);\n}\nconst allocUnsafe = allocUnsafeFn();\n\nconst writeStringBufferFnFn: () => ((len: number) => (string: string, buf: Uint8Array, offset: number) => void) = () => {\n  if ((globalThis as any).Buffer) {\n    return (length: number) => {\n      if (length < 48)\n        return utf8.write\n      return (string: string, buf: Uint8Array, offset: number) => (buf as any).write(string, offset)\n    }\n  }\n  return () => utf8.write\n}\nconst writeStringBufferFn = writeStringBufferFnFn()\n\nconst stringLengthFn: () => ((str: string) => number) = () => {\n  if ((globalThis as any).Buffer) {\n    return ((globalThis as any).Buffer).byteLength\n  }\n  return utf8.length\n}\n\n\ntype ChainedWrite = (() => any) & { next?: ChainedWrite }\nexport class BinaryWriter {\n\n  totalSize: number;\n\n  private _writes: ChainedWrite;\n  private _writesTail: ChainedWrite;\n  private _buf: Uint8Array;\n\n  public constructor() {\n    this.totalSize = 0;\n    this._writes = () => this._buf = allocUnsafe(this.totalSize);\n    this._writesTail = this._writes;\n  }\n\n  public bool(value: boolean) {\n    return BinaryWriter.bool(value, this)\n  }\n\n  public static bool(value: boolean, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writer._buf[offset] = value ? 1 : 0\n    writer.totalSize += 1;\n\n  }\n  public u8(value: number) {\n    return BinaryWriter.u8(value, this)\n  }\n\n  public static u8(value: number, writer: BinaryWriter) {\n    checkInt(value, 0, 0xff, 1);\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writer._buf[offset] = value\n    writer.totalSize += 1;\n  }\n\n  public u16(value: number) {\n    return BinaryWriter.u16(value, this)\n  }\n\n  public static u16(value: number, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeUInt16LE(value, writer._buf, offset);\n    writer.totalSize += 2;\n  }\n\n  public u32(value: number) {\n    return BinaryWriter.u32(value, this)\n  }\n\n  public static u32(value: number, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeUInt32LE(value, writer._buf, offset)\n    writer.totalSize += 4;\n\n  }\n\n\n  public u64(value: number | bigint) {\n    return BinaryWriter.u64(value, this)\n  }\n\n  public static u64(value: number | bigint, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeBigUint64Le(value, writer._buf, offset)\n    writer.totalSize += 8;\n  }\n\n  public u128(value: number | bigint) {\n    return BinaryWriter.u128(value, this)\n  }\n\n  public static u128(value: number | bigint, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeBufferLEBigInt(value, 16, writer._buf, offset)\n    writer.totalSize += 16;\n\n  }\n\n\n  public u256(value: number | bigint) {\n    return BinaryWriter.u256(value, this)\n  }\n\n  public static u256(value: number | bigint, writer: BinaryWriter) {\n\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeBufferLEBigInt(value, 32, writer._buf, offset)\n    writer.totalSize += 32;\n\n  }\n\n  public u512(value: number | bigint) {\n    return BinaryWriter.u512(value, this)\n  }\n\n  public static u512(value: number | bigint, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeBufferLEBigInt(value, 64, writer._buf, offset)\n    writer.totalSize += 64;\n\n  }\n\n  public f32(value: number) {\n    return BinaryWriter.f32(value, this)\n  }\n\n  public static f32(value: number, writer: BinaryWriter) {\n    if (Number.isNaN(value)) {\n      throw new BorshError(\"NaN is not supported for f32\")\n    }\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeFloatLE(value, writer._buf, offset)\n    writer.totalSize += 4;\n  }\n\n  public f64(value: number) {\n    return BinaryWriter.f64(value, this)\n  }\n\n  public static f64(value: number, writer: BinaryWriter) {\n    if (Number.isNaN(value)) {\n      throw new BorshError(\"NaN is not supported for f64\")\n    }\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => writeDoubleLE(value, writer._buf, offset)\n    writer.totalSize += 8;\n  }\n\n  public string(str: string) {\n    return BinaryWriter.string(str, this)\n  }\n\n  public static string(str: string, writer: BinaryWriter) {\n    const len = stringLengthFn()(str);\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => {\n      writeUInt32LE(len, writer._buf, offset);\n      writeStringBufferFn(len)(str, writer._buf, offset + 4);\n    }\n    writer.totalSize += 4 + len;\n  }\n\n  public static stringCustom(str: string, writer: BinaryWriter, lengthWriter: (len: number | bigint, buf: Uint8Array, offset: number) => void = writeUInt32LE, lengthSize = 4) {\n    const len = utf8.length(str);\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => {\n      lengthWriter(len, writer._buf, offset)\n      writeStringBufferFn(len)(str, writer._buf, offset + lengthSize);\n    }\n\n    writer.totalSize += lengthSize + len;\n  }\n\n  public set(array: Uint8Array) {\n    let offset = this.totalSize;\n    this._writes = this._writes.next = () => {\n      this._buf.set(array, offset);\n    }\n    this.totalSize += array.length\n  }\n\n  public uint8Array(array: Uint8Array) {\n    return BinaryWriter.uint8Array(array, this)\n\n  }\n\n  public static uint8Array(array: Uint8Array, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => {\n      writeUInt32LE(array.length, writer._buf, offset)\n      writer._buf.set(array, offset + 4);\n    }\n    writer.totalSize += array.length + 4;\n  }\n\n  public static uint8ArrayCustom(array: Uint8Array, writer: BinaryWriter, lengthWriter: (len: number | bigint, buf: Uint8Array, offset: number) => void = writeUInt32LE, lengthSize = 4) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => {\n      lengthWriter(array.length, writer._buf, offset)\n      writer._buf.set(array, offset + lengthSize);\n    }\n\n    writer.totalSize += array.length + lengthSize;\n  }\n\n  public static uint8ArrayFixed(array: Uint8Array, writer: BinaryWriter) {\n    let offset = writer.totalSize;\n    writer._writes = writer._writes.next = () => {\n      writer._buf.set(array, offset);\n    }\n    writer.totalSize += array.length;\n\n  }\n\n\n  public static smallNumberEncoding(encoding: SmallIntegerType): [((value: number, buf: Uint8Array, offset: number) => void), number] {\n    if (encoding === 'u8') {\n      return [(value: number, buf: Uint8Array, offset: number) => buf[offset] = value as number, 1]\n    }\n    else if (encoding === 'u16') {\n      return [writeUInt16LE, 2]\n    }\n    else if (encoding === 'u32') {\n      return [writeUInt32LE, 4]\n    }\n    else {\n      throw new Error(\"Unsupported encoding: \" + encoding)\n    }\n  }\n\n\n  public static write(encoding: PrimitiveType): (value: number | bigint | string | boolean | string, writer: BinaryWriter) => void {\n    if (encoding === 'u8') {\n      return BinaryWriter.u8\n    }\n    else if (encoding === 'u16') {\n      return BinaryWriter.u16\n    }\n    else if (encoding === 'u32') {\n      return BinaryWriter.u32\n    }\n    else if (encoding === 'u64') {\n      return BinaryWriter.u64\n    }\n    else if (encoding === 'u128') {\n      return BinaryWriter.u128\n    }\n    else if (encoding === 'u256') {\n      return BinaryWriter.u256\n    }\n    else if (encoding === 'u512') {\n      return BinaryWriter.u512\n    }\n    else if (encoding === 'bool') {\n      return BinaryWriter.bool\n    }\n    else if (encoding === 'f32') {\n      return BinaryWriter.f32\n    }\n    else if (encoding === 'f64') {\n      return BinaryWriter.f64\n    }\n    else if (encoding === 'string') {\n      return BinaryWriter.string\n    }\n    else {\n      throw new Error(\"Unsupported encoding: \" + encoding)\n    }\n  }\n\n  public finalize(): Uint8Array {\n    let current: ChainedWrite = this._writesTail;\n    while (current != null) {\n      current()\n      current = current.next\n    }\n    return this._buf;\n  }\n}\n\n\n\nexport class BinaryReader {\n  _buf: Uint8Array;\n  _offset: number;\n\n  public constructor(buf: Uint8Array) {\n    this._buf = buf;\n    this._offset = 0;\n  }\n\n  bool(): boolean {\n    return BinaryReader.bool(this)\n  }\n\n  static bool(reader: BinaryReader): boolean {\n    const value = reader._buf[reader._offset];\n    reader._offset += 1;\n    if (value !== 1 && value !== 0) {\n      throw new BorshError(\"Unexpected value for boolean: \" + value + \". Expecting either 1 or 0 \")\n    }\n    return value ? true : false;\n  }\n\n  u8(): number {\n    return BinaryReader.u8(this)\n  }\n\n  static u8(reader: BinaryReader): number {\n    if (reader._offset >= reader._buf.length) {\n      throw new BorshError(\"Reader out of bounds\")\n    }\n\n    const value = reader._buf[reader._offset];\n    reader._offset += 1;\n    return value;\n  }\n\n  u16(): number {\n    return BinaryReader.u16(this)\n  }\n\n  static u16(reader: BinaryReader): number {\n    const value = readUInt16LE(reader._buf, reader._offset);\n    reader._offset += 2;\n    return value;\n  }\n\n\n  u32(): number {\n    return BinaryReader.u32(this)\n  }\n\n  static u32(reader: BinaryReader): number {\n    const value = readUInt32LE(reader._buf, reader._offset);\n    reader._offset += 4;\n    return value;\n  }\n\n  u64(): bigint {\n    return BinaryReader.u64(this)\n  }\n\n  static u64(reader: BinaryReader): bigint {\n    const value = readBigUInt64LE(reader._buf, reader._offset);\n    reader._offset += 8;\n    return value\n  }\n\n  u128(): bigint {\n    return BinaryReader.u128(this)\n\n  }\n  static u128(reader: BinaryReader): bigint {\n    const value = readUIntLE(reader._buf, reader._offset, 16);\n    reader._offset += 16;\n    return value\n  }\n  u256(): bigint {\n    return BinaryReader.u256(this)\n  }\n\n  static u256(reader: BinaryReader): bigint {\n    const value = readUIntLE(reader._buf, reader._offset, 32);\n    reader._offset += 32;\n    return value\n  }\n\n  u512(): bigint {\n    return BinaryReader.u512(this)\n  }\n\n  static u512(reader: BinaryReader): bigint {\n    const buf = reader.buffer(64);\n    return toBigIntLE(buf)\n  }\n\n\n  f32(): number {\n    return BinaryReader.f32(this)\n  }\n\n\n  static f32(reader: BinaryReader): number {\n    const value = readFloatLE(reader._buf, reader._offset)\n    reader._offset += 4;\n    if (Number.isNaN(value)) {\n      throw new BorshError(\"Recieved NaN reading f32\")\n    }\n    return value;\n  }\n\n\n  f64(): number {\n    return BinaryReader.f64(this)\n  }\n\n  static f64(reader: BinaryReader): number {\n    const value = readDoubleLE(reader._buf, reader._offset)\n    reader._offset += 8;\n    if (Number.isNaN(value)) {\n      throw new BorshError(\"Recieved NaN reading f64\")\n    }\n    return value;\n  }\n\n\n  string(): string {\n    return BinaryReader.string(this);\n  }\n\n  static string(reader: BinaryReader): string {\n    const len = reader.u32();\n    const end = reader._offset + len;\n    if (end > reader._buf.length) {\n      throw new BorshError(\"Error decoding UTF-8 string: Invalid length\")\n    }\n\n    try {\n      const string = utf8.read(reader._buf, reader._offset, end);\n      reader._offset = end;\n      return string;\n    } catch (e) {\n      throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n    }\n  }\n\n  static bufferString(reader: BinaryReader): string {\n    const len = reader.u32();\n    const end = reader._offset + len;\n    if (end > reader._buf.length) {\n      throw new BorshError(\"Error decoding UTF-8 string: Invalid length\")\n    }\n\n    const string = (reader._buf as Buffer).toString(undefined, reader._offset, end);\n    reader._offset = end;\n    return string;\n  }\n\n\n  static bufferStringCustom(reader: BinaryReader, length: (reader: BinaryReader) => number): string {\n    const len = length(reader);\n    const end = reader._offset + len;\n    if (end > reader._buf.length) {\n      throw new BorshError(\"Error decoding UTF-8 string: Invalid length\")\n    }\n\n    try {\n\n      const string = (reader._buf as Buffer).toString(undefined, reader._offset, end);\n      reader._offset = end;\n      return string;\n    } catch (e) {\n      throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n    }\n  }\n\n  static stringCustom(reader: BinaryReader, length: (reader: BinaryReader) => number): string {\n    const len = length(reader);\n    const end = reader._offset + len;\n    if (end > reader._buf.length) {\n      throw new BorshError(\"Error decoding UTF-8 string: Invalid length\")\n    }\n\n    try {\n      const string = utf8.read(reader._buf, reader._offset, end);\n      reader._offset = end;\n      return string;\n    } catch (e) {\n      throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n    }\n  }\n\n  public static read(encoding: PrimitiveType, fromBuffer?: boolean): ((reader: BinaryReader) => number) | ((reader: BinaryReader) => bigint) | ((reader: BinaryReader) => boolean) | ((reader: BinaryReader) => string) {\n    if (encoding === 'u8') {\n      return BinaryReader.u8\n    }\n    else if (encoding === 'u16') {\n      return BinaryReader.u16\n    }\n    else if (encoding === 'u32') {\n      return BinaryReader.u32\n    }\n    else if (encoding === 'u64') {\n      return BinaryReader.u64\n    }\n    else if (encoding === 'u128') {\n      return BinaryReader.u128\n    }\n    else if (encoding === 'u256') {\n      return BinaryReader.u256\n    }\n    else if (encoding === 'u512') {\n      return BinaryReader.u512\n    }\n    else if (encoding === 'string') {\n      return fromBuffer ? BinaryReader.bufferString : BinaryReader.string\n    }\n    else if (encoding === 'bool') {\n      return BinaryReader.bool\n    }\n    else if (encoding === 'f32') {\n      return BinaryReader.f32\n    }\n    else if (encoding === 'f64') {\n      return BinaryReader.f64\n    }\n    else {\n      throw new Error(\"Unsupported encoding: \" + encoding)\n    }\n  }\n\n  public buffer(len: number): Uint8Array {\n    const end = this._offset + len;\n    const result = this._buf.subarray(this._offset, end);\n    this._offset = end;\n    return result;\n  }\n\n\n  uint8Array(): Uint8Array {\n    return BinaryReader.uint8Array(this)\n  }\n\n  static uint8Array(reader: BinaryReader, size = reader.u32()): Uint8Array {\n    return reader.buffer(size);\n  }\n\n\n  readArray(fn: any): any[] {\n    const len = this.u32();\n    const result = new Array<any>(len);\n    for (let i = 0; i < len; ++i) {\n      result[i] = fn();\n    }\n    return result;\n  }\n}", "import {\n  FixedArrayKind,\n  OptionKind,\n  Field,\n  StructKind,\n  VecKind,\n  SimpleField,\n  CustomField,\n  Constructor,\n  AbstractType,\n  IntegerType,\n  getOffset,\n  StringType,\n  extendingClasses,\n} from \"./types.js\";\nexport * from \"./binary.js\";\nexport * from \"./types.js\";\nexport * from './error.js';\nimport { BorshError } from \"./error.js\";\nimport { BinaryWriter, BinaryReader } from \"./binary.js\";\n\n/**\n * Code below is quite optimized for performance hence there will be some \"wierd\" looking .js \n * Overall, they way it works, is that each Schema is translated into one big callback function that can execute very efficiently multiple time\n * This function or handle, is stored on the prototypes so we can easily access it when we want to serialize/deserialize\n */\n\n// we will store some metadata about the schemas on the prototype. Prototype set get is faster if we use numbers (so we are going to use that here)\nconst MAX_PROTOTYPE_SEARCH = 250;\nconst PROTOTYPE_POLLUTION_CONTEXT_RANGE = 500;\nconst PROTOTYPE_DESERIALIZATION_HANDLER_OFFSET = 500;\nconst PROTOTYPE_DEPENDENCY_HANDLER_OFFSET = PROTOTYPE_DESERIALIZATION_HANDLER_OFFSET + PROTOTYPE_POLLUTION_CONTEXT_RANGE;\nconst PROTOTYPE_SCHEMA_OFFSET = PROTOTYPE_DESERIALIZATION_HANDLER_OFFSET + PROTOTYPE_POLLUTION_CONTEXT_RANGE * 2;\n\n/**\n * Serialize an object with @field(...) or @variant(...) decorators\n * @param obj \n * @returns bytes\n */\nexport function serialize(\n  obj: any,\n  writer: BinaryWriter = new BinaryWriter()\n): Uint8Array {\n  (obj.constructor._borsh_serialize || (obj.constructor._borsh_serialize = serializeStruct(obj.constructor, true)))(obj, writer)\n  return writer.finalize();\n}\n\nfunction recursiveSerialize(obj: any, writer: BinaryWriter = new BinaryWriter()) {\n  (obj.constructor._borsh_serialize_recursive || (obj.constructor._borsh_serialize_recursive = serializeStruct(obj.constructor, false)))(obj, writer)\n  return writer.finalize();\n}\n\n\n/**\n * /// Deserializes object from bytes using schema.\n * @param buffer data\n * @param classType target Class\n * @param options options\n * @param options.unchecked if true then any remaining bytes after deserialization will be ignored \n * @param options.object no classes will be created, just plain js object\n * @param options.construct if true, constructors will be invoked on deserialization\n * @returns\n */\n\ntype DeserializeStructOptions = {\n  unchecked?: boolean\n} & ({ construct?: boolean } | { object?: boolean });\nexport function deserialize<T>(\n  buffer: Uint8Array,\n  classType: Constructor<T> | AbstractType<T>,\n  options?: DeserializeStructOptions\n): T {\n  // buffer = intoUint8Array(buffer);\n  const reader = new BinaryReader(buffer);\n  let fromBuffer = buffer.constructor !== Uint8Array\n  const result = deserializeStruct(classType, fromBuffer)(reader, options);\n  if (!options?.unchecked && reader._offset !== buffer.length) {\n    throw new BorshError(\n      `Unexpected ${buffer.length - reader._offset\n      } bytes after deserialized data. This is most likely due to that you are deserializing into the wrong class`\n    );\n  }\n  return result;\n}\n\n\n\n\n\nfunction serializeField(\n  fieldName: string,\n  fieldType: any,\n  options?: { unchecked: boolean }\n): (obj: any, writer: BinaryWriter) => any {\n  if (typeof fieldType.serialize == \"function\") {\n    return (obj, writer) => fieldType.serialize(obj, writer);\n  }\n  try {\n    const handleFn = (): (obj: any, writer: BinaryWriter) => any => {\n      if (typeof fieldType === \"string\") {\n        return BinaryWriter.write(fieldType as IntegerType)\n      }\n\n      else if (fieldType === Uint8Array) {\n        return BinaryWriter.uint8Array\n      }\n      else if (fieldType instanceof OptionKind) {\n        const fieldHandle = serializeField(fieldName, fieldType.elementType);\n\n        return (obj, writer) => {\n          if (obj != null) {\n            writer.u8(1);\n            fieldHandle(obj, writer)\n          }\n          else {\n            writer.u8(0)\n          }\n        }\n      }\n      else if (\n        fieldType instanceof VecKind ||\n        fieldType instanceof FixedArrayKind\n      ) {\n\n        if (fieldType.elementType === 'u8') {\n          if (fieldType instanceof FixedArrayKind) {\n            return options?.unchecked ? BinaryWriter.uint8ArrayFixed : (obj, writer) => {\n              if (obj.length !== fieldType.length) {\n                throw new BorshError(`Provided array does not equal fixed array size of field: ${fieldName}. Recieved: ${obj.length}, Expected: ${fieldType.length}`)\n              }\n              return BinaryWriter.uint8ArrayFixed(obj, writer)\n            }\n          }\n          else {\n            if (fieldType.sizeEncoding === 'u32')\n              return BinaryWriter.uint8Array\n            else {\n              const [sizeHandle, width] = BinaryWriter.smallNumberEncoding(fieldType.sizeEncoding)\n              return (obj, writer) => BinaryWriter.uint8ArrayCustom(obj, writer, sizeHandle, width)\n            }\n          }\n        }\n        else {\n          const sizeHandle = fieldType instanceof FixedArrayKind ? undefined : BinaryWriter.write(fieldType.sizeEncoding)\n          const fieldHandle = serializeField(null, fieldType.elementType);;\n          return (obj, writer) => {\n            let len = obj.length;\n            if (!sizeHandle) {\n              if ((fieldType as FixedArrayKind).length != len) {\n                throw new BorshError(\n                  `Expecting array of length ${(fieldType as any)[0]}, but got ${obj.length\n                  }`\n                );\n              }\n            } else {\n              sizeHandle(len, writer); // For dynamically sized array we write the size as uX according to specification\n            }\n            for (let i = 0; i < len; i++) {\n              fieldHandle(obj[i], writer)\n            }\n          }\n        }\n\n      }\n      else if (fieldType instanceof StringType) {\n        const [sizeHandle, width] = BinaryWriter.smallNumberEncoding(fieldType.sizeEncoding)\n        return (obj, writer) => BinaryWriter.stringCustom(obj, writer, sizeHandle, width)\n      }\n\n\n      else {\n        return (obj, writer) => {\n          if (!options?.unchecked && !checkClazzesCompatible(obj.constructor, fieldType)) {\n            throw new BorshError(`Field value of field ${fieldName} is not instance of expected Class ${getSuperMostClass(fieldType)?.name}. Got: ${obj.constructor.name}`)\n          }\n          serializeStruct(obj.constructor)(obj, writer)\n        }\n      }\n    }\n\n    const handle = handleFn()\n\n    if (!options?.unchecked) {\n      return (obj: any, writer: BinaryWriter) => {\n        if (obj == null && fieldType instanceof OptionKind === false) {\n          throw new BorshError(`Trying to serialize a null value to field \"${fieldName}\" which is not allowed since the field is not decorated with \"option(...)\" but \"${typeof fieldType === 'function' && fieldType?.name ? fieldType?.name : fieldType}\". Most likely you have forgotten to assign this value before serializing`)\n        }\n        return handle(obj, writer)\n      }\n    }\n    else {\n      return handle;\n\n    }\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n    throw error;\n  }\n}\n\n\nfunction serializeStruct(\n  ctor: Function,\n  allowCustomSerializer = true\n) {\n  let handle: (obj: any, writer: BinaryWriter) => any = undefined;\n  var i = 0;\n  let once = false;\n  while (true) {\n    let schema = getSchema(ctor, i);\n    if (schema) {\n      once = true;\n      const index = schema.variant;\n      if (index != undefined) {\n        let prev = handle;\n\n        if (typeof index === \"number\") {\n          handle = prev ? (obj, writer) => { prev(obj, writer); writer.u8(index) } : (_obj, writer) => BinaryWriter.u8(index, writer)\n        } else if (Array.isArray(index)) {\n          if (prev) {\n            handle = (obj, writer) => {\n              prev(obj, writer)\n              for (const i of index) {\n                writer.u8(i);\n              }\n            }\n          }\n          else {\n            handle = (_obj, writer) => {\n              for (const i of index) {\n                writer.u8(i);\n              }\n            }\n          }\n\n        }\n        else { // is string\n          handle = prev ? (obj, writer) => {\n            prev(obj, writer);\n            writer.string(index);\n          } : (_obj, writer) => writer.string(index);\n        }\n      }\n      if (allowCustomSerializer && schema.serializer) {\n        let prev = handle;\n        handle = prev ? (obj, writer) => {\n          prev(obj, writer);\n          schema.serializer(obj, writer, (obj: any) => recursiveSerialize(obj))\n        } : (obj, writer) => schema.serializer(obj, writer, (obj: any) => recursiveSerialize(obj))\n      }\n      else {\n        for (const field of schema.fields) {\n          let prev = handle;\n          const fieldHandle = serializeField(field.key, field.type);\n          if (prev) {\n            handle = (obj, writer) => {\n              prev(obj, writer);\n              fieldHandle(obj[field.key], writer)\n            }\n          }\n          else {\n            handle = (obj, writer) => fieldHandle(obj[field.key], writer)\n          }\n        }\n      }\n\n    }\n\n    else if (once && !getDependencies(ctor, i)?.length) {\n      return handle;\n    }\n    i++;\n    if (i == MAX_PROTOTYPE_SEARCH && !once) {\n      throw new BorshError(`Class ${ctor.name} is missing in schema`);\n    }\n  }\n}\n\nconst MAX_ARRAY_SIZE_ALLOCATION = 1024 * 1024;\n\nfunction deserializeField(\n  fieldName: string,\n  fieldType: any,\n  fromBuffer: boolean\n): (reader: BinaryReader, options: DeserializeStructOptions) => any {\n  try {\n    if (typeof fieldType === \"string\") {\n      return BinaryReader.read(fieldType as IntegerType, fromBuffer)\n    }\n\n    if (fieldType === Uint8Array) {\n      return (reader) => reader.uint8Array()\n    }\n\n    if (fieldType instanceof VecKind || fieldType instanceof FixedArrayKind) {\n      if (fieldType.elementType === 'u8') {\n        if (fieldType instanceof FixedArrayKind) {\n          return (reader) => reader.buffer(fieldType.length)\n        }\n        else {\n          const sizeHandle = BinaryReader.read(fieldType.sizeEncoding, fromBuffer) as (reader: BinaryReader) => number;\n          return (reader) => BinaryReader.uint8Array(reader, sizeHandle(reader))\n        }\n      }\n      else {\n        let sizeHandle = fieldType instanceof VecKind ? BinaryReader.read(fieldType.sizeEncoding, fromBuffer) as (reader: BinaryReader) => number : (() => fieldType.length);\n        const fieldHandle = deserializeField(null, fieldType.elementType, fromBuffer);\n        return (reader, options) => {\n          const len = sizeHandle(reader);\n          if (len < MAX_ARRAY_SIZE_ALLOCATION) {\n            let arr = new Array(len);\n            for (let i = 0; i < len; i++) {\n              arr[i] = fieldHandle(reader, options);\n            }\n            return arr;\n          }\n          else {\n            let arr = new Array(MAX_ARRAY_SIZE_ALLOCATION);\n            for (let i = 0; i < len; i++) {\n              arr[i] = fieldHandle(reader, options);\n            }\n            return arr;\n          }\n        }\n      }\n    }\n\n    if (fieldType instanceof StringType) {\n      const sizeReader = BinaryReader.read(fieldType.sizeEncoding, fromBuffer) as (reader: BinaryReader) => number;\n\n      return fromBuffer ? (reader) => BinaryReader.bufferStringCustom(reader, sizeReader) : (reader) => BinaryReader.stringCustom(reader, sizeReader)\n    }\n\n    if (typeof fieldType[\"deserialize\"] == \"function\") {\n      return (reader) => fieldType.deserialize(reader);\n    }\n\n    if (fieldType instanceof OptionKind) {\n      const fieldHandle = deserializeField(\n        fieldName,\n        fieldType.elementType,\n        fromBuffer\n      );\n      return (reader, options) => {\n        return reader.bool() ? fieldHandle(\n          reader,\n          options\n        ) : undefined;\n      }\n    }\n    return deserializeStruct(fieldType, fromBuffer)\n\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n    throw error;\n  }\n}\nexport function deserializeStruct(targetClazz: any, fromBuffer: boolean): (reader: BinaryReader, options?: DeserializeStructOptions) => any {\n\n  const handle = getCreateDeserializationHandle(targetClazz, 0, fromBuffer);\n  // \"compile time\"\n  return (reader: BinaryReader, options?: DeserializeStructOptions) => {\n    // \"runtime\" \n    const result = handle({}, reader, options)\n    if (!options?.unchecked && !(options as any)?.object && !checkClazzesCompatible(result.constructor, targetClazz)) {\n      throw new BorshError(`Deserialization of ${targetClazz?.name || targetClazz} yielded another Class: ${result.constructor?.name} which are not compatible`);\n    }\n    return result;\n  };\n\n}\n\n\nconst getCreateDeserializationHandle = (clazz: any, offset: number, fromBuffer: boolean): (result: any, reader: BinaryReader, options?: DeserializeStructOptions) => any => getDeserializationHandle(clazz, offset, fromBuffer) || setDeserializationHandle(clazz, offset, fromBuffer, createDeserializeStructHandle(clazz, offset, fromBuffer))\nconst getDeserializationHandle = (clazz: any, offset: number, fromBuffer: boolean) => clazz.prototype[PROTOTYPE_DESERIALIZATION_HANDLER_OFFSET + offset + (fromBuffer ? MAX_PROTOTYPE_SEARCH : 0)]\nconst setDeserializationHandle = (clazz: any, offset: number, fromBuffer: boolean, handle: (result: any, reader: BinaryReader, options?: DeserializeStructOptions) => any) => clazz.prototype[PROTOTYPE_DESERIALIZATION_HANDLER_OFFSET + offset + (fromBuffer ? MAX_PROTOTYPE_SEARCH : 0)] = handle;\nconst clearDeserializeStructHandle = (clazz: any, offset: number, fromBuffer: boolean) => delete clazz.prototype[PROTOTYPE_DESERIALIZATION_HANDLER_OFFSET + offset + (fromBuffer ? MAX_PROTOTYPE_SEARCH : 0)]\nconst createDeserializeStructHandle = (currClazz: Constructor<any>, offset: number, fromBuffer: boolean): ((result: any, reader: BinaryReader, options?: DeserializeStructOptions) => any) => {\n  let handle: (result: any, reader: BinaryReader, options?: DeserializeStructOptions) => any | undefined = undefined;\n  let endHandle = (result: any, reader: BinaryReader, options: DeserializeStructOptions) => {\n    if ((options as any)?.object) {\n      return result;\n    }\n    return Object.assign((options as any)?.construct ? new currClazz() : Object.create(currClazz.prototype), result);\n  }\n  let structSchema = getSchema(currClazz, offset);\n  if (structSchema) {\n    if (offset === 0) {\n      let index = getVariantIndex(structSchema);\n      if (index != null) {\n        // It is an (stupid) enum, but we deserialize into its variant directly\n        // This means we should omit the variant index\n        if (typeof index === \"number\") {\n          handle = (_, reader, __) => {\n            reader._offset += 1; // read 1 u\n          };\n        } else if (Array.isArray(index)) {\n          handle = (_, reader, __) => {\n            reader._offset += (index as Array<any>).length // read all u8's 1 u8 = 1 byte -> shift offset with 1*length\n          };\n        }\n        else { // string\n          handle = (_, reader, __) => {\n            reader.string();\n          };\n        }\n      }\n    }\n\n    for (const field of structSchema.fields) {\n      const prev = handle;\n      const fieldHandle = deserializeField(\n        field.key,\n        field.type,\n        fromBuffer\n      );\n      if (prev) {\n        handle = (result, reader: BinaryReader, options?: DeserializeStructOptions) => {\n          prev(result, reader, options)\n          result[field.key] = fieldHandle(reader,\n            options)\n        }\n      }\n      else handle = (result, reader: BinaryReader, options?: DeserializeStructOptions) => {\n        result[field.key] = fieldHandle(reader,\n          options)\n      }\n\n\n    }\n  }\n\n  // We know that we should serialize into the variant that accounts to the first byte of the read\n  let dependencies = getAllDependencies(currClazz, offset);\n  if (dependencies) {\n    let variantToDepndency: [any, any, {\n      schema: StructKind;\n      offset: number;\n    }][] = [];\n    let variantType: 'string' | 'number' | number | 'undefined';\n    for (const [actualClazz, dependency] of dependencies) {\n      const variantIndex = getVariantIndex(dependency.schema);\n      let currentVariantType = typeof variantIndex === 'object' ? variantIndex.length : typeof variantIndex as ('string' | 'number');\n      if (!variantType) {\n        variantType = currentVariantType;\n      }\n      else if (currentVariantType !== variantType) {\n        throw new Error(`Variant extending ${currClazz.name} have different types, expecting either number, number[] (with same sizes) or string, but not a combination of them`)\n      }\n      variantToDepndency.push([variantIndex, actualClazz, dependency])\n    }\n    if (variantType === 'undefined') {\n      if (dependencies.size === 1) {\n        const dep = variantToDepndency[0];\n        return (result, reader, options) => {\n          handle && handle(result, reader, options)\n          return getCreateDeserializationHandle(dep[1], dep[2].offset, fromBuffer)(result, reader, options)\n        }\n      }\n      else throw new BorshError(`Failed to find class to deserialize to from ${currClazz.name}: but no variants are used which makes deserialization undeterministic`)\n\n    }\n\n    return (result, reader, options) => {\n      handle && handle(result, reader, options)\n      let next = undefined;\n      let nextOffset = undefined;\n\n      if (variantType === 'number') {\n        let agg = reader.u8();\n        for (const dep of variantToDepndency) {\n          if (agg === dep[0]) {\n            return getCreateDeserializationHandle(dep[1], dep[2].offset, fromBuffer)(result, reader, options)\n          }\n        }\n      }\n      else if (variantType === 'string') {\n        let variant = reader.string();\n        for (const dep of variantToDepndency) {\n          if (variant === dep[0]) {\n            return getCreateDeserializationHandle(dep[1], dep[2].offset, fromBuffer)(result, reader, options)\n          }\n        }\n      }\n      else // array \n      {\n        let agg: number[] = [];\n        for (let i = 0; i < (variantType as number); i++) {\n          agg.push(reader.u8())\n        }\n        for (const dep of variantToDepndency) {\n          let currentVariant = dep[0];\n          if (currentVariant.length === agg.length &&\n            (currentVariant as number[]).every((value, index) => value === agg[index])) {\n\n            return getCreateDeserializationHandle(dep[1], dep[2].offset, fromBuffer)(result, reader, options)\n          }\n        }\n      }\n\n      if (next == undefined && dependencies) {\n        // do a recursive call and copy result, \n        // this is not computationally performant since we are going to traverse multiple path\n        // and possible do deserialziation on bad paths\n        if (dependencies.size == 1) // still deterministic\n        {\n          const n = dependencies.entries().next().value;\n          next = n[0];\n          nextOffset = n[1].offset;\n        }\n        else if (dependencies.size > 1) {\n          const classes = [...dependencies.entries()].map(([c]) => c.name).join(', ')\n          throw new BorshError(`Failed to find class to deserialize to from ${currClazz.name} found: ${classes} but no variant matches bytes read from the buffer.`)\n        }\n      }\n      if (next != null) {\n        getCreateDeserializationHandle(next, nextOffset, fromBuffer)(result, reader, options)\n\n      }\n      else {\n        return endHandle(result, reader, options)\n      }\n\n    }\n\n  }\n  else {\n    if (handle) {\n      return (result, reader, options) => {\n        handle(result, reader, options)\n        return endHandle(result, reader, options)\n      }\n    }\n    return endHandle\n  }\n}\n\n\nconst getOrCreateStructMeta = (clazz: any, offset: number): StructKind => {\n\n  let schema: StructKind = getSchema(clazz, offset)\n  if (!schema) {\n    schema = new StructKind();\n  }\n\n  setSchema(clazz, schema, offset);\n  return schema\n}\nconst setDependencyToProtoType = (ctor: Function, offset: number) => {\n  let proto = Object.getPrototypeOf(ctor);\n  while (proto.prototype?.constructor != undefined) { // TODO break early if already done this!\n    let newOffset = --offset;\n    let dependencies = getDependencies(proto, newOffset);\n    if (dependencies) {\n      for (const dependency of dependencies) {\n        if (ctor.prototype instanceof dependency || dependency === ctor) {\n          return;\n        }\n      }\n    }\n    else {\n      dependencies = []\n    }\n    dependencies.push(ctor);\n    setDependencies(proto, newOffset, dependencies)\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n\n\nconst getSuperMostClass = (clazz: AbstractType<any>) => {\n  while (Object.getPrototypeOf(clazz).prototype != undefined) {\n    clazz = Object.getPrototypeOf(clazz);\n  }\n  return clazz;\n}\n/**\n * @param clazzA \n * @param clazzB \n * @returns true if A inherit B or B inherit A or A == B, else false\n */\nconst checkClazzesCompatible = (clazzA: Constructor<any> | AbstractType<any>, clazzB: Constructor<any> | AbstractType<any>) => {\n  return clazzA == clazzB || clazzA.isPrototypeOf(clazzB) || clazzB.isPrototypeOf(clazzA)\n}\n\nexport const getDependencies = (ctor: Function, offset: number): Function[] | undefined => ctor.prototype[PROTOTYPE_DEPENDENCY_HANDLER_OFFSET + offset]\n\nconst setDependencies = (ctor: Function, offset: number, dependencies: Function[]) => {\n  ctor.prototype[PROTOTYPE_DEPENDENCY_HANDLER_OFFSET + offset] = dependencies // [getDependencyKey(ctor)] \n}\n\nexport const getAllDependencies = (ctor: Function, offset: number): Map<Function, { schema: StructKind, offset: number }> | undefined => {\n  let existing = getDependencies(ctor, offset);\n  if (existing) {\n    let ret: Map<Function, { schema: StructKind, offset: number }> = new Map()\n    for (const v of existing) {\n      let schema = getSubMostSchema(v);\n      if (schema.fields.length > 0 || schema.variant != undefined) { // non trivial\n        ret.set(v, { schema, offset: getOffset(v) });\n      }\n      else { // check recursively\n        let req = getAllDependencies(v, offset);\n        for (const [rv, rk] of req) {\n          ret.set(rv, rk);\n        }\n      }\n    }\n    return ret;\n  }\n}\n\n\nconst getDependenciesRecursively = (ctor: Function, offset: number, mem: Function[] = []): Function[] => {\n  let dep = getDependencies(ctor, offset);\n  if (dep) {\n    for (const f of dep) {\n      if (mem.includes(f)) {\n        continue;\n      }\n      mem.push(f);\n      getDependenciesRecursively(f, offset, mem);\n    }\n  }\n  return mem\n}\n\n\nconst setSchema = (ctor: Function, schemas: StructKind, offset: number) => {\n  ctor.prototype[PROTOTYPE_SCHEMA_OFFSET + offset] = schemas;\n\n}\n\nexport const getSchema = (ctor: Function, offset: number = getOffset(ctor)): StructKind => ctor.prototype[PROTOTYPE_SCHEMA_OFFSET + offset]\n\nconst getSubMostSchema = (ctor: Function): StructKind => {\n  let last = undefined;\n  for (var i = 0; i < MAX_PROTOTYPE_SEARCH; i++) {\n    const curr = ctor.prototype[PROTOTYPE_SCHEMA_OFFSET + i];\n    if (!curr && last && !getDependencies(ctor, i)?.length) {\n      return last;\n    }\n    last = curr;\n  }\n  return;\n}\n\n\n\nexport const getSchemasBottomUp = (ctor: Function): StructKind[] => {\n\n  let last = undefined;\n  let ret: StructKind[] = [];\n  for (var i = 0; i < 1000; i++) {\n    const curr = getSchema(ctor, i);\n    if (!curr) {\n      if (last && !getDependencies(ctor, i)?.length) {\n        return ret;\n      }\n    }\n    else {\n      ret.push(curr);\n      last = curr;\n    }\n  }\n  return ret;\n}\n\n/**\n *\n * @param kind 'struct' or 'variant. 'variant' equivalnt to Rust Enum\n * @returns Schema decorator function for classes\n */\nexport const variant = (index: number | number[] | string) => {\n  return (ctor: Function) => {\n    let offset = getOffset(ctor);\n    setDependencyToProtoType(ctor, offset);\n    let schemas = getOrCreateStructMeta(ctor, offset);\n    schemas.variant = index;\n\n    // clear deserialization handles for all dependencies since we might have made a dynamic import which breakes the deserialization path caches\n    for (const clazz of extendingClasses(ctor)) {\n      clearDeserializeStructHandle(clazz, 0, true);\n      clearDeserializeStructHandle(clazz, 0, false)\n    }\n\n\n\n    // Check for variant conficts \n    for (let i = offset - 1; i >= 0; i--) {\n      const dependencies = getDependencies(ctor, i)\n      if (dependencies) {\n        for (const dependency of dependencies) {\n          if (dependency !== ctor) {\n            let otherVariant = getVariantIndex(getSchema(dependency, getOffset(dependency)))\n            if (typeof otherVariant !== typeof index) {\n              throw new BorshError(`Variant of ${ctor.name} have different type compared to its sibling: ${dependency.name}, expecting either number, number[] (with same sizes) or string, but not a combination of them`)\n            }\n            else if (index === otherVariant || (Array.isArray(index) && Array.isArray(otherVariant) && (index.length !== otherVariant.length || index.every((value, index) => value === (otherVariant as number[])[index])))) {\n              throw new BorshError(`Variant of ${ctor.name}: ${JSON.stringify(index)} is the same as for ${dependency.name} which is not allowed (non-determinism)`)\n\n            }\n          }\n          if (getVariantIndex(getSchema(dependency, getOffset(dependency))) != null) {\n            return; // No need to validate more\n          }\n        }\n      }\n      if (getVariantIndex(getSchema(ctor, i)) != null) {\n        return; // No need to validate more\n      }\n    }\n  }\n\n\n};\n\nconst getVariantIndex = (schema: StructKind): number | number[] | string | undefined => {\n  return schema.variant\n};\n\n/**\n * @param properties, the properties of the field mapping to schema\n * @returns\n */\nexport function field(properties: SimpleField | CustomField<any>) {\n  return (target: {} | any, name?: PropertyKey): any => {\n    const offset = getOffset(target.constructor);\n    setDependencyToProtoType(target.constructor, offset);\n    const schemas = getOrCreateStructMeta(target.constructor, offset);\n    const schema = schemas;\n    const key = name.toString();\n\n    let field: Field = undefined;\n    if ((properties as SimpleField)[\"type\"] != undefined) {\n      field = {\n        key,\n        type: (properties as SimpleField)[\"type\"],\n      };\n    } else {\n      field = {\n        key,\n        type: properties as CustomField<any>,\n      };\n    }\n\n    if (properties.index === undefined) {\n      schema.fields.push(field); // add to the end. This will make property decorator execution order define field order\n    } else {\n      if (schema.fields[properties.index]) {\n        throw new BorshError(\n          \"Multiple fields defined at the same index: \" +\n          properties.index +\n          \", class: \" +\n          target.constructor.name\n        );\n      }\n      if (properties.index >= schema.fields.length) {\n        resize(schema.fields, properties.index + 1, undefined);\n      }\n      schema.fields[properties.index] = field;\n    }\n  };\n}\n\n\n/**\n * @experimental\n * @param properties, the properties of the field mapping to schema\n * @returns\n */\nexport function serializer() {\n  return function (target: any, propertyKey: string) {\n    const offset = getOffset(target.constructor);\n    const schemas = getOrCreateStructMeta(target.constructor, offset);\n    schemas.serializer = (obj, writer, serialize) => obj[propertyKey](writer, serialize)\n  };\n}\n\n\n\n\n/**\n * @param clazzes\n * @param validate, run validation?\n * @returns Schema map\n */\nexport const validate = (clazzes: Constructor<any> | Constructor<any>[], allowUndefined = false) => {\n  return validateIterator(clazzes, allowUndefined, new Set());\n};\n\nconst validateIterator = (clazzes: AbstractType<any> | AbstractType<any>[], allowUndefined: boolean, visited: Set<string>) => {\n  clazzes = Array.isArray(clazzes) ? clazzes : [clazzes];\n  let schemas = new Map<any, StructKind>();\n  clazzes.forEach((clazz, ix) => {\n    clazz = getSuperMostClass(clazz);\n    let dependencies = getDependenciesRecursively(clazz, getOffset(clazz));\n    dependencies.push(clazz);\n    dependencies.forEach((v, k) => {\n      const schema = getSchema(v);\n      if (!schema) {\n        return;\n      }\n      schemas.set(v, schema);\n      visited.add(v.name);\n\n\n    });\n\n    let lastVariant: number | number[] | string = undefined;\n    let lastKey: Function = undefined;\n    getAllDependencies(clazz, getOffset(clazz))?.forEach((dependency, key) => {\n      if (!lastVariant)\n        lastVariant = getVariantIndex(dependency.schema);\n      else if (!validateVariantAreCompatible(lastVariant, getVariantIndex(dependency.schema))) {\n        throw new BorshError(`Class ${key.name} is extended by classes with variants of different types. Expecting only one of number, number[]or string`)\n      }\n\n      if (lastKey != undefined && lastVariant == undefined) {\n        throw new BorshError(`Classes inherit ${clazz} and are introducing new field without introducing variants. This leads to unoptimized deserialization`)\n      }\n      lastKey = key;\n    })\n\n    schemas.forEach((structSchema, clazz) => {\n      structSchema.fields.forEach((field) => {\n        if (!field) {\n          throw new BorshError(\n            \"Field is missing definition, most likely due to field indexing with missing indices\"\n          );\n        }\n        if (allowUndefined) {\n          return;\n        }\n        if (field.type instanceof Function) {\n          if (!getSchema(field.type) && !getAllDependencies(field.type, getOffset(clazz))?.size) {\n            throw new BorshError(\"Unknown field type: \" + field.type.name);\n          }\n\n          // Validate field\n          validateIterator(field.type, allowUndefined, visited);\n        }\n      });\n    })\n  });\n\n\n}\n\n\nconst resize = (arr: Array<any>, newSize: number, defaultValue: any) => {\n  while (newSize > arr.length) arr.push(defaultValue);\n  arr.length = newSize;\n};\n\nconst validateVariantAreCompatible = (a: number | number[] | string, b: number | number[] | string) => {\n  if (typeof a != typeof b) {\n    return false;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length != b.length) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport const getDiscriminator = (constructor: Constructor<any>): Uint8Array => {\n  const schemas = getSchemasBottomUp(constructor);\n  const writer = new BinaryWriter();\n  for (let i = 0; i < schemas.length; i++) {\n    const clazz = schemas[i];\n    if (i !== schemas.length - 1 && clazz.fields.length > 0) {\n      throw new BorshError(\"Discriminator can not be resolved for inheritance where super class contains fields, undefined behaviour\")\n    }\n    const variant = clazz.variant;\n    if (variant == undefined) {\n      continue;\n    }\n    if (typeof variant === 'string') {\n      writer.string(variant)\n    }\n    else if (typeof variant === 'number') {\n      writer.u8(variant)\n    }\n    else if (Array.isArray(variant)) {\n      variant.forEach((v) => {\n        writer.u8(v)\n      })\n    }\n    else {\n      throw new BorshError(\"Can not resolve discriminator for variant with type: \" + (typeof variant))\n    }\n\n  }\n\n  return writer.finalize();\n}", null],
  "mappings": "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",
  "names": ["fetchRetry", "fetch", "error", "utf8", "exports", "utf8", "fetchBuilder", "fetch", "_"]
}
