pragma language_version 0.17;
import CompactStandardLibrary;
import "openzeppelin-contracts/access/Ownable" prefix Ownable_;

export enum PHASE { commitment, revealing, finished };

export ledger productName: Opaque<"string">;
export ledger productDescription: Opaque<"string">;
export ledger rounds: Uint<64>;
export ledger currentRound: Counter;
export ledger auctioneerPK: Bytes<32>;
//export ledger maxParticipantCount: Uint<64>;
export ledger registeredParticipants: Set<Bytes<32>>;
export ledger secretBids: Set<[Bytes<32>, Bytes<32>]>; // (CommitDelValor, CommitDeIdentidad) 
export ledger revealedBids: Set<Uint<64>>; // valor revelado  
export ledger phase: PHASE;
export ledger winnerEncryptedPublicKey: Bytes<32>;

witness secretKey(): Bytes<32>;

constructor(
    productName_: Opaque<"string">, 
    productDescription_: Opaque<"string">,
    rounds_: Uint<64>,
    auctioneerPK_: Bytes<32>,
) {
    productName = disclose(productName_);
    productDescription = disclose(productDescription_);
    rounds = disclose(rounds_);
    currentRound.increment(1); // We want to initialize the round counter in 1
    auctioneerPK = disclose(auctioneerPK_);
    registeredParticipants.resetToDefault(); // = default<Set<Bytes<32>>>;
    secretBids.resetToDefault();// = default<Set<[Bytes<32>, Bytes<32>]>>;
    revealedBids.resetToDefault();// = default<Set<Bytes<32>>>;
    phase = PHASE.commitment;
    //Ownable_initialize(left<ZswapCoinPublicKey, ContractAddress>(auctioneerPK));
}

export circuit commitSecretBid(value: Uint<64>, bidNonce: Bytes<32>, idNonce: Bytes<32>): []{
    assert(phase == PHASE.commitment, "Wrong phase to do that");
    const bidCommit = persistentCommit<Uint<64>>(value, bidNonce);
    const identityCommit = disclose(persistentCommit<Bytes<32>>(secretKey(), idNonce));
    if (currentRound.read() == 1) {
        registeredParticipants.insert(identityCommit);
    }
    assert(registeredParticipants.member(identityCommit), "You are not registered as participant");
    secretBids.insert(disclose([bidCommit, identityCommit]));
}

export circuit moveToRevealPhase(): [] {
    Ownable_assertOnlyOwner();
    assert(phase == PHASE.commitment, "Wrong phase to do that");
    phase = PHASE.revealing;
}

export circuit revealBid(value: Uint<64>, bidNonce: Bytes<32>, idNonce: Bytes<32>): [] {
    assert(phase == PHASE.revealing, "Wrong phase to do that");
    const bidCommit = persistentCommit<Uint<64>>(value, bidNonce);
    const identityCommit = disclose(persistentCommit<Bytes<32>>(secretKey(), idNonce));
    assert(registeredParticipants.member(identityCommit), "You are not registered as a participant");
    assert(secretBids.member(disclose([bidCommit, identityCommit])), "That bid is a lie");
    revealedBids.insert(disclose(value));
}

export circuit moveToNextPhase(): [] {
    Ownable_assertOnlyOwner();
    assert(phase == PHASE.revealing, "Wrong phase to do that");
    assert(currentRound.read() != rounds, "This is the last round");
    revealedBids.resetToDefault();
    secretBids.resetToDefault();
    phase = PHASE.commitment;
    currentRound.increment(1);
}

export circuit claimWin(value: Uint<64>, bidNonce: Bytes<32>, idNonce: Bytes<32>, encryptedPublicKey: Bytes<32>): [] {
    assert(phase == PHASE.revealing, "Bids are not revealed yet");
    assert(currentRound.read() == rounds, "There are still missing rounds");
    const bidCommit = persistentCommit<Uint<64>>(value, bidNonce);
    const identityCommit = disclose(persistentCommit<Bytes<32>>(secretKey(), idNonce));
    assert(secretBids.member(disclose([bidCommit, identityCommit])), "That bid is a lie");
    winnerEncryptedPublicKey = disclose(encryptedPublicKey);
}

export circuit finishAuction(): [] {
    Ownable_assertOnlyOwner();
    assert(phase == PHASE.revealing, "Bids are not revealed yet");
    assert(currentRound.read() == rounds, "There are still missing rounds");
    phase = PHASE.finished;
}